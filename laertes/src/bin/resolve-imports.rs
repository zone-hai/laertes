#![feature(rustc_private)]
#![feature(box_patterns)]
#![feature(str_split_once)]

extern crate env_logger;

use crate::def_id::{DefId, LOCAL_CRATE};
use itertools::Itertools;
use laertes::{
    analysis,
    colored::*,
    compiler_interface::*,
    constants::*,
    io::{FileIO, OutputMode},
    lazy_static::lazy_static,
    ptr_provenance::*,
    rustc_driver,
    rustc_hir::{intravisit::FnKind, *},
    rustc_lint::{LateContext, LateLintPass, LintContext, LintPass},
    rustc_span::{sym, FileName, FileNameDisplayPreference, Span},
    rustc_target::spec::abi::Abi,
    types::Type,
    Atom,
};
use rustfix::{Replacement, Snippet, Solution, Suggestion};
use std::{
    collections::{BTreeSet, HashMap, HashSet},
    panic,
    path::PathBuf,
    sync::{
        atomic::{AtomicBool, Ordering},
        Mutex,
    },
};

lazy_static! {
    /// Rustfix suggestions for editing the source files
    static ref RUSTFIX_SUGGESTIONS: Mutex<HashMap<PathBuf, Vec<Suggestion>>> = Mutex::new(HashMap::default());
}

/// Whether to merge foreign type declarations for types not defined in the program
pub static MERGE_FOREIGN_TYPES: AtomicBool = AtomicBool::new(true);

/// Whether to merge anonymous structs named C2RustUnnamed_<N>
pub static MERGE_ANONYMOUS_STRUCTS: AtomicBool = AtomicBool::new(true);

/// Returns the name of the definition at given HIR node in current crate
fn get_hir_qname(ctx: &LateContext<'_>, hir_id: HirId) -> FnName {
    let def_id = DefId {
        krate: LOCAL_CRATE,
        index: ctx.tcx.hir().local_def_id(hir_id).local_def_index,
    };
    ctx.get_def_path(def_id)
        .iter()
        .map(|segment| segment.to_string())
        .filter(|s| !s.is_empty())
        .join("::")
}

/// Checks if the given function is generated by the compiler
fn is_synthetic_fn(_fn_decl: &FnDecl<'_>, body: &Body<'_>) -> bool {
    body.value.span.in_derive_expansion()
}

/// Get the field names and *syntactic* types of a struct or union (or
/// field indices as strings if it is a tuple struct)
fn get_fields(ctx: &LateContext, variant_data: &VariantData) -> Vec<(String, Type)> {
    variant_data
        .fields()
        .iter()
        .map(|f| {
            let mut field_ty = Type::from_hir_ty(ctx, f.ty);
            field_ty.make_syntactic_unqual();
            (f.ident.as_str().to_string(), field_ty)
        })
        .collect()
}

// Use interned strings for names, we use `Name` instead of `Symbol`
// to prevent clashes with [`Symbol`] used and defined by rustc.
type Name = Atom;

/// Information about which parts of the source code are relevant to
/// an external type
#[derive(Default, Eq, PartialEq)]
struct ItemInfo {
    /// Unqualified name
    unqual_name: String,
    /// The span for this definition
    span: Span,
    /*
    /// The spans for commenting out (e.g. `#[derive(..)]` spans) when
    /// removing this item
    to_comment_out: Vec<Span>,
    /// The spans to remove when removing this item, e.g. the annotations
    to_remove: Vec<Span>,
    */
    /// End of the parent `extern { .. }` statement, so that we can add this item if need be
    end_of_extern: Span,
    /// The parent module, so that we can look up imported names
    parent_mod: String,
}

/// A type signature to match up ADTs with the same shape and unqualified names
#[derive(Debug, PartialEq, Eq, Hash)]
enum TypeSig {
    /// An unknown type (coming from type definitions)
    Unknown,
    /// A foreign type (coming from an extern item). Used for merging
    /// multiple references to the same foreign type name.
    Foreign,
    /// A struct with field names.
    ///
    /// TODO: field sizes/shapes as well for better matching. That
    /// would require some constraint solving
    Struct(Vec<(String, Type)>),
    /// A C union with field names
    Union(Vec<(String, Type)>),
    /// Denotes a static variable, not a type
    StaticVar,
}

/// A pass for the rewriting part of this tool
struct RewritePass {
    /// Call graph built by pointer provenance
    call_graph: CallGraph,
    /// A mapping of structs and unions to their definitions in the crate
    type_defs: HashMap<String, HashMap<TypeSig, String>>,
    /// Information about unresolved names, we post-process them to
    /// resolve them
    ///
    /// QualifiedName -> (UnqualifiedName, Spans)
    unresolved_types: HashMap<String, ItemInfo>,
    /// Information about unresolves extern static variables
    unresolved_static_vars: HashMap<String, ItemInfo>,
    /// Whether to remove `#[repr(..)]`
    remove_repr: bool,
    /// Whether to remove `#[derive(..)]`
    remove_derive: bool,
    /// Whether to remove `#[no_mangle]`
    remove_no_mangle: bool,
    /// Keep track of a unique ID for removed extern functions so we can remove their `no_mangle` attribute
    removed_fns: HashSet<Span>,
    /// Names imported in each module
    imported_names: HashMap<String, HashSet<String>>,
    /// Name of the current module being processed
    current_mod: String,
    /// The mapping of static variables to their definitions in the
    /// crate. The `None` case indicates that there are multiple
    /// definitions, so we cannot resolve the names without some
    /// linker info.
    static_var_defs: HashMap<String, Option<String>>,
}

impl RewritePass {
    pub fn new() -> Box<LatePass> {
        Box::new(RewritePass {
            call_graph: analysis::result::<CallGraph>().unwrap(),
            type_defs: HashMap::default(),
            remove_repr: false,
            remove_derive: false,
            remove_no_mangle: false,
            removed_fns: HashSet::default(),
            imported_names: HashMap::default(),
            current_mod: "".to_owned(),
            unresolved_types: HashMap::default(),
            unresolved_static_vars: HashMap::default(),
            static_var_defs: HashMap::default(),
        })
    }

    fn calls_c_fns_we_handle(&self, ctx: &LateContext, fn_name: &Name) -> bool {
        if let Some(callees) = &self.call_graph.closure().unwrap().get(fn_name) {
            C_FNS_WE_HANDLE.iter().any(|name| {
                callees.contains(&Name::from(format!("{}::{}", local_crate_name(ctx), name)))
            })
        } else {
            false
        }
    }

    // Return a boolean indicating whether the given function is safe
    // A function is considered safe if it does not have any unsafe behavior and does not call any C functions that the linter can handle.
    fn is_safe_fn(&self, ctx: &LateContext, fn_name: &Name) -> bool {
        self.call_graph
            .unsafe_behavior()
            .get(fn_name)
            .map_or(true, |s| s.is_empty())
            && !self.calls_c_fns_we_handle(ctx, fn_name)
    }

    /// Generates the string representation of a version of the given
    /// fn header that is not unsafe.
    fn safe_header_snippet(fn_header: FnHeader) -> String {
        assert_eq!(fn_header.asyncness, IsAsync::NotAsync);
        let const_str = if fn_header.is_const() { "const " } else { "" };
        let extern_str = if fn_header.abi == Abi::Rust {
            "".to_string()
        } else {
            format!("extern \"{}\" ", fn_header.abi.name())
        };
        format!(" {}{}fn ", const_str, extern_str)
    }

    fn process_fn(
        &mut self,
        ctx: &LateContext<'_>,
        name: Name,
        fn_header: FnHeader,
        header_span: Span,
    ) {
        let can_remove_unsafe = self.is_safe_fn(ctx, &name);

        // check if we can remove `unsafe`
        if fn_header.unsafety == Unsafety::Unsafe && can_remove_unsafe {
            println!("Remove unsafe from {}", name);
            self.make_suggestion(
                ctx,
                header_span,
                format!("remove `unsafe` from {}", name),
                Self::safe_header_snippet(fn_header),
            );
        }
    }

    // Create a suggestion for a possible fix to a coding issue found by the program.
    fn make_suggestion(
        &self,
        ctx: &LateContext<'_>,
        span: Span,
        message: String,
        replacement: String,
    ) {
        use rustfix::{LinePosition, LineRange};

        let source_map = ctx.sess().source_map();
        let fname = source_map.span_to_filename(span);

        let fname_real = match fname {
            FileName::Real(ref n) => n,
            _ => {
                println!(
                    "{}",
                    format!("WARNING: Attempted to fix generated code at {:?}", span)
                        .bold()
                        .red()
                );
                return;
            },
        };

        let file = source_map.get_source_file(&fname).unwrap();
        let lo = file.lookup_file_pos_with_col_display(span.lo());
        let hi = file.lookup_file_pos_with_col_display(span.hi());
        let line_range = LineRange {
            start: LinePosition {
                line: lo.0,
                column: lo.2,
            },
            end: LinePosition {
                line: hi.0,
                column: hi.2,
            },
        };
        let file_name_display_preference = FileNameDisplayPreference::Remapped;
        // The Snippet object represents a piece of source code within a file.
        let snippet = Snippet {
            // file_name: file_name.as_string();
            file_name: (*fname_real)
                .to_string_lossy(file_name_display_preference)
                .to_string(),
            line_range,
            range: (file.bytepos_to_file_charpos(span.lo()).0)
                ..(file.bytepos_to_file_charpos(span.hi()).0),
            text: (
                "".into(),
                source_map.span_to_snippet(span).unwrap(),
                "".into(),
            ),
        };

        let mut suggestions = RUSTFIX_SUGGESTIONS.lock().unwrap();

        suggestions
            // .entry(fname_real.local_path().into())
            .entry(fname_real.local_path().unwrap().into())
            .or_insert(vec![])
            .push(Suggestion {
                message: "".to_owned(),
                snippets: vec![snippet.clone()],
                solutions: vec![Solution {
                    message,
                    replacements: vec![Replacement {
                        snippet,
                        replacement,
                    }],
                }],
            });
    }

    // write this as a 2-pass program
    //
    // - pass 1: decide where each struct/fn name comes from (based on
    // signature later on, if need be)
    //
    //   - (assumption: they must both come from the same module)
    //
    // - pass 2: rewrite struct defs and imports for all other
    // modules, so that we guarantee that we refer to an actual type
    // definition
    fn deduplicate_struct(
        &mut self,
        ctx: &LateContext,
        unnormalized_unqual_name: &str,
        qual_name: String,
        type_sig: TypeSig,
        struct_def_span: Span,
    ) {
        let unqual_name = if unnormalized_unqual_name.starts_with("C2RustUnnamed")
            && MERGE_ANONYMOUS_STRUCTS.load(Ordering::Relaxed)
        {
            "C2RustUnnamed"
        } else {
            unnormalized_unqual_name
        };

        if let Some(matching_sigs) = self.type_defs.get(unqual_name) {
            let def_name = if let Some(def_qname) = matching_sigs.get(&type_sig) {
                def_qname
            } else {
                // there are no matching signatures, introduce this
                // definition as the canonical one for its signature

                self.type_defs
                    .entry(unqual_name.to_owned())
                    .or_default()
                    .insert(type_sig, qual_name.split_once("::").unwrap().1.to_owned());
                // log::warn!("There are multiple definitions with the same unqualified name to rewrite the typedef `{}` as", qual_name)
                return;
            };
            let (top, rest) = def_name.split_once("::").unwrap();
            let name_to_import = if top == local_crate_name(ctx) {
                rest
            } else {
                &def_name
            };
            let snippet = if self.imported_names[self.current_mod.as_str()]
                .contains(unnormalized_unqual_name)
            {
                "".to_string()
            } else {
                self.imported_names
                    .get_mut(self.current_mod.as_str())
                    .unwrap()
                    .insert(unqual_name.to_string());
                format!(
                    "pub type {} = crate::{};",
                    unnormalized_unqual_name, name_to_import
                )
            };
            // this struct is already defined, deduplicate it
            self.make_suggestion(
                ctx,
                struct_def_span,
                "deduplicate struct".to_owned(),
                snippet,
            );
            // mark repr and automatically_derived attributes related to this struct as to be removed_fns
            self.remove_repr = true;
            self.remove_derive = true;
        } else {
            // there is no matching type name, register this as the first one
            self.type_defs
                .entry(unqual_name.to_owned())
                .or_default()
                .insert(type_sig, qual_name.split_once("::").unwrap().1.to_owned());
        }
    }
}

impl LintPass for RewritePass {
    fn name(&self) -> &'static str {
        "RewritePass"
    }
}

// rustc_lint::LateLintPass rustc的官方trait 里面是一系列回调函数
impl<'tcx> LateLintPass<'tcx> for RewritePass {
    fn check_mod(
        &mut self,
        ctx: &LateContext<'tcx>,
        _mod: &'tcx Mod<'tcx>,
        _: Span,
        hir_id: HirId,
    ) {
        // reset the imports
        self.current_mod = get_hir_qname(ctx, hir_id);
        self.imported_names
            .insert(self.current_mod.clone(), HashSet::default());
    }

    fn check_item(&mut self, ctx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {
        // skip derived items
        if item.span.in_derive_expansion() {
            let attrs = ctx.tcx.hir().attrs(item.hir_id());
            for attr in attrs {
                // println!("{}", attr.name_or_empty().to_ident_string());
                self.check_attribute(ctx, attr);
            }
            return;
        }
        // Define a closure that takes no arguments and
        // returns the fully qualified name of the definition associated with item.hir_id() in the current crate
        let name = || get_hir_qname(ctx, item.hir_id());
        let crate_name = local_crate_name(ctx);
        // end of this foreign module
        let end_of_extern = item.span.shrink_to_hi();

        // don't remove attributes related to structs by default
        self.remove_repr = false;
        self.remove_derive = false;
        self.remove_no_mangle = false;

        match &item.kind {
            // Handle foreign module (`extern { ... }`) declarations
            ItemKind::ForeignMod {
                items: foreign_items,
                ..
            } => {
                // use BTreeSet to keep the functions in a stable order for rewrite
                let mut items_to_import: BTreeSet<String> = BTreeSet::new();
                for foreign_item in *foreign_items {
                    let unqual_name = &*foreign_item.ident.as_str();
                    if unqual_name == "close"{
                        continue;
                    }
                    match ctx.tcx.hir().foreign_item((*foreign_item).id).kind {
                        ForeignItemKind::Fn(..) => {
                            if let Some(def_qname) = self
                                .call_graph
                                .defined_fns
                                .get(&Name::from(&*foreign_item.ident.as_str()))
                            {
                                // this function is defined in another
                                // module, remove the extern definition
                                // and add it to the fns to import via
                                // `use`
                                self.make_suggestion(
                                    ctx,
                                    foreign_item.span,
                                    "remove extern function that is defined in another module"
                                        .to_owned(),
                                    "".to_owned(),
                                );
                                let current_names =
                                    self.imported_names.get_mut(&self.current_mod).unwrap();
                                if !current_names.contains(unqual_name) {
                                    current_names.insert(unqual_name.to_string());
                                    items_to_import.insert(def_qname.to_string());
                                }
                                self.removed_fns.insert(foreign_item.span);
                            }
                        },
                        ForeignItemKind::Type => {
                            if let Some(matching_sigs) = self.type_defs.get(unqual_name) {
                                self.make_suggestion(
                                    ctx,
                                    foreign_item.span,
                                    "remove extern type that is also declared in another module"
                                        .to_owned(),
                                    "".to_owned(),
                                );
                                let current_names =
                                    self.imported_names.get_mut(&self.current_mod).unwrap();
                                if !current_names.contains(unqual_name) {
                                    assert!(
                                        matching_sigs.len() == 1,
                                        "multiple matching definitions for the same extern at {:?}: {:?}",
                                        foreign_item.span,
                                        matching_sigs
                                    );
                                    let def_qname = matching_sigs.values().last().unwrap();
                                    current_names.insert(unqual_name.to_string());
                                    items_to_import.insert(def_qname.to_string());
                                }
                            } else {
                                // name() gives the name of the enclosing
                                // module for foreign type declarations due to
                                // rustc's understanding of definitions. so,
                                // we have to do the following trick
                                let name = format!("{}::{}", name(), unqual_name);
                                self.unresolved_types.insert(
                                    name,
                                    ItemInfo {
                                        unqual_name: unqual_name.to_owned(),
                                        span: foreign_item.span,
                                        end_of_extern,
                                        parent_mod: self.current_mod.clone(),
                                    },
                                );
                            }
                        },
                        ForeignItemKind::Static(..) => {
                            let name = format!("{}::{}", name(), unqual_name);
                            self.unresolved_static_vars.insert(
                                name,
                                ItemInfo {
                                    unqual_name: unqual_name.to_owned(),
                                    span: foreign_item.span,
                                    end_of_extern,
                                    parent_mod: self.current_mod.clone(),
                                },
                            );
                        },
                    }
                }
                if !items_to_import.is_empty() {
                    let use_stmts = items_to_import
                        .into_iter()
                        .map(|name| {
                            // import the name in a crate name-agnostic way
                            let (top, rest) = name.split_once("::").unwrap();
                            let name_to_import = if top == crate_name { rest } else { &name };
                            format!("\npub use crate::{};", name_to_import)
                        })
                        .join("");
                    self.make_suggestion(
                        ctx,
                        end_of_extern,
                        "import extern functions that are defined in other modules".to_owned(),
                        use_stmts,
                    );
                }
            },
            // handle and deduplicate struct definitions
            ItemKind::Struct(variant_data, _) => {
                let unqual_name = item.ident.as_str();
                // println!("check_item: Struct = {}", unqual_name);

                // if unqual_name == "in6_addr" || unqual_name == "sockaddr_in6" {
                //     return;
                // } else if unqual_name == "sigaction" || unqual_name == "sigpipe_ignore" {
                //     return;
                // } else if unqual_name == "Curl_sockaddr_storage"{
                //     return;
                // }

                self.deduplicate_struct(
                    ctx,
                    &unqual_name,
                    name(),
                    TypeSig::Struct(get_fields(ctx, variant_data)),
                    item.span,
                ); // , data.fields(), generics);
                let attrs = ctx.tcx.hir().attrs(item.hir_id());
                for attr in attrs {
                    // println!("{}", attr.name_or_empty().to_ident_string());
                    self.check_attribute(ctx, attr);
                }
            },
            ItemKind::Union(variant_data, _) => {
                let unqual_name = item.ident.as_str();
                self.deduplicate_struct(
                    ctx,
                    &unqual_name,
                    name(),
                    TypeSig::Union(get_fields(ctx, variant_data)),
                    item.span,
                ); // , data.fields(), generics);
                let attrs = ctx.tcx.hir().attrs(item.hir_id());
                for attr in attrs {
                    // println!("{}", attr.name_or_empty().to_ident_string());
                    self.check_attribute(ctx, attr);
                }
            },
            ItemKind::TyAlias(..) => {
                let unqual_name = item.ident.as_str();
                if !unqual_name.starts_with("C2RustUnnamed") {
                    self.deduplicate_struct(ctx, &unqual_name, name(), TypeSig::Unknown, item.span);
                    let attrs = ctx.tcx.hir().attrs(item.hir_id());
                    for attr in attrs {
                        // println!("{}", attr.name_or_empty().to_ident_string());
                        self.check_attribute(ctx, attr);
                    }
                }
            },
            ItemKind::Static(..) if matches!(item.vis.node, VisibilityKind::Public) => {
                let unqual_name = item.ident.as_str().to_string();
                if let Some(other_def) = self.static_var_defs.get(&unqual_name) {
                    log::warn!(
                        "There are multiple static definitions with the name `{}`: `{}` and `{:?}`. So, we are not resolving it.",
                        unqual_name,
                        name(),
                        other_def
                            .as_ref()
                            .map(|s| s.as_ref())
                            .unwrap_or("more than 1 other name")
                    );
                    // Insert `None` to mark that this object has multiple definitions so it doesn't have a proper resolution
                    self.static_var_defs.insert(unqual_name.to_string(), None);
                } else {
                    self.static_var_defs
                        .insert(unqual_name.to_string(), Some(name()));
                }
            },
            _ => {},
        }
    }

    fn check_crate_post(&mut self, ctx: &LateContext<'tcx>) {
        // println!("fn check_crate_post");
        let crate_name = local_crate_name(ctx);
        // resolve unresolved items if possible
        let mut items_to_import_per_mod: HashMap<Span, BTreeSet<String>> = HashMap::new();
        for (qual_name, info) in &self.unresolved_types {
            if let Some(type_def) = self.type_defs.get(&info.unqual_name) {
                assert_eq!(
                    type_def.len(),
                    1,
                    "There are multiple type definitions with the name `{}`: `{}` and `{:?}`",
                    info.unqual_name,
                    qual_name,
                    type_def,
                );
                let (sig, def_qname) = type_def.iter().last().unwrap();
                assert_ne!(qual_name, def_qname, "Circular type definition!");

                if *sig == TypeSig::Unknown || *sig == TypeSig::Foreign {
                    log::warn!(
                        "resolving extern type `{}` to typedef or extern `{}`. this may cause circular type definitions!",
                        qual_name,
                        def_qname
                    );
                }

                self.make_suggestion(
                    ctx,
                    info.span,
                    "remove extern type that is also declared in another module".to_owned(),
                    "".to_owned(),
                );
                let current_names = self.imported_names.get_mut(&info.parent_mod).unwrap();
                if !current_names.contains(&info.unqual_name) {
                    current_names.insert(info.unqual_name.clone());
                    items_to_import_per_mod
                        .entry(info.end_of_extern)
                        .or_default()
                        .insert(def_qname.clone());
                }
            } else if MERGE_FOREIGN_TYPES.load(Ordering::Relaxed) {
                // there is no type to resolve to, resolve other foreign names to this name.
                self.type_defs
                    .entry(info.unqual_name.clone())
                    .or_default()
                    .insert(TypeSig::Foreign, qual_name.clone());
            }
        }

        for (_qual_name, info) in &self.unresolved_static_vars {
            if let Some(Some(def_qname)) = self.static_var_defs.get(&info.unqual_name) {
                if &info.unqual_name == "Curl_ssl" {
                    continue;
                }
                self.make_suggestion(
                    ctx,
                    info.span,
                    "remove extern variable that is also declared in another module".to_owned(),
                    "".to_owned(),
                );
                let current_names = self.imported_names.get_mut(&info.parent_mod).unwrap();
                if !current_names.contains(&info.unqual_name) {
                    current_names.insert(info.unqual_name.clone());
                    items_to_import_per_mod
                        .entry(info.end_of_extern)
                        .or_default()
                        .insert(def_qname.clone());
                }
            }
        }

        for (end_of_extern, items_to_import) in items_to_import_per_mod {
            let use_stmts = items_to_import
                .into_iter()
                .map(|name| {
                    // import the name in a crate name-agnostic way
                    let (top, rest) = name.split_once("::").unwrap();
                    let name_to_import = if top == crate_name { rest } else { &name };
                    format!("\npub use crate::{};", name_to_import)
                })
                .join("");
            self.make_suggestion(
                ctx,
                end_of_extern,
                "import extern functions that are defined in other modules".to_owned(),
                use_stmts,
            );
        }
    }

    fn check_item_post(&mut self, _: &LateContext<'tcx>, _: &'tcx Item<'tcx>) {
        // stop removing #[no_mangle] after the extern block
        self.remove_no_mangle = false;
    }

    fn check_foreign_item(&mut self, _: &LateContext<'tcx>, _: &'tcx ForeignItem<'tcx>) {
        self.remove_no_mangle = true; // rustc no longer requires `no_mangle` for foreign items.
    }

    fn check_fn_post(
        &mut self,
        ctx: &LateContext<'tcx>,
        kind: FnKind<'tcx>,
        decl: &'tcx FnDecl<'tcx>,
        body: &'tcx Body<'tcx>,
        _span: Span,
        hir_id: HirId,
    ) {
        self.remove_no_mangle = false;
        let name = Name::from(get_hir_qname(ctx, hir_id));
        log::warn!("fn name : {:?}", name);
        match kind {
            FnKind::ItemFn(ident, _, header, visibility) => {
                // the header is between the visibility and the
                // function name (the `extern .. fn` part of the
                // signature `pub extern .. fn foo`)
                let header_span = visibility.span.between(ident.span);
                // don't process c_variadic function, mut args must unsafe
                if decl.c_variadic {
                    return;
                }
                self.process_fn(ctx, name, header, header_span);
            },
            FnKind::Method(..) if is_synthetic_fn(decl, body) => {
                // log::info!("Skipping synthetic method {} at {:?}", name, span)
            },
            FnKind::Method(..) => {}, // TODO: skip only bitfield methods we added
            FnKind::Closure => {
                log::error!("closures are not supported");
                return;
            },
        }
    }

    fn check_attribute(
        &mut self,
        ctx: &LateContext<'tcx>,
        attr: &'tcx laertes::rustc_ast::ast::Attribute,
    ) {
        // remove the attributes related to the structs that are removed
        if !attr.is_doc_comment() {
            if self.remove_repr && attr.has_name(sym::repr) {
                self.make_suggestion(ctx, attr.span, "delete repr".to_owned(), "".to_owned());
                self.remove_repr = false;
            } else if self.remove_derive && attr.has_name(sym::automatically_derived) {
                let begin_span = ctx
                    .sess()
                    .source_map()
                    .span_extend_to_prev_char(attr.span, '\n', true)
                    .shrink_to_lo();
                self.make_suggestion(
                    ctx,
                    begin_span,
                    "comment out derive".to_owned(),
                    "// ".to_owned(),
                );
                self.remove_derive = false;
            } else if self.remove_no_mangle && attr.has_name(sym::no_mangle) {
                self.make_suggestion(ctx, attr.span, "delete no_mangle".to_owned(), "".to_owned());
                self.remove_no_mangle = false;
            }
        }
    }
}

pub fn main() {
    // This is our logger
    env_logger::init();
    // Initialize rustc's logger as well
    rustc_driver::init_rustc_env_logger();

    POISON_SIGS_OF_FN_PTRS.store(false, Ordering::SeqCst);
    POISON_UNRELATED_TYPE_CASTS.store(false, Ordering::SeqCst);
    COMPUTE_OWNERSHIP.store(false, Ordering::SeqCst);

    run_compiler(&vec![], vec![PtrProvenancePass::new]);
    run_compiler(&vec![], vec![RewritePass::new]);

    println!("{}", "Unsafe removal suggestions:".bold().green());

    for (file, suggestions) in RUSTFIX_SUGGESTIONS.lock().unwrap().iter() {
        println!("For file {}:", file.to_str().unwrap());

        for suggestion in suggestions.iter() {
            let solution = &suggestion.solutions[0];
            println!("{}", solution.message);
            for replacement in &solution.replacements {
                println!(" - replace {:?}", replacement.snippet.text);
                println!("   with   `{}`", replacement.replacement);
                println!(
                    "   at {} {}:{}-{}:{}",
                    replacement.snippet.file_name,
                    replacement.snippet.line_range.start.line,
                    replacement.snippet.line_range.start.column,
                    replacement.snippet.line_range.end.line,
                    replacement.snippet.line_range.end.column,
                );
            }
        }
    }

    let cfg = laertes::Config {
        output_path: None,
        output_mode: OutputMode::Overwrite,
    };

    let file_io = FileIO::new(&cfg);

    println!("{}", "Applying fixes".bold().green());

    // 根据之前得到的建议重写代码，建议储存在RUSTFIX_SUGGESTIONS全局变量中
    for (file, suggestions) in RUSTFIX_SUGGESTIONS.lock().unwrap().drain() {
        println!("Rewriting file {}:", file.to_str().unwrap());

        let fixed_source_code =
            rustfix::apply_suggestions(&file_io.read_file(&file).unwrap(), &suggestions).unwrap();
        file_io.write_file(&file, &fixed_source_code).unwrap();
    }

    let orig_args: Vec<String> = std::env::args().collect();
    let args = laertes::cli::read_env(orig_args);
    let exit_code = run_compiler_with_setup(args, &vec![], vec![], |_| {}).0;

    if exit_code == 0 {
        println!(
            "DONE: {}",
            "The compiler successfully compiles the code".green()
        );
    } else {
        println!(
            "DONE: {}",
            "Compilation failed, please unroll the unsafe changes".red()
        );
    }
}

use ::libc;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type _xmlBuf;
    pub type _xmlDict;
    pub type _xmlHashTable;
    pub type _xmlStartTag;
    pub type _xmlAutomataState;
    pub type _xmlAutomata;
    pub type _xmlValidState;
    pub type _xmlRegexp;
    pub type _xmlRegExecCtxt;
    pub type _xmlSchemaVal;
    pub type _xmlTextReader;
    pub type _xmlStreamCtxt;
    pub type _xmlPattern;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn xmlEscapeFormatString(msg: *mut *mut xmlChar) -> *mut xmlChar;
    fn xmlStrncatNew(
        str1: *const xmlChar,
        str2: *const xmlChar,
        len: libc::c_int,
    ) -> *mut xmlChar;
    fn xmlStrncat(
        cur: *mut xmlChar,
        add: *const xmlChar,
        len: libc::c_int,
    ) -> *mut xmlChar;
    fn xmlStrcat(cur: *mut xmlChar, add: *const xmlChar) -> *mut xmlChar;
    fn xmlStrlen(str: *const xmlChar) -> libc::c_int;
    fn xmlStrEqual(str1: *const xmlChar, str2: *const xmlChar) -> libc::c_int;
    fn xmlCharStrdup(cur: *const libc::c_char) -> *mut xmlChar;
    fn xmlStrndup(cur: *const xmlChar, len: libc::c_int) -> *mut xmlChar;
    fn xmlStrdup(cur: *const xmlChar) -> *mut xmlChar;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn xmlDictCreate() -> xmlDictPtr;
    fn xmlDictReference(dict: xmlDictPtr) -> libc::c_int;
    fn xmlDictFree(dict: xmlDictPtr);
    fn xmlDictLookup(
        dict: xmlDictPtr,
        name: *const xmlChar,
        len: libc::c_int,
    ) -> *const xmlChar;
    fn xmlRegexpCompile(regexp: *const xmlChar) -> xmlRegexpPtr;
    fn xmlRegFreeRegexp(regexp: xmlRegexpPtr);
    fn xmlRegexpExec(comp: xmlRegexpPtr, value: *const xmlChar) -> libc::c_int;
    fn xmlRegexpIsDeterminist(comp: xmlRegexpPtr) -> libc::c_int;
    fn xmlRegNewExecCtxt(
        comp: xmlRegexpPtr,
        callback: xmlRegExecCallbacks,
        data: *mut libc::c_void,
    ) -> xmlRegExecCtxtPtr;
    fn xmlRegFreeExecCtxt(exec: xmlRegExecCtxtPtr);
    fn xmlRegExecPushString(
        exec: xmlRegExecCtxtPtr,
        value: *const xmlChar,
        data: *mut libc::c_void,
    ) -> libc::c_int;
    fn xmlRegExecPushString2(
        exec: xmlRegExecCtxtPtr,
        value: *const xmlChar,
        value2: *const xmlChar,
        data: *mut libc::c_void,
    ) -> libc::c_int;
    fn xmlRegExecNextValues(
        exec: xmlRegExecCtxtPtr,
        nbval: *mut libc::c_int,
        nbneg: *mut libc::c_int,
        values: *mut *mut xmlChar,
        terminal: *mut libc::c_int,
    ) -> libc::c_int;
    fn xmlRegExecErrInfo(
        exec: xmlRegExecCtxtPtr,
        string: *mut *const xmlChar,
        nbval: *mut libc::c_int,
        nbneg: *mut libc::c_int,
        values: *mut *mut xmlChar,
        terminal: *mut libc::c_int,
    ) -> libc::c_int;
    fn xmlValidateNCName(value: *const xmlChar, space: libc::c_int) -> libc::c_int;
    fn xmlValidateQName(value: *const xmlChar, space: libc::c_int) -> libc::c_int;
    fn xmlSplitQName2(name: *const xmlChar, prefix: *mut *mut xmlChar) -> *mut xmlChar;
    fn xmlSplitQName3(name: *const xmlChar, len: *mut libc::c_int) -> *const xmlChar;
    fn xmlNewNs(
        node: xmlNodePtr,
        href: *const xmlChar,
        prefix: *const xmlChar,
    ) -> xmlNsPtr;
    fn xmlFreeDoc(cur: xmlDocPtr);
    fn xmlNewProp(
        node: xmlNodePtr,
        name: *const xmlChar,
        value: *const xmlChar,
    ) -> xmlAttrPtr;
    fn xmlNewNsProp(
        node: xmlNodePtr,
        ns: xmlNsPtr,
        name: *const xmlChar,
        value: *const xmlChar,
    ) -> xmlAttrPtr;
    fn xmlNewDocText(doc: *const xmlDoc, content: *const xmlChar) -> xmlNodePtr;
    fn xmlDocGetRootElement(doc: *const xmlDoc) -> xmlNodePtr;
    fn xmlAddChild(parent: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
    fn xmlUnlinkNode(cur: xmlNodePtr);
    fn xmlFreeNode(cur: xmlNodePtr);
    fn xmlSearchNs(
        doc: xmlDocPtr,
        node: xmlNodePtr,
        nameSpace: *const xmlChar,
    ) -> xmlNsPtr;
    fn xmlSearchNsByHref(
        doc: xmlDocPtr,
        node: xmlNodePtr,
        href: *const xmlChar,
    ) -> xmlNsPtr;
    fn xmlGetNsList(doc: *const xmlDoc, node: *const xmlNode) -> *mut xmlNsPtr;
    fn xmlGetNoNsProp(node: *const xmlNode, name: *const xmlChar) -> *mut xmlChar;
    fn xmlHasProp(node: *const xmlNode, name: *const xmlChar) -> xmlAttrPtr;
    fn xmlNodeListGetString(
        doc: xmlDocPtr,
        list: *const xmlNode,
        inLine: libc::c_int,
    ) -> *mut xmlChar;
    fn xmlNodeGetContent(cur: *const xmlNode) -> *mut xmlChar;
    fn xmlNodeGetSpacePreserve(cur: *const xmlNode) -> libc::c_int;
    fn xmlNodeGetBase(doc: *const xmlDoc, cur: *const xmlNode) -> *mut xmlChar;
    fn xmlHashCreate(size: libc::c_int) -> xmlHashTablePtr;
    fn xmlHashCreateDict(size: libc::c_int, dict: xmlDictPtr) -> xmlHashTablePtr;
    fn xmlHashFree(table: xmlHashTablePtr, f: xmlHashDeallocator);
    fn xmlHashAddEntry(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        userdata: *mut libc::c_void,
    ) -> libc::c_int;
    fn xmlHashAddEntry2(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        name2: *const xmlChar,
        userdata: *mut libc::c_void,
    ) -> libc::c_int;
    fn xmlHashLookup(table: xmlHashTablePtr, name: *const xmlChar) -> *mut libc::c_void;
    fn xmlHashLookup2(
        table: xmlHashTablePtr,
        name: *const xmlChar,
        name2: *const xmlChar,
    ) -> *mut libc::c_void;
    fn xmlHashSize(table: xmlHashTablePtr) -> libc::c_int;
    fn xmlHashScan(table: xmlHashTablePtr, f: xmlHashScanner, data: *mut libc::c_void);
    fn xmlHashScanFull(
        table: xmlHashTablePtr,
        f: xmlHashScannerFull,
        data: *mut libc::c_void,
    );
    fn xmlGetLastError() -> xmlErrorPtr;
    fn __xmlRaiseError(
        schannel: xmlStructuredErrorFunc,
        channel: xmlGenericErrorFunc,
        data: *mut libc::c_void,
        ctx: *mut libc::c_void,
        node: *mut libc::c_void,
        domain: libc::c_int,
        code: libc::c_int,
        level: xmlErrorLevel,
        file: *const libc::c_char,
        line: libc::c_int,
        str1: *const libc::c_char,
        str2: *const libc::c_char,
        str3: *const libc::c_char,
        int1: libc::c_int,
        col: libc::c_int,
        msg: *const libc::c_char,
        _: ...
    );
    fn __xmlSimpleError(
        domain: libc::c_int,
        code: libc::c_int,
        node: xmlNodePtr,
        msg: *const libc::c_char,
        extra: *const libc::c_char,
    );
    fn xmlNewAutomata() -> xmlAutomataPtr;
    fn xmlFreeAutomata(am: xmlAutomataPtr);
    fn xmlAutomataGetInitState(am: xmlAutomataPtr) -> xmlAutomataStatePtr;
    fn xmlAutomataSetFinalState(
        am: xmlAutomataPtr,
        state: xmlAutomataStatePtr,
    ) -> libc::c_int;
    fn xmlAutomataNewState(am: xmlAutomataPtr) -> xmlAutomataStatePtr;
    fn xmlAutomataNewTransition2(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
        token: *const xmlChar,
        token2: *const xmlChar,
        data: *mut libc::c_void,
    ) -> xmlAutomataStatePtr;
    fn xmlAutomataNewNegTrans(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
        token: *const xmlChar,
        token2: *const xmlChar,
        data: *mut libc::c_void,
    ) -> xmlAutomataStatePtr;
    fn xmlAutomataNewCountTrans2(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
        token: *const xmlChar,
        token2: *const xmlChar,
        min: libc::c_int,
        max: libc::c_int,
        data: *mut libc::c_void,
    ) -> xmlAutomataStatePtr;
    fn xmlAutomataNewOnceTrans2(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
        token: *const xmlChar,
        token2: *const xmlChar,
        min: libc::c_int,
        max: libc::c_int,
        data: *mut libc::c_void,
    ) -> xmlAutomataStatePtr;
    fn xmlAutomataNewAllTrans(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
        lax: libc::c_int,
    ) -> xmlAutomataStatePtr;
    fn xmlAutomataNewEpsilon(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
    ) -> xmlAutomataStatePtr;
    fn xmlAutomataNewCountedTrans(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
        counter: libc::c_int,
    ) -> xmlAutomataStatePtr;
    fn xmlAutomataNewCounterTrans(
        am: xmlAutomataPtr,
        from: xmlAutomataStatePtr,
        to: xmlAutomataStatePtr,
        counter: libc::c_int,
    ) -> xmlAutomataStatePtr;
    fn xmlAutomataNewCounter(
        am: xmlAutomataPtr,
        min: libc::c_int,
        max: libc::c_int,
    ) -> libc::c_int;
    fn xmlAutomataCompile(am: xmlAutomataPtr) -> xmlRegexpPtr;
    fn xmlFreeEnumeration(cur: xmlEnumerationPtr);
    fn xmlAddID(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        value: *const xmlChar,
        attr: xmlAttrPtr,
    ) -> xmlIDPtr;
    fn xmlParserInputBufferCreateFilename(
        URI: *const libc::c_char,
        enc: xmlCharEncoding,
    ) -> xmlParserInputBufferPtr;
    fn xmlStopParser(ctxt: xmlParserCtxtPtr);
    fn xmlParseDocument(ctxt: xmlParserCtxtPtr) -> libc::c_int;
    fn xmlNewParserCtxt() -> xmlParserCtxtPtr;
    fn xmlFreeParserCtxt(ctxt: xmlParserCtxtPtr);
    fn xmlNewIOInputStream(
        ctxt: xmlParserCtxtPtr,
        input: xmlParserInputBufferPtr,
        enc: xmlCharEncoding,
    ) -> xmlParserInputPtr;
    fn xmlCtxtReadFile(
        ctxt: xmlParserCtxtPtr,
        filename: *const libc::c_char,
        encoding: *const libc::c_char,
        options: libc::c_int,
    ) -> xmlDocPtr;
    fn xmlCtxtReadMemory(
        ctxt: xmlParserCtxtPtr,
        buffer: *const libc::c_char,
        size: libc::c_int,
        URL: *const libc::c_char,
        encoding: *const libc::c_char,
        options: libc::c_int,
    ) -> xmlDocPtr;
    fn xmlSAX2GetLineNumber(ctx: *mut libc::c_void) -> libc::c_int;
    static mut xmlMalloc: xmlMallocFunc;
    static mut xmlMallocAtomic: xmlMallocFunc;
    static mut xmlRealloc: xmlReallocFunc;
    static mut xmlFree: xmlFreeFunc;
    fn __xmlGenericError() -> *mut xmlGenericErrorFunc;
    fn __xmlGenericErrorContext() -> *mut *mut libc::c_void;
    fn inputPush(ctxt: xmlParserCtxtPtr, value: xmlParserInputPtr) -> libc::c_int;
    fn xmlBuildURI(URI: *const xmlChar, base: *const xmlChar) -> *mut xmlChar;
    fn xmlSchemaInitTypes();
    fn xmlSchemaGetPredefinedType(
        name: *const xmlChar,
        ns: *const xmlChar,
    ) -> xmlSchemaTypePtr;
    fn xmlSchemaValidatePredefinedType(
        type_0: xmlSchemaTypePtr,
        value: *const xmlChar,
        val: *mut xmlSchemaValPtr,
    ) -> libc::c_int;
    fn xmlSchemaValPredefTypeNode(
        type_0: xmlSchemaTypePtr,
        value: *const xmlChar,
        val: *mut xmlSchemaValPtr,
        node: xmlNodePtr,
    ) -> libc::c_int;
    fn xmlSchemaValidateFacetWhtsp(
        facet: xmlSchemaFacetPtr,
        fws: xmlSchemaWhitespaceValueType,
        valType: xmlSchemaValType,
        value: *const xmlChar,
        val: xmlSchemaValPtr,
        ws: xmlSchemaWhitespaceValueType,
    ) -> libc::c_int;
    fn xmlSchemaFreeValue(val: xmlSchemaValPtr);
    fn xmlSchemaCompareValues(x: xmlSchemaValPtr, y: xmlSchemaValPtr) -> libc::c_int;
    fn xmlSchemaValidateListSimpleTypeFacet(
        facet: xmlSchemaFacetPtr,
        value: *const xmlChar,
        actualLen: libc::c_ulong,
        expectedLen: *mut libc::c_ulong,
    ) -> libc::c_int;
    fn xmlSchemaGetBuiltInType(type_0: xmlSchemaValType) -> xmlSchemaTypePtr;
    fn xmlSchemaIsBuiltInTypeFacet(
        type_0: xmlSchemaTypePtr,
        facetType: libc::c_int,
    ) -> libc::c_int;
    fn xmlSchemaCollapseString(value: *const xmlChar) -> *mut xmlChar;
    fn xmlSchemaWhiteSpaceReplace(value: *const xmlChar) -> *mut xmlChar;
    fn xmlSchemaGetFacetValueAsULong(facet: xmlSchemaFacetPtr) -> libc::c_ulong;
    fn xmlSchemaValidateLengthFacetWhtsp(
        facet: xmlSchemaFacetPtr,
        valType: xmlSchemaValType,
        value: *const xmlChar,
        val: xmlSchemaValPtr,
        length: *mut libc::c_ulong,
        ws: xmlSchemaWhitespaceValueType,
    ) -> libc::c_int;
    fn xmlSchemaValPredefTypeNodeNoNorm(
        type_0: xmlSchemaTypePtr,
        value: *const xmlChar,
        val: *mut xmlSchemaValPtr,
        node: xmlNodePtr,
    ) -> libc::c_int;
    fn xmlSchemaGetCanonValue(
        val: xmlSchemaValPtr,
        retValue: *mut *const xmlChar,
    ) -> libc::c_int;
    fn xmlSchemaValueAppend(prev: xmlSchemaValPtr, cur: xmlSchemaValPtr) -> libc::c_int;
    fn xmlSchemaValueGetNext(cur: xmlSchemaValPtr) -> xmlSchemaValPtr;
    fn xmlSchemaValueGetAsString(val: xmlSchemaValPtr) -> *const xmlChar;
    fn xmlSchemaValueGetAsBoolean(val: xmlSchemaValPtr) -> libc::c_int;
    fn xmlSchemaNewNOTATIONValue(
        name: *const xmlChar,
        ns: *const xmlChar,
    ) -> xmlSchemaValPtr;
    fn xmlSchemaNewQNameValue(
        namespaceName: *const xmlChar,
        localName: *const xmlChar,
    ) -> xmlSchemaValPtr;
    fn xmlSchemaCompareValuesWhtsp(
        x: xmlSchemaValPtr,
        xws: xmlSchemaWhitespaceValueType,
        y: xmlSchemaValPtr,
        yws: xmlSchemaWhitespaceValueType,
    ) -> libc::c_int;
    fn xmlSchemaCopyValue(val: xmlSchemaValPtr) -> xmlSchemaValPtr;
    fn xmlSchemaGetValType(val: xmlSchemaValPtr) -> xmlSchemaValType;
    fn xmlFreePattern(comp: xmlPatternPtr);
    fn xmlPatterncompile(
        pattern: *const xmlChar,
        dict: *mut xmlDict,
        flags: libc::c_int,
        namespaces: *mut *const xmlChar,
    ) -> xmlPatternPtr;
    fn xmlPatternGetStreamCtxt(comp: xmlPatternPtr) -> xmlStreamCtxtPtr;
    fn xmlFreeStreamCtxt(stream: xmlStreamCtxtPtr);
    fn xmlStreamPush(
        stream: xmlStreamCtxtPtr,
        name: *const xmlChar,
        ns: *const xmlChar,
    ) -> libc::c_int;
    fn xmlStreamPushAttr(
        stream: xmlStreamCtxtPtr,
        name: *const xmlChar,
        ns: *const xmlChar,
    ) -> libc::c_int;
    fn xmlStreamPop(stream: xmlStreamCtxtPtr) -> libc::c_int;
    fn xmlTextReaderLookupNamespace(
        reader: xmlTextReaderPtr,
        prefix: *const xmlChar,
    ) -> *mut xmlChar;
}
pub type xmlChar = libc::c_uchar;
pub type size_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type xmlFreeFunc = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type xmlMallocFunc = Option::<unsafe extern "C" fn(size_t) -> *mut libc::c_void>;
pub type xmlReallocFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, size_t) -> *mut libc::c_void,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserInputBuffer {
    pub context: *mut libc::c_void,
    pub readcallback: xmlInputReadCallback,
    pub closecallback: xmlInputCloseCallback,
    pub encoder: xmlCharEncodingHandlerPtr,
    pub buffer: xmlBufPtr,
    pub raw: xmlBufPtr,
    pub compressed: libc::c_int,
    pub error: libc::c_int,
    pub rawconsumed: libc::c_ulong,
}
pub type xmlBufPtr = *mut xmlBuf;
pub type xmlBuf = _xmlBuf;
pub type xmlCharEncodingHandlerPtr = *mut xmlCharEncodingHandler;
pub type xmlCharEncodingHandler = _xmlCharEncodingHandler;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlCharEncodingHandler {
    pub name: *mut libc::c_char,
    pub input: xmlCharEncodingInputFunc,
    pub output: xmlCharEncodingOutputFunc,
    pub iconv_in: iconv_t,
    pub iconv_out: iconv_t,
}
pub type iconv_t = *mut libc::c_void;
pub type xmlCharEncodingOutputFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_uchar,
        *mut libc::c_int,
        *const libc::c_uchar,
        *mut libc::c_int,
    ) -> libc::c_int,
>;
pub type xmlCharEncodingInputFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_uchar,
        *mut libc::c_int,
        *const libc::c_uchar,
        *mut libc::c_int,
    ) -> libc::c_int,
>;
pub type xmlInputCloseCallback = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
>;
pub type xmlInputReadCallback = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *mut libc::c_char,
        libc::c_int,
    ) -> libc::c_int,
>;
pub type xmlParserInputBuffer = _xmlParserInputBuffer;
pub type xmlParserInputBufferPtr = *mut xmlParserInputBuffer;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserInput {
    pub buf: xmlParserInputBufferPtr,
    pub filename: *const libc::c_char,
    pub directory: *const libc::c_char,
    pub base: *const xmlChar,
    pub cur: *const xmlChar,
    pub end: *const xmlChar,
    pub length: libc::c_int,
    pub line: libc::c_int,
    pub col: libc::c_int,
    pub consumed: libc::c_ulong,
    pub free: xmlParserInputDeallocate,
    pub encoding: *const xmlChar,
    pub version: *const xmlChar,
    pub standalone: libc::c_int,
    pub id: libc::c_int,
}
pub type xmlParserInputDeallocate = Option::<unsafe extern "C" fn(*mut xmlChar) -> ()>;
pub type xmlParserInput = _xmlParserInput;
pub type xmlParserInputPtr = *mut xmlParserInput;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserCtxt {
    pub sax: *mut _xmlSAXHandler,
    pub userData: *mut libc::c_void,
    pub myDoc: xmlDocPtr,
    pub wellFormed: libc::c_int,
    pub replaceEntities: libc::c_int,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub standalone: libc::c_int,
    pub html: libc::c_int,
    pub input: xmlParserInputPtr,
    pub inputNr: libc::c_int,
    pub inputMax: libc::c_int,
    pub inputTab: *mut xmlParserInputPtr,
    pub node: xmlNodePtr,
    pub nodeNr: libc::c_int,
    pub nodeMax: libc::c_int,
    pub nodeTab: *mut xmlNodePtr,
    pub record_info: libc::c_int,
    pub node_seq: xmlParserNodeInfoSeq,
    pub errNo: libc::c_int,
    pub hasExternalSubset: libc::c_int,
    pub hasPErefs: libc::c_int,
    pub external: libc::c_int,
    pub valid: libc::c_int,
    pub validate: libc::c_int,
    pub vctxt: xmlValidCtxt,
    pub instate: xmlParserInputState,
    pub token: libc::c_int,
    pub directory: *mut libc::c_char,
    pub name: *const xmlChar,
    pub nameNr: libc::c_int,
    pub nameMax: libc::c_int,
    pub nameTab: *mut *const xmlChar,
    pub nbChars: libc::c_long,
    pub checkIndex: libc::c_long,
    pub keepBlanks: libc::c_int,
    pub disableSAX: libc::c_int,
    pub inSubset: libc::c_int,
    pub intSubName: *const xmlChar,
    pub extSubURI: *mut xmlChar,
    pub extSubSystem: *mut xmlChar,
    pub space: *mut libc::c_int,
    pub spaceNr: libc::c_int,
    pub spaceMax: libc::c_int,
    pub spaceTab: *mut libc::c_int,
    pub depth: libc::c_int,
    pub entity: xmlParserInputPtr,
    pub charset: libc::c_int,
    pub nodelen: libc::c_int,
    pub nodemem: libc::c_int,
    pub pedantic: libc::c_int,
    pub _private: *mut libc::c_void,
    pub loadsubset: libc::c_int,
    pub linenumbers: libc::c_int,
    pub catalogs: *mut libc::c_void,
    pub recovery: libc::c_int,
    pub progressive: libc::c_int,
    pub dict: xmlDictPtr,
    pub atts: *mut *const xmlChar,
    pub maxatts: libc::c_int,
    pub docdict: libc::c_int,
    pub str_xml: *const xmlChar,
    pub str_xmlns: *const xmlChar,
    pub str_xml_ns: *const xmlChar,
    pub sax2: libc::c_int,
    pub nsNr: libc::c_int,
    pub nsMax: libc::c_int,
    pub nsTab: *mut *const xmlChar,
    pub attallocs: *mut libc::c_int,
    pub pushTab: *mut xmlStartTag,
    pub attsDefault: xmlHashTablePtr,
    pub attsSpecial: xmlHashTablePtr,
    pub nsWellFormed: libc::c_int,
    pub options: libc::c_int,
    pub dictNames: libc::c_int,
    pub freeElemsNr: libc::c_int,
    pub freeElems: xmlNodePtr,
    pub freeAttrsNr: libc::c_int,
    pub freeAttrs: xmlAttrPtr,
    pub lastError: xmlError,
    pub parseMode: xmlParserMode,
    pub nbentities: libc::c_ulong,
    pub sizeentities: libc::c_ulong,
    pub nodeInfo: *mut xmlParserNodeInfo,
    pub nodeInfoNr: libc::c_int,
    pub nodeInfoMax: libc::c_int,
    pub nodeInfoTab: *mut xmlParserNodeInfo,
    pub input_id: libc::c_int,
    pub sizeentcopy: libc::c_ulong,
}
pub type xmlParserNodeInfo = _xmlParserNodeInfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserNodeInfo {
    pub node: *const _xmlNode,
    pub begin_pos: libc::c_ulong,
    pub begin_line: libc::c_ulong,
    pub end_pos: libc::c_ulong,
    pub end_line: libc::c_ulong,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNode {
    pub _private: *mut libc::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub content: *mut xmlChar,
    pub properties: *mut _xmlAttr,
    pub nsDef: *mut xmlNs,
    pub psvi: *mut libc::c_void,
    pub line: libc::c_ushort,
    pub extra: libc::c_ushort,
}
pub type xmlNs = _xmlNs;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNs {
    pub next: *mut _xmlNs,
    pub type_0: xmlNsType,
    pub href: *const xmlChar,
    pub prefix: *const xmlChar,
    pub _private: *mut libc::c_void,
    pub context: *mut _xmlDoc,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDoc {
    pub _private: *mut libc::c_void,
    pub type_0: xmlElementType,
    pub name: *mut libc::c_char,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub compression: libc::c_int,
    pub standalone: libc::c_int,
    pub intSubset: *mut _xmlDtd,
    pub extSubset: *mut _xmlDtd,
    pub oldNs: *mut _xmlNs,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub ids: *mut libc::c_void,
    pub refs: *mut libc::c_void,
    pub URL: *const xmlChar,
    pub charset: libc::c_int,
    pub dict: *mut _xmlDict,
    pub psvi: *mut libc::c_void,
    pub parseFlags: libc::c_int,
    pub properties: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDtd {
    pub _private: *mut libc::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDoc,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub notations: *mut libc::c_void,
    pub elements: *mut libc::c_void,
    pub attributes: *mut libc::c_void,
    pub entities: *mut libc::c_void,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub pentities: *mut libc::c_void,
}
pub type xmlElementType = libc::c_uint;
pub const XML_XINCLUDE_END: xmlElementType = 20;
pub const XML_XINCLUDE_START: xmlElementType = 19;
pub const XML_NAMESPACE_DECL: xmlElementType = 18;
pub const XML_ENTITY_DECL: xmlElementType = 17;
pub const XML_ATTRIBUTE_DECL: xmlElementType = 16;
pub const XML_ELEMENT_DECL: xmlElementType = 15;
pub const XML_DTD_NODE: xmlElementType = 14;
pub const XML_HTML_DOCUMENT_NODE: xmlElementType = 13;
pub const XML_NOTATION_NODE: xmlElementType = 12;
pub const XML_DOCUMENT_FRAG_NODE: xmlElementType = 11;
pub const XML_DOCUMENT_TYPE_NODE: xmlElementType = 10;
pub const XML_DOCUMENT_NODE: xmlElementType = 9;
pub const XML_COMMENT_NODE: xmlElementType = 8;
pub const XML_PI_NODE: xmlElementType = 7;
pub const XML_ENTITY_NODE: xmlElementType = 6;
pub const XML_ENTITY_REF_NODE: xmlElementType = 5;
pub const XML_CDATA_SECTION_NODE: xmlElementType = 4;
pub const XML_TEXT_NODE: xmlElementType = 3;
pub const XML_ATTRIBUTE_NODE: xmlElementType = 2;
pub const XML_ELEMENT_NODE: xmlElementType = 1;
pub type xmlNsType = xmlElementType;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlAttr {
    pub _private: *mut libc::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlAttr,
    pub prev: *mut _xmlAttr,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub atype: xmlAttributeType,
    pub psvi: *mut libc::c_void,
}
pub type xmlAttributeType = libc::c_uint;
pub const XML_ATTRIBUTE_NOTATION: xmlAttributeType = 10;
pub const XML_ATTRIBUTE_ENUMERATION: xmlAttributeType = 9;
pub const XML_ATTRIBUTE_NMTOKENS: xmlAttributeType = 8;
pub const XML_ATTRIBUTE_NMTOKEN: xmlAttributeType = 7;
pub const XML_ATTRIBUTE_ENTITIES: xmlAttributeType = 6;
pub const XML_ATTRIBUTE_ENTITY: xmlAttributeType = 5;
pub const XML_ATTRIBUTE_IDREFS: xmlAttributeType = 4;
pub const XML_ATTRIBUTE_IDREF: xmlAttributeType = 3;
pub const XML_ATTRIBUTE_ID: xmlAttributeType = 2;
pub const XML_ATTRIBUTE_CDATA: xmlAttributeType = 1;
pub type xmlParserMode = libc::c_uint;
pub const XML_PARSE_READER: xmlParserMode = 5;
pub const XML_PARSE_PUSH_SAX: xmlParserMode = 4;
pub const XML_PARSE_PUSH_DOM: xmlParserMode = 3;
pub const XML_PARSE_SAX: xmlParserMode = 2;
pub const XML_PARSE_DOM: xmlParserMode = 1;
pub const XML_PARSE_UNKNOWN: xmlParserMode = 0;
pub type xmlError = _xmlError;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlError {
    pub domain: libc::c_int,
    pub code: libc::c_int,
    pub message: *mut libc::c_char,
    pub level: xmlErrorLevel,
    pub file: *mut libc::c_char,
    pub line: libc::c_int,
    pub str1: *mut libc::c_char,
    pub str2: *mut libc::c_char,
    pub str3: *mut libc::c_char,
    pub int1: libc::c_int,
    pub int2: libc::c_int,
    pub ctxt: *mut libc::c_void,
    pub node: *mut libc::c_void,
}
pub type xmlErrorLevel = libc::c_uint;
pub const XML_ERR_FATAL: xmlErrorLevel = 3;
pub const XML_ERR_ERROR: xmlErrorLevel = 2;
pub const XML_ERR_WARNING: xmlErrorLevel = 1;
pub const XML_ERR_NONE: xmlErrorLevel = 0;
pub type xmlAttrPtr = *mut xmlAttr;
pub type xmlAttr = _xmlAttr;
pub type xmlNodePtr = *mut xmlNode;
pub type xmlNode = _xmlNode;
pub type xmlHashTablePtr = *mut xmlHashTable;
pub type xmlHashTable = _xmlHashTable;
pub type xmlStartTag = _xmlStartTag;
pub type xmlDictPtr = *mut xmlDict;
pub type xmlDict = _xmlDict;
pub type xmlParserInputState = libc::c_int;
pub const XML_PARSER_PUBLIC_LITERAL: xmlParserInputState = 16;
pub const XML_PARSER_IGNORE: xmlParserInputState = 15;
pub const XML_PARSER_EPILOG: xmlParserInputState = 14;
pub const XML_PARSER_SYSTEM_LITERAL: xmlParserInputState = 13;
pub const XML_PARSER_ATTRIBUTE_VALUE: xmlParserInputState = 12;
pub const XML_PARSER_ENTITY_VALUE: xmlParserInputState = 11;
pub const XML_PARSER_ENTITY_DECL: xmlParserInputState = 10;
pub const XML_PARSER_END_TAG: xmlParserInputState = 9;
pub const XML_PARSER_CDATA_SECTION: xmlParserInputState = 8;
pub const XML_PARSER_CONTENT: xmlParserInputState = 7;
pub const XML_PARSER_START_TAG: xmlParserInputState = 6;
pub const XML_PARSER_COMMENT: xmlParserInputState = 5;
pub const XML_PARSER_PROLOG: xmlParserInputState = 4;
pub const XML_PARSER_DTD: xmlParserInputState = 3;
pub const XML_PARSER_PI: xmlParserInputState = 2;
pub const XML_PARSER_MISC: xmlParserInputState = 1;
pub const XML_PARSER_START: xmlParserInputState = 0;
pub const XML_PARSER_EOF: xmlParserInputState = -1;
pub type xmlValidCtxt = _xmlValidCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlValidCtxt {
    pub userData: *mut libc::c_void,
    pub error: xmlValidityErrorFunc,
    pub warning: xmlValidityWarningFunc,
    pub node: xmlNodePtr,
    pub nodeNr: libc::c_int,
    pub nodeMax: libc::c_int,
    pub nodeTab: *mut xmlNodePtr,
    pub flags: libc::c_uint,
    pub doc: xmlDocPtr,
    pub valid: libc::c_int,
    pub vstate: *mut xmlValidState,
    pub vstateNr: libc::c_int,
    pub vstateMax: libc::c_int,
    pub vstateTab: *mut xmlValidState,
    pub am: xmlAutomataPtr,
    pub state: xmlAutomataStatePtr,
}
pub type xmlAutomataStatePtr = *mut xmlAutomataState;
pub type xmlAutomataState = _xmlAutomataState;
pub type xmlAutomataPtr = *mut xmlAutomata;
pub type xmlAutomata = _xmlAutomata;
pub type xmlValidState = _xmlValidState;
pub type xmlDocPtr = *mut xmlDoc;
pub type xmlDoc = _xmlDoc;
pub type xmlValidityWarningFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const libc::c_char, ...) -> (),
>;
pub type xmlValidityErrorFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const libc::c_char, ...) -> (),
>;
pub type xmlParserNodeInfoSeq = _xmlParserNodeInfoSeq;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserNodeInfoSeq {
    pub maximum: libc::c_ulong,
    pub length: libc::c_ulong,
    pub buffer: *mut xmlParserNodeInfo,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXHandler {
    pub internalSubset: internalSubsetSAXFunc,
    pub isStandalone: isStandaloneSAXFunc,
    pub hasInternalSubset: hasInternalSubsetSAXFunc,
    pub hasExternalSubset: hasExternalSubsetSAXFunc,
    pub resolveEntity: resolveEntitySAXFunc,
    pub getEntity: getEntitySAXFunc,
    pub entityDecl: entityDeclSAXFunc,
    pub notationDecl: notationDeclSAXFunc,
    pub attributeDecl: attributeDeclSAXFunc,
    pub elementDecl: elementDeclSAXFunc,
    pub unparsedEntityDecl: unparsedEntityDeclSAXFunc,
    pub setDocumentLocator: setDocumentLocatorSAXFunc,
    pub startDocument: startDocumentSAXFunc,
    pub endDocument: endDocumentSAXFunc,
    pub startElement: startElementSAXFunc,
    pub endElement: endElementSAXFunc,
    pub reference: referenceSAXFunc,
    pub characters: charactersSAXFunc,
    pub ignorableWhitespace: ignorableWhitespaceSAXFunc,
    pub processingInstruction: processingInstructionSAXFunc,
    pub comment: commentSAXFunc,
    pub warning: warningSAXFunc,
    pub error: errorSAXFunc,
    pub fatalError: fatalErrorSAXFunc,
    pub getParameterEntity: getParameterEntitySAXFunc,
    pub cdataBlock: cdataBlockSAXFunc,
    pub externalSubset: externalSubsetSAXFunc,
    pub initialized: libc::c_uint,
    pub _private: *mut libc::c_void,
    pub startElementNs: startElementNsSAX2Func,
    pub endElementNs: endElementNsSAX2Func,
    pub serror: xmlStructuredErrorFunc,
}
pub type xmlStructuredErrorFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, xmlErrorPtr) -> (),
>;
pub type xmlErrorPtr = *mut xmlError;
pub type endElementNsSAX2Func = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
        *const xmlChar,
    ) -> (),
>;
pub type startElementNsSAX2Func = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
        *const xmlChar,
        libc::c_int,
        *mut *const xmlChar,
        libc::c_int,
        libc::c_int,
        *mut *const xmlChar,
    ) -> (),
>;
pub type externalSubsetSAXFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
        *const xmlChar,
    ) -> (),
>;
pub type cdataBlockSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar, libc::c_int) -> (),
>;
pub type getParameterEntitySAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> xmlEntityPtr,
>;
pub type xmlEntityPtr = *mut xmlEntity;
pub type xmlEntity = _xmlEntity;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlEntity {
    pub _private: *mut libc::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDtd,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub orig: *mut xmlChar,
    pub content: *mut xmlChar,
    pub length: libc::c_int,
    pub etype: xmlEntityType,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub nexte: *mut _xmlEntity,
    pub URI: *const xmlChar,
    pub owner: libc::c_int,
    pub checked: libc::c_int,
}
pub type xmlEntityType = libc::c_uint;
pub const XML_INTERNAL_PREDEFINED_ENTITY: xmlEntityType = 6;
pub const XML_EXTERNAL_PARAMETER_ENTITY: xmlEntityType = 5;
pub const XML_INTERNAL_PARAMETER_ENTITY: xmlEntityType = 4;
pub const XML_EXTERNAL_GENERAL_UNPARSED_ENTITY: xmlEntityType = 3;
pub const XML_EXTERNAL_GENERAL_PARSED_ENTITY: xmlEntityType = 2;
pub const XML_INTERNAL_GENERAL_ENTITY: xmlEntityType = 1;
pub type fatalErrorSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const libc::c_char, ...) -> (),
>;
pub type errorSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const libc::c_char, ...) -> (),
>;
pub type warningSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const libc::c_char, ...) -> (),
>;
pub type commentSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
>;
pub type processingInstructionSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar, *const xmlChar) -> (),
>;
pub type ignorableWhitespaceSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar, libc::c_int) -> (),
>;
pub type charactersSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar, libc::c_int) -> (),
>;
pub type referenceSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
>;
pub type endElementSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
>;
pub type startElementSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar, *mut *const xmlChar) -> (),
>;
pub type endDocumentSAXFunc = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type startDocumentSAXFunc = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type setDocumentLocatorSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, xmlSAXLocatorPtr) -> (),
>;
pub type xmlSAXLocatorPtr = *mut xmlSAXLocator;
pub type xmlSAXLocator = _xmlSAXLocator;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXLocator {
    pub getPublicId: Option::<unsafe extern "C" fn(*mut libc::c_void) -> *const xmlChar>,
    pub getSystemId: Option::<unsafe extern "C" fn(*mut libc::c_void) -> *const xmlChar>,
    pub getLineNumber: Option::<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
    pub getColumnNumber: Option::<
        unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
    >,
}
pub type unparsedEntityDeclSAXFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
        *const xmlChar,
        *const xmlChar,
    ) -> (),
>;
pub type elementDeclSAXFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        libc::c_int,
        xmlElementContentPtr,
    ) -> (),
>;
pub type xmlElementContentPtr = *mut xmlElementContent;
pub type xmlElementContent = _xmlElementContent;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlElementContent {
    pub type_0: xmlElementContentType,
    pub ocur: xmlElementContentOccur,
    pub name: *const xmlChar,
    pub c1: *mut _xmlElementContent,
    pub c2: *mut _xmlElementContent,
    pub parent: *mut _xmlElementContent,
    pub prefix: *const xmlChar,
}
pub type xmlElementContentOccur = libc::c_uint;
pub const XML_ELEMENT_CONTENT_PLUS: xmlElementContentOccur = 4;
pub const XML_ELEMENT_CONTENT_MULT: xmlElementContentOccur = 3;
pub const XML_ELEMENT_CONTENT_OPT: xmlElementContentOccur = 2;
pub const XML_ELEMENT_CONTENT_ONCE: xmlElementContentOccur = 1;
pub type xmlElementContentType = libc::c_uint;
pub const XML_ELEMENT_CONTENT_OR: xmlElementContentType = 4;
pub const XML_ELEMENT_CONTENT_SEQ: xmlElementContentType = 3;
pub const XML_ELEMENT_CONTENT_ELEMENT: xmlElementContentType = 2;
pub const XML_ELEMENT_CONTENT_PCDATA: xmlElementContentType = 1;
pub type attributeDeclSAXFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
        libc::c_int,
        libc::c_int,
        *const xmlChar,
        xmlEnumerationPtr,
    ) -> (),
>;
pub type xmlEnumerationPtr = *mut xmlEnumeration;
pub type xmlEnumeration = _xmlEnumeration;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlEnumeration {
    pub next: *mut _xmlEnumeration,
    pub name: *const xmlChar,
}
pub type notationDeclSAXFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
        *const xmlChar,
    ) -> (),
>;
pub type entityDeclSAXFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        libc::c_int,
        *const xmlChar,
        *const xmlChar,
        *mut xmlChar,
    ) -> (),
>;
pub type getEntitySAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> xmlEntityPtr,
>;
pub type resolveEntitySAXFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
    ) -> xmlParserInputPtr,
>;
pub type hasExternalSubsetSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
>;
pub type hasInternalSubsetSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
>;
pub type isStandaloneSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
>;
pub type internalSubsetSAXFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
        *const xmlChar,
    ) -> (),
>;
pub type xmlParserCtxt = _xmlParserCtxt;
pub type xmlParserCtxtPtr = *mut xmlParserCtxt;
pub type xmlSAXHandler = _xmlSAXHandler;
pub type xmlSAXHandlerPtr = *mut xmlSAXHandler;
pub type xmlRegexp = _xmlRegexp;
pub type xmlRegexpPtr = *mut xmlRegexp;
pub type xmlRegExecCtxt = _xmlRegExecCtxt;
pub type xmlRegExecCtxtPtr = *mut xmlRegExecCtxt;
pub type xmlRegExecCallbacks = Option::<
    unsafe extern "C" fn(
        xmlRegExecCtxtPtr,
        *const xmlChar,
        *mut libc::c_void,
        *mut libc::c_void,
    ) -> (),
>;
pub type xmlNsPtr = *mut xmlNs;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlID {
    pub next: *mut _xmlID,
    pub value: *const xmlChar,
    pub attr: xmlAttrPtr,
    pub name: *const xmlChar,
    pub lineno: libc::c_int,
    pub doc: *mut _xmlDoc,
}
pub type xmlID = _xmlID;
pub type xmlIDPtr = *mut xmlID;
pub type xmlHashDeallocator = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
>;
pub type xmlHashScanner = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *mut libc::c_void, *const xmlChar) -> (),
>;
pub type xmlHashScannerFull = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
        *const xmlChar,
    ) -> (),
>;
pub type C2RustUnnamed = libc::c_uint;
pub const XML_FROM_URI: C2RustUnnamed = 30;
pub const XML_FROM_BUFFER: C2RustUnnamed = 29;
pub const XML_FROM_SCHEMATRONV: C2RustUnnamed = 28;
pub const XML_FROM_I18N: C2RustUnnamed = 27;
pub const XML_FROM_MODULE: C2RustUnnamed = 26;
pub const XML_FROM_WRITER: C2RustUnnamed = 25;
pub const XML_FROM_CHECK: C2RustUnnamed = 24;
pub const XML_FROM_VALID: C2RustUnnamed = 23;
pub const XML_FROM_XSLT: C2RustUnnamed = 22;
pub const XML_FROM_C14N: C2RustUnnamed = 21;
pub const XML_FROM_CATALOG: C2RustUnnamed = 20;
pub const XML_FROM_RELAXNGV: C2RustUnnamed = 19;
pub const XML_FROM_RELAXNGP: C2RustUnnamed = 18;
pub const XML_FROM_SCHEMASV: C2RustUnnamed = 17;
pub const XML_FROM_SCHEMASP: C2RustUnnamed = 16;
pub const XML_FROM_DATATYPE: C2RustUnnamed = 15;
pub const XML_FROM_REGEXP: C2RustUnnamed = 14;
pub const XML_FROM_XPOINTER: C2RustUnnamed = 13;
pub const XML_FROM_XPATH: C2RustUnnamed = 12;
pub const XML_FROM_XINCLUDE: C2RustUnnamed = 11;
pub const XML_FROM_HTTP: C2RustUnnamed = 10;
pub const XML_FROM_FTP: C2RustUnnamed = 9;
pub const XML_FROM_IO: C2RustUnnamed = 8;
pub const XML_FROM_OUTPUT: C2RustUnnamed = 7;
pub const XML_FROM_MEMORY: C2RustUnnamed = 6;
pub const XML_FROM_HTML: C2RustUnnamed = 5;
pub const XML_FROM_DTD: C2RustUnnamed = 4;
pub const XML_FROM_NAMESPACE: C2RustUnnamed = 3;
pub const XML_FROM_TREE: C2RustUnnamed = 2;
pub const XML_FROM_PARSER: C2RustUnnamed = 1;
pub const XML_FROM_NONE: C2RustUnnamed = 0;
pub type xmlParserErrors = libc::c_uint;
pub const XML_BUF_OVERFLOW: xmlParserErrors = 7000;
pub const XML_I18N_NO_OUTPUT: xmlParserErrors = 6004;
pub const XML_I18N_CONV_FAILED: xmlParserErrors = 6003;
pub const XML_I18N_EXCESS_HANDLER: xmlParserErrors = 6002;
pub const XML_I18N_NO_HANDLER: xmlParserErrors = 6001;
pub const XML_I18N_NO_NAME: xmlParserErrors = 6000;
pub const XML_CHECK_NAME_NOT_NULL: xmlParserErrors = 5037;
pub const XML_CHECK_WRONG_NAME: xmlParserErrors = 5036;
pub const XML_CHECK_OUTSIDE_DICT: xmlParserErrors = 5035;
pub const XML_CHECK_NOT_NCNAME: xmlParserErrors = 5034;
pub const XML_CHECK_NO_DICT: xmlParserErrors = 5033;
pub const XML_CHECK_NOT_UTF8: xmlParserErrors = 5032;
pub const XML_CHECK_NS_ANCESTOR: xmlParserErrors = 5031;
pub const XML_CHECK_NS_SCOPE: xmlParserErrors = 5030;
pub const XML_CHECK_WRONG_PARENT: xmlParserErrors = 5029;
pub const XML_CHECK_NO_HREF: xmlParserErrors = 5028;
pub const XML_CHECK_NOT_NS_DECL: xmlParserErrors = 5027;
pub const XML_CHECK_NOT_ENTITY_DECL: xmlParserErrors = 5026;
pub const XML_CHECK_NOT_ELEM_DECL: xmlParserErrors = 5025;
pub const XML_CHECK_NOT_ATTR_DECL: xmlParserErrors = 5024;
pub const XML_CHECK_NOT_ATTR: xmlParserErrors = 5023;
pub const XML_CHECK_NOT_DTD: xmlParserErrors = 5022;
pub const XML_CHECK_WRONG_NEXT: xmlParserErrors = 5021;
pub const XML_CHECK_NO_NEXT: xmlParserErrors = 5020;
pub const XML_CHECK_WRONG_PREV: xmlParserErrors = 5019;
pub const XML_CHECK_NO_PREV: xmlParserErrors = 5018;
pub const XML_CHECK_WRONG_DOC: xmlParserErrors = 5017;
pub const XML_CHECK_NO_ELEM: xmlParserErrors = 5016;
pub const XML_CHECK_NO_NAME: xmlParserErrors = 5015;
pub const XML_CHECK_NO_DOC: xmlParserErrors = 5014;
pub const XML_CHECK_NO_PARENT: xmlParserErrors = 5013;
pub const XML_CHECK_ENTITY_TYPE: xmlParserErrors = 5012;
pub const XML_CHECK_UNKNOWN_NODE: xmlParserErrors = 5011;
pub const XML_CHECK_FOUND_NOTATION: xmlParserErrors = 5010;
pub const XML_CHECK_FOUND_FRAGMENT: xmlParserErrors = 5009;
pub const XML_CHECK_FOUND_DOCTYPE: xmlParserErrors = 5008;
pub const XML_CHECK_FOUND_COMMENT: xmlParserErrors = 5007;
pub const XML_CHECK_FOUND_PI: xmlParserErrors = 5006;
pub const XML_CHECK_FOUND_ENTITY: xmlParserErrors = 5005;
pub const XML_CHECK_FOUND_ENTITYREF: xmlParserErrors = 5004;
pub const XML_CHECK_FOUND_CDATA: xmlParserErrors = 5003;
pub const XML_CHECK_FOUND_TEXT: xmlParserErrors = 5002;
pub const XML_CHECK_FOUND_ATTRIBUTE: xmlParserErrors = 5001;
pub const XML_CHECK_FOUND_ELEMENT: xmlParserErrors = 5000;
pub const XML_MODULE_CLOSE: xmlParserErrors = 4901;
pub const XML_MODULE_OPEN: xmlParserErrors = 4900;
pub const XML_SCHEMATRONV_REPORT: xmlParserErrors = 4001;
pub const XML_SCHEMATRONV_ASSERT: xmlParserErrors = 4000;
pub const XML_SCHEMAP_COS_ALL_LIMITED: xmlParserErrors = 3091;
pub const XML_SCHEMAP_A_PROPS_CORRECT_3: xmlParserErrors = 3090;
pub const XML_SCHEMAP_AU_PROPS_CORRECT: xmlParserErrors = 3089;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_2: xmlParserErrors = 3088;
pub const XML_SCHEMAP_AG_PROPS_CORRECT: xmlParserErrors = 3087;
pub const XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH: xmlParserErrors = 3086;
pub const XML_SCHEMAP_WARN_ATTR_REDECL_PROH: xmlParserErrors = 3085;
pub const XML_SCHEMAP_WARN_UNLOCATED_SCHEMA: xmlParserErrors = 3084;
pub const XML_SCHEMAP_WARN_SKIP_SCHEMA: xmlParserErrors = 3083;
pub const XML_SCHEMAP_SRC_IMPORT: xmlParserErrors = 3082;
pub const XML_SCHEMAP_SRC_REDEFINE: xmlParserErrors = 3081;
pub const XML_SCHEMAP_C_PROPS_CORRECT: xmlParserErrors = 3080;
pub const XML_SCHEMAP_A_PROPS_CORRECT_2: xmlParserErrors = 3079;
pub const XML_SCHEMAP_AU_PROPS_CORRECT_2: xmlParserErrors = 3078;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3: xmlParserErrors = 3077;
pub const XML_SCHEMAP_SRC_CT_1: xmlParserErrors = 3076;
pub const XML_SCHEMAP_MG_PROPS_CORRECT_2: xmlParserErrors = 3075;
pub const XML_SCHEMAP_MG_PROPS_CORRECT_1: xmlParserErrors = 3074;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3: xmlParserErrors = 3073;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2: xmlParserErrors = 3072;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1: xmlParserErrors = 3071;
pub const XML_SCHEMAP_NOT_DETERMINISTIC: xmlParserErrors = 3070;
pub const XML_SCHEMAP_INTERNAL: xmlParserErrors = 3069;
pub const XML_SCHEMAP_SRC_IMPORT_2_2: xmlParserErrors = 3068;
pub const XML_SCHEMAP_SRC_IMPORT_2_1: xmlParserErrors = 3067;
pub const XML_SCHEMAP_SRC_IMPORT_2: xmlParserErrors = 3066;
pub const XML_SCHEMAP_SRC_IMPORT_1_2: xmlParserErrors = 3065;
pub const XML_SCHEMAP_SRC_IMPORT_1_1: xmlParserErrors = 3064;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_1: xmlParserErrors = 3063;
pub const XML_SCHEMAP_CVC_SIMPLE_TYPE: xmlParserErrors = 3062;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2: xmlParserErrors = 3061;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1: xmlParserErrors = 3060;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_1: xmlParserErrors = 3059;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_1: xmlParserErrors = 3058;
pub const XML_SCHEMAP_NO_XSI: xmlParserErrors = 3057;
pub const XML_SCHEMAP_NO_XMLNS: xmlParserErrors = 3056;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_4: xmlParserErrors = 3055;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_3_2: xmlParserErrors = 3054;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_3_1: xmlParserErrors = 3053;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_2: xmlParserErrors = 3052;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_1: xmlParserErrors = 3051;
pub const XML_SCHEMAP_SRC_INCLUDE: xmlParserErrors = 3050;
pub const XML_SCHEMAP_E_PROPS_CORRECT_6: xmlParserErrors = 3049;
pub const XML_SCHEMAP_E_PROPS_CORRECT_5: xmlParserErrors = 3048;
pub const XML_SCHEMAP_E_PROPS_CORRECT_4: xmlParserErrors = 3047;
pub const XML_SCHEMAP_E_PROPS_CORRECT_3: xmlParserErrors = 3046;
pub const XML_SCHEMAP_E_PROPS_CORRECT_2: xmlParserErrors = 3045;
pub const XML_SCHEMAP_P_PROPS_CORRECT_2_2: xmlParserErrors = 3044;
pub const XML_SCHEMAP_P_PROPS_CORRECT_2_1: xmlParserErrors = 3043;
pub const XML_SCHEMAP_P_PROPS_CORRECT_1: xmlParserErrors = 3042;
pub const XML_SCHEMAP_SRC_ELEMENT_3: xmlParserErrors = 3041;
pub const XML_SCHEMAP_SRC_ELEMENT_2_2: xmlParserErrors = 3040;
pub const XML_SCHEMAP_SRC_ELEMENT_2_1: xmlParserErrors = 3039;
pub const XML_SCHEMAP_SRC_ELEMENT_1: xmlParserErrors = 3038;
pub const XML_SCHEMAP_S4S_ATTR_INVALID_VALUE: xmlParserErrors = 3037;
pub const XML_SCHEMAP_S4S_ATTR_MISSING: xmlParserErrors = 3036;
pub const XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED: xmlParserErrors = 3035;
pub const XML_SCHEMAP_S4S_ELEM_MISSING: xmlParserErrors = 3034;
pub const XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED: xmlParserErrors = 3033;
pub const XML_SCHEMAP_COS_ST_DERIVED_OK_2_2: xmlParserErrors = 3032;
pub const XML_SCHEMAP_COS_ST_DERIVED_OK_2_1: xmlParserErrors = 3031;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5: xmlParserErrors = 3030;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4: xmlParserErrors = 3029;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3: xmlParserErrors = 3028;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1: xmlParserErrors = 3027;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2: xmlParserErrors = 3026;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2: xmlParserErrors = 3025;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1: xmlParserErrors = 3024;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_1: xmlParserErrors = 3023;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5: xmlParserErrors = 3022;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4: xmlParserErrors = 3021;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3: xmlParserErrors = 3020;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2: xmlParserErrors = 3019;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1: xmlParserErrors = 3018;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2: xmlParserErrors = 3017;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1: xmlParserErrors = 3016;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_1: xmlParserErrors = 3015;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2: xmlParserErrors = 3014;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1: xmlParserErrors = 3013;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_2: xmlParserErrors = 3012;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_1: xmlParserErrors = 3011;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_3: xmlParserErrors = 3010;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_2: xmlParserErrors = 3009;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_1: xmlParserErrors = 3008;
pub const XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES: xmlParserErrors = 3007;
pub const XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE: xmlParserErrors = 3006;
pub const XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE: xmlParserErrors = 3005;
pub const XML_SCHEMAP_SRC_RESOLVE: xmlParserErrors = 3004;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_4: xmlParserErrors = 3003;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_3: xmlParserErrors = 3002;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_2: xmlParserErrors = 3001;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_1: xmlParserErrors = 3000;
pub const XML_HTTP_UNKNOWN_HOST: xmlParserErrors = 2022;
pub const XML_HTTP_USE_IP: xmlParserErrors = 2021;
pub const XML_HTTP_URL_SYNTAX: xmlParserErrors = 2020;
pub const XML_FTP_URL_SYNTAX: xmlParserErrors = 2003;
pub const XML_FTP_ACCNT: xmlParserErrors = 2002;
pub const XML_FTP_EPSV_ANSWER: xmlParserErrors = 2001;
pub const XML_FTP_PASV_ANSWER: xmlParserErrors = 2000;
pub const XML_C14N_RELATIVE_NAMESPACE: xmlParserErrors = 1955;
pub const XML_C14N_UNKNOW_NODE: xmlParserErrors = 1954;
pub const XML_C14N_INVALID_NODE: xmlParserErrors = 1953;
pub const XML_C14N_CREATE_STACK: xmlParserErrors = 1952;
pub const XML_C14N_REQUIRES_UTF8: xmlParserErrors = 1951;
pub const XML_C14N_CREATE_CTXT: xmlParserErrors = 1950;
pub const XML_XPTR_EXTRA_OBJECTS: xmlParserErrors = 1903;
pub const XML_XPTR_EVAL_FAILED: xmlParserErrors = 1902;
pub const XML_XPTR_CHILDSEQ_START: xmlParserErrors = 1901;
pub const XML_XPTR_UNKNOWN_SCHEME: xmlParserErrors = 1900;
pub const XML_SCHEMAV_MISC: xmlParserErrors = 1879;
pub const XML_SCHEMAV_CVC_WILDCARD: xmlParserErrors = 1878;
pub const XML_SCHEMAV_CVC_IDC: xmlParserErrors = 1877;
pub const XML_SCHEMAV_CVC_TYPE_2: xmlParserErrors = 1876;
pub const XML_SCHEMAV_CVC_TYPE_1: xmlParserErrors = 1875;
pub const XML_SCHEMAV_CVC_AU: xmlParserErrors = 1874;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_1: xmlParserErrors = 1873;
pub const XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING: xmlParserErrors = 1872;
pub const XML_SCHEMAV_ELEMENT_CONTENT: xmlParserErrors = 1871;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2: xmlParserErrors = 1870;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1: xmlParserErrors = 1869;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_4: xmlParserErrors = 1868;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2: xmlParserErrors = 1867;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1: xmlParserErrors = 1866;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1: xmlParserErrors = 1865;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_4: xmlParserErrors = 1864;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_3: xmlParserErrors = 1863;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_2: xmlParserErrors = 1862;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_1: xmlParserErrors = 1861;
pub const XML_SCHEMAV_CVC_ELT_7: xmlParserErrors = 1860;
pub const XML_SCHEMAV_CVC_ELT_6: xmlParserErrors = 1859;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_2_2: xmlParserErrors = 1858;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_2_1: xmlParserErrors = 1857;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_1: xmlParserErrors = 1856;
pub const XML_SCHEMAV_CVC_ELT_5_2_1: xmlParserErrors = 1855;
pub const XML_SCHEMAV_CVC_ELT_5_1_2: xmlParserErrors = 1854;
pub const XML_SCHEMAV_CVC_ELT_5_1_1: xmlParserErrors = 1853;
pub const XML_SCHEMAV_CVC_ELT_4_3: xmlParserErrors = 1852;
pub const XML_SCHEMAV_CVC_ELT_4_2: xmlParserErrors = 1851;
pub const XML_SCHEMAV_CVC_ELT_4_1: xmlParserErrors = 1850;
pub const XML_SCHEMAV_CVC_ELT_3_2_2: xmlParserErrors = 1849;
pub const XML_SCHEMAV_CVC_ELT_3_2_1: xmlParserErrors = 1848;
pub const XML_SCHEMAV_CVC_ELT_3_1: xmlParserErrors = 1847;
pub const XML_SCHEMAV_CVC_ELT_2: xmlParserErrors = 1846;
pub const XML_SCHEMAV_CVC_ELT_1: xmlParserErrors = 1845;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4: xmlParserErrors = 1844;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3: xmlParserErrors = 1843;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2: xmlParserErrors = 1842;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1: xmlParserErrors = 1841;
pub const XML_SCHEMAV_CVC_ENUMERATION_VALID: xmlParserErrors = 1840;
pub const XML_SCHEMAV_CVC_PATTERN_VALID: xmlParserErrors = 1839;
pub const XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID: xmlParserErrors = 1838;
pub const XML_SCHEMAV_CVC_TOTALDIGITS_VALID: xmlParserErrors = 1837;
pub const XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID: xmlParserErrors = 1836;
pub const XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID: xmlParserErrors = 1835;
pub const XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID: xmlParserErrors = 1834;
pub const XML_SCHEMAV_CVC_MININCLUSIVE_VALID: xmlParserErrors = 1833;
pub const XML_SCHEMAV_CVC_MAXLENGTH_VALID: xmlParserErrors = 1832;
pub const XML_SCHEMAV_CVC_MINLENGTH_VALID: xmlParserErrors = 1831;
pub const XML_SCHEMAV_CVC_LENGTH_VALID: xmlParserErrors = 1830;
pub const XML_SCHEMAV_CVC_FACET_VALID: xmlParserErrors = 1829;
pub const XML_SCHEMAV_CVC_TYPE_3_1_2: xmlParserErrors = 1828;
pub const XML_SCHEMAV_CVC_TYPE_3_1_1: xmlParserErrors = 1827;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3: xmlParserErrors = 1826;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2: xmlParserErrors = 1825;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1: xmlParserErrors = 1824;
pub const XML_SCHEMAV_FACET: xmlParserErrors = 1823;
pub const XML_SCHEMAV_VALUE: xmlParserErrors = 1822;
pub const XML_SCHEMAV_ATTRINVALID: xmlParserErrors = 1821;
pub const XML_SCHEMAV_ATTRUNKNOWN: xmlParserErrors = 1820;
pub const XML_SCHEMAV_NOTSIMPLE: xmlParserErrors = 1819;
pub const XML_SCHEMAV_INTERNAL: xmlParserErrors = 1818;
pub const XML_SCHEMAV_CONSTRUCT: xmlParserErrors = 1817;
pub const XML_SCHEMAV_NOTDETERMINIST: xmlParserErrors = 1816;
pub const XML_SCHEMAV_INVALIDELEM: xmlParserErrors = 1815;
pub const XML_SCHEMAV_INVALIDATTR: xmlParserErrors = 1814;
pub const XML_SCHEMAV_EXTRACONTENT: xmlParserErrors = 1813;
pub const XML_SCHEMAV_NOTNILLABLE: xmlParserErrors = 1812;
pub const XML_SCHEMAV_HAVEDEFAULT: xmlParserErrors = 1811;
pub const XML_SCHEMAV_ELEMCONT: xmlParserErrors = 1810;
pub const XML_SCHEMAV_NOTEMPTY: xmlParserErrors = 1809;
pub const XML_SCHEMAV_ISABSTRACT: xmlParserErrors = 1808;
pub const XML_SCHEMAV_NOROLLBACK: xmlParserErrors = 1807;
pub const XML_SCHEMAV_NOTYPE: xmlParserErrors = 1806;
pub const XML_SCHEMAV_WRONGELEM: xmlParserErrors = 1805;
pub const XML_SCHEMAV_MISSING: xmlParserErrors = 1804;
pub const XML_SCHEMAV_NOTTOPLEVEL: xmlParserErrors = 1803;
pub const XML_SCHEMAV_UNDECLAREDELEM: xmlParserErrors = 1802;
pub const XML_SCHEMAV_NOROOT: xmlParserErrors = 1801;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_3: xmlParserErrors = 1800;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3: xmlParserErrors = 1799;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2: xmlParserErrors = 1798;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1: xmlParserErrors = 1797;
pub const XML_SCHEMAP_SRC_IMPORT_3_2: xmlParserErrors = 1796;
pub const XML_SCHEMAP_SRC_IMPORT_3_1: xmlParserErrors = 1795;
pub const XML_SCHEMAP_UNION_NOT_EXPRESSIBLE: xmlParserErrors = 1794;
pub const XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE: xmlParserErrors = 1793;
pub const XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER: xmlParserErrors = 1792;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3: xmlParserErrors = 1791;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2: xmlParserErrors = 1790;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2: xmlParserErrors = 1789;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1: xmlParserErrors = 1788;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1: xmlParserErrors = 1787;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_5: xmlParserErrors = 1786;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_4: xmlParserErrors = 1785;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_3: xmlParserErrors = 1784;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_2: xmlParserErrors = 1783;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_1: xmlParserErrors = 1782;
pub const XML_SCHEMAP_REF_AND_CONTENT: xmlParserErrors = 1781;
pub const XML_SCHEMAP_INVALID_ATTR_NAME: xmlParserErrors = 1780;
pub const XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD: xmlParserErrors = 1779;
pub const XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION: xmlParserErrors = 1778;
pub const XML_SCHEMAP_INVALID_ATTR_COMBINATION: xmlParserErrors = 1777;
pub const XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE: xmlParserErrors = 1776;
pub const XML_SCHEMAP_RECURSIVE: xmlParserErrors = 1775;
pub const XML_SCHEMAP_INVALID_ATTR_USE: xmlParserErrors = 1774;
pub const XML_SCHEMAP_UNKNOWN_MEMBER_TYPE: xmlParserErrors = 1773;
pub const XML_SCHEMAP_NOT_SCHEMA: xmlParserErrors = 1772;
pub const XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI: xmlParserErrors = 1771;
pub const XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI: xmlParserErrors = 1770;
pub const XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD: xmlParserErrors = 1769;
pub const XML_SCHEMAP_DEF_AND_PREFIX: xmlParserErrors = 1768;
pub const XML_SCHEMAP_UNKNOWN_PREFIX: xmlParserErrors = 1767;
pub const XML_SCHEMAP_FAILED_PARSE: xmlParserErrors = 1766;
pub const XML_SCHEMAP_REDEFINED_NOTATION: xmlParserErrors = 1765;
pub const XML_SCHEMAP_REDEFINED_ATTR: xmlParserErrors = 1764;
pub const XML_SCHEMAP_REDEFINED_ATTRGROUP: xmlParserErrors = 1763;
pub const XML_SCHEMAP_REDEFINED_ELEMENT: xmlParserErrors = 1762;
pub const XML_SCHEMAP_REDEFINED_TYPE: xmlParserErrors = 1761;
pub const XML_SCHEMAP_REDEFINED_GROUP: xmlParserErrors = 1760;
pub const XML_SCHEMAP_NOROOT: xmlParserErrors = 1759;
pub const XML_SCHEMAP_NOTHING_TO_PARSE: xmlParserErrors = 1758;
pub const XML_SCHEMAP_FAILED_LOAD: xmlParserErrors = 1757;
pub const XML_SCHEMAP_REGEXP_INVALID: xmlParserErrors = 1756;
pub const XML_SCHEMAP_ELEM_DEFAULT_FIXED: xmlParserErrors = 1755;
pub const XML_SCHEMAP_UNKNOWN_UNION_CHILD: xmlParserErrors = 1754;
pub const XML_SCHEMAP_UNKNOWN_TYPE: xmlParserErrors = 1753;
pub const XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD: xmlParserErrors = 1752;
pub const XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD: xmlParserErrors = 1751;
pub const XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD: xmlParserErrors = 1750;
pub const XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD: xmlParserErrors = 1749;
pub const XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD: xmlParserErrors = 1748;
pub const XML_SCHEMAP_UNKNOWN_REF: xmlParserErrors = 1747;
pub const XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD: xmlParserErrors = 1746;
pub const XML_SCHEMAP_UNKNOWN_NOTATION_CHILD: xmlParserErrors = 1745;
pub const XML_SCHEMAP_UNKNOWN_LIST_CHILD: xmlParserErrors = 1744;
pub const XML_SCHEMAP_UNKNOWN_IMPORT_CHILD: xmlParserErrors = 1743;
pub const XML_SCHEMAP_UNKNOWN_GROUP_CHILD: xmlParserErrors = 1742;
pub const XML_SCHEMAP_UNKNOWN_FACET_TYPE: xmlParserErrors = 1741;
pub const XML_SCHEMAP_UNKNOWN_FACET_CHILD: xmlParserErrors = 1740;
pub const XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD: xmlParserErrors = 1739;
pub const XML_SCHEMAP_UNKNOWN_ELEM_CHILD: xmlParserErrors = 1738;
pub const XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD: xmlParserErrors = 1737;
pub const XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD: xmlParserErrors = 1736;
pub const XML_SCHEMAP_UNKNOWN_CHOICE_CHILD: xmlParserErrors = 1735;
pub const XML_SCHEMAP_UNKNOWN_BASE_TYPE: xmlParserErrors = 1734;
pub const XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP: xmlParserErrors = 1733;
pub const XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD: xmlParserErrors = 1732;
pub const XML_SCHEMAP_UNKNOWN_ATTR_CHILD: xmlParserErrors = 1731;
pub const XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD: xmlParserErrors = 1730;
pub const XML_SCHEMAP_UNKNOWN_ALL_CHILD: xmlParserErrors = 1729;
pub const XML_SCHEMAP_TYPE_AND_SUBTYPE: xmlParserErrors = 1728;
pub const XML_SCHEMAP_SIMPLETYPE_NONAME: xmlParserErrors = 1727;
pub const XML_SCHEMAP_RESTRICTION_NONAME_NOREF: xmlParserErrors = 1726;
pub const XML_SCHEMAP_REF_AND_SUBTYPE: xmlParserErrors = 1725;
pub const XML_SCHEMAP_NOTYPE_NOREF: xmlParserErrors = 1724;
pub const XML_SCHEMAP_NOTATION_NO_NAME: xmlParserErrors = 1723;
pub const XML_SCHEMAP_NOATTR_NOREF: xmlParserErrors = 1722;
pub const XML_SCHEMAP_INVALID_WHITE_SPACE: xmlParserErrors = 1721;
pub const XML_SCHEMAP_INVALID_REF_AND_SUBTYPE: xmlParserErrors = 1720;
pub const XML_SCHEMAP_INVALID_MINOCCURS: xmlParserErrors = 1719;
pub const XML_SCHEMAP_INVALID_MAXOCCURS: xmlParserErrors = 1718;
pub const XML_SCHEMAP_INVALID_FACET_VALUE: xmlParserErrors = 1717;
pub const XML_SCHEMAP_INVALID_FACET: xmlParserErrors = 1716;
pub const XML_SCHEMAP_INVALID_ENUM: xmlParserErrors = 1715;
pub const XML_SCHEMAP_INVALID_BOOLEAN: xmlParserErrors = 1714;
pub const XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI: xmlParserErrors = 1713;
pub const XML_SCHEMAP_IMPORT_REDEFINE_NSNAME: xmlParserErrors = 1712;
pub const XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI: xmlParserErrors = 1711;
pub const XML_SCHEMAP_GROUP_NONAME_NOREF: xmlParserErrors = 1710;
pub const XML_SCHEMAP_FAILED_BUILD_IMPORT: xmlParserErrors = 1709;
pub const XML_SCHEMAP_FACET_NO_VALUE: xmlParserErrors = 1708;
pub const XML_SCHEMAP_EXTENSION_NO_BASE: xmlParserErrors = 1707;
pub const XML_SCHEMAP_ELEM_NONAME_NOREF: xmlParserErrors = 1706;
pub const XML_SCHEMAP_ELEMFORMDEFAULT_VALUE: xmlParserErrors = 1705;
pub const XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF: xmlParserErrors = 1704;
pub const XML_SCHEMAP_ATTR_NONAME_NOREF: xmlParserErrors = 1703;
pub const XML_SCHEMAP_ATTRGRP_NONAME_NOREF: xmlParserErrors = 1702;
pub const XML_SCHEMAP_ATTRFORMDEFAULT_VALUE: xmlParserErrors = 1701;
pub const XML_SCHEMAP_PREFIX_UNDEFINED: xmlParserErrors = 1700;
pub const XML_CATALOG_RECURSION: xmlParserErrors = 1654;
pub const XML_CATALOG_NOT_CATALOG: xmlParserErrors = 1653;
pub const XML_CATALOG_PREFER_VALUE: xmlParserErrors = 1652;
pub const XML_CATALOG_ENTRY_BROKEN: xmlParserErrors = 1651;
pub const XML_CATALOG_MISSING_ATTR: xmlParserErrors = 1650;
pub const XML_XINCLUDE_FRAGMENT_ID: xmlParserErrors = 1618;
pub const XML_XINCLUDE_DEPRECATED_NS: xmlParserErrors = 1617;
pub const XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE: xmlParserErrors = 1616;
pub const XML_XINCLUDE_FALLBACKS_IN_INCLUDE: xmlParserErrors = 1615;
pub const XML_XINCLUDE_INCLUDE_IN_INCLUDE: xmlParserErrors = 1614;
pub const XML_XINCLUDE_XPTR_RESULT: xmlParserErrors = 1613;
pub const XML_XINCLUDE_XPTR_FAILED: xmlParserErrors = 1612;
pub const XML_XINCLUDE_MULTIPLE_ROOT: xmlParserErrors = 1611;
pub const XML_XINCLUDE_UNKNOWN_ENCODING: xmlParserErrors = 1610;
pub const XML_XINCLUDE_BUILD_FAILED: xmlParserErrors = 1609;
pub const XML_XINCLUDE_INVALID_CHAR: xmlParserErrors = 1608;
pub const XML_XINCLUDE_TEXT_DOCUMENT: xmlParserErrors = 1607;
pub const XML_XINCLUDE_TEXT_FRAGMENT: xmlParserErrors = 1606;
pub const XML_XINCLUDE_HREF_URI: xmlParserErrors = 1605;
pub const XML_XINCLUDE_NO_FALLBACK: xmlParserErrors = 1604;
pub const XML_XINCLUDE_NO_HREF: xmlParserErrors = 1603;
pub const XML_XINCLUDE_ENTITY_DEF_MISMATCH: xmlParserErrors = 1602;
pub const XML_XINCLUDE_PARSE_VALUE: xmlParserErrors = 1601;
pub const XML_XINCLUDE_RECURSION: xmlParserErrors = 1600;
pub const XML_IO_EAFNOSUPPORT: xmlParserErrors = 1556;
pub const XML_IO_EALREADY: xmlParserErrors = 1555;
pub const XML_IO_EADDRINUSE: xmlParserErrors = 1554;
pub const XML_IO_ENETUNREACH: xmlParserErrors = 1553;
pub const XML_IO_ECONNREFUSED: xmlParserErrors = 1552;
pub const XML_IO_EISCONN: xmlParserErrors = 1551;
pub const XML_IO_ENOTSOCK: xmlParserErrors = 1550;
pub const XML_IO_LOAD_ERROR: xmlParserErrors = 1549;
pub const XML_IO_BUFFER_FULL: xmlParserErrors = 1548;
pub const XML_IO_NO_INPUT: xmlParserErrors = 1547;
pub const XML_IO_WRITE: xmlParserErrors = 1546;
pub const XML_IO_FLUSH: xmlParserErrors = 1545;
pub const XML_IO_ENCODER: xmlParserErrors = 1544;
pub const XML_IO_NETWORK_ATTEMPT: xmlParserErrors = 1543;
pub const XML_IO_EXDEV: xmlParserErrors = 1542;
pub const XML_IO_ETIMEDOUT: xmlParserErrors = 1541;
pub const XML_IO_ESRCH: xmlParserErrors = 1540;
pub const XML_IO_ESPIPE: xmlParserErrors = 1539;
pub const XML_IO_EROFS: xmlParserErrors = 1538;
pub const XML_IO_ERANGE: xmlParserErrors = 1537;
pub const XML_IO_EPIPE: xmlParserErrors = 1536;
pub const XML_IO_EPERM: xmlParserErrors = 1535;
pub const XML_IO_ENXIO: xmlParserErrors = 1534;
pub const XML_IO_ENOTTY: xmlParserErrors = 1533;
pub const XML_IO_ENOTSUP: xmlParserErrors = 1532;
pub const XML_IO_ENOTEMPTY: xmlParserErrors = 1531;
pub const XML_IO_ENOTDIR: xmlParserErrors = 1530;
pub const XML_IO_ENOSYS: xmlParserErrors = 1529;
pub const XML_IO_ENOSPC: xmlParserErrors = 1528;
pub const XML_IO_ENOMEM: xmlParserErrors = 1527;
pub const XML_IO_ENOLCK: xmlParserErrors = 1526;
pub const XML_IO_ENOEXEC: xmlParserErrors = 1525;
pub const XML_IO_ENOENT: xmlParserErrors = 1524;
pub const XML_IO_ENODEV: xmlParserErrors = 1523;
pub const XML_IO_ENFILE: xmlParserErrors = 1522;
pub const XML_IO_ENAMETOOLONG: xmlParserErrors = 1521;
pub const XML_IO_EMSGSIZE: xmlParserErrors = 1520;
pub const XML_IO_EMLINK: xmlParserErrors = 1519;
pub const XML_IO_EMFILE: xmlParserErrors = 1518;
pub const XML_IO_EISDIR: xmlParserErrors = 1517;
pub const XML_IO_EIO: xmlParserErrors = 1516;
pub const XML_IO_EINVAL: xmlParserErrors = 1515;
pub const XML_IO_EINTR: xmlParserErrors = 1514;
pub const XML_IO_EINPROGRESS: xmlParserErrors = 1513;
pub const XML_IO_EFBIG: xmlParserErrors = 1512;
pub const XML_IO_EFAULT: xmlParserErrors = 1511;
pub const XML_IO_EEXIST: xmlParserErrors = 1510;
pub const XML_IO_EDOM: xmlParserErrors = 1509;
pub const XML_IO_EDEADLK: xmlParserErrors = 1508;
pub const XML_IO_ECHILD: xmlParserErrors = 1507;
pub const XML_IO_ECANCELED: xmlParserErrors = 1506;
pub const XML_IO_EBUSY: xmlParserErrors = 1505;
pub const XML_IO_EBADMSG: xmlParserErrors = 1504;
pub const XML_IO_EBADF: xmlParserErrors = 1503;
pub const XML_IO_EAGAIN: xmlParserErrors = 1502;
pub const XML_IO_EACCES: xmlParserErrors = 1501;
pub const XML_IO_UNKNOWN: xmlParserErrors = 1500;
pub const XML_REGEXP_COMPILE_ERROR: xmlParserErrors = 1450;
pub const XML_SAVE_UNKNOWN_ENCODING: xmlParserErrors = 1403;
pub const XML_SAVE_NO_DOCTYPE: xmlParserErrors = 1402;
pub const XML_SAVE_CHAR_INVALID: xmlParserErrors = 1401;
pub const XML_SAVE_NOT_UTF8: xmlParserErrors = 1400;
pub const XML_TREE_NOT_UTF8: xmlParserErrors = 1303;
pub const XML_TREE_UNTERMINATED_ENTITY: xmlParserErrors = 1302;
pub const XML_TREE_INVALID_DEC: xmlParserErrors = 1301;
pub const XML_TREE_INVALID_HEX: xmlParserErrors = 1300;
pub const XML_XPATH_INVALID_CHAR_ERROR: xmlParserErrors = 1221;
pub const XML_XPATH_ENCODING_ERROR: xmlParserErrors = 1220;
pub const XML_XPATH_UNDEF_PREFIX_ERROR: xmlParserErrors = 1219;
pub const XML_XPTR_SUB_RESOURCE_ERROR: xmlParserErrors = 1218;
pub const XML_XPTR_RESOURCE_ERROR: xmlParserErrors = 1217;
pub const XML_XPTR_SYNTAX_ERROR: xmlParserErrors = 1216;
pub const XML_XPATH_MEMORY_ERROR: xmlParserErrors = 1215;
pub const XML_XPATH_INVALID_CTXT_POSITION: xmlParserErrors = 1214;
pub const XML_XPATH_INVALID_CTXT_SIZE: xmlParserErrors = 1213;
pub const XML_XPATH_INVALID_ARITY: xmlParserErrors = 1212;
pub const XML_XPATH_INVALID_TYPE: xmlParserErrors = 1211;
pub const XML_XPATH_INVALID_OPERAND: xmlParserErrors = 1210;
pub const XML_XPATH_UNKNOWN_FUNC_ERROR: xmlParserErrors = 1209;
pub const XML_XPATH_UNCLOSED_ERROR: xmlParserErrors = 1208;
pub const XML_XPATH_EXPR_ERROR: xmlParserErrors = 1207;
pub const XML_XPATH_INVALID_PREDICATE_ERROR: xmlParserErrors = 1206;
pub const XML_XPATH_UNDEF_VARIABLE_ERROR: xmlParserErrors = 1205;
pub const XML_XPATH_VARIABLE_REF_ERROR: xmlParserErrors = 1204;
pub const XML_XPATH_START_LITERAL_ERROR: xmlParserErrors = 1203;
pub const XML_XPATH_UNFINISHED_LITERAL_ERROR: xmlParserErrors = 1202;
pub const XML_XPATH_NUMBER_ERROR: xmlParserErrors = 1201;
pub const XML_XPATH_EXPRESSION_OK: xmlParserErrors = 1200;
pub const XML_RNGP_XML_NS: xmlParserErrors = 1122;
pub const XML_RNGP_XMLNS_NAME: xmlParserErrors = 1121;
pub const XML_RNGP_VALUE_NO_CONTENT: xmlParserErrors = 1120;
pub const XML_RNGP_VALUE_EMPTY: xmlParserErrors = 1119;
pub const XML_RNGP_URI_NOT_ABSOLUTE: xmlParserErrors = 1118;
pub const XML_RNGP_URI_FRAGMENT: xmlParserErrors = 1117;
pub const XML_RNGP_UNKNOWN_TYPE_LIB: xmlParserErrors = 1116;
pub const XML_RNGP_UNKNOWN_CONSTRUCT: xmlParserErrors = 1115;
pub const XML_RNGP_UNKNOWN_COMBINE: xmlParserErrors = 1114;
pub const XML_RNGP_UNKNOWN_ATTRIBUTE: xmlParserErrors = 1113;
pub const XML_RNGP_TYPE_VALUE: xmlParserErrors = 1112;
pub const XML_RNGP_TYPE_NOT_FOUND: xmlParserErrors = 1111;
pub const XML_RNGP_TYPE_MISSING: xmlParserErrors = 1110;
pub const XML_RNGP_TEXT_HAS_CHILD: xmlParserErrors = 1109;
pub const XML_RNGP_TEXT_EXPECTED: xmlParserErrors = 1108;
pub const XML_RNGP_START_MISSING: xmlParserErrors = 1107;
pub const XML_RNGP_START_EMPTY: xmlParserErrors = 1106;
pub const XML_RNGP_START_CONTENT: xmlParserErrors = 1105;
pub const XML_RNGP_START_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1104;
pub const XML_RNGP_REF_NOT_EMPTY: xmlParserErrors = 1103;
pub const XML_RNGP_REF_NO_NAME: xmlParserErrors = 1102;
pub const XML_RNGP_REF_NO_DEF: xmlParserErrors = 1101;
pub const XML_RNGP_REF_NAME_INVALID: xmlParserErrors = 1100;
pub const XML_RNGP_REF_CYCLE: xmlParserErrors = 1099;
pub const XML_RNGP_REF_CREATE_FAILED: xmlParserErrors = 1098;
pub const XML_RNGP_PREFIX_UNDEFINED: xmlParserErrors = 1097;
pub const XML_RNGP_PAT_START_VALUE: xmlParserErrors = 1096;
pub const XML_RNGP_PAT_START_TEXT: xmlParserErrors = 1095;
pub const XML_RNGP_PAT_START_ONEMORE: xmlParserErrors = 1094;
pub const XML_RNGP_PAT_START_LIST: xmlParserErrors = 1093;
pub const XML_RNGP_PAT_START_INTERLEAVE: xmlParserErrors = 1092;
pub const XML_RNGP_PAT_START_GROUP: xmlParserErrors = 1091;
pub const XML_RNGP_PAT_START_EMPTY: xmlParserErrors = 1090;
pub const XML_RNGP_PAT_START_DATA: xmlParserErrors = 1089;
pub const XML_RNGP_PAT_START_ATTR: xmlParserErrors = 1088;
pub const XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR: xmlParserErrors = 1087;
pub const XML_RNGP_PAT_ONEMORE_GROUP_ATTR: xmlParserErrors = 1086;
pub const XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME: xmlParserErrors = 1085;
pub const XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME: xmlParserErrors = 1084;
pub const XML_RNGP_PAT_LIST_TEXT: xmlParserErrors = 1083;
pub const XML_RNGP_PAT_LIST_REF: xmlParserErrors = 1082;
pub const XML_RNGP_PAT_LIST_LIST: xmlParserErrors = 1081;
pub const XML_RNGP_PAT_LIST_INTERLEAVE: xmlParserErrors = 1080;
pub const XML_RNGP_PAT_LIST_ELEM: xmlParserErrors = 1079;
pub const XML_RNGP_PAT_LIST_ATTR: xmlParserErrors = 1078;
pub const XML_RNGP_PAT_DATA_EXCEPT_TEXT: xmlParserErrors = 1077;
pub const XML_RNGP_PAT_DATA_EXCEPT_REF: xmlParserErrors = 1076;
pub const XML_RNGP_PAT_DATA_EXCEPT_ONEMORE: xmlParserErrors = 1075;
pub const XML_RNGP_PAT_DATA_EXCEPT_LIST: xmlParserErrors = 1074;
pub const XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE: xmlParserErrors = 1073;
pub const XML_RNGP_PAT_DATA_EXCEPT_GROUP: xmlParserErrors = 1072;
pub const XML_RNGP_PAT_DATA_EXCEPT_EMPTY: xmlParserErrors = 1071;
pub const XML_RNGP_PAT_DATA_EXCEPT_ELEM: xmlParserErrors = 1070;
pub const XML_RNGP_PAT_DATA_EXCEPT_ATTR: xmlParserErrors = 1069;
pub const XML_RNGP_PAT_ATTR_ELEM: xmlParserErrors = 1068;
pub const XML_RNGP_PAT_ATTR_ATTR: xmlParserErrors = 1067;
pub const XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME: xmlParserErrors = 1066;
pub const XML_RNGP_PARSE_ERROR: xmlParserErrors = 1065;
pub const XML_RNGP_PARENTREF_NOT_EMPTY: xmlParserErrors = 1064;
pub const XML_RNGP_PARENTREF_NO_PARENT: xmlParserErrors = 1063;
pub const XML_RNGP_PARENTREF_NO_NAME: xmlParserErrors = 1062;
pub const XML_RNGP_PARENTREF_NAME_INVALID: xmlParserErrors = 1061;
pub const XML_RNGP_PARENTREF_CREATE_FAILED: xmlParserErrors = 1060;
pub const XML_RNGP_PARAM_NAME_MISSING: xmlParserErrors = 1059;
pub const XML_RNGP_PARAM_FORBIDDEN: xmlParserErrors = 1058;
pub const XML_RNGP_NSNAME_NO_NS: xmlParserErrors = 1057;
pub const XML_RNGP_NSNAME_ATTR_ANCESTOR: xmlParserErrors = 1056;
pub const XML_RNGP_NOTALLOWED_NOT_EMPTY: xmlParserErrors = 1055;
pub const XML_RNGP_NEED_COMBINE: xmlParserErrors = 1054;
pub const XML_RNGP_NAME_MISSING: xmlParserErrors = 1053;
pub const XML_RNGP_MISSING_HREF: xmlParserErrors = 1052;
pub const XML_RNGP_INVALID_VALUE: xmlParserErrors = 1051;
pub const XML_RNGP_INVALID_URI: xmlParserErrors = 1050;
pub const XML_RNGP_INVALID_DEFINE_NAME: xmlParserErrors = 1049;
pub const XML_RNGP_INTERLEAVE_NO_CONTENT: xmlParserErrors = 1048;
pub const XML_RNGP_INTERLEAVE_EMPTY: xmlParserErrors = 1047;
pub const XML_RNGP_INTERLEAVE_CREATE_FAILED: xmlParserErrors = 1046;
pub const XML_RNGP_INTERLEAVE_ADD: xmlParserErrors = 1045;
pub const XML_RNGP_INCLUDE_RECURSE: xmlParserErrors = 1044;
pub const XML_RNGP_INCLUDE_FAILURE: xmlParserErrors = 1043;
pub const XML_RNGP_INCLUDE_EMPTY: xmlParserErrors = 1042;
pub const XML_RNGP_HREF_ERROR: xmlParserErrors = 1041;
pub const XML_RNGP_GROUP_ATTR_CONFLICT: xmlParserErrors = 1040;
pub const XML_RNGP_GRAMMAR_NO_START: xmlParserErrors = 1039;
pub const XML_RNGP_GRAMMAR_MISSING: xmlParserErrors = 1038;
pub const XML_RNGP_GRAMMAR_EMPTY: xmlParserErrors = 1037;
pub const XML_RNGP_GRAMMAR_CONTENT: xmlParserErrors = 1036;
pub const XML_RNGP_FOREIGN_ELEMENT: xmlParserErrors = 1035;
pub const XML_RNGP_FORBIDDEN_ATTRIBUTE: xmlParserErrors = 1034;
pub const XML_RNGP_EXTERNALREF_RECURSE: xmlParserErrors = 1033;
pub const XML_RNGP_EXTERNAL_REF_FAILURE: xmlParserErrors = 1032;
pub const XML_RNGP_EXTERNALREF_EMTPY: xmlParserErrors = 1031;
pub const XML_RNGP_EXCEPT_NO_CONTENT: xmlParserErrors = 1030;
pub const XML_RNGP_EXCEPT_MULTIPLE: xmlParserErrors = 1029;
pub const XML_RNGP_EXCEPT_MISSING: xmlParserErrors = 1028;
pub const XML_RNGP_EXCEPT_EMPTY: xmlParserErrors = 1027;
pub const XML_RNGP_ERROR_TYPE_LIB: xmlParserErrors = 1026;
pub const XML_RNGP_EMPTY_NOT_EMPTY: xmlParserErrors = 1025;
pub const XML_RNGP_EMPTY_CONTENT: xmlParserErrors = 1024;
pub const XML_RNGP_EMPTY_CONSTRUCT: xmlParserErrors = 1023;
pub const XML_RNGP_EMPTY: xmlParserErrors = 1022;
pub const XML_RNGP_ELEM_TEXT_CONFLICT: xmlParserErrors = 1021;
pub const XML_RNGP_ELEMENT_NO_CONTENT: xmlParserErrors = 1020;
pub const XML_RNGP_ELEMENT_NAME: xmlParserErrors = 1019;
pub const XML_RNGP_ELEMENT_CONTENT: xmlParserErrors = 1018;
pub const XML_RNGP_ELEMENT_EMPTY: xmlParserErrors = 1017;
pub const XML_RNGP_ELEM_CONTENT_ERROR: xmlParserErrors = 1016;
pub const XML_RNGP_ELEM_CONTENT_EMPTY: xmlParserErrors = 1015;
pub const XML_RNGP_DEFINE_NAME_MISSING: xmlParserErrors = 1014;
pub const XML_RNGP_DEFINE_MISSING: xmlParserErrors = 1013;
pub const XML_RNGP_DEFINE_EMPTY: xmlParserErrors = 1012;
pub const XML_RNGP_DEFINE_CREATE_FAILED: xmlParserErrors = 1011;
pub const XML_RNGP_DEF_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1010;
pub const XML_RNGP_DATA_CONTENT: xmlParserErrors = 1009;
pub const XML_RNGP_CREATE_FAILURE: xmlParserErrors = 1008;
pub const XML_RNGP_CHOICE_EMPTY: xmlParserErrors = 1007;
pub const XML_RNGP_CHOICE_CONTENT: xmlParserErrors = 1006;
pub const XML_RNGP_ATTRIBUTE_NOOP: xmlParserErrors = 1005;
pub const XML_RNGP_ATTRIBUTE_EMPTY: xmlParserErrors = 1004;
pub const XML_RNGP_ATTRIBUTE_CONTENT: xmlParserErrors = 1003;
pub const XML_RNGP_ATTRIBUTE_CHILDREN: xmlParserErrors = 1002;
pub const XML_RNGP_ATTR_CONFLICT: xmlParserErrors = 1001;
pub const XML_RNGP_ANYNAME_ATTR_ANCESTOR: xmlParserErrors = 1000;
pub const XML_HTML_INCORRECTLY_OPENED_COMMENT: xmlParserErrors = 802;
pub const XML_HTML_UNKNOWN_TAG: xmlParserErrors = 801;
pub const XML_HTML_STRUCURE_ERROR: xmlParserErrors = 800;
pub const XML_DTD_DUP_TOKEN: xmlParserErrors = 541;
pub const XML_DTD_XMLID_TYPE: xmlParserErrors = 540;
pub const XML_DTD_XMLID_VALUE: xmlParserErrors = 539;
pub const XML_DTD_STANDALONE_DEFAULTED: xmlParserErrors = 538;
pub const XML_DTD_UNKNOWN_NOTATION: xmlParserErrors = 537;
pub const XML_DTD_UNKNOWN_ID: xmlParserErrors = 536;
pub const XML_DTD_UNKNOWN_ENTITY: xmlParserErrors = 535;
pub const XML_DTD_UNKNOWN_ELEM: xmlParserErrors = 534;
pub const XML_DTD_UNKNOWN_ATTRIBUTE: xmlParserErrors = 533;
pub const XML_DTD_STANDALONE_WHITE_SPACE: xmlParserErrors = 532;
pub const XML_DTD_ROOT_NAME: xmlParserErrors = 531;
pub const XML_DTD_NOT_STANDALONE: xmlParserErrors = 530;
pub const XML_DTD_NOT_PCDATA: xmlParserErrors = 529;
pub const XML_DTD_NOT_EMPTY: xmlParserErrors = 528;
pub const XML_DTD_NOTATION_VALUE: xmlParserErrors = 527;
pub const XML_DTD_NOTATION_REDEFINED: xmlParserErrors = 526;
pub const XML_DTD_NO_ROOT: xmlParserErrors = 525;
pub const XML_DTD_NO_PREFIX: xmlParserErrors = 524;
pub const XML_DTD_NO_ELEM_NAME: xmlParserErrors = 523;
pub const XML_DTD_NO_DTD: xmlParserErrors = 522;
pub const XML_DTD_NO_DOC: xmlParserErrors = 521;
pub const XML_DTD_MULTIPLE_ID: xmlParserErrors = 520;
pub const XML_DTD_MIXED_CORRUPT: xmlParserErrors = 519;
pub const XML_DTD_MISSING_ATTRIBUTE: xmlParserErrors = 518;
pub const XML_DTD_LOAD_ERROR: xmlParserErrors = 517;
pub const XML_DTD_INVALID_DEFAULT: xmlParserErrors = 516;
pub const XML_DTD_INVALID_CHILD: xmlParserErrors = 515;
pub const XML_DTD_ID_SUBSET: xmlParserErrors = 514;
pub const XML_DTD_ID_REDEFINED: xmlParserErrors = 513;
pub const XML_DTD_ID_FIXED: xmlParserErrors = 512;
pub const XML_DTD_ENTITY_TYPE: xmlParserErrors = 511;
pub const XML_DTD_EMPTY_NOTATION: xmlParserErrors = 510;
pub const XML_DTD_ELEM_REDEFINED: xmlParserErrors = 509;
pub const XML_DTD_ELEM_NAMESPACE: xmlParserErrors = 508;
pub const XML_DTD_ELEM_DEFAULT_NAMESPACE: xmlParserErrors = 507;
pub const XML_DTD_DIFFERENT_PREFIX: xmlParserErrors = 506;
pub const XML_DTD_CONTENT_NOT_DETERMINIST: xmlParserErrors = 505;
pub const XML_DTD_CONTENT_MODEL: xmlParserErrors = 504;
pub const XML_DTD_CONTENT_ERROR: xmlParserErrors = 503;
pub const XML_DTD_ATTRIBUTE_VALUE: xmlParserErrors = 502;
pub const XML_DTD_ATTRIBUTE_REDEFINED: xmlParserErrors = 501;
pub const XML_DTD_ATTRIBUTE_DEFAULT: xmlParserErrors = 500;
pub const XML_NS_ERR_COLON: xmlParserErrors = 205;
pub const XML_NS_ERR_EMPTY: xmlParserErrors = 204;
pub const XML_NS_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 203;
pub const XML_NS_ERR_QNAME: xmlParserErrors = 202;
pub const XML_NS_ERR_UNDEFINED_NAMESPACE: xmlParserErrors = 201;
pub const XML_NS_ERR_XML_NAMESPACE: xmlParserErrors = 200;
pub const XML_ERR_COMMENT_ABRUPTLY_ENDED: xmlParserErrors = 112;
pub const XML_ERR_USER_STOP: xmlParserErrors = 111;
pub const XML_ERR_NAME_TOO_LONG: xmlParserErrors = 110;
pub const XML_ERR_VERSION_MISMATCH: xmlParserErrors = 109;
pub const XML_ERR_UNKNOWN_VERSION: xmlParserErrors = 108;
pub const XML_WAR_ENTITY_REDEFINED: xmlParserErrors = 107;
pub const XML_WAR_NS_COLUMN: xmlParserErrors = 106;
pub const XML_ERR_NOTATION_PROCESSING: xmlParserErrors = 105;
pub const XML_ERR_ENTITY_PROCESSING: xmlParserErrors = 104;
pub const XML_ERR_NOT_STANDALONE: xmlParserErrors = 103;
pub const XML_WAR_SPACE_VALUE: xmlParserErrors = 102;
pub const XML_ERR_MISSING_ENCODING: xmlParserErrors = 101;
pub const XML_WAR_NS_URI_RELATIVE: xmlParserErrors = 100;
pub const XML_WAR_NS_URI: xmlParserErrors = 99;
pub const XML_WAR_LANG_VALUE: xmlParserErrors = 98;
pub const XML_WAR_UNKNOWN_VERSION: xmlParserErrors = 97;
pub const XML_ERR_VERSION_MISSING: xmlParserErrors = 96;
pub const XML_ERR_CONDSEC_INVALID_KEYWORD: xmlParserErrors = 95;
pub const XML_ERR_NO_DTD: xmlParserErrors = 94;
pub const XML_WAR_CATALOG_PI: xmlParserErrors = 93;
pub const XML_ERR_URI_FRAGMENT: xmlParserErrors = 92;
pub const XML_ERR_INVALID_URI: xmlParserErrors = 91;
pub const XML_ERR_ENTITY_BOUNDARY: xmlParserErrors = 90;
pub const XML_ERR_ENTITY_LOOP: xmlParserErrors = 89;
pub const XML_ERR_ENTITY_PE_INTERNAL: xmlParserErrors = 88;
pub const XML_ERR_ENTITY_CHAR_ERROR: xmlParserErrors = 87;
pub const XML_ERR_EXTRA_CONTENT: xmlParserErrors = 86;
pub const XML_ERR_NOT_WELL_BALANCED: xmlParserErrors = 85;
pub const XML_ERR_VALUE_REQUIRED: xmlParserErrors = 84;
pub const XML_ERR_CONDSEC_INVALID: xmlParserErrors = 83;
pub const XML_ERR_EXT_ENTITY_STANDALONE: xmlParserErrors = 82;
pub const XML_ERR_INVALID_ENCODING: xmlParserErrors = 81;
pub const XML_ERR_HYPHEN_IN_COMMENT: xmlParserErrors = 80;
pub const XML_ERR_ENCODING_NAME: xmlParserErrors = 79;
pub const XML_ERR_STANDALONE_VALUE: xmlParserErrors = 78;
pub const XML_ERR_TAG_NOT_FINISHED: xmlParserErrors = 77;
pub const XML_ERR_TAG_NAME_MISMATCH: xmlParserErrors = 76;
pub const XML_ERR_EQUAL_REQUIRED: xmlParserErrors = 75;
pub const XML_ERR_LTSLASH_REQUIRED: xmlParserErrors = 74;
pub const XML_ERR_GT_REQUIRED: xmlParserErrors = 73;
pub const XML_ERR_LT_REQUIRED: xmlParserErrors = 72;
pub const XML_ERR_PUBID_REQUIRED: xmlParserErrors = 71;
pub const XML_ERR_URI_REQUIRED: xmlParserErrors = 70;
pub const XML_ERR_PCDATA_REQUIRED: xmlParserErrors = 69;
pub const XML_ERR_NAME_REQUIRED: xmlParserErrors = 68;
pub const XML_ERR_NMTOKEN_REQUIRED: xmlParserErrors = 67;
pub const XML_ERR_SEPARATOR_REQUIRED: xmlParserErrors = 66;
pub const XML_ERR_SPACE_REQUIRED: xmlParserErrors = 65;
pub const XML_ERR_RESERVED_XML_NAME: xmlParserErrors = 64;
pub const XML_ERR_CDATA_NOT_FINISHED: xmlParserErrors = 63;
pub const XML_ERR_MISPLACED_CDATA_END: xmlParserErrors = 62;
pub const XML_ERR_DOCTYPE_NOT_FINISHED: xmlParserErrors = 61;
pub const XML_ERR_EXT_SUBSET_NOT_FINISHED: xmlParserErrors = 60;
pub const XML_ERR_CONDSEC_NOT_FINISHED: xmlParserErrors = 59;
pub const XML_ERR_CONDSEC_NOT_STARTED: xmlParserErrors = 58;
pub const XML_ERR_XMLDECL_NOT_FINISHED: xmlParserErrors = 57;
pub const XML_ERR_XMLDECL_NOT_STARTED: xmlParserErrors = 56;
pub const XML_ERR_ELEMCONTENT_NOT_FINISHED: xmlParserErrors = 55;
pub const XML_ERR_ELEMCONTENT_NOT_STARTED: xmlParserErrors = 54;
pub const XML_ERR_MIXED_NOT_FINISHED: xmlParserErrors = 53;
pub const XML_ERR_MIXED_NOT_STARTED: xmlParserErrors = 52;
pub const XML_ERR_ATTLIST_NOT_FINISHED: xmlParserErrors = 51;
pub const XML_ERR_ATTLIST_NOT_STARTED: xmlParserErrors = 50;
pub const XML_ERR_NOTATION_NOT_FINISHED: xmlParserErrors = 49;
pub const XML_ERR_NOTATION_NOT_STARTED: xmlParserErrors = 48;
pub const XML_ERR_PI_NOT_FINISHED: xmlParserErrors = 47;
pub const XML_ERR_PI_NOT_STARTED: xmlParserErrors = 46;
pub const XML_ERR_COMMENT_NOT_FINISHED: xmlParserErrors = 45;
pub const XML_ERR_LITERAL_NOT_FINISHED: xmlParserErrors = 44;
pub const XML_ERR_LITERAL_NOT_STARTED: xmlParserErrors = 43;
pub const XML_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 42;
pub const XML_ERR_ATTRIBUTE_WITHOUT_VALUE: xmlParserErrors = 41;
pub const XML_ERR_ATTRIBUTE_NOT_FINISHED: xmlParserErrors = 40;
pub const XML_ERR_ATTRIBUTE_NOT_STARTED: xmlParserErrors = 39;
pub const XML_ERR_LT_IN_ATTRIBUTE: xmlParserErrors = 38;
pub const XML_ERR_ENTITY_NOT_FINISHED: xmlParserErrors = 37;
pub const XML_ERR_ENTITY_NOT_STARTED: xmlParserErrors = 36;
pub const XML_ERR_NS_DECL_ERROR: xmlParserErrors = 35;
pub const XML_ERR_STRING_NOT_CLOSED: xmlParserErrors = 34;
pub const XML_ERR_STRING_NOT_STARTED: xmlParserErrors = 33;
pub const XML_ERR_UNSUPPORTED_ENCODING: xmlParserErrors = 32;
pub const XML_ERR_UNKNOWN_ENCODING: xmlParserErrors = 31;
pub const XML_ERR_ENTITY_IS_PARAMETER: xmlParserErrors = 30;
pub const XML_ERR_ENTITY_IS_EXTERNAL: xmlParserErrors = 29;
pub const XML_ERR_UNPARSED_ENTITY: xmlParserErrors = 28;
pub const XML_WAR_UNDECLARED_ENTITY: xmlParserErrors = 27;
pub const XML_ERR_UNDECLARED_ENTITY: xmlParserErrors = 26;
pub const XML_ERR_PEREF_SEMICOL_MISSING: xmlParserErrors = 25;
pub const XML_ERR_PEREF_NO_NAME: xmlParserErrors = 24;
pub const XML_ERR_ENTITYREF_SEMICOL_MISSING: xmlParserErrors = 23;
pub const XML_ERR_ENTITYREF_NO_NAME: xmlParserErrors = 22;
pub const XML_ERR_PEREF_IN_INT_SUBSET: xmlParserErrors = 21;
pub const XML_ERR_PEREF_IN_EPILOG: xmlParserErrors = 20;
pub const XML_ERR_PEREF_IN_PROLOG: xmlParserErrors = 19;
pub const XML_ERR_PEREF_AT_EOF: xmlParserErrors = 18;
pub const XML_ERR_ENTITYREF_IN_DTD: xmlParserErrors = 17;
pub const XML_ERR_ENTITYREF_IN_EPILOG: xmlParserErrors = 16;
pub const XML_ERR_ENTITYREF_IN_PROLOG: xmlParserErrors = 15;
pub const XML_ERR_ENTITYREF_AT_EOF: xmlParserErrors = 14;
pub const XML_ERR_CHARREF_IN_DTD: xmlParserErrors = 13;
pub const XML_ERR_CHARREF_IN_EPILOG: xmlParserErrors = 12;
pub const XML_ERR_CHARREF_IN_PROLOG: xmlParserErrors = 11;
pub const XML_ERR_CHARREF_AT_EOF: xmlParserErrors = 10;
pub const XML_ERR_INVALID_CHAR: xmlParserErrors = 9;
pub const XML_ERR_INVALID_CHARREF: xmlParserErrors = 8;
pub const XML_ERR_INVALID_DEC_CHARREF: xmlParserErrors = 7;
pub const XML_ERR_INVALID_HEX_CHARREF: xmlParserErrors = 6;
pub const XML_ERR_DOCUMENT_END: xmlParserErrors = 5;
pub const XML_ERR_DOCUMENT_EMPTY: xmlParserErrors = 4;
pub const XML_ERR_DOCUMENT_START: xmlParserErrors = 3;
pub const XML_ERR_NO_MEMORY: xmlParserErrors = 2;
pub const XML_ERR_INTERNAL_ERROR: xmlParserErrors = 1;
pub const XML_ERR_OK: xmlParserErrors = 0;
pub type xmlGenericErrorFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const libc::c_char, ...) -> (),
>;
pub type xmlValidCtxtPtr = *mut xmlValidCtxt;
pub type xmlCharEncoding = libc::c_int;
pub const XML_CHAR_ENCODING_ASCII: xmlCharEncoding = 22;
pub const XML_CHAR_ENCODING_EUC_JP: xmlCharEncoding = 21;
pub const XML_CHAR_ENCODING_SHIFT_JIS: xmlCharEncoding = 20;
pub const XML_CHAR_ENCODING_2022_JP: xmlCharEncoding = 19;
pub const XML_CHAR_ENCODING_8859_9: xmlCharEncoding = 18;
pub const XML_CHAR_ENCODING_8859_8: xmlCharEncoding = 17;
pub const XML_CHAR_ENCODING_8859_7: xmlCharEncoding = 16;
pub const XML_CHAR_ENCODING_8859_6: xmlCharEncoding = 15;
pub const XML_CHAR_ENCODING_8859_5: xmlCharEncoding = 14;
pub const XML_CHAR_ENCODING_8859_4: xmlCharEncoding = 13;
pub const XML_CHAR_ENCODING_8859_3: xmlCharEncoding = 12;
pub const XML_CHAR_ENCODING_8859_2: xmlCharEncoding = 11;
pub const XML_CHAR_ENCODING_8859_1: xmlCharEncoding = 10;
pub const XML_CHAR_ENCODING_UCS2: xmlCharEncoding = 9;
pub const XML_CHAR_ENCODING_UCS4_3412: xmlCharEncoding = 8;
pub const XML_CHAR_ENCODING_UCS4_2143: xmlCharEncoding = 7;
pub const XML_CHAR_ENCODING_EBCDIC: xmlCharEncoding = 6;
pub const XML_CHAR_ENCODING_UCS4BE: xmlCharEncoding = 5;
pub const XML_CHAR_ENCODING_UCS4LE: xmlCharEncoding = 4;
pub const XML_CHAR_ENCODING_UTF16BE: xmlCharEncoding = 3;
pub const XML_CHAR_ENCODING_UTF16LE: xmlCharEncoding = 2;
pub const XML_CHAR_ENCODING_UTF8: xmlCharEncoding = 1;
pub const XML_CHAR_ENCODING_NONE: xmlCharEncoding = 0;
pub const XML_CHAR_ENCODING_ERROR: xmlCharEncoding = -1;
pub type C2RustUnnamed_0 = libc::c_uint;
pub const XML_PARSE_BIG_LINES: C2RustUnnamed_0 = 4194304;
pub const XML_PARSE_IGNORE_ENC: C2RustUnnamed_0 = 2097152;
pub const XML_PARSE_OLDSAX: C2RustUnnamed_0 = 1048576;
pub const XML_PARSE_HUGE: C2RustUnnamed_0 = 524288;
pub const XML_PARSE_NOBASEFIX: C2RustUnnamed_0 = 262144;
pub const XML_PARSE_OLD10: C2RustUnnamed_0 = 131072;
pub const XML_PARSE_COMPACT: C2RustUnnamed_0 = 65536;
pub const XML_PARSE_NOXINCNODE: C2RustUnnamed_0 = 32768;
pub const XML_PARSE_NOCDATA: C2RustUnnamed_0 = 16384;
pub const XML_PARSE_NSCLEAN: C2RustUnnamed_0 = 8192;
pub const XML_PARSE_NODICT: C2RustUnnamed_0 = 4096;
pub const XML_PARSE_NONET: C2RustUnnamed_0 = 2048;
pub const XML_PARSE_XINCLUDE: C2RustUnnamed_0 = 1024;
pub const XML_PARSE_SAX1: C2RustUnnamed_0 = 512;
pub const XML_PARSE_NOBLANKS: C2RustUnnamed_0 = 256;
pub const XML_PARSE_PEDANTIC: C2RustUnnamed_0 = 128;
pub const XML_PARSE_NOWARNING: C2RustUnnamed_0 = 64;
pub const XML_PARSE_NOERROR: C2RustUnnamed_0 = 32;
pub const XML_PARSE_DTDVALID: C2RustUnnamed_0 = 16;
pub const XML_PARSE_DTDATTR: C2RustUnnamed_0 = 8;
pub const XML_PARSE_DTDLOAD: C2RustUnnamed_0 = 4;
pub const XML_PARSE_NOENT: C2RustUnnamed_0 = 2;
pub const XML_PARSE_RECOVER: C2RustUnnamed_0 = 1;
pub type C2RustUnnamed_1 = libc::c_uint;
pub const XML_SCHEMA_VAL_VC_I_CREATE: C2RustUnnamed_1 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchema {
    pub name: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub version: *const xmlChar,
    pub id: *const xmlChar,
    pub doc: xmlDocPtr,
    pub annot: xmlSchemaAnnotPtr,
    pub flags: libc::c_int,
    pub typeDecl: xmlHashTablePtr,
    pub attrDecl: xmlHashTablePtr,
    pub attrgrpDecl: xmlHashTablePtr,
    pub elemDecl: xmlHashTablePtr,
    pub notaDecl: xmlHashTablePtr,
    pub schemasImports: xmlHashTablePtr,
    pub _private: *mut libc::c_void,
    pub groupDecl: xmlHashTablePtr,
    pub dict: xmlDictPtr,
    pub includes: *mut libc::c_void,
    pub preserve: libc::c_int,
    pub counter: libc::c_int,
    pub idcDef: xmlHashTablePtr,
    pub volatiles: *mut libc::c_void,
}
pub type xmlSchemaAnnotPtr = *mut xmlSchemaAnnot;
pub type xmlSchemaAnnot = _xmlSchemaAnnot;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAnnot {
    pub next: *mut _xmlSchemaAnnot,
    pub content: xmlNodePtr,
}
pub type xmlSchema = _xmlSchema;
pub type xmlSchemaPtr = *mut xmlSchema;
pub type xmlSchemaValidityErrorFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const libc::c_char, ...) -> (),
>;
pub type xmlSchemaValidityWarningFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const libc::c_char, ...) -> (),
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaParserCtxt {
    pub type_0: libc::c_int,
    pub errCtxt: *mut libc::c_void,
    pub error: xmlSchemaValidityErrorFunc,
    pub warning: xmlSchemaValidityWarningFunc,
    pub err: libc::c_int,
    pub nberrors: libc::c_int,
    pub serror: xmlStructuredErrorFunc,
    pub constructor: xmlSchemaConstructionCtxtPtr,
    pub ownsConstructor: libc::c_int,
    pub schema: xmlSchemaPtr,
    pub counter: libc::c_int,
    pub URL: *const xmlChar,
    pub doc: xmlDocPtr,
    pub preserve: libc::c_int,
    pub buffer: *const libc::c_char,
    pub size: libc::c_int,
    pub am: xmlAutomataPtr,
    pub start: xmlAutomataStatePtr,
    pub end: xmlAutomataStatePtr,
    pub state: xmlAutomataStatePtr,
    pub dict: xmlDictPtr,
    pub ctxtType: xmlSchemaTypePtr,
    pub options: libc::c_int,
    pub vctxt: xmlSchemaValidCtxtPtr,
    pub isS4S: libc::c_int,
    pub isRedefine: libc::c_int,
    pub xsiAssemble: libc::c_int,
    pub stop: libc::c_int,
    pub targetNamespace: *const xmlChar,
    pub redefined: xmlSchemaBucketPtr,
    pub redef: xmlSchemaRedefPtr,
    pub redefCounter: libc::c_int,
    pub attrProhibs: xmlSchemaItemListPtr,
}
pub type xmlSchemaItemListPtr = *mut xmlSchemaItemList;
pub type xmlSchemaItemList = _xmlSchemaItemList;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaItemList {
    pub items: *mut *mut libc::c_void,
    pub nbItems: libc::c_int,
    pub sizeItems: libc::c_int,
}
pub type xmlSchemaRedefPtr = *mut xmlSchemaRedef;
pub type xmlSchemaRedef = _xmlSchemaRedef;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaRedef {
    pub next: xmlSchemaRedefPtr,
    pub item: xmlSchemaBasicItemPtr,
    pub reference: xmlSchemaBasicItemPtr,
    pub target: xmlSchemaBasicItemPtr,
    pub refName: *const xmlChar,
    pub refTargetNs: *const xmlChar,
    pub targetBucket: xmlSchemaBucketPtr,
}
pub type xmlSchemaBucketPtr = *mut xmlSchemaBucket;
pub type xmlSchemaBucket = _xmlSchemaBucket;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaBucket {
    pub type_0: libc::c_int,
    pub flags: libc::c_int,
    pub schemaLocation: *const xmlChar,
    pub origTargetNamespace: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub doc: xmlDocPtr,
    pub relations: xmlSchemaSchemaRelationPtr,
    pub located: libc::c_int,
    pub parsed: libc::c_int,
    pub imported: libc::c_int,
    pub preserveDoc: libc::c_int,
    pub globals: xmlSchemaItemListPtr,
    pub locals: xmlSchemaItemListPtr,
}
pub type xmlSchemaSchemaRelationPtr = *mut xmlSchemaSchemaRelation;
pub type xmlSchemaSchemaRelation = _xmlSchemaSchemaRelation;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaSchemaRelation {
    pub next: xmlSchemaSchemaRelationPtr,
    pub type_0: libc::c_int,
    pub importNamespace: *const xmlChar,
    pub bucket: xmlSchemaBucketPtr,
}
pub type xmlSchemaBasicItemPtr = *mut xmlSchemaBasicItem;
pub type xmlSchemaBasicItem = _xmlSchemaBasicItem;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaBasicItem {
    pub type_0: xmlSchemaTypeType,
    pub dummy: *mut libc::c_void,
}
pub type xmlSchemaTypeType = libc::c_uint;
pub const XML_SCHEMA_EXTRA_ATTR_USE_PROHIB: xmlSchemaTypeType = 2001;
pub const XML_SCHEMA_EXTRA_QNAMEREF: xmlSchemaTypeType = 2000;
pub const XML_SCHEMA_FACET_MINLENGTH: xmlSchemaTypeType = 1011;
pub const XML_SCHEMA_FACET_MAXLENGTH: xmlSchemaTypeType = 1010;
pub const XML_SCHEMA_FACET_LENGTH: xmlSchemaTypeType = 1009;
pub const XML_SCHEMA_FACET_WHITESPACE: xmlSchemaTypeType = 1008;
pub const XML_SCHEMA_FACET_ENUMERATION: xmlSchemaTypeType = 1007;
pub const XML_SCHEMA_FACET_PATTERN: xmlSchemaTypeType = 1006;
pub const XML_SCHEMA_FACET_FRACTIONDIGITS: xmlSchemaTypeType = 1005;
pub const XML_SCHEMA_FACET_TOTALDIGITS: xmlSchemaTypeType = 1004;
pub const XML_SCHEMA_FACET_MAXEXCLUSIVE: xmlSchemaTypeType = 1003;
pub const XML_SCHEMA_FACET_MAXINCLUSIVE: xmlSchemaTypeType = 1002;
pub const XML_SCHEMA_FACET_MINEXCLUSIVE: xmlSchemaTypeType = 1001;
pub const XML_SCHEMA_FACET_MININCLUSIVE: xmlSchemaTypeType = 1000;
pub const XML_SCHEMA_TYPE_ATTRIBUTE_USE: xmlSchemaTypeType = 26;
pub const XML_SCHEMA_TYPE_PARTICLE: xmlSchemaTypeType = 25;
pub const XML_SCHEMA_TYPE_IDC_KEYREF: xmlSchemaTypeType = 24;
pub const XML_SCHEMA_TYPE_IDC_KEY: xmlSchemaTypeType = 23;
pub const XML_SCHEMA_TYPE_IDC_UNIQUE: xmlSchemaTypeType = 22;
pub const XML_SCHEMA_TYPE_ANY_ATTRIBUTE: xmlSchemaTypeType = 21;
pub const XML_SCHEMA_TYPE_UNION: xmlSchemaTypeType = 20;
pub const XML_SCHEMA_TYPE_LIST: xmlSchemaTypeType = 19;
pub const XML_SCHEMA_TYPE_NOTATION: xmlSchemaTypeType = 18;
pub const XML_SCHEMA_TYPE_GROUP: xmlSchemaTypeType = 17;
pub const XML_SCHEMA_TYPE_ATTRIBUTEGROUP: xmlSchemaTypeType = 16;
pub const XML_SCHEMA_TYPE_ATTRIBUTE: xmlSchemaTypeType = 15;
pub const XML_SCHEMA_TYPE_ELEMENT: xmlSchemaTypeType = 14;
pub const XML_SCHEMA_TYPE_EXTENSION: xmlSchemaTypeType = 13;
pub const XML_SCHEMA_TYPE_RESTRICTION: xmlSchemaTypeType = 12;
pub const XML_SCHEMA_TYPE_UR: xmlSchemaTypeType = 11;
pub const XML_SCHEMA_TYPE_COMPLEX_CONTENT: xmlSchemaTypeType = 10;
pub const XML_SCHEMA_TYPE_SIMPLE_CONTENT: xmlSchemaTypeType = 9;
pub const XML_SCHEMA_TYPE_ALL: xmlSchemaTypeType = 8;
pub const XML_SCHEMA_TYPE_CHOICE: xmlSchemaTypeType = 7;
pub const XML_SCHEMA_TYPE_SEQUENCE: xmlSchemaTypeType = 6;
pub const XML_SCHEMA_TYPE_COMPLEX: xmlSchemaTypeType = 5;
pub const XML_SCHEMA_TYPE_SIMPLE: xmlSchemaTypeType = 4;
pub const XML_SCHEMA_TYPE_FACET: xmlSchemaTypeType = 3;
pub const XML_SCHEMA_TYPE_ANY: xmlSchemaTypeType = 2;
pub const XML_SCHEMA_TYPE_BASIC: xmlSchemaTypeType = 1;
pub type xmlSchemaValidCtxtPtr = *mut xmlSchemaValidCtxt;
pub type xmlSchemaValidCtxt = _xmlSchemaValidCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaValidCtxt {
    pub type_0: libc::c_int,
    pub errCtxt: *mut libc::c_void,
    pub error: xmlSchemaValidityErrorFunc,
    pub warning: xmlSchemaValidityWarningFunc,
    pub serror: xmlStructuredErrorFunc,
    pub schema: xmlSchemaPtr,
    pub doc: xmlDocPtr,
    pub input: xmlParserInputBufferPtr,
    pub enc: xmlCharEncoding,
    pub sax: xmlSAXHandlerPtr,
    pub parserCtxt: xmlParserCtxtPtr,
    pub user_data: *mut libc::c_void,
    pub filename: *mut libc::c_char,
    pub err: libc::c_int,
    pub nberrors: libc::c_int,
    pub node: xmlNodePtr,
    pub cur: xmlNodePtr,
    pub regexp: xmlRegExecCtxtPtr,
    pub value: xmlSchemaValPtr,
    pub valueWS: libc::c_int,
    pub options: libc::c_int,
    pub validationRoot: xmlNodePtr,
    pub pctxt: xmlSchemaParserCtxtPtr,
    pub xsiAssemble: libc::c_int,
    pub depth: libc::c_int,
    pub elemInfos: *mut xmlSchemaNodeInfoPtr,
    pub sizeElemInfos: libc::c_int,
    pub inode: xmlSchemaNodeInfoPtr,
    pub aidcs: xmlSchemaIDCAugPtr,
    pub xpathStates: xmlSchemaIDCStateObjPtr,
    pub xpathStatePool: xmlSchemaIDCStateObjPtr,
    pub idcMatcherCache: xmlSchemaIDCMatcherPtr,
    pub idcNodes: *mut xmlSchemaPSVIIDCNodePtr,
    pub nbIdcNodes: libc::c_int,
    pub sizeIdcNodes: libc::c_int,
    pub idcKeys: *mut xmlSchemaPSVIIDCKeyPtr,
    pub nbIdcKeys: libc::c_int,
    pub sizeIdcKeys: libc::c_int,
    pub flags: libc::c_int,
    pub dict: xmlDictPtr,
    pub reader: xmlTextReaderPtr,
    pub attrInfos: *mut xmlSchemaAttrInfoPtr,
    pub nbAttrInfos: libc::c_int,
    pub sizeAttrInfos: libc::c_int,
    pub skipDepth: libc::c_int,
    pub nodeQNames: xmlSchemaItemListPtr,
    pub hasKeyrefs: libc::c_int,
    pub createIDCNodeTables: libc::c_int,
    pub psviExposeIDCNodeTables: libc::c_int,
    pub locFunc: xmlSchemaValidityLocatorFunc,
    pub locCtxt: *mut libc::c_void,
}
pub type xmlSchemaValidityLocatorFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *mut *const libc::c_char,
        *mut libc::c_ulong,
    ) -> libc::c_int,
>;
pub type xmlSchemaAttrInfoPtr = *mut xmlSchemaAttrInfo;
pub type xmlSchemaAttrInfo = _xmlSchemaAttrInfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttrInfo {
    pub nodeType: libc::c_int,
    pub node: xmlNodePtr,
    pub nodeLine: libc::c_int,
    pub localName: *const xmlChar,
    pub nsName: *const xmlChar,
    pub value: *const xmlChar,
    pub val: xmlSchemaValPtr,
    pub typeDef: xmlSchemaTypePtr,
    pub flags: libc::c_int,
    pub decl: xmlSchemaAttributePtr,
    pub use_0: xmlSchemaAttributeUsePtr,
    pub state: libc::c_int,
    pub metaType: libc::c_int,
    pub vcValue: *const xmlChar,
    pub parent: xmlSchemaNodeInfoPtr,
}
pub type xmlSchemaNodeInfoPtr = *mut xmlSchemaNodeInfo;
pub type xmlSchemaNodeInfo = _xmlSchemaNodeInfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaNodeInfo {
    pub nodeType: libc::c_int,
    pub node: xmlNodePtr,
    pub nodeLine: libc::c_int,
    pub localName: *const xmlChar,
    pub nsName: *const xmlChar,
    pub value: *const xmlChar,
    pub val: xmlSchemaValPtr,
    pub typeDef: xmlSchemaTypePtr,
    pub flags: libc::c_int,
    pub valNeeded: libc::c_int,
    pub normVal: libc::c_int,
    pub decl: xmlSchemaElementPtr,
    pub depth: libc::c_int,
    pub idcTable: xmlSchemaPSVIIDCBindingPtr,
    pub idcMatchers: xmlSchemaIDCMatcherPtr,
    pub regexCtxt: xmlRegExecCtxtPtr,
    pub nsBindings: *mut *const xmlChar,
    pub nbNsBindings: libc::c_int,
    pub sizeNsBindings: libc::c_int,
    pub hasKeyrefs: libc::c_int,
    pub appliedXPath: libc::c_int,
}
pub type xmlSchemaIDCMatcherPtr = *mut xmlSchemaIDCMatcher;
pub type xmlSchemaIDCMatcher = _xmlSchemaIDCMatcher;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDCMatcher {
    pub type_0: libc::c_int,
    pub depth: libc::c_int,
    pub next: xmlSchemaIDCMatcherPtr,
    pub nextCached: xmlSchemaIDCMatcherPtr,
    pub aidc: xmlSchemaIDCAugPtr,
    pub idcType: libc::c_int,
    pub keySeqs: *mut *mut xmlSchemaPSVIIDCKeyPtr,
    pub sizeKeySeqs: libc::c_int,
    pub targets: xmlSchemaItemListPtr,
    pub htab: xmlHashTablePtr,
}
pub type xmlSchemaPSVIIDCKeyPtr = *mut xmlSchemaPSVIIDCKey;
pub type xmlSchemaPSVIIDCKey = _xmlSchemaPSVIIDCKey;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaPSVIIDCKey {
    pub type_0: xmlSchemaTypePtr,
    pub val: xmlSchemaValPtr,
}
pub type xmlSchemaValPtr = *mut xmlSchemaVal;
pub type xmlSchemaVal = _xmlSchemaVal;
pub type xmlSchemaTypePtr = *mut xmlSchemaType;
pub type xmlSchemaType = _xmlSchemaType;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaType {
    pub type_0: xmlSchemaTypeType,
    pub next: *mut _xmlSchemaType,
    pub name: *const xmlChar,
    pub id: *const xmlChar,
    pub ref_0: *const xmlChar,
    pub refNs: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub subtypes: xmlSchemaTypePtr,
    pub attributes: xmlSchemaAttributePtr,
    pub node: xmlNodePtr,
    pub minOccurs: libc::c_int,
    pub maxOccurs: libc::c_int,
    pub flags: libc::c_int,
    pub contentType: xmlSchemaContentType,
    pub base: *const xmlChar,
    pub baseNs: *const xmlChar,
    pub baseType: xmlSchemaTypePtr,
    pub facets: xmlSchemaFacetPtr,
    pub redef: *mut _xmlSchemaType,
    pub recurse: libc::c_int,
    pub attributeUses: *mut xmlSchemaAttributeLinkPtr,
    pub attributeWildcard: xmlSchemaWildcardPtr,
    pub builtInType: libc::c_int,
    pub memberTypes: xmlSchemaTypeLinkPtr,
    pub facetSet: xmlSchemaFacetLinkPtr,
    pub refPrefix: *const xmlChar,
    pub contentTypeDef: xmlSchemaTypePtr,
    pub contModel: xmlRegexpPtr,
    pub targetNamespace: *const xmlChar,
    pub attrUses: *mut libc::c_void,
}
pub type xmlSchemaFacetLinkPtr = *mut xmlSchemaFacetLink;
pub type xmlSchemaFacetLink = _xmlSchemaFacetLink;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaFacetLink {
    pub next: *mut _xmlSchemaFacetLink,
    pub facet: xmlSchemaFacetPtr,
}
pub type xmlSchemaFacetPtr = *mut xmlSchemaFacet;
pub type xmlSchemaFacet = _xmlSchemaFacet;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaFacet {
    pub type_0: xmlSchemaTypeType,
    pub next: *mut _xmlSchemaFacet,
    pub value: *const xmlChar,
    pub id: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub node: xmlNodePtr,
    pub fixed: libc::c_int,
    pub whitespace: libc::c_int,
    pub val: xmlSchemaValPtr,
    pub regexp: xmlRegexpPtr,
}
pub type xmlSchemaTypeLinkPtr = *mut xmlSchemaTypeLink;
pub type xmlSchemaTypeLink = _xmlSchemaTypeLink;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaTypeLink {
    pub next: *mut _xmlSchemaTypeLink,
    pub type_0: xmlSchemaTypePtr,
}
pub type xmlSchemaWildcardPtr = *mut xmlSchemaWildcard;
pub type xmlSchemaWildcard = _xmlSchemaWildcard;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaWildcard {
    pub type_0: xmlSchemaTypeType,
    pub id: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub node: xmlNodePtr,
    pub minOccurs: libc::c_int,
    pub maxOccurs: libc::c_int,
    pub processContents: libc::c_int,
    pub any: libc::c_int,
    pub nsSet: xmlSchemaWildcardNsPtr,
    pub negNsSet: xmlSchemaWildcardNsPtr,
    pub flags: libc::c_int,
}
pub type xmlSchemaWildcardNsPtr = *mut xmlSchemaWildcardNs;
pub type xmlSchemaWildcardNs = _xmlSchemaWildcardNs;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaWildcardNs {
    pub next: *mut _xmlSchemaWildcardNs,
    pub value: *const xmlChar,
}
pub type xmlSchemaAttributeLinkPtr = *mut xmlSchemaAttributeLink;
pub type xmlSchemaAttributeLink = _xmlSchemaAttributeLink;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttributeLink {
    pub next: *mut _xmlSchemaAttributeLink,
    pub attr: *mut _xmlSchemaAttribute,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttribute {
    pub type_0: xmlSchemaTypeType,
    pub next: *mut _xmlSchemaAttribute,
    pub name: *const xmlChar,
    pub id: *const xmlChar,
    pub ref_0: *const xmlChar,
    pub refNs: *const xmlChar,
    pub typeName: *const xmlChar,
    pub typeNs: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub base: xmlSchemaTypePtr,
    pub occurs: libc::c_int,
    pub defValue: *const xmlChar,
    pub subtypes: xmlSchemaTypePtr,
    pub node: xmlNodePtr,
    pub targetNamespace: *const xmlChar,
    pub flags: libc::c_int,
    pub refPrefix: *const xmlChar,
    pub defVal: xmlSchemaValPtr,
    pub refDecl: xmlSchemaAttributePtr,
}
pub type xmlSchemaAttributePtr = *mut xmlSchemaAttribute;
pub type xmlSchemaAttribute = _xmlSchemaAttribute;
pub type xmlSchemaContentType = libc::c_uint;
pub const XML_SCHEMA_CONTENT_ANY: xmlSchemaContentType = 7;
pub const XML_SCHEMA_CONTENT_BASIC: xmlSchemaContentType = 6;
pub const XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS: xmlSchemaContentType = 5;
pub const XML_SCHEMA_CONTENT_SIMPLE: xmlSchemaContentType = 4;
pub const XML_SCHEMA_CONTENT_MIXED: xmlSchemaContentType = 3;
pub const XML_SCHEMA_CONTENT_ELEMENTS: xmlSchemaContentType = 2;
pub const XML_SCHEMA_CONTENT_EMPTY: xmlSchemaContentType = 1;
pub const XML_SCHEMA_CONTENT_UNKNOWN: xmlSchemaContentType = 0;
pub type xmlSchemaIDCAugPtr = *mut xmlSchemaIDCAug;
pub type xmlSchemaIDCAug = _xmlSchemaIDCAug;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDCAug {
    pub next: xmlSchemaIDCAugPtr,
    pub def: xmlSchemaIDCPtr,
    pub keyrefDepth: libc::c_int,
}
pub type xmlSchemaIDCPtr = *mut xmlSchemaIDC;
pub type xmlSchemaIDC = _xmlSchemaIDC;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDC {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaIDCPtr,
    pub node: xmlNodePtr,
    pub name: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub selector: xmlSchemaIDCSelectPtr,
    pub fields: xmlSchemaIDCSelectPtr,
    pub nbFields: libc::c_int,
    pub ref_0: xmlSchemaQNameRefPtr,
}
pub type xmlSchemaQNameRefPtr = *mut xmlSchemaQNameRef;
pub type xmlSchemaQNameRef = _xmlSchemaQNameRef;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaQNameRef {
    pub type_0: xmlSchemaTypeType,
    pub item: xmlSchemaBasicItemPtr,
    pub itemType: xmlSchemaTypeType,
    pub name: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub node: xmlNodePtr,
}
pub type xmlSchemaIDCSelectPtr = *mut xmlSchemaIDCSelect;
pub type xmlSchemaIDCSelect = _xmlSchemaIDCSelect;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDCSelect {
    pub next: xmlSchemaIDCSelectPtr,
    pub idc: xmlSchemaIDCPtr,
    pub index: libc::c_int,
    pub xpath: *const xmlChar,
    pub xpathComp: *mut libc::c_void,
}
pub type xmlSchemaPSVIIDCBindingPtr = *mut xmlSchemaPSVIIDCBinding;
pub type xmlSchemaPSVIIDCBinding = _xmlSchemaPSVIIDCBinding;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaPSVIIDCBinding {
    pub next: xmlSchemaPSVIIDCBindingPtr,
    pub definition: xmlSchemaIDCPtr,
    pub nodeTable: *mut xmlSchemaPSVIIDCNodePtr,
    pub nbNodes: libc::c_int,
    pub sizeNodes: libc::c_int,
    pub dupls: xmlSchemaItemListPtr,
}
pub type xmlSchemaPSVIIDCNodePtr = *mut xmlSchemaPSVIIDCNode;
pub type xmlSchemaPSVIIDCNode = _xmlSchemaPSVIIDCNode;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaPSVIIDCNode {
    pub node: xmlNodePtr,
    pub keys: *mut xmlSchemaPSVIIDCKeyPtr,
    pub nodeLine: libc::c_int,
    pub nodeQNameID: libc::c_int,
}
pub type xmlSchemaElementPtr = *mut xmlSchemaElement;
pub type xmlSchemaElement = _xmlSchemaElement;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaElement {
    pub type_0: xmlSchemaTypeType,
    pub next: *mut _xmlSchemaType,
    pub name: *const xmlChar,
    pub id: *const xmlChar,
    pub ref_0: *const xmlChar,
    pub refNs: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub subtypes: xmlSchemaTypePtr,
    pub attributes: xmlSchemaAttributePtr,
    pub node: xmlNodePtr,
    pub minOccurs: libc::c_int,
    pub maxOccurs: libc::c_int,
    pub flags: libc::c_int,
    pub targetNamespace: *const xmlChar,
    pub namedType: *const xmlChar,
    pub namedTypeNs: *const xmlChar,
    pub substGroup: *const xmlChar,
    pub substGroupNs: *const xmlChar,
    pub scope: *const xmlChar,
    pub value: *const xmlChar,
    pub refDecl: *mut _xmlSchemaElement,
    pub contModel: xmlRegexpPtr,
    pub contentType: xmlSchemaContentType,
    pub refPrefix: *const xmlChar,
    pub defVal: xmlSchemaValPtr,
    pub idcs: *mut libc::c_void,
}
pub type xmlSchemaAttributeUsePtr = *mut xmlSchemaAttributeUse;
pub type xmlSchemaAttributeUse = _xmlSchemaAttributeUse;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttributeUse {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaAttributeUsePtr,
    pub attrDecl: xmlSchemaAttributePtr,
    pub flags: libc::c_int,
    pub node: xmlNodePtr,
    pub occurs: libc::c_int,
    pub defValue: *const xmlChar,
    pub defVal: xmlSchemaValPtr,
}
pub type xmlTextReaderPtr = *mut xmlTextReader;
pub type xmlTextReader = _xmlTextReader;
pub type xmlSchemaIDCStateObjPtr = *mut xmlSchemaIDCStateObj;
pub type xmlSchemaIDCStateObj = _xmlSchemaIDCStateObj;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDCStateObj {
    pub type_0: libc::c_int,
    pub next: xmlSchemaIDCStateObjPtr,
    pub depth: libc::c_int,
    pub history: *mut libc::c_int,
    pub nbHistory: libc::c_int,
    pub sizeHistory: libc::c_int,
    pub matcher: xmlSchemaIDCMatcherPtr,
    pub sel: xmlSchemaIDCSelectPtr,
    pub xpathCtxt: *mut libc::c_void,
}
pub type xmlSchemaParserCtxtPtr = *mut xmlSchemaParserCtxt;
pub type xmlSchemaParserCtxt = _xmlSchemaParserCtxt;
pub type xmlSchemaConstructionCtxtPtr = *mut xmlSchemaConstructionCtxt;
pub type xmlSchemaConstructionCtxt = _xmlSchemaConstructionCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaConstructionCtxt {
    pub mainSchema: xmlSchemaPtr,
    pub mainBucket: xmlSchemaBucketPtr,
    pub dict: xmlDictPtr,
    pub buckets: xmlSchemaItemListPtr,
    pub bucket: xmlSchemaBucketPtr,
    pub pending: xmlSchemaItemListPtr,
    pub substGroups: xmlHashTablePtr,
    pub redefs: xmlSchemaRedefPtr,
    pub lastRedef: xmlSchemaRedefPtr,
}
pub type xmlSchemaSubstGroupPtr = *mut xmlSchemaSubstGroup;
pub type xmlSchemaSubstGroup = _xmlSchemaSubstGroup;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaSubstGroup {
    pub head: xmlSchemaElementPtr,
    pub members: xmlSchemaItemListPtr,
}
pub type xmlIDCHashEntryPtr = *mut xmlIDCHashEntry;
pub type xmlIDCHashEntry = _xmlIDCHashEntry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlIDCHashEntry {
    pub next: xmlIDCHashEntryPtr,
    pub index: libc::c_int,
}
pub type xmlStreamCtxtPtr = *mut xmlStreamCtxt;
pub type xmlStreamCtxt = _xmlStreamCtxt;
pub type xmlSchemaAbstractCtxtPtr = *mut xmlSchemaAbstractCtxt;
pub type xmlSchemaAbstractCtxt = _xmlSchemaAbstractCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAbstractCtxt {
    pub type_0: libc::c_int,
    pub dummy: *mut libc::c_void,
}
pub type xmlSchemaImportPtr = *mut xmlSchemaImport;
pub type xmlSchemaImport = _xmlSchemaImport;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaImport {
    pub type_0: libc::c_int,
    pub flags: libc::c_int,
    pub schemaLocation: *const xmlChar,
    pub origTargetNamespace: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub doc: xmlDocPtr,
    pub relations: xmlSchemaSchemaRelationPtr,
    pub located: libc::c_int,
    pub parsed: libc::c_int,
    pub imported: libc::c_int,
    pub preserveDoc: libc::c_int,
    pub globals: xmlSchemaItemListPtr,
    pub locals: xmlSchemaItemListPtr,
    pub schema: xmlSchemaPtr,
}
pub type xmlSchemaTreeItemPtr = *mut xmlSchemaTreeItem;
pub type xmlSchemaTreeItem = _xmlSchemaTreeItem;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaTreeItem {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaTreeItemPtr,
    pub children: xmlSchemaTreeItemPtr,
}
pub const XML_SCHEMAS_ANYTYPE: xmlSchemaValType = 45;
pub type xmlSchemaNotationPtr = *mut xmlSchemaNotation;
pub type xmlSchemaNotation = _xmlSchemaNotation;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaNotation {
    pub type_0: xmlSchemaTypeType,
    pub name: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub identifier: *const xmlChar,
    pub targetNamespace: *const xmlChar,
}
pub type xmlPatternPtr = *mut xmlPattern;
pub type xmlPattern = _xmlPattern;
pub type xmlSchemaModelGroupDefPtr = *mut xmlSchemaModelGroupDef;
pub type xmlSchemaModelGroupDef = _xmlSchemaModelGroupDef;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaModelGroupDef {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaTreeItemPtr,
    pub children: xmlSchemaTreeItemPtr,
    pub name: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub node: xmlNodePtr,
    pub flags: libc::c_int,
}
pub type xmlSchemaAttributeGroupPtr = *mut xmlSchemaAttributeGroup;
pub type xmlSchemaAttributeGroup = _xmlSchemaAttributeGroup;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttributeGroup {
    pub type_0: xmlSchemaTypeType,
    pub next: *mut _xmlSchemaAttribute,
    pub name: *const xmlChar,
    pub id: *const xmlChar,
    pub ref_0: *const xmlChar,
    pub refNs: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub attributes: xmlSchemaAttributePtr,
    pub node: xmlNodePtr,
    pub flags: libc::c_int,
    pub attributeWildcard: xmlSchemaWildcardPtr,
    pub refPrefix: *const xmlChar,
    pub refItem: xmlSchemaAttributeGroupPtr,
    pub targetNamespace: *const xmlChar,
    pub attrUses: *mut libc::c_void,
}
pub type xmlSchemaModelGroupPtr = *mut xmlSchemaModelGroup;
pub type xmlSchemaModelGroup = _xmlSchemaModelGroup;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaModelGroup {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaTreeItemPtr,
    pub children: xmlSchemaTreeItemPtr,
    pub node: xmlNodePtr,
}
pub type xmlSchemaAttributeUseProhibPtr = *mut xmlSchemaAttributeUseProhib;
pub type xmlSchemaAttributeUseProhib = _xmlSchemaAttributeUseProhib;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttributeUseProhib {
    pub type_0: xmlSchemaTypeType,
    pub node: xmlNodePtr,
    pub name: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub isRef: libc::c_int,
}
pub type xmlSchemaParticlePtr = *mut xmlSchemaParticle;
pub type xmlSchemaParticle = _xmlSchemaParticle;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaParticle {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaTreeItemPtr,
    pub children: xmlSchemaTreeItemPtr,
    pub minOccurs: libc::c_int,
    pub maxOccurs: libc::c_int,
    pub node: xmlNodePtr,
}
pub type xmlSchemaValType = libc::c_uint;
pub const XML_SCHEMAS_ANYSIMPLETYPE: xmlSchemaValType = 46;
pub const XML_SCHEMAS_BASE64BINARY: xmlSchemaValType = 44;
pub const XML_SCHEMAS_HEXBINARY: xmlSchemaValType = 43;
pub const XML_SCHEMAS_UBYTE: xmlSchemaValType = 42;
pub const XML_SCHEMAS_BYTE: xmlSchemaValType = 41;
pub const XML_SCHEMAS_USHORT: xmlSchemaValType = 40;
pub const XML_SCHEMAS_SHORT: xmlSchemaValType = 39;
pub const XML_SCHEMAS_ULONG: xmlSchemaValType = 38;
pub const XML_SCHEMAS_LONG: xmlSchemaValType = 37;
pub const XML_SCHEMAS_UINT: xmlSchemaValType = 36;
pub const XML_SCHEMAS_INT: xmlSchemaValType = 35;
pub const XML_SCHEMAS_PINTEGER: xmlSchemaValType = 34;
pub const XML_SCHEMAS_NNINTEGER: xmlSchemaValType = 33;
pub const XML_SCHEMAS_NINTEGER: xmlSchemaValType = 32;
pub const XML_SCHEMAS_NPINTEGER: xmlSchemaValType = 31;
pub const XML_SCHEMAS_INTEGER: xmlSchemaValType = 30;
pub const XML_SCHEMAS_ANYURI: xmlSchemaValType = 29;
pub const XML_SCHEMAS_NOTATION: xmlSchemaValType = 28;
pub const XML_SCHEMAS_ENTITIES: xmlSchemaValType = 27;
pub const XML_SCHEMAS_ENTITY: xmlSchemaValType = 26;
pub const XML_SCHEMAS_IDREFS: xmlSchemaValType = 25;
pub const XML_SCHEMAS_IDREF: xmlSchemaValType = 24;
pub const XML_SCHEMAS_ID: xmlSchemaValType = 23;
pub const XML_SCHEMAS_NCNAME: xmlSchemaValType = 22;
pub const XML_SCHEMAS_QNAME: xmlSchemaValType = 21;
pub const XML_SCHEMAS_NAME: xmlSchemaValType = 20;
pub const XML_SCHEMAS_NMTOKENS: xmlSchemaValType = 19;
pub const XML_SCHEMAS_NMTOKEN: xmlSchemaValType = 18;
pub const XML_SCHEMAS_LANGUAGE: xmlSchemaValType = 17;
pub const XML_SCHEMAS_TOKEN: xmlSchemaValType = 16;
pub const XML_SCHEMAS_BOOLEAN: xmlSchemaValType = 15;
pub const XML_SCHEMAS_DOUBLE: xmlSchemaValType = 14;
pub const XML_SCHEMAS_FLOAT: xmlSchemaValType = 13;
pub const XML_SCHEMAS_DURATION: xmlSchemaValType = 12;
pub const XML_SCHEMAS_DATETIME: xmlSchemaValType = 11;
pub const XML_SCHEMAS_DATE: xmlSchemaValType = 10;
pub const XML_SCHEMAS_GYEARMONTH: xmlSchemaValType = 9;
pub const XML_SCHEMAS_GYEAR: xmlSchemaValType = 8;
pub const XML_SCHEMAS_GMONTHDAY: xmlSchemaValType = 7;
pub const XML_SCHEMAS_GMONTH: xmlSchemaValType = 6;
pub const XML_SCHEMAS_GDAY: xmlSchemaValType = 5;
pub const XML_SCHEMAS_TIME: xmlSchemaValType = 4;
pub const XML_SCHEMAS_DECIMAL: xmlSchemaValType = 3;
pub const XML_SCHEMAS_NORMSTRING: xmlSchemaValType = 2;
pub const XML_SCHEMAS_STRING: xmlSchemaValType = 1;
pub const XML_SCHEMAS_UNKNOWN: xmlSchemaValType = 0;
pub type xmlSchemaWhitespaceValueType = libc::c_uint;
pub const XML_SCHEMA_WHITESPACE_COLLAPSE: xmlSchemaWhitespaceValueType = 3;
pub const XML_SCHEMA_WHITESPACE_REPLACE: xmlSchemaWhitespaceValueType = 2;
pub const XML_SCHEMA_WHITESPACE_PRESERVE: xmlSchemaWhitespaceValueType = 1;
pub const XML_SCHEMA_WHITESPACE_UNKNOWN: xmlSchemaWhitespaceValueType = 0;
pub type xmlSchemaIncludePtr = *mut xmlSchemaInclude;
pub type xmlSchemaInclude = _xmlSchemaInclude;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaInclude {
    pub type_0: libc::c_int,
    pub flags: libc::c_int,
    pub schemaLocation: *const xmlChar,
    pub origTargetNamespace: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub doc: xmlDocPtr,
    pub relations: xmlSchemaSchemaRelationPtr,
    pub located: libc::c_int,
    pub parsed: libc::c_int,
    pub imported: libc::c_int,
    pub preserveDoc: libc::c_int,
    pub globals: xmlSchemaItemListPtr,
    pub locals: xmlSchemaItemListPtr,
    pub ownerImport: xmlSchemaImportPtr,
}
pub type xmlSchemaAnnotItemPtr = *mut xmlSchemaAnnotItem;
pub type xmlSchemaAnnotItem = _xmlSchemaAnnotItem;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAnnotItem {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
}
pub const XML_PATTERN_XSSEL: C2RustUnnamed_2 = 2;
pub const XML_PATTERN_XSFIELD: C2RustUnnamed_2 = 4;
pub type xmlSchemaSAXPlugPtr = *mut xmlSchemaSAXPlugStruct;
pub type xmlSchemaSAXPlugStruct = _xmlSchemaSAXPlug;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaSAXPlug {
    pub magic: libc::c_uint,
    pub user_sax_ptr: *mut xmlSAXHandlerPtr,
    pub user_sax: xmlSAXHandlerPtr,
    pub user_data_ptr: *mut *mut libc::c_void,
    pub user_data: *mut libc::c_void,
    pub schemas_sax: xmlSAXHandler,
    pub ctxt: xmlSchemaValidCtxtPtr,
}
pub type C2RustUnnamed_2 = libc::c_uint;
pub const XML_PATTERN_XPATH: C2RustUnnamed_2 = 1;
pub const XML_PATTERN_DEFAULT: C2RustUnnamed_2 = 0;
static mut xmlSchemaNs: *const xmlChar = b"http://www.w3.org/2001/XMLSchema\0"
    as *const u8 as *const libc::c_char as *const xmlChar;
static mut xmlSchemaInstanceNs: *const xmlChar = b"http://www.w3.org/2001/XMLSchema-instance\0"
    as *const u8 as *const libc::c_char as *const xmlChar;
static mut xmlNamespaceNs: *const xmlChar = b"http://www.w3.org/2000/xmlns/\0"
    as *const u8 as *const libc::c_char as *const xmlChar;
unsafe extern "C" fn xmlSchemaItemTypeToStr(
    mut type_0: xmlSchemaTypeType,
) -> *const xmlChar {
    match type_0 as libc::c_uint {
        1 => {
            return b"simple type definition\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
        4 => {
            return b"simple type definition\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
        5 => {
            return b"complex type definition\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
        14 => {
            return b"element declaration\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
        26 => {
            return b"attribute use\0" as *const u8 as *const libc::c_char as *mut xmlChar;
        }
        15 => {
            return b"attribute declaration\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
        17 => {
            return b"model group definition\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
        16 => {
            return b"attribute group definition\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
        18 => {
            return b"notation declaration\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
        6 => {
            return b"model group (sequence)\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
        7 => {
            return b"model group (choice)\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
        8 => {
            return b"model group (all)\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
        25 => return b"particle\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        22 => {
            return b"unique identity-constraint\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
        23 => {
            return b"key identity-constraint\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
        24 => {
            return b"keyref identity-constraint\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
        2 => {
            return b"wildcard (any)\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
        2000 => {
            return b"[helper component] QName reference\0" as *const u8
                as *const libc::c_char as *mut xmlChar;
        }
        2001 => {
            return b"[helper component] attribute use prohibition\0" as *const u8
                as *const libc::c_char as *mut xmlChar;
        }
        _ => {
            return b"Not a schema component\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
    };
}
unsafe extern "C" fn xmlSchemaGetComponentTypeStr(
    mut item: xmlSchemaBasicItemPtr,
) -> *const xmlChar {
    match (*item).type_0 as libc::c_uint {
        1 => {
            if (*(item as xmlSchemaTypePtr)).type_0 as libc::c_uint
                == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
                || (*(item as xmlSchemaTypePtr)).builtInType
                    == XML_SCHEMAS_ANYTYPE as libc::c_int
            {
                return b"complex type definition\0" as *const u8 as *const libc::c_char
                    as *mut xmlChar
            } else {
                return b"simple type definition\0" as *const u8 as *const libc::c_char
                    as *mut xmlChar
            }
        }
        _ => return xmlSchemaItemTypeToStr((*item).type_0),
    };
}
unsafe extern "C" fn xmlSchemaGetComponentNode(
    mut item: xmlSchemaBasicItemPtr,
) -> xmlNodePtr {
    match (*item).type_0 as libc::c_uint {
        14 => return (*(item as xmlSchemaElementPtr)).node,
        15 => return (*(item as xmlSchemaAttributePtr)).node,
        5 | 4 => return (*(item as xmlSchemaTypePtr)).node,
        2 | 21 => return (*(item as xmlSchemaWildcardPtr)).node,
        25 => return (*(item as xmlSchemaParticlePtr)).node,
        6 | 7 | 8 => return (*(item as xmlSchemaModelGroupPtr)).node,
        17 => return (*(item as xmlSchemaModelGroupDefPtr)).node,
        16 => return (*(item as xmlSchemaAttributeGroupPtr)).node,
        22 | 23 | 24 => return (*(item as xmlSchemaIDCPtr)).node,
        2000 => return (*(item as xmlSchemaQNameRefPtr)).node,
        26 => return (*(item as xmlSchemaAttributeUsePtr)).node,
        _ => return 0 as xmlNodePtr,
    };
}
unsafe extern "C" fn xmlSchemaFormatQName(
    mut buf: *mut *mut xmlChar,
    mut namespaceName: *const xmlChar,
    mut localName: *const xmlChar,
) -> *const xmlChar {
    if !(*buf).is_null() {
        xmlFree.expect("non-null function pointer")(*buf as *mut libc::c_void);
        *buf = 0 as *mut xmlChar;
    }
    if !namespaceName.is_null() {
        *buf = xmlStrdup(b"{\0" as *const u8 as *const libc::c_char as *mut xmlChar);
        *buf = xmlStrcat(*buf, namespaceName);
        *buf = xmlStrcat(
            *buf,
            b"}\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    }
    if !localName.is_null() {
        if namespaceName.is_null() {
            return localName;
        }
        *buf = xmlStrcat(*buf, localName);
    } else {
        *buf = xmlStrcat(
            *buf,
            b"(NULL)\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    }
    return *buf as *const xmlChar;
}
unsafe extern "C" fn xmlSchemaFormatQNameNs(
    mut buf: *mut *mut xmlChar,
    mut ns: xmlNsPtr,
    mut localName: *const xmlChar,
) -> *const xmlChar {
    if !ns.is_null() {
        return xmlSchemaFormatQName(buf, (*ns).href, localName)
    } else {
        return xmlSchemaFormatQName(buf, 0 as *const xmlChar, localName)
    };
}
unsafe extern "C" fn xmlSchemaGetComponentName(
    mut item: xmlSchemaBasicItemPtr,
) -> *const xmlChar {
    if item.is_null() {
        return 0 as *const xmlChar;
    }
    match (*item).type_0 as libc::c_uint {
        14 => return (*(item as xmlSchemaElementPtr)).name,
        15 => return (*(item as xmlSchemaAttributePtr)).name,
        16 => return (*(item as xmlSchemaAttributeGroupPtr)).name,
        1 | 4 | 5 => return (*(item as xmlSchemaTypePtr)).name,
        17 => return (*(item as xmlSchemaModelGroupDefPtr)).name,
        23 | 22 | 24 => return (*(item as xmlSchemaIDCPtr)).name,
        26 => {
            if !((*(item as xmlSchemaAttributeUsePtr)).attrDecl).is_null() {
                return xmlSchemaGetComponentName(
                    (*(item as xmlSchemaAttributeUsePtr)).attrDecl
                        as xmlSchemaBasicItemPtr,
                )
            } else {
                return 0 as *const xmlChar
            }
        }
        2000 => return (*(item as xmlSchemaQNameRefPtr)).name,
        18 => return (*(item as xmlSchemaNotationPtr)).name,
        _ => {}
    }
    return 0 as *const xmlChar;
}
unsafe extern "C" fn xmlSchemaGetComponentTargetNs(
    mut item: xmlSchemaBasicItemPtr,
) -> *const xmlChar {
    if item.is_null() {
        return 0 as *const xmlChar;
    }
    match (*item).type_0 as libc::c_uint {
        14 => return (*(item as xmlSchemaElementPtr)).targetNamespace,
        15 => return (*(item as xmlSchemaAttributePtr)).targetNamespace,
        16 => return (*(item as xmlSchemaAttributeGroupPtr)).targetNamespace,
        1 => {
            return b"http://www.w3.org/2001/XMLSchema\0" as *const u8
                as *const libc::c_char as *mut xmlChar;
        }
        4 | 5 => return (*(item as xmlSchemaTypePtr)).targetNamespace,
        17 => return (*(item as xmlSchemaModelGroupDefPtr)).targetNamespace,
        23 | 22 | 24 => return (*(item as xmlSchemaIDCPtr)).targetNamespace,
        26 => {
            if !((*(item as xmlSchemaAttributeUsePtr)).attrDecl).is_null() {
                return xmlSchemaGetComponentTargetNs(
                    (*(item as xmlSchemaAttributeUsePtr)).attrDecl
                        as xmlSchemaBasicItemPtr,
                );
            }
        }
        2000 => return (*(item as xmlSchemaQNameRefPtr)).targetNamespace,
        18 => return (*(item as xmlSchemaNotationPtr)).targetNamespace,
        _ => {}
    }
    return 0 as *const xmlChar;
}
unsafe extern "C" fn xmlSchemaGetComponentQName(
    mut buf: *mut *mut xmlChar,
    mut item: *mut libc::c_void,
) -> *const xmlChar {
    return xmlSchemaFormatQName(
        buf,
        xmlSchemaGetComponentTargetNs(item as xmlSchemaBasicItemPtr),
        xmlSchemaGetComponentName(item as xmlSchemaBasicItemPtr),
    );
}
unsafe extern "C" fn xmlSchemaGetComponentDesignation(
    mut buf: *mut *mut xmlChar,
    mut item: *mut libc::c_void,
) -> *const xmlChar {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    *buf = xmlStrcat(*buf, xmlSchemaGetComponentTypeStr(item as xmlSchemaBasicItemPtr));
    *buf = xmlStrcat(*buf, b" '\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    *buf = xmlStrcat(
        *buf,
        xmlSchemaGetComponentQName(
            &mut str,
            item as xmlSchemaBasicItemPtr as *mut libc::c_void,
        ),
    );
    *buf = xmlStrcat(*buf, b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    if !str.is_null() {
        xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
        str = 0 as *mut xmlChar;
    }
    return *buf;
}
unsafe extern "C" fn xmlSchemaGetIDCDesignation(
    mut buf: *mut *mut xmlChar,
    mut idc: xmlSchemaIDCPtr,
) -> *const xmlChar {
    return xmlSchemaGetComponentDesignation(buf, idc as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaWildcardPCToString(mut pc: libc::c_int) -> *const xmlChar {
    match pc {
        1 => return b"skip\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        2 => return b"lax\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        3 => return b"strict\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        _ => {
            return b"invalid process contents\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
    };
}
unsafe extern "C" fn xmlSchemaGetCanonValueWhtspExt_1(
    mut val: xmlSchemaValPtr,
    mut ws: xmlSchemaWhitespaceValueType,
    mut retValue: *mut *mut xmlChar,
    mut for_hash: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut list: libc::c_int = 0;
    let mut valType: xmlSchemaValType = XML_SCHEMAS_UNKNOWN;
    let mut value: *const xmlChar = 0 as *const xmlChar;
    let mut value2: *const xmlChar = 0 as *const xmlChar;
    if retValue.is_null() || val.is_null() {
        return -(1 as libc::c_int);
    }
    list = if !(xmlSchemaValueGetNext(val)).is_null() {
        1 as libc::c_int
    } else {
        0 as libc::c_int
    };
    *retValue = 0 as *mut xmlChar;
    loop {
        value = 0 as *const xmlChar;
        valType = xmlSchemaGetValType(val);
        match valType as libc::c_uint {
            1 | 2 | 46 => {
                value = xmlSchemaValueGetAsString(val);
                if !value.is_null() {
                    if ws as libc::c_uint
                        == XML_SCHEMA_WHITESPACE_COLLAPSE as libc::c_int as libc::c_uint
                    {
                        value2 = xmlSchemaCollapseString(value);
                    } else if ws as libc::c_uint
                            == XML_SCHEMA_WHITESPACE_REPLACE as libc::c_int
                                as libc::c_uint
                        {
                        value2 = xmlSchemaWhiteSpaceReplace(value);
                    }
                    if !value2.is_null() {
                        value = value2;
                    }
                }
            }
            _ => {
                if xmlSchemaGetCanonValue(val, &mut value2) == -(1 as libc::c_int) {
                    if !value2.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(value2 as *mut xmlChar as *mut libc::c_void);
                    }
                    current_block = 11962130098811163542;
                    break;
                } else {
                    if for_hash != 0
                        && valType as libc::c_uint
                            == XML_SCHEMAS_DECIMAL as libc::c_int as libc::c_uint
                    {
                        let mut len: libc::c_int = xmlStrlen(value2);
                        if len > 2 as libc::c_int
                            && *value2.offset((len - 1 as libc::c_int) as isize)
                                as libc::c_int == '0' as i32
                            && *value2.offset((len - 2 as libc::c_int) as isize)
                                as libc::c_int == '.' as i32
                        {
                            *(value2 as *mut xmlChar)
                                .offset(
                                    (len - 2 as libc::c_int) as isize,
                                ) = 0 as libc::c_int as xmlChar;
                        }
                    }
                    value = value2;
                }
            }
        }
        if (*retValue).is_null() {
            if value.is_null() {
                if list == 0 {
                    *retValue = xmlStrdup(
                        b"\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                }
            } else {
                *retValue = xmlStrdup(value);
            }
        } else if !value.is_null() {
            *retValue = xmlStrcat(
                *retValue,
                b" \0" as *const u8 as *const libc::c_char as *mut xmlChar,
            );
            *retValue = xmlStrcat(*retValue, value);
        }
        if !value2.is_null() {
            xmlFree
                .expect(
                    "non-null function pointer",
                )(value2 as *mut xmlChar as *mut libc::c_void);
            value2 = 0 as *const xmlChar;
        }
        val = xmlSchemaValueGetNext(val);
        if val.is_null() {
            current_block = 3222590281903869779;
            break;
        }
    }
    match current_block {
        3222590281903869779 => return 0 as libc::c_int,
        _ => {
            if !(*retValue).is_null() {
                xmlFree
                    .expect("non-null function pointer")(*retValue as *mut libc::c_void);
            }
            if !value2.is_null() {
                xmlFree
                    .expect(
                        "non-null function pointer",
                    )(value2 as *mut xmlChar as *mut libc::c_void);
            }
            return -(1 as libc::c_int);
        }
    };
}
unsafe extern "C" fn xmlSchemaGetCanonValueWhtspExt(
    mut val: xmlSchemaValPtr,
    mut ws: xmlSchemaWhitespaceValueType,
    mut retValue: *mut *mut xmlChar,
) -> libc::c_int {
    return xmlSchemaGetCanonValueWhtspExt_1(val, ws, retValue, 0 as libc::c_int);
}
unsafe extern "C" fn xmlSchemaGetCanonValueHash(
    mut val: xmlSchemaValPtr,
    mut retValue: *mut *mut xmlChar,
) -> libc::c_int {
    return xmlSchemaGetCanonValueWhtspExt_1(
        val,
        XML_SCHEMA_WHITESPACE_COLLAPSE,
        retValue,
        1 as libc::c_int,
    );
}
unsafe extern "C" fn xmlSchemaFormatItemForReport(
    mut buf: *mut *mut xmlChar,
    mut itemDes: *const xmlChar,
    mut item: xmlSchemaBasicItemPtr,
    mut itemNode: xmlNodePtr,
) -> *mut xmlChar {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut named: libc::c_int = 1 as libc::c_int;
    if !(*buf).is_null() {
        xmlFree.expect("non-null function pointer")(*buf as *mut libc::c_void);
        *buf = 0 as *mut xmlChar;
    }
    if !itemDes.is_null() {
        *buf = xmlStrdup(itemDes);
    } else if !item.is_null() {
        let mut current_block_107: u64;
        match (*item).type_0 as libc::c_uint {
            1 => {
                let mut type_0: xmlSchemaTypePtr = item as xmlSchemaTypePtr;
                if (*type_0).flags & (1 as libc::c_int) << 8 as libc::c_int != 0 {
                    *buf = xmlStrdup(
                        b"atomic type 'xs:\0" as *const u8 as *const libc::c_char
                            as *mut xmlChar,
                    );
                } else if (*type_0).flags & (1 as libc::c_int) << 6 as libc::c_int != 0 {
                    *buf = xmlStrdup(
                        b"list type 'xs:\0" as *const u8 as *const libc::c_char
                            as *mut xmlChar,
                    );
                } else if (*type_0).flags & (1 as libc::c_int) << 7 as libc::c_int != 0 {
                    *buf = xmlStrdup(
                        b"union type 'xs:\0" as *const u8 as *const libc::c_char
                            as *mut xmlChar,
                    );
                } else {
                    *buf = xmlStrdup(
                        b"simple type 'xs:\0" as *const u8 as *const libc::c_char
                            as *mut xmlChar,
                    );
                }
                *buf = xmlStrcat(*buf, (*type_0).name);
                *buf = xmlStrcat(
                    *buf,
                    b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            }
            4 => {
                let mut type_1: xmlSchemaTypePtr = item as xmlSchemaTypePtr;
                if (*type_1).flags & (1 as libc::c_int) << 3 as libc::c_int != 0 {
                    *buf = xmlStrdup(
                        b"\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                } else {
                    *buf = xmlStrdup(
                        b"local \0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                }
                if (*type_1).flags & (1 as libc::c_int) << 8 as libc::c_int != 0 {
                    *buf = xmlStrcat(
                        *buf,
                        b"atomic type\0" as *const u8 as *const libc::c_char
                            as *mut xmlChar,
                    );
                } else if (*type_1).flags & (1 as libc::c_int) << 6 as libc::c_int != 0 {
                    *buf = xmlStrcat(
                        *buf,
                        b"list type\0" as *const u8 as *const libc::c_char
                            as *mut xmlChar,
                    );
                } else if (*type_1).flags & (1 as libc::c_int) << 7 as libc::c_int != 0 {
                    *buf = xmlStrcat(
                        *buf,
                        b"union type\0" as *const u8 as *const libc::c_char
                            as *mut xmlChar,
                    );
                } else {
                    *buf = xmlStrcat(
                        *buf,
                        b"simple type\0" as *const u8 as *const libc::c_char
                            as *mut xmlChar,
                    );
                }
                if (*type_1).flags & (1 as libc::c_int) << 3 as libc::c_int != 0 {
                    *buf = xmlStrcat(
                        *buf,
                        b" '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                    *buf = xmlStrcat(*buf, (*type_1).name);
                    *buf = xmlStrcat(
                        *buf,
                        b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                }
                current_block_107 = 13253659531982233645;
            }
            5 => {
                let mut type_2: xmlSchemaTypePtr = item as xmlSchemaTypePtr;
                if (*type_2).flags & (1 as libc::c_int) << 3 as libc::c_int != 0 {
                    *buf = xmlStrdup(
                        b"\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                } else {
                    *buf = xmlStrdup(
                        b"local \0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                }
                *buf = xmlStrcat(
                    *buf,
                    b"complex type\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
                if (*type_2).flags & (1 as libc::c_int) << 3 as libc::c_int != 0 {
                    *buf = xmlStrcat(
                        *buf,
                        b" '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                    *buf = xmlStrcat(*buf, (*type_2).name);
                    *buf = xmlStrcat(
                        *buf,
                        b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                }
                current_block_107 = 13253659531982233645;
            }
            26 => {
                let mut ause: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
                ause = item as xmlSchemaAttributeUsePtr;
                *buf = xmlStrdup(
                    b"attribute use \0" as *const u8 as *const libc::c_char
                        as *mut xmlChar,
                );
                if !((*ause).attrDecl).is_null() {
                    *buf = xmlStrcat(
                        *buf,
                        b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                    *buf = xmlStrcat(
                        *buf,
                        xmlSchemaGetComponentQName(
                            &mut str,
                            (*ause).attrDecl as *mut libc::c_void,
                        ),
                    );
                    if !str.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str as *mut libc::c_void);
                        str = 0 as *mut xmlChar;
                    }
                    *buf = xmlStrcat(
                        *buf,
                        b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                } else {
                    *buf = xmlStrcat(
                        *buf,
                        b"(unknown)\0" as *const u8 as *const libc::c_char
                            as *mut xmlChar,
                    );
                }
                current_block_107 = 13253659531982233645;
            }
            15 => {
                let mut attr: xmlSchemaAttributePtr = 0 as *mut xmlSchemaAttribute;
                attr = item as xmlSchemaAttributePtr;
                *buf = xmlStrdup(
                    b"attribute decl.\0" as *const u8 as *const libc::c_char
                        as *mut xmlChar,
                );
                *buf = xmlStrcat(
                    *buf,
                    b" '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
                *buf = xmlStrcat(
                    *buf,
                    xmlSchemaFormatQName(&mut str, (*attr).targetNamespace, (*attr).name),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                *buf = xmlStrcat(
                    *buf,
                    b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            }
            16 => {
                xmlSchemaGetComponentDesignation(buf, item as *mut libc::c_void);
                current_block_107 = 13253659531982233645;
            }
            14 => {
                let mut elem: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
                elem = item as xmlSchemaElementPtr;
                *buf = xmlStrdup(
                    b"element decl.\0" as *const u8 as *const libc::c_char
                        as *mut xmlChar,
                );
                *buf = xmlStrcat(
                    *buf,
                    b" '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
                *buf = xmlStrcat(
                    *buf,
                    xmlSchemaFormatQName(&mut str, (*elem).targetNamespace, (*elem).name),
                );
                *buf = xmlStrcat(
                    *buf,
                    b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            }
            22 | 23 | 24 => {
                if (*item).type_0 as libc::c_uint
                    == XML_SCHEMA_TYPE_IDC_UNIQUE as libc::c_int as libc::c_uint
                {
                    *buf = xmlStrdup(
                        b"unique '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                } else if (*item).type_0 as libc::c_uint
                        == XML_SCHEMA_TYPE_IDC_KEY as libc::c_int as libc::c_uint
                    {
                    *buf = xmlStrdup(
                        b"key '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                } else {
                    *buf = xmlStrdup(
                        b"keyRef '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                }
                *buf = xmlStrcat(*buf, (*(item as xmlSchemaIDCPtr)).name);
                *buf = xmlStrcat(
                    *buf,
                    b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            }
            2 | 21 => {
                *buf = xmlStrdup(
                    xmlSchemaWildcardPCToString(
                        (*(item as xmlSchemaWildcardPtr)).processContents,
                    ),
                );
                *buf = xmlStrcat(
                    *buf,
                    b" wildcard\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            }
            1000 | 1001 | 1002 | 1003 | 1004 | 1005 | 1006 | 1007 | 1008 | 1009 | 1010
            | 1011 => {
                *buf = xmlStrdup(
                    b"facet '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
                *buf = xmlStrcat(*buf, xmlSchemaFacetTypeToString((*item).type_0));
                *buf = xmlStrcat(
                    *buf,
                    b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            }
            17 => {
                *buf = xmlStrdup(
                    b"model group def.\0" as *const u8 as *const libc::c_char
                        as *mut xmlChar,
                );
                *buf = xmlStrcat(
                    *buf,
                    b" '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
                *buf = xmlStrcat(
                    *buf,
                    xmlSchemaGetComponentQName(&mut str, item as *mut libc::c_void),
                );
                *buf = xmlStrcat(
                    *buf,
                    b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                current_block_107 = 13253659531982233645;
            }
            6 | 7 | 8 | 25 => {
                *buf = xmlStrdup(xmlSchemaGetComponentTypeStr(item));
                current_block_107 = 13253659531982233645;
            }
            18 => {
                *buf = xmlStrdup(xmlSchemaGetComponentTypeStr(item));
                *buf = xmlStrcat(
                    *buf,
                    b" '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
                *buf = xmlStrcat(
                    *buf,
                    xmlSchemaGetComponentQName(&mut str, item as *mut libc::c_void),
                );
                *buf = xmlStrcat(
                    *buf,
                    b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                current_block_107 = 2993333835388634117;
            }
            _ => {
                current_block_107 = 2993333835388634117;
            }
        }
        match current_block_107 {
            2993333835388634117 => {
                named = 0 as libc::c_int;
            }
            _ => {}
        }
    } else {
        named = 0 as libc::c_int;
    }
    if named == 0 as libc::c_int && !itemNode.is_null() {
        let mut elem_0: xmlNodePtr = 0 as *mut xmlNode;
        if (*itemNode).type_0 as libc::c_uint
            == XML_ATTRIBUTE_NODE as libc::c_int as libc::c_uint
        {
            elem_0 = (*itemNode).parent;
        } else {
            elem_0 = itemNode;
        }
        *buf = xmlStrdup(
            b"Element '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
        if !((*elem_0).ns).is_null() {
            *buf = xmlStrcat(
                *buf,
                xmlSchemaFormatQName(&mut str, (*(*elem_0).ns).href, (*elem_0).name),
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
        } else {
            *buf = xmlStrcat(*buf, (*elem_0).name);
        }
        *buf = xmlStrcat(
            *buf,
            b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    }
    if !itemNode.is_null()
        && (*itemNode).type_0 as libc::c_uint
            == XML_ATTRIBUTE_NODE as libc::c_int as libc::c_uint
    {
        *buf = xmlStrcat(
            *buf,
            b", attribute '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
        if !((*itemNode).ns).is_null() {
            *buf = xmlStrcat(
                *buf,
                xmlSchemaFormatQName(&mut str, (*(*itemNode).ns).href, (*itemNode).name),
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
        } else {
            *buf = xmlStrcat(*buf, (*itemNode).name);
        }
        *buf = xmlStrcat(
            *buf,
            b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    }
    if !str.is_null() {
        xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
        str = 0 as *mut xmlChar;
    }
    return xmlEscapeFormatString(buf);
}
unsafe extern "C" fn xmlSchemaFormatFacetEnumSet(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut buf: *mut *mut xmlChar,
    mut type_0: xmlSchemaTypePtr,
) -> *const xmlChar {
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut ws: xmlSchemaWhitespaceValueType = XML_SCHEMA_WHITESPACE_UNKNOWN;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut res: libc::c_int = 0;
    let mut found: libc::c_int = 0 as libc::c_int;
    if !(*buf).is_null() {
        xmlFree.expect("non-null function pointer")(*buf as *mut libc::c_void);
    }
    *buf = 0 as *mut xmlChar;
    loop {
        ws = xmlSchemaGetWhiteSpaceFacetValue((*type_0).baseType);
        facet = (*type_0).facets;
        while !facet.is_null() {
            if !((*facet).type_0 as libc::c_uint
                != XML_SCHEMA_FACET_ENUMERATION as libc::c_int as libc::c_uint)
            {
                found = 1 as libc::c_int;
                res = xmlSchemaGetCanonValueWhtspExt((*facet).val, ws, &mut value);
                if res == -(1 as libc::c_int) {
                    xmlSchemaInternalErr(
                        actxt,
                        b"xmlSchemaFormatFacetEnumSet\0" as *const u8
                            as *const libc::c_char,
                        b"compute the canonical lexical representation\0" as *const u8
                            as *const libc::c_char,
                    );
                    if !(*buf).is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(*buf as *mut libc::c_void);
                    }
                    *buf = 0 as *mut xmlChar;
                    return 0 as *const xmlChar;
                }
                if (*buf).is_null() {
                    *buf = xmlStrdup(
                        b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                } else {
                    *buf = xmlStrcat(
                        *buf,
                        b", '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                }
                *buf = xmlStrcat(*buf, value);
                *buf = xmlStrcat(
                    *buf,
                    b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
                if !value.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(value as *mut libc::c_void);
                    value = 0 as *mut xmlChar;
                }
            }
            facet = (*facet).next;
        }
        if found != 0 {
            break;
        }
        type_0 = (*type_0).baseType;
        if !(!type_0.is_null()
            && (*type_0).type_0 as libc::c_uint
                != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint)
        {
            break;
        }
    }
    return *buf as *const xmlChar;
}
unsafe extern "C" fn xmlSchemaPSimpleErr(mut msg: *const libc::c_char) {
    __xmlSimpleError(
        XML_FROM_SCHEMASP as libc::c_int,
        XML_ERR_NO_MEMORY as libc::c_int,
        0 as xmlNodePtr,
        0 as *const libc::c_char,
        msg,
    );
}
unsafe extern "C" fn xmlSchemaPErrMemory(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut extra: *const libc::c_char,
    mut node: xmlNodePtr,
) {
    if !ctxt.is_null() {
        let ref mut fresh0 = (*ctxt).nberrors;
        *fresh0 += 1;
    }
    __xmlSimpleError(
        XML_FROM_SCHEMASP as libc::c_int,
        XML_ERR_NO_MEMORY as libc::c_int,
        node,
        0 as *const libc::c_char,
        extra,
    );
}
unsafe extern "C" fn xmlSchemaPErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut error: libc::c_int,
    mut msg: *const libc::c_char,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
) {
    let mut channel: xmlGenericErrorFunc = None;
    let mut schannel: xmlStructuredErrorFunc = None;
    let mut data: *mut libc::c_void = 0 as *mut libc::c_void;
    if !ctxt.is_null() {
        let ref mut fresh1 = (*ctxt).nberrors;
        *fresh1 += 1;
        (*ctxt).err = error;
        channel = (*ctxt).error;
        data = (*ctxt).errCtxt;
        schannel = (*ctxt).serror;
    }
    __xmlRaiseError(
        schannel,
        channel,
        data,
        ctxt as *mut libc::c_void,
        node as *mut libc::c_void,
        XML_FROM_SCHEMASP as libc::c_int,
        error,
        XML_ERR_ERROR,
        0 as *const libc::c_char,
        0 as libc::c_int,
        str1 as *const libc::c_char,
        str2 as *const libc::c_char,
        0 as *const libc::c_char,
        0 as libc::c_int,
        0 as libc::c_int,
        msg,
        str1,
        str2,
    );
}
unsafe extern "C" fn xmlSchemaPErr2(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut child: xmlNodePtr,
    mut error: libc::c_int,
    mut msg: *const libc::c_char,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
) {
    if !child.is_null() {
        xmlSchemaPErr(ctxt, child, error, msg, str1, str2);
    } else {
        xmlSchemaPErr(ctxt, node, error, msg, str1, str2);
    };
}
unsafe extern "C" fn xmlSchemaPErrExt(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut error: libc::c_int,
    mut strData1: *const xmlChar,
    mut strData2: *const xmlChar,
    mut strData3: *const xmlChar,
    mut msg: *const libc::c_char,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
    mut str3: *const xmlChar,
    mut str4: *const xmlChar,
    mut str5: *const xmlChar,
) {
    let mut channel: xmlGenericErrorFunc = None;
    let mut schannel: xmlStructuredErrorFunc = None;
    let mut data: *mut libc::c_void = 0 as *mut libc::c_void;
    if !ctxt.is_null() {
        let ref mut fresh2 = (*ctxt).nberrors;
        *fresh2 += 1;
        (*ctxt).err = error;
        channel = (*ctxt).error;
        data = (*ctxt).errCtxt;
        schannel = (*ctxt).serror;
    }
    __xmlRaiseError(
        schannel,
        channel,
        data,
        ctxt as *mut libc::c_void,
        node as *mut libc::c_void,
        XML_FROM_SCHEMASP as libc::c_int,
        error,
        XML_ERR_ERROR,
        0 as *const libc::c_char,
        0 as libc::c_int,
        strData1 as *const libc::c_char,
        strData2 as *const libc::c_char,
        strData3 as *const libc::c_char,
        0 as libc::c_int,
        0 as libc::c_int,
        msg,
        str1,
        str2,
        str3,
        str4,
        str5,
    );
}
unsafe extern "C" fn xmlSchemaVErrMemory(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut extra: *const libc::c_char,
    mut node: xmlNodePtr,
) {
    if !ctxt.is_null() {
        let ref mut fresh3 = (*ctxt).nberrors;
        *fresh3 += 1;
        (*ctxt).err = XML_SCHEMAV_INTERNAL as libc::c_int;
    }
    __xmlSimpleError(
        XML_FROM_SCHEMASV as libc::c_int,
        XML_ERR_NO_MEMORY as libc::c_int,
        node,
        0 as *const libc::c_char,
        extra,
    );
}
unsafe extern "C" fn xmlSchemaPSimpleInternalErr(
    mut node: xmlNodePtr,
    mut msg: *const libc::c_char,
    mut str: *const xmlChar,
) {
    __xmlSimpleError(
        XML_FROM_SCHEMASP as libc::c_int,
        XML_SCHEMAP_INTERNAL as libc::c_int,
        node,
        msg,
        str as *const libc::c_char,
    );
}
unsafe extern "C" fn xmlSchemaErr4Line(
    mut ctxt: xmlSchemaAbstractCtxtPtr,
    mut errorLevel: xmlErrorLevel,
    mut error: libc::c_int,
    mut node: xmlNodePtr,
    mut line: libc::c_int,
    mut msg: *const libc::c_char,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
    mut str3: *const xmlChar,
    mut str4: *const xmlChar,
) {
    let mut schannel: xmlStructuredErrorFunc = None;
    let mut channel: xmlGenericErrorFunc = None;
    let mut data: *mut libc::c_void = 0 as *mut libc::c_void;
    if !ctxt.is_null() {
        if (*ctxt).type_0 == 2 as libc::c_int {
            let mut vctxt: xmlSchemaValidCtxtPtr = ctxt as xmlSchemaValidCtxtPtr;
            let mut file: *const libc::c_char = 0 as *const libc::c_char;
            let mut col: libc::c_int = 0 as libc::c_int;
            if errorLevel as libc::c_uint
                != XML_ERR_WARNING as libc::c_int as libc::c_uint
            {
                let ref mut fresh4 = (*vctxt).nberrors;
                *fresh4 += 1;
                (*vctxt).err = error;
                channel = (*vctxt).error;
            } else {
                channel = (*vctxt).warning;
            }
            schannel = (*vctxt).serror;
            data = (*vctxt).errCtxt;
            if line == 0 as libc::c_int {
                if node.is_null() && (*vctxt).depth >= 0 as libc::c_int
                    && !((*vctxt).inode).is_null()
                {
                    node = (*(*vctxt).inode).node;
                }
                if node.is_null() && !((*vctxt).parserCtxt).is_null()
                    && !((*(*vctxt).parserCtxt).input).is_null()
                {
                    file = (*(*(*vctxt).parserCtxt).input).filename;
                    line = (*(*(*vctxt).parserCtxt).input).line;
                    col = (*(*(*vctxt).parserCtxt).input).col;
                }
            } else {
                node = 0 as xmlNodePtr;
                if !((*vctxt).doc).is_null() {
                    file = (*(*vctxt).doc).URL as *const libc::c_char;
                } else if !((*vctxt).parserCtxt).is_null()
                        && !((*(*vctxt).parserCtxt).input).is_null()
                    {
                    file = (*(*(*vctxt).parserCtxt).input).filename;
                }
            }
            if ((*vctxt).locFunc).is_some() {
                if file.is_null() || line == 0 as libc::c_int {
                    let mut l: libc::c_ulong = 0;
                    let mut f: *const libc::c_char = 0 as *const libc::c_char;
                    ((*vctxt).locFunc)
                        .expect(
                            "non-null function pointer",
                        )((*vctxt).locCtxt, &mut f, &mut l);
                    if file.is_null() {
                        file = f;
                    }
                    if line == 0 as libc::c_int {
                        line = l as libc::c_int;
                    }
                }
            }
            if file.is_null() && !((*vctxt).filename).is_null() {
                file = (*vctxt).filename;
            }
            __xmlRaiseError(
                schannel,
                channel,
                data,
                ctxt as *mut libc::c_void,
                node as *mut libc::c_void,
                XML_FROM_SCHEMASV as libc::c_int,
                error,
                errorLevel,
                file,
                line,
                str1 as *const libc::c_char,
                str2 as *const libc::c_char,
                str3 as *const libc::c_char,
                0 as libc::c_int,
                col,
                msg,
                str1,
                str2,
                str3,
                str4,
            );
        } else if (*ctxt).type_0 == 1 as libc::c_int {
            let mut pctxt: xmlSchemaParserCtxtPtr = ctxt as xmlSchemaParserCtxtPtr;
            if errorLevel as libc::c_uint
                != XML_ERR_WARNING as libc::c_int as libc::c_uint
            {
                let ref mut fresh5 = (*pctxt).nberrors;
                *fresh5 += 1;
                (*pctxt).err = error;
                channel = (*pctxt).error;
            } else {
                channel = (*pctxt).warning;
            }
            schannel = (*pctxt).serror;
            data = (*pctxt).errCtxt;
            __xmlRaiseError(
                schannel,
                channel,
                data,
                ctxt as *mut libc::c_void,
                node as *mut libc::c_void,
                XML_FROM_SCHEMASP as libc::c_int,
                error,
                errorLevel,
                0 as *const libc::c_char,
                0 as libc::c_int,
                str1 as *const libc::c_char,
                str2 as *const libc::c_char,
                str3 as *const libc::c_char,
                0 as libc::c_int,
                0 as libc::c_int,
                msg,
                str1,
                str2,
                str3,
                str4,
            );
        } else {
            (*__xmlGenericError())
                .expect(
                    "non-null function pointer",
                )(
                *__xmlGenericErrorContext(),
                b"Unimplemented block at %s:%d\n\0" as *const u8 as *const libc::c_char,
                b"xmlschemas.c\0" as *const u8 as *const libc::c_char,
                2188 as libc::c_int,
            );
        }
    }
}
unsafe extern "C" fn xmlSchemaErr3(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: libc::c_int,
    mut node: xmlNodePtr,
    mut msg: *const libc::c_char,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
    mut str3: *const xmlChar,
) {
    xmlSchemaErr4Line(
        actxt,
        XML_ERR_ERROR,
        error,
        node,
        0 as libc::c_int,
        msg,
        str1,
        str2,
        str3,
        0 as *const xmlChar,
    );
}
unsafe extern "C" fn xmlSchemaErr4(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: libc::c_int,
    mut node: xmlNodePtr,
    mut msg: *const libc::c_char,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
    mut str3: *const xmlChar,
    mut str4: *const xmlChar,
) {
    xmlSchemaErr4Line(
        actxt,
        XML_ERR_ERROR,
        error,
        node,
        0 as libc::c_int,
        msg,
        str1,
        str2,
        str3,
        str4,
    );
}
unsafe extern "C" fn xmlSchemaErr(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: libc::c_int,
    mut node: xmlNodePtr,
    mut msg: *const libc::c_char,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
) {
    xmlSchemaErr4(
        actxt,
        error,
        node,
        msg,
        str1,
        str2,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
}
unsafe extern "C" fn xmlSchemaFormatNodeForError(
    mut msg: *mut *mut xmlChar,
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut node: xmlNodePtr,
) -> *mut xmlChar {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    *msg = 0 as *mut xmlChar;
    if !node.is_null()
        && (*node).type_0 as libc::c_uint
            != XML_ELEMENT_NODE as libc::c_int as libc::c_uint
        && (*node).type_0 as libc::c_uint
            != XML_ATTRIBUTE_NODE as libc::c_int as libc::c_uint
    {
        *msg = xmlStrdup(b"\0" as *const u8 as *const libc::c_char as *mut xmlChar);
        return *msg;
    }
    if !node.is_null() {
        if (*node).type_0 as libc::c_uint
            == XML_ATTRIBUTE_NODE as libc::c_int as libc::c_uint
        {
            let mut elem: xmlNodePtr = (*node).parent;
            *msg = xmlStrdup(
                b"Element '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            );
            if !((*elem).ns).is_null() {
                *msg = xmlStrcat(
                    *msg,
                    xmlSchemaFormatQName(&mut str, (*(*elem).ns).href, (*elem).name),
                );
            } else {
                *msg = xmlStrcat(
                    *msg,
                    xmlSchemaFormatQName(&mut str, 0 as *const xmlChar, (*elem).name),
                );
            }
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
            *msg = xmlStrcat(
                *msg,
                b"', \0" as *const u8 as *const libc::c_char as *mut xmlChar,
            );
            *msg = xmlStrcat(
                *msg,
                b"attribute '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            );
        } else {
            *msg = xmlStrdup(
                b"Element '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            );
        }
        if !((*node).ns).is_null() {
            *msg = xmlStrcat(
                *msg,
                xmlSchemaFormatQName(&mut str, (*(*node).ns).href, (*node).name),
            );
        } else {
            *msg = xmlStrcat(
                *msg,
                xmlSchemaFormatQName(&mut str, 0 as *const xmlChar, (*node).name),
            );
        }
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
        *msg = xmlStrcat(
            *msg,
            b"': \0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    } else if (*actxt).type_0 == 2 as libc::c_int {
        let mut vctxt: xmlSchemaValidCtxtPtr = actxt as xmlSchemaValidCtxtPtr;
        if (*(*vctxt).inode).nodeType == XML_ATTRIBUTE_NODE as libc::c_int {
            let mut ielem: xmlSchemaNodeInfoPtr = *((*vctxt).elemInfos)
                .offset((*vctxt).depth as isize);
            *msg = xmlStrdup(
                b"Element '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            );
            *msg = xmlStrcat(
                *msg,
                xmlSchemaFormatQName(&mut str, (*ielem).nsName, (*ielem).localName),
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
            *msg = xmlStrcat(
                *msg,
                b"', \0" as *const u8 as *const libc::c_char as *mut xmlChar,
            );
            *msg = xmlStrcat(
                *msg,
                b"attribute '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            );
        } else {
            *msg = xmlStrdup(
                b"Element '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            );
        }
        *msg = xmlStrcat(
            *msg,
            xmlSchemaFormatQName(
                &mut str,
                (*(*vctxt).inode).nsName,
                (*(*vctxt).inode).localName,
            ),
        );
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
        *msg = xmlStrcat(
            *msg,
            b"': \0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    } else if (*actxt).type_0 == 1 as libc::c_int {
        *msg = xmlStrdup(b"\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    } else {
        (*__xmlGenericError())
            .expect(
                "non-null function pointer",
            )(
            *__xmlGenericErrorContext(),
            b"Unimplemented block at %s:%d\n\0" as *const u8 as *const libc::c_char,
            b"xmlschemas.c\0" as *const u8 as *const libc::c_char,
            2309 as libc::c_int,
        );
        return 0 as *mut xmlChar;
    }
    xmlEscapeFormatString(msg);
    return *msg;
}
unsafe extern "C" fn xmlSchemaInternalErr2(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut funcName: *const libc::c_char,
    mut message: *const libc::c_char,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    if actxt.is_null() {
        return;
    }
    msg = xmlStrdup(
        b"Internal error: %s, \0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    msg = xmlStrcat(msg, message as *mut xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    if (*actxt).type_0 == 2 as libc::c_int {
        xmlSchemaErr3(
            actxt,
            XML_SCHEMAV_INTERNAL as libc::c_int,
            0 as xmlNodePtr,
            msg as *const libc::c_char,
            funcName as *const xmlChar,
            str1,
            str2,
        );
    } else if (*actxt).type_0 == 1 as libc::c_int {
        xmlSchemaErr3(
            actxt,
            XML_SCHEMAP_INTERNAL as libc::c_int,
            0 as xmlNodePtr,
            msg as *const libc::c_char,
            funcName as *const xmlChar,
            str1,
            str2,
        );
    }
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
        msg = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaInternalErr(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut funcName: *const libc::c_char,
    mut message: *const libc::c_char,
) {
    xmlSchemaInternalErr2(
        actxt,
        funcName,
        message,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
}
unsafe extern "C" fn xmlSchemaCustomErr4(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: xmlParserErrors,
    mut node: xmlNodePtr,
    mut item: xmlSchemaBasicItemPtr,
    mut message: *const libc::c_char,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
    mut str3: *const xmlChar,
    mut str4: *const xmlChar,
) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    if node.is_null() && !item.is_null() && (*actxt).type_0 == 1 as libc::c_int {
        node = xmlSchemaGetComponentNode(item);
        xmlSchemaFormatItemForReport(
            &mut msg,
            0 as *const xmlChar,
            item,
            0 as xmlNodePtr,
        );
        msg = xmlStrcat(
            msg,
            b": \0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    } else {
        xmlSchemaFormatNodeForError(&mut msg, actxt, node);
    }
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    xmlSchemaErr4(
        actxt,
        error as libc::c_int,
        node,
        msg as *const libc::c_char,
        str1,
        str2,
        str3,
        str4,
    );
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
        msg = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaCustomErr(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: xmlParserErrors,
    mut node: xmlNodePtr,
    mut item: xmlSchemaBasicItemPtr,
    mut message: *const libc::c_char,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
) {
    xmlSchemaCustomErr4(
        actxt,
        error,
        node,
        item,
        message,
        str1,
        str2,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
}
unsafe extern "C" fn xmlSchemaCustomWarning(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: xmlParserErrors,
    mut node: xmlNodePtr,
    mut type_0: xmlSchemaTypePtr,
    mut message: *const libc::c_char,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
    mut str3: *const xmlChar,
) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(&mut msg, actxt, node);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    xmlSchemaErr4Line(
        actxt,
        XML_ERR_WARNING,
        error as libc::c_int,
        node,
        0 as libc::c_int,
        msg as *const libc::c_char,
        str1,
        str2,
        str3,
        0 as *const xmlChar,
    );
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
        msg = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaKeyrefErr(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut error: xmlParserErrors,
    mut idcNode: xmlSchemaPSVIIDCNodePtr,
    mut type_0: xmlSchemaTypePtr,
    mut message: *const libc::c_char,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    let mut qname: *mut xmlChar = 0 as *mut xmlChar;
    msg = xmlStrdup(
        b"Element '%s': \0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    xmlSchemaErr4Line(
        vctxt as xmlSchemaAbstractCtxtPtr,
        XML_ERR_ERROR,
        error as libc::c_int,
        0 as xmlNodePtr,
        (*idcNode).nodeLine,
        msg as *const libc::c_char,
        xmlSchemaFormatQName(
            &mut qname,
            *((*(*vctxt).nodeQNames).items)
                .offset(((*idcNode).nodeQNameID + 1 as libc::c_int) as isize)
                as *const xmlChar,
            *((*(*vctxt).nodeQNames).items).offset((*idcNode).nodeQNameID as isize)
                as *const xmlChar,
        ),
        str1,
        str2,
        0 as *const xmlChar,
    );
    if !qname.is_null() {
        xmlFree.expect("non-null function pointer")(qname as *mut libc::c_void);
        qname = 0 as *mut xmlChar;
    }
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
        msg = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaEvalErrorNodeType(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut node: xmlNodePtr,
) -> libc::c_int {
    if !node.is_null() {
        return (*node).type_0 as libc::c_int;
    }
    if (*actxt).type_0 == 2 as libc::c_int
        && !((*(actxt as xmlSchemaValidCtxtPtr)).inode).is_null()
    {
        return (*(*(actxt as xmlSchemaValidCtxtPtr)).inode).nodeType;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn xmlSchemaIsGlobalItem(mut item: xmlSchemaTypePtr) -> libc::c_int {
    match (*item).type_0 as libc::c_uint {
        5 | 4 => {
            if (*item).flags & (1 as libc::c_int) << 3 as libc::c_int != 0 {
                return 1 as libc::c_int;
            }
        }
        17 => return 1 as libc::c_int,
        14 => {
            if (*(item as xmlSchemaElementPtr)).flags
                & (1 as libc::c_int) << 1 as libc::c_int != 0
            {
                return 1 as libc::c_int;
            }
        }
        15 => {
            if (*(item as xmlSchemaAttributePtr)).flags
                & (1 as libc::c_int) << 0 as libc::c_int != 0
            {
                return 1 as libc::c_int;
            }
        }
        _ => return 1 as libc::c_int,
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaSimpleTypeErr(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: xmlParserErrors,
    mut node: xmlNodePtr,
    mut value: *const xmlChar,
    mut type_0: xmlSchemaTypePtr,
    mut displayValue: libc::c_int,
) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(&mut msg, actxt, node);
    if displayValue != 0
        || xmlSchemaEvalErrorNodeType(actxt, node) == XML_ATTRIBUTE_NODE as libc::c_int
    {
        msg = xmlStrcat(
            msg,
            b"'%s' is not a valid value of \0" as *const u8 as *const libc::c_char
                as *mut xmlChar,
        );
    } else {
        msg = xmlStrcat(
            msg,
            b"The character content is not a valid value of \0" as *const u8
                as *const libc::c_char as *mut xmlChar,
        );
    }
    if xmlSchemaIsGlobalItem(type_0) == 0 {
        msg = xmlStrcat(
            msg,
            b"the local \0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    } else {
        msg = xmlStrcat(
            msg,
            b"the \0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    }
    if (*type_0).flags & (1 as libc::c_int) << 8 as libc::c_int != 0 {
        msg = xmlStrcat(
            msg,
            b"atomic type\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    } else if (*type_0).flags & (1 as libc::c_int) << 6 as libc::c_int != 0 {
        msg = xmlStrcat(
            msg,
            b"list type\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    } else if (*type_0).flags & (1 as libc::c_int) << 7 as libc::c_int != 0 {
        msg = xmlStrcat(
            msg,
            b"union type\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    }
    if xmlSchemaIsGlobalItem(type_0) != 0 {
        let mut str: *mut xmlChar = 0 as *mut xmlChar;
        msg = xmlStrcat(
            msg,
            b" '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
        if (*type_0).builtInType != 0 as libc::c_int {
            msg = xmlStrcat(
                msg,
                b"xs:\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            );
            str = xmlStrdup((*type_0).name);
        } else {
            let mut qName: *const xmlChar = xmlSchemaFormatQName(
                &mut str,
                (*type_0).targetNamespace,
                (*type_0).name,
            );
            if str.is_null() {
                str = xmlStrdup(qName);
            }
        }
        msg = xmlStrcat(msg, xmlEscapeFormatString(&mut str));
        msg = xmlStrcat(msg, b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar);
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
    }
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    if displayValue != 0
        || xmlSchemaEvalErrorNodeType(actxt, node) == XML_ATTRIBUTE_NODE as libc::c_int
    {
        xmlSchemaErr(
            actxt,
            error as libc::c_int,
            node,
            msg as *const libc::c_char,
            value,
            0 as *const xmlChar,
        );
    } else {
        xmlSchemaErr(
            actxt,
            error as libc::c_int,
            node,
            msg as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
        msg = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaFormatErrorNodeQName(
    mut str: *mut *mut xmlChar,
    mut ni: xmlSchemaNodeInfoPtr,
    mut node: xmlNodePtr,
) -> *const xmlChar {
    if !node.is_null() {
        if !((*node).ns).is_null() {
            return xmlSchemaFormatQName(str, (*(*node).ns).href, (*node).name)
        } else {
            return xmlSchemaFormatQName(str, 0 as *const xmlChar, (*node).name)
        }
    } else {
        if !ni.is_null() {
            return xmlSchemaFormatQName(str, (*ni).nsName, (*ni).localName);
        }
    }
    return 0 as *const xmlChar;
}
unsafe extern "C" fn xmlSchemaIllegalAttrErr(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: xmlParserErrors,
    mut ni: xmlSchemaAttrInfoPtr,
    mut node: xmlNodePtr,
) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(&mut msg, actxt, node);
    msg = xmlStrcat(
        msg,
        b"The attribute '%s' is not allowed.\n\0" as *const u8 as *const libc::c_char
            as *mut xmlChar,
    );
    xmlSchemaErr(
        actxt,
        error as libc::c_int,
        node,
        msg as *const libc::c_char,
        xmlSchemaFormatErrorNodeQName(&mut str, ni as xmlSchemaNodeInfoPtr, node),
        0 as *const xmlChar,
    );
    if !str.is_null() {
        xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
        str = 0 as *mut xmlChar;
    }
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
        msg = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaComplexTypeErr(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: xmlParserErrors,
    mut node: xmlNodePtr,
    mut type_0: xmlSchemaTypePtr,
    mut message: *const libc::c_char,
    mut nbval: libc::c_int,
    mut nbneg: libc::c_int,
    mut values: *mut *mut xmlChar,
) {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    let mut localName: *mut xmlChar = 0 as *mut xmlChar;
    let mut nsName: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    let mut end: *const xmlChar = 0 as *const xmlChar;
    let mut i: libc::c_int = 0;
    xmlSchemaFormatNodeForError(&mut msg, actxt, node);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    if nbval + nbneg > 0 as libc::c_int {
        if nbval + nbneg > 1 as libc::c_int {
            str = xmlStrdup(
                b" Expected is one of ( \0" as *const u8 as *const libc::c_char
                    as *mut xmlChar,
            );
        } else {
            str = xmlStrdup(
                b" Expected is ( \0" as *const u8 as *const libc::c_char as *mut xmlChar,
            );
        }
        nsName = 0 as *mut xmlChar;
        let mut current_block_55: u64;
        i = 0 as libc::c_int;
        while i < nbval + nbneg {
            cur = *values.offset(i as isize);
            if !cur.is_null() {
                if *cur.offset(0 as libc::c_int as isize) as libc::c_int == 'n' as i32
                    && *cur.offset(1 as libc::c_int as isize) as libc::c_int
                        == 'o' as i32
                    && *cur.offset(2 as libc::c_int as isize) as libc::c_int
                        == 't' as i32
                    && *cur.offset(3 as libc::c_int as isize) as libc::c_int
                        == ' ' as i32
                {
                    cur = cur.offset(4 as libc::c_int as isize);
                    str = xmlStrcat(
                        str,
                        b"##other\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                }
                localName = 0 as *mut xmlChar;
                end = cur;
                if *end as libc::c_int == '*' as i32 {
                    localName = xmlStrdup(
                        b"*\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                    end = end.offset(1);
                } else {
                    while *end as libc::c_int != 0 as libc::c_int
                        && *end as libc::c_int != '|' as i32
                    {
                        end = end.offset(1);
                    }
                    localName = xmlStrncat(
                        localName,
                        cur as *mut xmlChar,
                        end.offset_from(cur) as libc::c_long as libc::c_int,
                    );
                }
                if *end as libc::c_int != 0 as libc::c_int {
                    end = end.offset(1);
                    if nbneg == 0 as libc::c_int || *end as libc::c_int != '*' as i32
                        || *localName as libc::c_int != '*' as i32
                    {
                        cur = end;
                        if *end as libc::c_int == '*' as i32 {
                            nsName = xmlStrdup(
                                b"{*}\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                            );
                        } else {
                            while *end as libc::c_int != 0 as libc::c_int {
                                end = end.offset(1);
                            }
                            if i >= nbval {
                                nsName = xmlStrdup(
                                    b"{##other:\0" as *const u8 as *const libc::c_char
                                        as *mut xmlChar,
                                );
                            } else {
                                nsName = xmlStrdup(
                                    b"{\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                                );
                            }
                            nsName = xmlStrncat(
                                nsName,
                                cur as *mut xmlChar,
                                end.offset_from(cur) as libc::c_long as libc::c_int,
                            );
                            nsName = xmlStrcat(
                                nsName,
                                b"}\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                            );
                        }
                        str = xmlStrcat(str, nsName);
                        if !nsName.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(nsName as *mut libc::c_void);
                            nsName = 0 as *mut xmlChar;
                        }
                        current_block_55 = 7990025728955927862;
                    } else {
                        if !localName.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(localName as *mut libc::c_void);
                            localName = 0 as *mut xmlChar;
                        }
                        current_block_55 = 13536709405535804910;
                    }
                } else {
                    current_block_55 = 7990025728955927862;
                }
                match current_block_55 {
                    13536709405535804910 => {}
                    _ => {
                        str = xmlStrcat(str, localName);
                        if !localName.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(localName as *mut libc::c_void);
                            localName = 0 as *mut xmlChar;
                        }
                        if i < nbval + nbneg - 1 as libc::c_int {
                            str = xmlStrcat(
                                str,
                                b", \0" as *const u8 as *const libc::c_char as *mut xmlChar,
                            );
                        }
                    }
                }
            }
            i += 1;
        }
        str = xmlStrcat(
            str,
            b" ).\n\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
        msg = xmlStrcat(msg, xmlEscapeFormatString(&mut str));
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
    } else {
        msg = xmlStrcat(
            msg,
            b"\n\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    }
    xmlSchemaErr(
        actxt,
        error as libc::c_int,
        node,
        msg as *const libc::c_char,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
    xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFacetErr(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: xmlParserErrors,
    mut node: xmlNodePtr,
    mut value: *const xmlChar,
    mut length: libc::c_ulong,
    mut type_0: xmlSchemaTypePtr,
    mut facet: xmlSchemaFacetPtr,
    mut message: *const libc::c_char,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
) {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    let mut facetType: xmlSchemaTypeType = 0 as xmlSchemaTypeType;
    let mut nodeType: libc::c_int = xmlSchemaEvalErrorNodeType(actxt, node);
    xmlSchemaFormatNodeForError(&mut msg, actxt, node);
    if error as libc::c_uint
        == XML_SCHEMAV_CVC_ENUMERATION_VALID as libc::c_int as libc::c_uint
    {
        facetType = XML_SCHEMA_FACET_ENUMERATION;
    } else {
        facetType = (*facet).type_0;
    }
    msg = xmlStrcat(msg, b"[\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    msg = xmlStrcat(
        msg,
        b"facet '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facetType));
    msg = xmlStrcat(msg, b"'] \0" as *const u8 as *const libc::c_char as *mut xmlChar);
    if message.is_null() {
        if facetType as libc::c_uint
            == XML_SCHEMA_FACET_LENGTH as libc::c_int as libc::c_uint
            || facetType as libc::c_uint
                == XML_SCHEMA_FACET_MINLENGTH as libc::c_int as libc::c_uint
            || facetType as libc::c_uint
                == XML_SCHEMA_FACET_MAXLENGTH as libc::c_int as libc::c_uint
        {
            let mut len: [libc::c_char; 25] = [0; 25];
            let mut actLen: [libc::c_char; 25] = [0; 25];
            if nodeType == XML_ATTRIBUTE_NODE as libc::c_int {
                msg = xmlStrcat(
                    msg,
                    b"The value '%s' has a length of '%s'; \0" as *const u8
                        as *const libc::c_char as *mut xmlChar,
                );
            } else {
                msg = xmlStrcat(
                    msg,
                    b"The value has a length of '%s'; \0" as *const u8
                        as *const libc::c_char as *mut xmlChar,
                );
            }
            snprintf(
                len.as_mut_ptr(),
                24 as libc::c_int as libc::c_ulong,
                b"%lu\0" as *const u8 as *const libc::c_char,
                xmlSchemaGetFacetValueAsULong(facet),
            );
            snprintf(
                actLen.as_mut_ptr(),
                24 as libc::c_int as libc::c_ulong,
                b"%lu\0" as *const u8 as *const libc::c_char,
                length,
            );
            if facetType as libc::c_uint
                == XML_SCHEMA_FACET_LENGTH as libc::c_int as libc::c_uint
            {
                msg = xmlStrcat(
                    msg,
                    b"this differs from the allowed length of '%s'.\n\0" as *const u8
                        as *const libc::c_char as *mut xmlChar,
                );
            } else if facetType as libc::c_uint
                    == XML_SCHEMA_FACET_MAXLENGTH as libc::c_int as libc::c_uint
                {
                msg = xmlStrcat(
                    msg,
                    b"this exceeds the allowed maximum length of '%s'.\n\0" as *const u8
                        as *const libc::c_char as *mut xmlChar,
                );
            } else if facetType as libc::c_uint
                    == XML_SCHEMA_FACET_MINLENGTH as libc::c_int as libc::c_uint
                {
                msg = xmlStrcat(
                    msg,
                    b"this underruns the allowed minimum length of '%s'.\n\0"
                        as *const u8 as *const libc::c_char as *mut xmlChar,
                );
            }
            if nodeType == XML_ATTRIBUTE_NODE as libc::c_int {
                xmlSchemaErr3(
                    actxt,
                    error as libc::c_int,
                    node,
                    msg as *const libc::c_char,
                    value,
                    actLen.as_mut_ptr() as *const xmlChar,
                    len.as_mut_ptr() as *const xmlChar,
                );
            } else {
                xmlSchemaErr(
                    actxt,
                    error as libc::c_int,
                    node,
                    msg as *const libc::c_char,
                    actLen.as_mut_ptr() as *const xmlChar,
                    len.as_mut_ptr() as *const xmlChar,
                );
            }
        } else if facetType as libc::c_uint
                == XML_SCHEMA_FACET_ENUMERATION as libc::c_int as libc::c_uint
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is not an element of the set {%s}.\n\0" as *const u8
                    as *const libc::c_char as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as libc::c_int,
                node,
                msg as *const libc::c_char,
                value,
                xmlSchemaFormatFacetEnumSet(actxt, &mut str, type_0),
            );
        } else if facetType as libc::c_uint
                == XML_SCHEMA_FACET_PATTERN as libc::c_int as libc::c_uint
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is not accepted by the pattern '%s'.\n\0" as *const u8
                    as *const libc::c_char as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as libc::c_int,
                node,
                msg as *const libc::c_char,
                value,
                (*facet).value,
            );
        } else if facetType as libc::c_uint
                == XML_SCHEMA_FACET_MININCLUSIVE as libc::c_int as libc::c_uint
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is less than the minimum value allowed ('%s').\n\0"
                    as *const u8 as *const libc::c_char as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as libc::c_int,
                node,
                msg as *const libc::c_char,
                value,
                (*facet).value,
            );
        } else if facetType as libc::c_uint
                == XML_SCHEMA_FACET_MAXINCLUSIVE as libc::c_int as libc::c_uint
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is greater than the maximum value allowed ('%s').\n\0"
                    as *const u8 as *const libc::c_char as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as libc::c_int,
                node,
                msg as *const libc::c_char,
                value,
                (*facet).value,
            );
        } else if facetType as libc::c_uint
                == XML_SCHEMA_FACET_MINEXCLUSIVE as libc::c_int as libc::c_uint
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' must be greater than '%s'.\n\0" as *const u8
                    as *const libc::c_char as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as libc::c_int,
                node,
                msg as *const libc::c_char,
                value,
                (*facet).value,
            );
        } else if facetType as libc::c_uint
                == XML_SCHEMA_FACET_MAXEXCLUSIVE as libc::c_int as libc::c_uint
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' must be less than '%s'.\n\0" as *const u8
                    as *const libc::c_char as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as libc::c_int,
                node,
                msg as *const libc::c_char,
                value,
                (*facet).value,
            );
        } else if facetType as libc::c_uint
                == XML_SCHEMA_FACET_TOTALDIGITS as libc::c_int as libc::c_uint
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' has more digits than are allowed ('%s').\n\0"
                    as *const u8 as *const libc::c_char as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as libc::c_int,
                node,
                msg as *const libc::c_char,
                value,
                (*facet).value,
            );
        } else if facetType as libc::c_uint
                == XML_SCHEMA_FACET_FRACTIONDIGITS as libc::c_int as libc::c_uint
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' has more fractional digits than are allowed ('%s').\n\0"
                    as *const u8 as *const libc::c_char as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as libc::c_int,
                node,
                msg as *const libc::c_char,
                value,
                (*facet).value,
            );
        } else if nodeType == XML_ATTRIBUTE_NODE as libc::c_int {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is not facet-valid.\n\0" as *const u8
                    as *const libc::c_char as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as libc::c_int,
                node,
                msg as *const libc::c_char,
                value,
                0 as *const xmlChar,
            );
        } else {
            msg = xmlStrcat(
                msg,
                b"The value is not facet-valid.\n\0" as *const u8 as *const libc::c_char
                    as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as libc::c_int,
                node,
                msg as *const libc::c_char,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
        }
    } else {
        msg = xmlStrcat(msg, message as *const xmlChar);
        msg = xmlStrcat(
            msg,
            b".\n\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
        xmlSchemaErr(
            actxt,
            error as libc::c_int,
            node,
            msg as *const libc::c_char,
            str1,
            str2,
        );
    }
    if !str.is_null() {
        xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
        str = 0 as *mut xmlChar;
    }
    xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaPMissingAttrErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut ownerElem: xmlNodePtr,
    mut name: *const libc::c_char,
    mut message: *const libc::c_char,
) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(&mut des, 0 as *const xmlChar, ownerItem, ownerElem);
    if !message.is_null() {
        xmlSchemaPErr(
            ctxt,
            ownerElem,
            error as libc::c_int,
            b"%s: %s.\n\0" as *const u8 as *const libc::c_char,
            des,
            message as *mut xmlChar,
        );
    } else {
        xmlSchemaPErr(
            ctxt,
            ownerElem,
            error as libc::c_int,
            b"%s: The attribute '%s' is required but missing.\n\0" as *const u8
                as *const libc::c_char,
            des,
            name as *mut xmlChar,
        );
    }
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
        des = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaPResCompAttrErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut ownerElem: xmlNodePtr,
    mut name: *const libc::c_char,
    mut refName: *const xmlChar,
    mut refURI: *const xmlChar,
    mut refType: xmlSchemaTypeType,
    mut refTypeStr: *const libc::c_char,
) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    let mut strA: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(&mut des, 0 as *const xmlChar, ownerItem, ownerElem);
    if refTypeStr.is_null() {
        refTypeStr = xmlSchemaItemTypeToStr(refType) as *const libc::c_char;
    }
    xmlSchemaPErrExt(
        ctxt,
        ownerElem,
        error as libc::c_int,
        0 as *const xmlChar,
        0 as *const xmlChar,
        0 as *const xmlChar,
        b"%s, attribute '%s': The QName value '%s' does not resolve to a(n) %s.\n\0"
            as *const u8 as *const libc::c_char,
        des,
        name as *mut xmlChar,
        xmlSchemaFormatQName(&mut strA, refURI, refName),
        refTypeStr as *mut xmlChar,
        0 as *const xmlChar,
    );
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
        des = 0 as *mut xmlChar;
    }
    if !strA.is_null() {
        xmlFree.expect("non-null function pointer")(strA as *mut libc::c_void);
        strA = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaPCustomAttrErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut ownerDes: *mut *mut xmlChar,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut attr: xmlAttrPtr,
    mut msg: *const libc::c_char,
) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    if ownerDes.is_null() {
        xmlSchemaFormatItemForReport(
            &mut des,
            0 as *const xmlChar,
            ownerItem,
            (*attr).parent,
        );
    } else if (*ownerDes).is_null() {
        xmlSchemaFormatItemForReport(
            ownerDes,
            0 as *const xmlChar,
            ownerItem,
            (*attr).parent,
        );
        des = *ownerDes;
    } else {
        des = *ownerDes;
    }
    if attr.is_null() {
        xmlSchemaPErrExt(
            ctxt,
            0 as xmlNodePtr,
            error as libc::c_int,
            0 as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
            b"%s, attribute '%s': %s.\n\0" as *const u8 as *const libc::c_char,
            des,
            b"Unknown\0" as *const u8 as *const libc::c_char as *const xmlChar,
            msg as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    } else {
        xmlSchemaPErrExt(
            ctxt,
            attr as xmlNodePtr,
            error as libc::c_int,
            0 as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
            b"%s, attribute '%s': %s.\n\0" as *const u8 as *const libc::c_char,
            des,
            (*attr).name,
            msg as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    if ownerDes.is_null() {
        if !des.is_null() {
            xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
            des = 0 as *mut xmlChar;
        }
    }
}
unsafe extern "C" fn xmlSchemaPIllegalAttrErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut ownerComp: xmlSchemaBasicItemPtr,
    mut attr: xmlAttrPtr,
) {
    let mut strA: *mut xmlChar = 0 as *mut xmlChar;
    let mut strB: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(
        &mut strA,
        ctxt as xmlSchemaAbstractCtxtPtr,
        (*attr).parent,
    );
    xmlSchemaErr4(
        ctxt as xmlSchemaAbstractCtxtPtr,
        error as libc::c_int,
        attr as xmlNodePtr,
        b"%sThe attribute '%s' is not allowed.\n\0" as *const u8 as *const libc::c_char,
        strA,
        xmlSchemaFormatQNameNs(&mut strB, (*attr).ns, (*attr).name),
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
    if !strA.is_null() {
        xmlFree.expect("non-null function pointer")(strA as *mut libc::c_void);
        strA = 0 as *mut xmlChar;
    }
    if !strB.is_null() {
        xmlFree.expect("non-null function pointer")(strB as *mut libc::c_void);
        strB = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaPCustomErrExt(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut item: xmlSchemaBasicItemPtr,
    mut itemElem: xmlNodePtr,
    mut message: *const libc::c_char,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
    mut str3: *const xmlChar,
) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(&mut des, 0 as *const xmlChar, item, itemElem);
    msg = xmlStrdup(b"%s: \0" as *const u8 as *const libc::c_char as *mut xmlChar);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    if itemElem.is_null() && !item.is_null() {
        itemElem = xmlSchemaGetComponentNode(item);
    }
    xmlSchemaPErrExt(
        ctxt,
        itemElem,
        error as libc::c_int,
        0 as *const xmlChar,
        0 as *const xmlChar,
        0 as *const xmlChar,
        msg as *const libc::c_char,
        des,
        str1,
        str2,
        str3,
        0 as *const xmlChar,
    );
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
        des = 0 as *mut xmlChar;
    }
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
        msg = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaPCustomErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut item: xmlSchemaBasicItemPtr,
    mut itemElem: xmlNodePtr,
    mut message: *const libc::c_char,
    mut str1: *const xmlChar,
) {
    xmlSchemaPCustomErrExt(
        ctxt,
        error,
        item,
        itemElem,
        message,
        str1,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
}
unsafe extern "C" fn xmlSchemaPAttrUseErr4(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut node: xmlNodePtr,
    mut ownerItem: xmlSchemaBasicItemPtr,
    attruse: xmlSchemaAttributeUsePtr,
    mut message: *const libc::c_char,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
    mut str3: *const xmlChar,
    mut str4: *const xmlChar,
) {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(
        &mut msg,
        0 as *const xmlChar,
        ownerItem,
        0 as xmlNodePtr,
    );
    msg = xmlStrcat(msg, b", \0" as *const u8 as *const libc::c_char as *mut xmlChar);
    msg = xmlStrcat(
        msg,
        xmlSchemaFormatItemForReport(
            &mut str,
            0 as *const xmlChar,
            attruse as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
        ),
    );
    if !str.is_null() {
        xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
        str = 0 as *mut xmlChar;
    }
    msg = xmlStrcat(msg, b": \0" as *const u8 as *const libc::c_char as *mut xmlChar);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    xmlSchemaErr4(
        ctxt as xmlSchemaAbstractCtxtPtr,
        error as libc::c_int,
        node,
        msg as *const libc::c_char,
        str1,
        str2,
        str3,
        str4,
    );
    xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaPIllegalFacetAtomicErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut type_0: xmlSchemaTypePtr,
    mut baseType: xmlSchemaTypePtr,
    mut facet: xmlSchemaFacetPtr,
) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    let mut strT: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(
        &mut des,
        0 as *const xmlChar,
        type_0 as xmlSchemaBasicItemPtr,
        (*type_0).node,
    );
    xmlSchemaPErrExt(
        ctxt,
        (*type_0).node,
        error as libc::c_int,
        0 as *const xmlChar,
        0 as *const xmlChar,
        0 as *const xmlChar,
        b"%s: The facet '%s' is not allowed on types derived from the type %s.\n\0"
            as *const u8 as *const libc::c_char,
        des,
        xmlSchemaFacetTypeToString((*facet).type_0),
        xmlSchemaFormatItemForReport(
            &mut strT,
            0 as *const xmlChar,
            baseType as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
        ),
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
        des = 0 as *mut xmlChar;
    }
    if !strT.is_null() {
        xmlFree.expect("non-null function pointer")(strT as *mut libc::c_void);
        strT = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaPIllegalFacetListUnionErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut type_0: xmlSchemaTypePtr,
    mut facet: xmlSchemaFacetPtr,
) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(
        &mut des,
        0 as *const xmlChar,
        type_0 as xmlSchemaBasicItemPtr,
        (*type_0).node,
    );
    xmlSchemaPErr(
        ctxt,
        (*type_0).node,
        error as libc::c_int,
        b"%s: The facet '%s' is not allowed.\n\0" as *const u8 as *const libc::c_char,
        des,
        xmlSchemaFacetTypeToString((*facet).type_0),
    );
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
        des = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaPMutualExclAttrErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut attr: xmlAttrPtr,
    mut name1: *const libc::c_char,
    mut name2: *const libc::c_char,
) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(
        &mut des,
        0 as *const xmlChar,
        ownerItem,
        (*attr).parent,
    );
    xmlSchemaPErrExt(
        ctxt,
        attr as xmlNodePtr,
        error as libc::c_int,
        0 as *const xmlChar,
        0 as *const xmlChar,
        0 as *const xmlChar,
        b"%s: The attributes '%s' and '%s' are mutually exclusive.\n\0" as *const u8
            as *const libc::c_char,
        des,
        name1 as *mut xmlChar,
        name2 as *mut xmlChar,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
        des = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaPSimpleTypeErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut node: xmlNodePtr,
    mut type_0: xmlSchemaTypePtr,
    mut expected: *const libc::c_char,
    mut value: *const xmlChar,
    mut message: *const libc::c_char,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(&mut msg, ctxt as xmlSchemaAbstractCtxtPtr, node);
    if message.is_null() {
        if !type_0.is_null() {
            if (*node).type_0 as libc::c_uint
                == XML_ATTRIBUTE_NODE as libc::c_int as libc::c_uint
            {
                msg = xmlStrcat(
                    msg,
                    b"'%s' is not a valid value of \0" as *const u8
                        as *const libc::c_char as *mut xmlChar,
                );
            } else {
                msg = xmlStrcat(
                    msg,
                    b"The character content is not a valid value of \0" as *const u8
                        as *const libc::c_char as *mut xmlChar,
                );
            }
            if xmlSchemaIsGlobalItem(type_0) == 0 {
                msg = xmlStrcat(
                    msg,
                    b"the local \0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
            } else {
                msg = xmlStrcat(
                    msg,
                    b"the \0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
            }
            if (*type_0).flags & (1 as libc::c_int) << 8 as libc::c_int != 0 {
                msg = xmlStrcat(
                    msg,
                    b"atomic type\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
            } else if (*type_0).flags & (1 as libc::c_int) << 6 as libc::c_int != 0 {
                msg = xmlStrcat(
                    msg,
                    b"list type\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
            } else if (*type_0).flags & (1 as libc::c_int) << 7 as libc::c_int != 0 {
                msg = xmlStrcat(
                    msg,
                    b"union type\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
            }
            if xmlSchemaIsGlobalItem(type_0) != 0 {
                let mut str: *mut xmlChar = 0 as *mut xmlChar;
                msg = xmlStrcat(
                    msg,
                    b" '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
                if (*type_0).builtInType != 0 as libc::c_int {
                    msg = xmlStrcat(
                        msg,
                        b"xs:\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    );
                    str = xmlStrdup((*type_0).name);
                } else {
                    let mut qName: *const xmlChar = xmlSchemaFormatQName(
                        &mut str,
                        (*type_0).targetNamespace,
                        (*type_0).name,
                    );
                    if str.is_null() {
                        str = xmlStrdup(qName);
                    }
                }
                msg = xmlStrcat(msg, xmlEscapeFormatString(&mut str));
                msg = xmlStrcat(
                    msg,
                    b"'.\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
            }
        } else if (*node).type_0 as libc::c_uint
                == XML_ATTRIBUTE_NODE as libc::c_int as libc::c_uint
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is not valid.\0" as *const u8 as *const libc::c_char
                    as *mut xmlChar,
            );
        } else {
            msg = xmlStrcat(
                msg,
                b"The character content is not valid.\0" as *const u8
                    as *const libc::c_char as *mut xmlChar,
            );
        }
        if !expected.is_null() {
            let mut expectedEscaped: *mut xmlChar = xmlCharStrdup(expected);
            msg = xmlStrcat(
                msg,
                b" Expected is '\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            );
            msg = xmlStrcat(msg, xmlEscapeFormatString(&mut expectedEscaped));
            if !expectedEscaped.is_null() {
                xmlFree
                    .expect(
                        "non-null function pointer",
                    )(expectedEscaped as *mut libc::c_void);
                expectedEscaped = 0 as *mut xmlChar;
            }
            msg = xmlStrcat(
                msg,
                b"'.\n\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            );
        } else {
            msg = xmlStrcat(
                msg,
                b"\n\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            );
        }
        if (*node).type_0 as libc::c_uint
            == XML_ATTRIBUTE_NODE as libc::c_int as libc::c_uint
        {
            xmlSchemaPErr(
                ctxt,
                node,
                error as libc::c_int,
                msg as *const libc::c_char,
                value,
                0 as *const xmlChar,
            );
        } else {
            xmlSchemaPErr(
                ctxt,
                node,
                error as libc::c_int,
                msg as *const libc::c_char,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
        }
    } else {
        msg = xmlStrcat(msg, message as *mut xmlChar);
        msg = xmlStrcat(
            msg,
            b".\n\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
        xmlSchemaPErrExt(
            ctxt,
            node,
            error as libc::c_int,
            0 as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
            msg as *const libc::c_char,
            str1,
            str2,
            0 as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
        msg = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaPContentErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut ownerElem: xmlNodePtr,
    mut child: xmlNodePtr,
    mut message: *const libc::c_char,
    mut content: *const libc::c_char,
) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(&mut des, 0 as *const xmlChar, ownerItem, ownerElem);
    if !message.is_null() {
        xmlSchemaPErr2(
            ctxt,
            ownerElem,
            child,
            error as libc::c_int,
            b"%s: %s.\n\0" as *const u8 as *const libc::c_char,
            des,
            message as *mut xmlChar,
        );
    } else if !content.is_null() {
        xmlSchemaPErr2(
            ctxt,
            ownerElem,
            child,
            error as libc::c_int,
            b"%s: The content is not valid. Expected is %s.\n\0" as *const u8
                as *const libc::c_char,
            des,
            content as *mut xmlChar,
        );
    } else {
        xmlSchemaPErr2(
            ctxt,
            ownerElem,
            child,
            error as libc::c_int,
            b"%s: The content is not valid.\n\0" as *const u8 as *const libc::c_char,
            des,
            0 as *const xmlChar,
        );
    }
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
        des = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaNewSchema(
    mut ctxt: xmlSchemaParserCtxtPtr,
) -> xmlSchemaPtr {
    let mut ret: xmlSchemaPtr = 0 as *mut xmlSchema;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchema>() as libc::c_ulong) as xmlSchemaPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating schema\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchema>() as libc::c_ulong,
    );
    let ref mut fresh6 = (*ret).dict;
    *fresh6 = (*ctxt).dict;
    xmlDictReference((*ret).dict);
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaNewFacet() -> xmlSchemaFacetPtr {
    let mut ret: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaFacet>() as libc::c_ulong) as xmlSchemaFacetPtr;
    if ret.is_null() {
        return 0 as xmlSchemaFacetPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaFacet>() as libc::c_ulong,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaNewAnnot(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaAnnotPtr {
    let mut ret: xmlSchemaAnnotPtr = 0 as *mut xmlSchemaAnnot;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaAnnot>() as libc::c_ulong) as xmlSchemaAnnotPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating annotation\0" as *const u8 as *const libc::c_char,
            node,
        );
        return 0 as xmlSchemaAnnotPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaAnnot>() as libc::c_ulong,
    );
    let ref mut fresh7 = (*ret).content;
    *fresh7 = node;
    return ret;
}
unsafe extern "C" fn xmlSchemaItemListCreate() -> xmlSchemaItemListPtr {
    let mut ret: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaItemList>() as libc::c_ulong)
        as xmlSchemaItemListPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating an item list structure\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaItemListPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaItemList>() as libc::c_ulong,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaItemListClear(mut list: xmlSchemaItemListPtr) {
    if !((*list).items).is_null() {
        xmlFree.expect("non-null function pointer")((*list).items as *mut libc::c_void);
        let ref mut fresh8 = (*list).items;
        *fresh8 = 0 as *mut *mut libc::c_void;
    }
    (*list).nbItems = 0 as libc::c_int;
    (*list).sizeItems = 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaItemListAdd(
    mut list: xmlSchemaItemListPtr,
    mut item: *mut libc::c_void,
) -> libc::c_int {
    if ((*list).items).is_null() {
        let ref mut fresh9 = (*list).items;
        *fresh9 = xmlMalloc
            .expect(
                "non-null function pointer",
            )(
            (20 as libc::c_int as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
                ),
        ) as *mut *mut libc::c_void;
        if ((*list).items).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"allocating new item list\0" as *const u8 as *const libc::c_char,
                0 as xmlNodePtr,
            );
            return -(1 as libc::c_int);
        }
        (*list).sizeItems = 20 as libc::c_int;
    } else if (*list).sizeItems <= (*list).nbItems {
        (*list).sizeItems *= 2 as libc::c_int;
        let ref mut fresh10 = (*list).items;
        *fresh10 = xmlRealloc
            .expect(
                "non-null function pointer",
            )(
            (*list).items as *mut libc::c_void,
            ((*list).sizeItems as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
                ),
        ) as *mut *mut libc::c_void;
        if ((*list).items).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"growing item list\0" as *const u8 as *const libc::c_char,
                0 as xmlNodePtr,
            );
            (*list).sizeItems = 0 as libc::c_int;
            return -(1 as libc::c_int);
        }
    }
    let ref mut fresh11 = (*list).nbItems;
    let fresh12 = *fresh11;
    *fresh11 = *fresh11 + 1;
    let ref mut fresh13 = *((*list).items).offset(fresh12 as isize);
    *fresh13 = item;
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaItemListAddSize(
    mut list: xmlSchemaItemListPtr,
    mut initialSize: libc::c_int,
    mut item: *mut libc::c_void,
) -> libc::c_int {
    if ((*list).items).is_null() {
        if initialSize <= 0 as libc::c_int {
            initialSize = 1 as libc::c_int;
        }
        let ref mut fresh14 = (*list).items;
        *fresh14 = xmlMalloc
            .expect(
                "non-null function pointer",
            )(
            (initialSize as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
                ),
        ) as *mut *mut libc::c_void;
        if ((*list).items).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"allocating new item list\0" as *const u8 as *const libc::c_char,
                0 as xmlNodePtr,
            );
            return -(1 as libc::c_int);
        }
        (*list).sizeItems = initialSize;
    } else if (*list).sizeItems <= (*list).nbItems {
        (*list).sizeItems *= 2 as libc::c_int;
        let ref mut fresh15 = (*list).items;
        *fresh15 = xmlRealloc
            .expect(
                "non-null function pointer",
            )(
            (*list).items as *mut libc::c_void,
            ((*list).sizeItems as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
                ),
        ) as *mut *mut libc::c_void;
        if ((*list).items).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"growing item list\0" as *const u8 as *const libc::c_char,
                0 as xmlNodePtr,
            );
            (*list).sizeItems = 0 as libc::c_int;
            return -(1 as libc::c_int);
        }
    }
    let ref mut fresh16 = (*list).nbItems;
    let fresh17 = *fresh16;
    *fresh16 = *fresh16 + 1;
    let ref mut fresh18 = *((*list).items).offset(fresh17 as isize);
    *fresh18 = item;
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaItemListInsert(
    mut list: xmlSchemaItemListPtr,
    mut item: *mut libc::c_void,
    mut idx: libc::c_int,
) -> libc::c_int {
    if ((*list).items).is_null() {
        let ref mut fresh19 = (*list).items;
        *fresh19 = xmlMalloc
            .expect(
                "non-null function pointer",
            )(
            (20 as libc::c_int as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
                ),
        ) as *mut *mut libc::c_void;
        if ((*list).items).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"allocating new item list\0" as *const u8 as *const libc::c_char,
                0 as xmlNodePtr,
            );
            return -(1 as libc::c_int);
        }
        (*list).sizeItems = 20 as libc::c_int;
    } else if (*list).sizeItems <= (*list).nbItems {
        (*list).sizeItems *= 2 as libc::c_int;
        let ref mut fresh20 = (*list).items;
        *fresh20 = xmlRealloc
            .expect(
                "non-null function pointer",
            )(
            (*list).items as *mut libc::c_void,
            ((*list).sizeItems as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
                ),
        ) as *mut *mut libc::c_void;
        if ((*list).items).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"growing item list\0" as *const u8 as *const libc::c_char,
                0 as xmlNodePtr,
            );
            (*list).sizeItems = 0 as libc::c_int;
            return -(1 as libc::c_int);
        }
    }
    if idx >= (*list).nbItems {
        let ref mut fresh21 = (*list).nbItems;
        let fresh22 = *fresh21;
        *fresh21 = *fresh21 + 1;
        let ref mut fresh23 = *((*list).items).offset(fresh22 as isize);
        *fresh23 = item;
    } else {
        let mut i: libc::c_int = 0;
        i = (*list).nbItems;
        while i > idx {
            let ref mut fresh24 = *((*list).items).offset(i as isize);
            *fresh24 = *((*list).items).offset((i - 1 as libc::c_int) as isize);
            i -= 1;
        }
        let ref mut fresh25 = *((*list).items).offset(idx as isize);
        *fresh25 = item;
        let ref mut fresh26 = (*list).nbItems;
        *fresh26 += 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaItemListRemove(
    mut list: xmlSchemaItemListPtr,
    mut idx: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    if ((*list).items).is_null() || idx >= (*list).nbItems {
        xmlSchemaPSimpleErr(
            b"Internal error: xmlSchemaItemListRemove, index error.\n\0" as *const u8
                as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    if (*list).nbItems == 1 as libc::c_int {
        xmlFree.expect("non-null function pointer")((*list).items as *mut libc::c_void);
        let ref mut fresh27 = (*list).items;
        *fresh27 = 0 as *mut *mut libc::c_void;
        (*list).nbItems = 0 as libc::c_int;
        (*list).sizeItems = 0 as libc::c_int;
    } else if (*list).nbItems - 1 as libc::c_int == idx {
        let ref mut fresh28 = (*list).nbItems;
        *fresh28 -= 1;
    } else {
        i = idx;
        while i < (*list).nbItems - 1 as libc::c_int {
            let ref mut fresh29 = *((*list).items).offset(i as isize);
            *fresh29 = *((*list).items).offset((i + 1 as libc::c_int) as isize);
            i += 1;
        }
        let ref mut fresh30 = (*list).nbItems;
        *fresh30 -= 1;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaItemListFree(mut list: xmlSchemaItemListPtr) {
    if list.is_null() {
        return;
    }
    if !((*list).items).is_null() {
        xmlFree.expect("non-null function pointer")((*list).items as *mut libc::c_void);
    }
    xmlFree.expect("non-null function pointer")(list as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaBucketFree(mut bucket: xmlSchemaBucketPtr) {
    if bucket.is_null() {
        return;
    }
    if !((*bucket).globals).is_null() {
        xmlSchemaComponentListFree((*bucket).globals);
        xmlSchemaItemListFree((*bucket).globals);
    }
    if !((*bucket).locals).is_null() {
        xmlSchemaComponentListFree((*bucket).locals);
        xmlSchemaItemListFree((*bucket).locals);
    }
    if !((*bucket).relations).is_null() {
        let mut prev: xmlSchemaSchemaRelationPtr = 0 as *mut xmlSchemaSchemaRelation;
        let mut cur: xmlSchemaSchemaRelationPtr = (*bucket).relations;
        loop {
            prev = cur;
            cur = (*cur).next;
            xmlFree.expect("non-null function pointer")(prev as *mut libc::c_void);
            if cur.is_null() {
                break;
            }
        }
    }
    if (*bucket).preserveDoc == 0 && !((*bucket).doc).is_null() {
        xmlFreeDoc((*bucket).doc);
    }
    if (*bucket).type_0 == 1 as libc::c_int {
        if !((*(bucket as xmlSchemaImportPtr)).schema).is_null() {
            xmlSchemaFree((*(bucket as xmlSchemaImportPtr)).schema);
        }
    }
    xmlFree.expect("non-null function pointer")(bucket as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaBucketFreeEntry(
    mut bucket: *mut libc::c_void,
    mut name: *const xmlChar,
) {
    xmlSchemaBucketFree(bucket as xmlSchemaBucketPtr);
}
unsafe extern "C" fn xmlSchemaBucketCreate(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: libc::c_int,
    mut targetNamespace: *const xmlChar,
) -> xmlSchemaBucketPtr {
    let mut ret: xmlSchemaBucketPtr = 0 as *mut xmlSchemaBucket;
    let mut size: libc::c_int = 0;
    let mut mainSchema: xmlSchemaPtr = 0 as *mut xmlSchema;
    if ((*(*pctxt).constructor).mainSchema).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaBucketCreate\0" as *const u8 as *const libc::c_char,
            b"no main schema on constructor\0" as *const u8 as *const libc::c_char,
        );
        return 0 as xmlSchemaBucketPtr;
    }
    mainSchema = (*(*pctxt).constructor).mainSchema;
    if type_0 == 2 as libc::c_int || type_0 == 3 as libc::c_int {
        size = ::std::mem::size_of::<xmlSchemaInclude>() as libc::c_ulong as libc::c_int;
    } else {
        size = ::std::mem::size_of::<xmlSchemaImport>() as libc::c_ulong as libc::c_int;
    }
    ret = xmlMalloc.expect("non-null function pointer")(size as size_t)
        as xmlSchemaBucketPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating schema bucket\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaBucketPtr;
    }
    memset(ret as *mut libc::c_void, 0 as libc::c_int, size as libc::c_ulong);
    let ref mut fresh31 = (*ret).targetNamespace;
    *fresh31 = targetNamespace;
    (*ret).type_0 = type_0;
    let ref mut fresh32 = (*ret).globals;
    *fresh32 = xmlSchemaItemListCreate();
    if ((*ret).globals).is_null() {
        xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void);
        return 0 as xmlSchemaBucketPtr;
    }
    let ref mut fresh33 = (*ret).locals;
    *fresh33 = xmlSchemaItemListCreate();
    if ((*ret).locals).is_null() {
        xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void);
        return 0 as xmlSchemaBucketPtr;
    }
    if !(!((*(*pctxt).constructor).buckets).is_null()
        && (*(*(*pctxt).constructor).buckets).nbItems > 0 as libc::c_int)
    {
        if type_0 == 2 as libc::c_int || type_0 == 3 as libc::c_int {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaBucketCreate\0" as *const u8 as *const libc::c_char,
                b"first bucket but it's an include or redefine\0" as *const u8
                    as *const libc::c_char,
            );
            xmlSchemaBucketFree(ret);
            return 0 as xmlSchemaBucketPtr;
        }
        (*ret).type_0 = 0 as libc::c_int;
        let ref mut fresh34 = (*(*pctxt).constructor).mainBucket;
        *fresh34 = ret;
        let ref mut fresh35 = (*(ret as xmlSchemaImportPtr)).schema;
        *fresh35 = mainSchema;
        let ref mut fresh36 = (*mainSchema).targetNamespace;
        *fresh36 = targetNamespace;
    } else if type_0 == 0 as libc::c_int {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaBucketCreate\0" as *const u8 as *const libc::c_char,
            b"main bucket but it's not the first one\0" as *const u8
                as *const libc::c_char,
        );
        xmlSchemaBucketFree(ret);
        return 0 as xmlSchemaBucketPtr;
    } else {
        if type_0 == 1 as libc::c_int {
            let ref mut fresh37 = (*(ret as xmlSchemaImportPtr)).schema;
            *fresh37 = xmlSchemaNewSchema(pctxt);
            if ((*(ret as xmlSchemaImportPtr)).schema).is_null() {
                xmlSchemaBucketFree(ret);
                return 0 as xmlSchemaBucketPtr;
            }
            let ref mut fresh38 = (*(*(ret as xmlSchemaImportPtr)).schema)
                .targetNamespace;
            *fresh38 = targetNamespace;
        }
    }
    if type_0 == 0 as libc::c_int || type_0 == 1 as libc::c_int {
        let mut res: libc::c_int = 0;
        if ((*mainSchema).schemasImports).is_null() {
            let ref mut fresh39 = (*mainSchema).schemasImports;
            *fresh39 = xmlHashCreateDict(5 as libc::c_int, (*(*pctxt).constructor).dict);
            if ((*mainSchema).schemasImports).is_null() {
                xmlSchemaBucketFree(ret);
                return 0 as xmlSchemaBucketPtr;
            }
        }
        if targetNamespace.is_null() {
            res = xmlHashAddEntry(
                (*mainSchema).schemasImports,
                b"##\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ret as *mut libc::c_void,
            );
        } else {
            res = xmlHashAddEntry(
                (*mainSchema).schemasImports,
                targetNamespace,
                ret as *mut libc::c_void,
            );
        }
        if res != 0 as libc::c_int {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaBucketCreate\0" as *const u8 as *const libc::c_char,
                b"failed to add the schema bucket to the hash\0" as *const u8
                    as *const libc::c_char,
            );
            xmlSchemaBucketFree(ret);
            return 0 as xmlSchemaBucketPtr;
        }
    } else {
        if (*(*(*pctxt).constructor).bucket).type_0 == 0 as libc::c_int
            || (*(*(*pctxt).constructor).bucket).type_0 == 1 as libc::c_int
        {
            let ref mut fresh40 = (*(ret as xmlSchemaIncludePtr)).ownerImport;
            *fresh40 = (*(*pctxt).constructor).bucket as xmlSchemaImportPtr;
        } else {
            let ref mut fresh41 = (*(ret as xmlSchemaIncludePtr)).ownerImport;
            *fresh41 = (*((*(*pctxt).constructor).bucket as xmlSchemaIncludePtr))
                .ownerImport;
        }
        if ((*mainSchema).includes).is_null() {
            let ref mut fresh42 = (*mainSchema).includes;
            *fresh42 = xmlSchemaItemListCreate() as *mut libc::c_void;
            if ((*mainSchema).includes).is_null() {
                xmlSchemaBucketFree(ret);
                return 0 as xmlSchemaBucketPtr;
            }
        }
        xmlSchemaItemListAdd(
            (*mainSchema).includes as xmlSchemaItemListPtr,
            ret as *mut libc::c_void,
        );
    }
    if xmlSchemaItemListAdd((*(*pctxt).constructor).buckets, ret as *mut libc::c_void)
        == -(1 as libc::c_int)
    {
        return 0 as xmlSchemaBucketPtr;
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaAddItemSize(
    mut list: *mut xmlSchemaItemListPtr,
    mut initialSize: libc::c_int,
    mut item: *mut libc::c_void,
) -> libc::c_int {
    if (*list).is_null() {
        *list = xmlSchemaItemListCreate();
        if (*list).is_null() {
            return -(1 as libc::c_int);
        }
    }
    xmlSchemaItemListAddSize(*list, initialSize, item);
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaFreeAnnot(mut annot: xmlSchemaAnnotPtr) {
    if annot.is_null() {
        return;
    }
    if ((*annot).next).is_null() {
        xmlFree.expect("non-null function pointer")(annot as *mut libc::c_void);
    } else {
        let mut prev: xmlSchemaAnnotPtr = 0 as *mut xmlSchemaAnnot;
        loop {
            prev = annot;
            annot = (*annot).next;
            xmlFree.expect("non-null function pointer")(prev as *mut libc::c_void);
            if annot.is_null() {
                break;
            }
        }
    };
}
unsafe extern "C" fn xmlSchemaFreeNotation(mut nota: xmlSchemaNotationPtr) {
    if nota.is_null() {
        return;
    }
    xmlFree.expect("non-null function pointer")(nota as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeAttribute(mut attr: xmlSchemaAttributePtr) {
    if attr.is_null() {
        return;
    }
    if !((*attr).annot).is_null() {
        xmlSchemaFreeAnnot((*attr).annot);
    }
    if !((*attr).defVal).is_null() {
        xmlSchemaFreeValue((*attr).defVal);
    }
    xmlFree.expect("non-null function pointer")(attr as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeAttributeUse(mut use_0: xmlSchemaAttributeUsePtr) {
    if use_0.is_null() {
        return;
    }
    if !((*use_0).annot).is_null() {
        xmlSchemaFreeAnnot((*use_0).annot);
    }
    if !((*use_0).defVal).is_null() {
        xmlSchemaFreeValue((*use_0).defVal);
    }
    xmlFree.expect("non-null function pointer")(use_0 as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeAttributeUseProhib(
    mut prohib: xmlSchemaAttributeUseProhibPtr,
) {
    if prohib.is_null() {
        return;
    }
    xmlFree.expect("non-null function pointer")(prohib as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeWildcardNsSet(mut set: xmlSchemaWildcardNsPtr) {
    let mut next: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    while !set.is_null() {
        next = (*set).next;
        xmlFree.expect("non-null function pointer")(set as *mut libc::c_void);
        set = next;
    }
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFreeWildcard(mut wildcard: xmlSchemaWildcardPtr) {
    if wildcard.is_null() {
        return;
    }
    if !((*wildcard).annot).is_null() {
        xmlSchemaFreeAnnot((*wildcard).annot);
    }
    if !((*wildcard).nsSet).is_null() {
        xmlSchemaFreeWildcardNsSet((*wildcard).nsSet);
    }
    if !((*wildcard).negNsSet).is_null() {
        xmlFree
            .expect(
                "non-null function pointer",
            )((*wildcard).negNsSet as *mut libc::c_void);
    }
    xmlFree.expect("non-null function pointer")(wildcard as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeAttributeGroup(
    mut attrGr: xmlSchemaAttributeGroupPtr,
) {
    if attrGr.is_null() {
        return;
    }
    if !((*attrGr).annot).is_null() {
        xmlSchemaFreeAnnot((*attrGr).annot);
    }
    if !((*attrGr).attrUses).is_null() {
        xmlSchemaItemListFree((*attrGr).attrUses as xmlSchemaItemListPtr);
    }
    xmlFree.expect("non-null function pointer")(attrGr as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeQNameRef(mut item: xmlSchemaQNameRefPtr) {
    xmlFree.expect("non-null function pointer")(item as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeTypeLinkList(mut link: xmlSchemaTypeLinkPtr) {
    let mut next: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    while !link.is_null() {
        next = (*link).next;
        xmlFree.expect("non-null function pointer")(link as *mut libc::c_void);
        link = next;
    }
}
unsafe extern "C" fn xmlSchemaFreeIDCStateObjList(mut sto: xmlSchemaIDCStateObjPtr) {
    let mut next: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    while !sto.is_null() {
        next = (*sto).next;
        if !((*sto).history).is_null() {
            xmlFree
                .expect(
                    "non-null function pointer",
                )((*sto).history as *mut libc::c_void);
        }
        if !((*sto).xpathCtxt).is_null() {
            xmlFreeStreamCtxt((*sto).xpathCtxt as xmlStreamCtxtPtr);
        }
        xmlFree.expect("non-null function pointer")(sto as *mut libc::c_void);
        sto = next;
    }
}
unsafe extern "C" fn xmlSchemaFreeIDC(mut idcDef: xmlSchemaIDCPtr) {
    let mut cur: xmlSchemaIDCSelectPtr = 0 as *mut xmlSchemaIDCSelect;
    let mut prev: xmlSchemaIDCSelectPtr = 0 as *mut xmlSchemaIDCSelect;
    if idcDef.is_null() {
        return;
    }
    if !((*idcDef).annot).is_null() {
        xmlSchemaFreeAnnot((*idcDef).annot);
    }
    if !((*idcDef).selector).is_null() {
        if !((*(*idcDef).selector).xpathComp).is_null() {
            xmlFreePattern((*(*idcDef).selector).xpathComp as xmlPatternPtr);
        }
        xmlFree
            .expect(
                "non-null function pointer",
            )((*idcDef).selector as *mut libc::c_void);
    }
    if !((*idcDef).fields).is_null() {
        cur = (*idcDef).fields;
        loop {
            prev = cur;
            cur = (*cur).next;
            if !((*prev).xpathComp).is_null() {
                xmlFreePattern((*prev).xpathComp as xmlPatternPtr);
            }
            xmlFree.expect("non-null function pointer")(prev as *mut libc::c_void);
            if cur.is_null() {
                break;
            }
        }
    }
    xmlFree.expect("non-null function pointer")(idcDef as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeElement(mut elem: xmlSchemaElementPtr) {
    if elem.is_null() {
        return;
    }
    if !((*elem).annot).is_null() {
        xmlSchemaFreeAnnot((*elem).annot);
    }
    if !((*elem).contModel).is_null() {
        xmlRegFreeRegexp((*elem).contModel);
    }
    if !((*elem).defVal).is_null() {
        xmlSchemaFreeValue((*elem).defVal);
    }
    xmlFree.expect("non-null function pointer")(elem as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFreeFacet(mut facet: xmlSchemaFacetPtr) {
    if facet.is_null() {
        return;
    }
    if !((*facet).val).is_null() {
        xmlSchemaFreeValue((*facet).val);
    }
    if !((*facet).regexp).is_null() {
        xmlRegFreeRegexp((*facet).regexp);
    }
    if !((*facet).annot).is_null() {
        xmlSchemaFreeAnnot((*facet).annot);
    }
    xmlFree.expect("non-null function pointer")(facet as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFreeType(mut type_0: xmlSchemaTypePtr) {
    if type_0.is_null() {
        return;
    }
    if !((*type_0).annot).is_null() {
        xmlSchemaFreeAnnot((*type_0).annot);
    }
    if !((*type_0).facets).is_null() {
        let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
        let mut next: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
        facet = (*type_0).facets;
        while !facet.is_null() {
            next = (*facet).next;
            xmlSchemaFreeFacet(facet);
            facet = next;
        }
    }
    if !((*type_0).attrUses).is_null() {
        xmlSchemaItemListFree((*type_0).attrUses as xmlSchemaItemListPtr);
    }
    if !((*type_0).memberTypes).is_null() {
        xmlSchemaFreeTypeLinkList((*type_0).memberTypes);
    }
    if !((*type_0).facetSet).is_null() {
        let mut next_0: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
        let mut link: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
        link = (*type_0).facetSet;
        loop {
            next_0 = (*link).next;
            xmlFree.expect("non-null function pointer")(link as *mut libc::c_void);
            link = next_0;
            if link.is_null() {
                break;
            }
        }
    }
    if !((*type_0).contModel).is_null() {
        xmlRegFreeRegexp((*type_0).contModel);
    }
    xmlFree.expect("non-null function pointer")(type_0 as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeModelGroupDef(mut item: xmlSchemaModelGroupDefPtr) {
    if !((*item).annot).is_null() {
        xmlSchemaFreeAnnot((*item).annot);
    }
    xmlFree.expect("non-null function pointer")(item as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeModelGroup(mut item: xmlSchemaModelGroupPtr) {
    if !((*item).annot).is_null() {
        xmlSchemaFreeAnnot((*item).annot);
    }
    xmlFree.expect("non-null function pointer")(item as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaComponentListFree(mut list: xmlSchemaItemListPtr) {
    if list.is_null() || (*list).nbItems == 0 as libc::c_int {
        return;
    }
    let mut item: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
    let mut items: *mut xmlSchemaTreeItemPtr = (*list).items
        as *mut xmlSchemaTreeItemPtr;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (*list).nbItems {
        item = *items.offset(i as isize);
        if !item.is_null() {
            match (*item).type_0 as libc::c_uint {
                4 | 5 => {
                    xmlSchemaFreeType(item as xmlSchemaTypePtr);
                }
                15 => {
                    xmlSchemaFreeAttribute(item as xmlSchemaAttributePtr);
                }
                26 => {
                    xmlSchemaFreeAttributeUse(item as xmlSchemaAttributeUsePtr);
                }
                2001 => {
                    xmlSchemaFreeAttributeUseProhib(
                        item as xmlSchemaAttributeUseProhibPtr,
                    );
                }
                14 => {
                    xmlSchemaFreeElement(item as xmlSchemaElementPtr);
                }
                25 => {
                    if !((*item).annot).is_null() {
                        xmlSchemaFreeAnnot((*item).annot);
                    }
                    xmlFree
                        .expect("non-null function pointer")(item as *mut libc::c_void);
                }
                6 | 7 | 8 => {
                    xmlSchemaFreeModelGroup(item as xmlSchemaModelGroupPtr);
                }
                16 => {
                    xmlSchemaFreeAttributeGroup(item as xmlSchemaAttributeGroupPtr);
                }
                17 => {
                    xmlSchemaFreeModelGroupDef(item as xmlSchemaModelGroupDefPtr);
                }
                2 | 21 => {
                    xmlSchemaFreeWildcard(item as xmlSchemaWildcardPtr);
                }
                23 | 22 | 24 => {
                    xmlSchemaFreeIDC(item as xmlSchemaIDCPtr);
                }
                18 => {
                    xmlSchemaFreeNotation(item as xmlSchemaNotationPtr);
                }
                2000 => {
                    xmlSchemaFreeQNameRef(item as xmlSchemaQNameRefPtr);
                }
                _ => {
                    xmlSchemaPSimpleInternalErr(
                        0 as xmlNodePtr,
                        b"Internal error: xmlSchemaComponentListFree, unexpected component type '%s'\n\0"
                            as *const u8 as *const libc::c_char,
                        xmlSchemaGetComponentTypeStr(item as xmlSchemaBasicItemPtr),
                    );
                }
            }
        }
        i += 1;
    }
    (*list).nbItems = 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFree(mut schema: xmlSchemaPtr) {
    if schema.is_null() {
        return;
    }
    if !((*schema).volatiles).is_null() {
        (*__xmlGenericError())
            .expect(
                "non-null function pointer",
            )(
            *__xmlGenericErrorContext(),
            b"Unimplemented block at %s:%d\n\0" as *const u8 as *const libc::c_char,
            b"xmlschemas.c\0" as *const u8 as *const libc::c_char,
            4191 as libc::c_int,
        );
    }
    if !((*schema).notaDecl).is_null() {
        xmlHashFree((*schema).notaDecl, None);
    }
    if !((*schema).attrDecl).is_null() {
        xmlHashFree((*schema).attrDecl, None);
    }
    if !((*schema).attrgrpDecl).is_null() {
        xmlHashFree((*schema).attrgrpDecl, None);
    }
    if !((*schema).elemDecl).is_null() {
        xmlHashFree((*schema).elemDecl, None);
    }
    if !((*schema).typeDecl).is_null() {
        xmlHashFree((*schema).typeDecl, None);
    }
    if !((*schema).groupDecl).is_null() {
        xmlHashFree((*schema).groupDecl, None);
    }
    if !((*schema).idcDef).is_null() {
        xmlHashFree((*schema).idcDef, None);
    }
    if !((*schema).schemasImports).is_null() {
        xmlHashFree(
            (*schema).schemasImports,
            Some(
                xmlSchemaBucketFreeEntry
                    as unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
            ),
        );
    }
    if !((*schema).includes).is_null() {
        let mut list: xmlSchemaItemListPtr = (*schema).includes as xmlSchemaItemListPtr;
        let mut i: libc::c_int = 0;
        i = 0 as libc::c_int;
        while i < (*list).nbItems {
            xmlSchemaBucketFree(
                *((*list).items).offset(i as isize) as xmlSchemaBucketPtr,
            );
            i += 1;
        }
        xmlSchemaItemListFree(list);
    }
    if !((*schema).annot).is_null() {
        xmlSchemaFreeAnnot((*schema).annot);
    }
    xmlDictFree((*schema).dict);
    xmlFree.expect("non-null function pointer")(schema as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaElementDump(
    mut payload: *mut libc::c_void,
    mut data: *mut libc::c_void,
    mut name: *const xmlChar,
    mut namespace: *const xmlChar,
    mut context: *const xmlChar,
) {
    let mut elem: xmlSchemaElementPtr = payload as xmlSchemaElementPtr;
    let mut output: *mut FILE = data as *mut FILE;
    if elem.is_null() {
        return;
    }
    fprintf(output, b"Element\0" as *const u8 as *const libc::c_char);
    if (*elem).flags & (1 as libc::c_int) << 1 as libc::c_int != 0 {
        fprintf(output, b" (global)\0" as *const u8 as *const libc::c_char);
    }
    fprintf(output, b": '%s' \0" as *const u8 as *const libc::c_char, (*elem).name);
    if !namespace.is_null() {
        fprintf(output, b"ns '%s'\0" as *const u8 as *const libc::c_char, namespace);
    }
    fprintf(output, b"\n\0" as *const u8 as *const libc::c_char);
    if (*elem).flags & (1 as libc::c_int) << 0 as libc::c_int != 0
        || (*elem).flags & (1 as libc::c_int) << 4 as libc::c_int != 0
        || (*elem).flags & (1 as libc::c_int) << 3 as libc::c_int != 0
        || (*elem).flags & (1 as libc::c_int) << 2 as libc::c_int != 0
    {
        fprintf(output, b"  props: \0" as *const u8 as *const libc::c_char);
        if (*elem).flags & (1 as libc::c_int) << 3 as libc::c_int != 0 {
            fprintf(output, b"[fixed] \0" as *const u8 as *const libc::c_char);
        }
        if (*elem).flags & (1 as libc::c_int) << 2 as libc::c_int != 0 {
            fprintf(output, b"[default] \0" as *const u8 as *const libc::c_char);
        }
        if (*elem).flags & (1 as libc::c_int) << 4 as libc::c_int != 0 {
            fprintf(output, b"[abstract] \0" as *const u8 as *const libc::c_char);
        }
        if (*elem).flags & (1 as libc::c_int) << 0 as libc::c_int != 0 {
            fprintf(output, b"[nillable] \0" as *const u8 as *const libc::c_char);
        }
        fprintf(output, b"\n\0" as *const u8 as *const libc::c_char);
    }
    if !((*elem).value).is_null() {
        fprintf(
            output,
            b"  value: '%s'\n\0" as *const u8 as *const libc::c_char,
            (*elem).value,
        );
    }
    if !((*elem).namedType).is_null() {
        fprintf(
            output,
            b"  type: '%s' \0" as *const u8 as *const libc::c_char,
            (*elem).namedType,
        );
        if !((*elem).namedTypeNs).is_null() {
            fprintf(
                output,
                b"ns '%s'\n\0" as *const u8 as *const libc::c_char,
                (*elem).namedTypeNs,
            );
        } else {
            fprintf(output, b"\n\0" as *const u8 as *const libc::c_char);
        }
    } else if !((*elem).subtypes).is_null() {
        xmlSchemaTypeDump((*elem).subtypes, output);
    }
    if !((*elem).substGroup).is_null() {
        fprintf(
            output,
            b"  substitutionGroup: '%s' \0" as *const u8 as *const libc::c_char,
            (*elem).substGroup,
        );
        if !((*elem).substGroupNs).is_null() {
            fprintf(
                output,
                b"ns '%s'\n\0" as *const u8 as *const libc::c_char,
                (*elem).substGroupNs,
            );
        } else {
            fprintf(output, b"\n\0" as *const u8 as *const libc::c_char);
        }
    }
}
unsafe extern "C" fn xmlSchemaAnnotDump(
    mut output: *mut FILE,
    mut annot: xmlSchemaAnnotPtr,
) {
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if annot.is_null() {
        return;
    }
    content = xmlNodeGetContent((*annot).content as *const xmlNode);
    if !content.is_null() {
        fprintf(output, b"  Annot: %s\n\0" as *const u8 as *const libc::c_char, content);
        xmlFree.expect("non-null function pointer")(content as *mut libc::c_void);
    } else {
        fprintf(output, b"  Annot: empty\n\0" as *const u8 as *const libc::c_char);
    };
}
unsafe extern "C" fn xmlSchemaContentModelDump(
    mut particle: xmlSchemaParticlePtr,
    mut output: *mut FILE,
    mut depth: libc::c_int,
) {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut term: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
    let mut shift: [libc::c_char; 100] = [0; 100];
    let mut i: libc::c_int = 0;
    if particle.is_null() {
        return;
    }
    i = 0 as libc::c_int;
    while i < depth && i < 25 as libc::c_int {
        shift[(2 as libc::c_int * i + 1 as libc::c_int)
            as usize] = ' ' as i32 as libc::c_char;
        shift[(2 as libc::c_int * i)
            as usize] = shift[(2 as libc::c_int * i + 1 as libc::c_int) as usize];
        i += 1;
    }
    shift[(2 as libc::c_int * i + 1 as libc::c_int)
        as usize] = 0 as libc::c_int as libc::c_char;
    shift[(2 as libc::c_int * i)
        as usize] = shift[(2 as libc::c_int * i + 1 as libc::c_int) as usize];
    fprintf(output, b"%s\0" as *const u8 as *const libc::c_char, shift.as_mut_ptr());
    if ((*particle).children).is_null() {
        fprintf(
            output,
            b"MISSING particle term\n\0" as *const u8 as *const libc::c_char,
        );
        return;
    }
    term = (*particle).children;
    if term.is_null() {
        fprintf(output, b"(NULL)\0" as *const u8 as *const libc::c_char);
    } else {
        match (*term).type_0 as libc::c_uint {
            14 => {
                fprintf(
                    output,
                    b"ELEM '%s'\0" as *const u8 as *const libc::c_char,
                    xmlSchemaFormatQName(
                        &mut str,
                        (*(term as xmlSchemaElementPtr)).targetNamespace,
                        (*(term as xmlSchemaElementPtr)).name,
                    ),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
            }
            6 => {
                fprintf(output, b"SEQUENCE\0" as *const u8 as *const libc::c_char);
            }
            7 => {
                fprintf(output, b"CHOICE\0" as *const u8 as *const libc::c_char);
            }
            8 => {
                fprintf(output, b"ALL\0" as *const u8 as *const libc::c_char);
            }
            2 => {
                fprintf(output, b"ANY\0" as *const u8 as *const libc::c_char);
            }
            _ => {
                fprintf(output, b"UNKNOWN\n\0" as *const u8 as *const libc::c_char);
                return;
            }
        }
    }
    if (*particle).minOccurs != 1 as libc::c_int {
        fprintf(
            output,
            b" min: %d\0" as *const u8 as *const libc::c_char,
            (*particle).minOccurs,
        );
    }
    if (*particle).maxOccurs >= (1 as libc::c_int) << 30 as libc::c_int {
        fprintf(output, b" max: unbounded\0" as *const u8 as *const libc::c_char);
    } else if (*particle).maxOccurs != 1 as libc::c_int {
        fprintf(
            output,
            b" max: %d\0" as *const u8 as *const libc::c_char,
            (*particle).maxOccurs,
        );
    }
    fprintf(output, b"\n\0" as *const u8 as *const libc::c_char);
    if !term.is_null()
        && ((*term).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_SEQUENCE as libc::c_int as libc::c_uint
            || (*term).type_0 as libc::c_uint
                == XML_SCHEMA_TYPE_CHOICE as libc::c_int as libc::c_uint
            || (*term).type_0 as libc::c_uint
                == XML_SCHEMA_TYPE_ALL as libc::c_int as libc::c_uint)
        && !((*term).children).is_null()
    {
        xmlSchemaContentModelDump(
            (*term).children as xmlSchemaParticlePtr,
            output,
            depth + 1 as libc::c_int,
        );
    }
    if !((*particle).next).is_null() {
        xmlSchemaContentModelDump(
            (*particle).next as xmlSchemaParticlePtr,
            output,
            depth,
        );
    }
}
unsafe extern "C" fn xmlSchemaAttrUsesDump(
    mut uses: xmlSchemaItemListPtr,
    mut output: *mut FILE,
) {
    let mut use_0: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
    let mut prohib: xmlSchemaAttributeUseProhibPtr = 0
        as *mut xmlSchemaAttributeUseProhib;
    let mut ref_0: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut tns: *const xmlChar = 0 as *const xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut i: libc::c_int = 0;
    if uses.is_null() || (*uses).nbItems == 0 as libc::c_int {
        return;
    }
    fprintf(output, b"  attributes:\n\0" as *const u8 as *const libc::c_char);
    i = 0 as libc::c_int;
    while i < (*uses).nbItems {
        use_0 = *((*uses).items).offset(i as isize) as xmlSchemaAttributeUsePtr;
        if (*use_0).type_0 as libc::c_uint
            == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB as libc::c_int as libc::c_uint
        {
            fprintf(output, b"  [prohibition] \0" as *const u8 as *const libc::c_char);
            prohib = use_0 as xmlSchemaAttributeUseProhibPtr;
            name = (*prohib).name;
            tns = (*prohib).targetNamespace;
        } else if (*use_0).type_0 as libc::c_uint
                == XML_SCHEMA_EXTRA_QNAMEREF as libc::c_int as libc::c_uint
            {
            fprintf(output, b"  [reference] \0" as *const u8 as *const libc::c_char);
            ref_0 = use_0 as xmlSchemaQNameRefPtr;
            name = (*ref_0).name;
            tns = (*ref_0).targetNamespace;
        } else {
            fprintf(output, b"  [use] \0" as *const u8 as *const libc::c_char);
            name = (*(*use_0).attrDecl).name;
            tns = (*(*use_0).attrDecl).targetNamespace;
        }
        fprintf(
            output,
            b"'%s'\n\0" as *const u8 as *const libc::c_char,
            xmlSchemaFormatQName(&mut str, tns, name) as *const libc::c_char,
        );
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
        i += 1;
    }
}
unsafe extern "C" fn xmlSchemaTypeDump(
    mut type_0: xmlSchemaTypePtr,
    mut output: *mut FILE,
) {
    if type_0.is_null() {
        fprintf(output, b"Type: NULL\n\0" as *const u8 as *const libc::c_char);
        return;
    }
    fprintf(output, b"Type: \0" as *const u8 as *const libc::c_char);
    if !((*type_0).name).is_null() {
        fprintf(output, b"'%s' \0" as *const u8 as *const libc::c_char, (*type_0).name);
    } else {
        fprintf(output, b"(no name) \0" as *const u8 as *const libc::c_char);
    }
    if !((*type_0).targetNamespace).is_null() {
        fprintf(
            output,
            b"ns '%s' \0" as *const u8 as *const libc::c_char,
            (*type_0).targetNamespace,
        );
    }
    match (*type_0).type_0 as libc::c_uint {
        1 => {
            fprintf(output, b"[basic] \0" as *const u8 as *const libc::c_char);
        }
        4 => {
            fprintf(output, b"[simple] \0" as *const u8 as *const libc::c_char);
        }
        5 => {
            fprintf(output, b"[complex] \0" as *const u8 as *const libc::c_char);
        }
        6 => {
            fprintf(output, b"[sequence] \0" as *const u8 as *const libc::c_char);
        }
        7 => {
            fprintf(output, b"[choice] \0" as *const u8 as *const libc::c_char);
        }
        8 => {
            fprintf(output, b"[all] \0" as *const u8 as *const libc::c_char);
        }
        11 => {
            fprintf(output, b"[ur] \0" as *const u8 as *const libc::c_char);
        }
        12 => {
            fprintf(output, b"[restriction] \0" as *const u8 as *const libc::c_char);
        }
        13 => {
            fprintf(output, b"[extension] \0" as *const u8 as *const libc::c_char);
        }
        _ => {
            fprintf(
                output,
                b"[unknown type %d] \0" as *const u8 as *const libc::c_char,
                (*type_0).type_0 as libc::c_uint,
            );
        }
    }
    fprintf(output, b"content: \0" as *const u8 as *const libc::c_char);
    match (*type_0).contentType as libc::c_uint {
        0 => {
            fprintf(output, b"[unknown] \0" as *const u8 as *const libc::c_char);
        }
        1 => {
            fprintf(output, b"[empty] \0" as *const u8 as *const libc::c_char);
        }
        2 => {
            fprintf(output, b"[element] \0" as *const u8 as *const libc::c_char);
        }
        3 => {
            fprintf(output, b"[mixed] \0" as *const u8 as *const libc::c_char);
        }
        6 => {
            fprintf(output, b"[basic] \0" as *const u8 as *const libc::c_char);
        }
        4 => {
            fprintf(output, b"[simple] \0" as *const u8 as *const libc::c_char);
        }
        7 => {
            fprintf(output, b"[any] \0" as *const u8 as *const libc::c_char);
        }
        5 | _ => {}
    }
    fprintf(output, b"\n\0" as *const u8 as *const libc::c_char);
    if !((*type_0).base).is_null() {
        fprintf(
            output,
            b"  base type: '%s'\0" as *const u8 as *const libc::c_char,
            (*type_0).base,
        );
        if !((*type_0).baseNs).is_null() {
            fprintf(
                output,
                b" ns '%s'\n\0" as *const u8 as *const libc::c_char,
                (*type_0).baseNs,
            );
        } else {
            fprintf(output, b"\n\0" as *const u8 as *const libc::c_char);
        }
    }
    if !((*type_0).attrUses).is_null() {
        xmlSchemaAttrUsesDump((*type_0).attrUses as xmlSchemaItemListPtr, output);
    }
    if !((*type_0).annot).is_null() {
        xmlSchemaAnnotDump(output, (*type_0).annot);
    }
    if (*type_0).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
        && !((*type_0).subtypes).is_null()
    {
        xmlSchemaContentModelDump(
            (*type_0).subtypes as xmlSchemaParticlePtr,
            output,
            1 as libc::c_int,
        );
    }
}
unsafe extern "C" fn xmlSchemaTypeDumpEntry(
    mut type_0: *mut libc::c_void,
    mut output: *mut libc::c_void,
    mut name: *const xmlChar,
) {
    xmlSchemaTypeDump(type_0 as xmlSchemaTypePtr, output as *mut FILE);
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaDump(mut output: *mut FILE, mut schema: xmlSchemaPtr) {
    if output.is_null() {
        return;
    }
    if schema.is_null() {
        fprintf(output, b"Schemas: NULL\n\0" as *const u8 as *const libc::c_char);
        return;
    }
    fprintf(output, b"Schemas: \0" as *const u8 as *const libc::c_char);
    if !((*schema).name).is_null() {
        fprintf(output, b"%s, \0" as *const u8 as *const libc::c_char, (*schema).name);
    } else {
        fprintf(output, b"no name, \0" as *const u8 as *const libc::c_char);
    }
    if !((*schema).targetNamespace).is_null() {
        fprintf(
            output,
            b"%s\0" as *const u8 as *const libc::c_char,
            (*schema).targetNamespace as *const libc::c_char,
        );
    } else {
        fprintf(output, b"no target namespace\0" as *const u8 as *const libc::c_char);
    }
    fprintf(output, b"\n\0" as *const u8 as *const libc::c_char);
    if !((*schema).annot).is_null() {
        xmlSchemaAnnotDump(output, (*schema).annot);
    }
    xmlHashScan(
        (*schema).typeDecl,
        Some(
            xmlSchemaTypeDumpEntry
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *mut libc::c_void,
                    *const xmlChar,
                ) -> (),
        ),
        output as *mut libc::c_void,
    );
    xmlHashScanFull(
        (*schema).elemDecl,
        Some(
            xmlSchemaElementDump
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *mut libc::c_void,
                    *const xmlChar,
                    *const xmlChar,
                    *const xmlChar,
                ) -> (),
        ),
        output as *mut libc::c_void,
    );
}
unsafe extern "C" fn xmlSchemaGetPropNode(
    mut node: xmlNodePtr,
    mut name: *const libc::c_char,
) -> xmlAttrPtr {
    let mut prop: xmlAttrPtr = 0 as *mut xmlAttr;
    if node.is_null() || name.is_null() {
        return 0 as xmlAttrPtr;
    }
    prop = (*node).properties;
    while !prop.is_null() {
        if ((*prop).ns).is_null() && xmlStrEqual((*prop).name, name as *mut xmlChar) != 0
        {
            return prop;
        }
        prop = (*prop).next;
    }
    return 0 as xmlAttrPtr;
}
unsafe extern "C" fn xmlSchemaGetPropNodeNs(
    mut node: xmlNodePtr,
    mut uri: *const libc::c_char,
    mut name: *const libc::c_char,
) -> xmlAttrPtr {
    let mut prop: xmlAttrPtr = 0 as *mut xmlAttr;
    if node.is_null() || name.is_null() {
        return 0 as xmlAttrPtr;
    }
    prop = (*node).properties;
    while !prop.is_null() {
        if !((*prop).ns).is_null()
            && xmlStrEqual((*prop).name, name as *mut xmlChar) != 0
            && xmlStrEqual((*(*prop).ns).href, uri as *mut xmlChar) != 0
        {
            return prop;
        }
        prop = (*prop).next;
    }
    return 0 as xmlAttrPtr;
}
unsafe extern "C" fn xmlSchemaGetNodeContent(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
) -> *const xmlChar {
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    val = xmlNodeGetContent(node as *const xmlNode);
    if val.is_null() {
        val = xmlStrdup(b"\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    }
    ret = xmlDictLookup((*ctxt).dict, val, -(1 as libc::c_int));
    xmlFree.expect("non-null function pointer")(val as *mut libc::c_void);
    return ret;
}
unsafe extern "C" fn xmlSchemaGetNodeContentNoDict(
    mut node: xmlNodePtr,
) -> *const xmlChar {
    return xmlNodeGetContent(node as *const xmlNode) as *const xmlChar;
}
unsafe extern "C" fn xmlSchemaGetProp(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut name: *const libc::c_char,
) -> *const xmlChar {
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    val = xmlGetNoNsProp(node as *const xmlNode, name as *mut xmlChar);
    if val.is_null() {
        return 0 as *const xmlChar;
    }
    ret = xmlDictLookup((*ctxt).dict, val, -(1 as libc::c_int));
    xmlFree.expect("non-null function pointer")(val as *mut libc::c_void);
    return ret;
}
unsafe extern "C" fn xmlSchemaGetElem(
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
) -> xmlSchemaElementPtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaElementPtr = 0 as xmlSchemaElementPtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaElementPtr;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret = xmlHashLookup((*schema).elemDecl, name) as xmlSchemaElementPtr;
            if !ret.is_null() {
                current_block = 16011728522843784008;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            16011728522843784008 => {}
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as libc::c_int {
                    let mut import: xmlSchemaImportPtr = 0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import = xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const libc::c_char as *const xmlChar,
                        ) as xmlSchemaImportPtr;
                    } else {
                        import = xmlHashLookup((*schema).schemasImports, nsName)
                            as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = xmlHashLookup((*(*import).schema).elemDecl, name)
                            as xmlSchemaElementPtr;
                    }
                }
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaGetType(
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
) -> xmlSchemaTypePtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
    if name.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    if !nsName.is_null() && xmlStrEqual(nsName, xmlSchemaNs) != 0 {
        ret = xmlSchemaGetPredefinedType(name, nsName);
        if !ret.is_null() {
            current_block = 7386887182042359627;
        } else {
            current_block = 15427931788582360902;
        }
    } else {
        current_block = 15427931788582360902;
    }
    match current_block {
        15427931788582360902 => {
            if !schema.is_null() {
                if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
                    ret = xmlHashLookup((*schema).typeDecl, name) as xmlSchemaTypePtr;
                    if !ret.is_null() {
                        current_block = 7386887182042359627;
                    } else {
                        current_block = 11812396948646013369;
                    }
                } else {
                    current_block = 11812396948646013369;
                }
                match current_block {
                    7386887182042359627 => {}
                    _ => {
                        if xmlHashSize((*schema).schemasImports) > 1 as libc::c_int {
                            let mut import: xmlSchemaImportPtr = 0
                                as *mut xmlSchemaImport;
                            if nsName.is_null() {
                                import = xmlHashLookup(
                                    (*schema).schemasImports,
                                    b"##\0" as *const u8 as *const libc::c_char
                                        as *const xmlChar,
                                ) as xmlSchemaImportPtr;
                            } else {
                                import = xmlHashLookup((*schema).schemasImports, nsName)
                                    as xmlSchemaImportPtr;
                            }
                            if !import.is_null() {
                                ret = xmlHashLookup((*(*import).schema).typeDecl, name)
                                    as xmlSchemaTypePtr;
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaGetAttributeDecl(
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
) -> xmlSchemaAttributePtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaAttributePtr = 0 as xmlSchemaAttributePtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaAttributePtr;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret = xmlHashLookup((*schema).attrDecl, name) as xmlSchemaAttributePtr;
            if !ret.is_null() {
                current_block = 16794065014550217599;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            16794065014550217599 => {}
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as libc::c_int {
                    let mut import: xmlSchemaImportPtr = 0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import = xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const libc::c_char as *const xmlChar,
                        ) as xmlSchemaImportPtr;
                    } else {
                        import = xmlHashLookup((*schema).schemasImports, nsName)
                            as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = xmlHashLookup((*(*import).schema).attrDecl, name)
                            as xmlSchemaAttributePtr;
                    }
                }
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaGetAttributeGroup(
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
) -> xmlSchemaAttributeGroupPtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaAttributeGroupPtr = 0 as xmlSchemaAttributeGroupPtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret = xmlHashLookup((*schema).attrgrpDecl, name)
                as xmlSchemaAttributeGroupPtr;
            if !ret.is_null() {
                current_block = 16237746940514357066;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            16237746940514357066 => {}
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as libc::c_int {
                    let mut import: xmlSchemaImportPtr = 0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import = xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const libc::c_char as *const xmlChar,
                        ) as xmlSchemaImportPtr;
                    } else {
                        import = xmlHashLookup((*schema).schemasImports, nsName)
                            as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = xmlHashLookup((*(*import).schema).attrgrpDecl, name)
                            as xmlSchemaAttributeGroupPtr;
                    }
                }
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaGetGroup(
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
) -> xmlSchemaModelGroupDefPtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaModelGroupDefPtr = 0 as xmlSchemaModelGroupDefPtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaModelGroupDefPtr;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret = xmlHashLookup((*schema).groupDecl, name) as xmlSchemaModelGroupDefPtr;
            if !ret.is_null() {
                current_block = 13643637003490791894;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            13643637003490791894 => {}
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as libc::c_int {
                    let mut import: xmlSchemaImportPtr = 0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import = xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const libc::c_char as *const xmlChar,
                        ) as xmlSchemaImportPtr;
                    } else {
                        import = xmlHashLookup((*schema).schemasImports, nsName)
                            as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = xmlHashLookup((*(*import).schema).groupDecl, name)
                            as xmlSchemaModelGroupDefPtr;
                    }
                }
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaGetNotation(
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
) -> xmlSchemaNotationPtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaNotationPtr = 0 as xmlSchemaNotationPtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaNotationPtr;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret = xmlHashLookup((*schema).notaDecl, name) as xmlSchemaNotationPtr;
            if !ret.is_null() {
                current_block = 16231198170495011546;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            16231198170495011546 => {}
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as libc::c_int {
                    let mut import: xmlSchemaImportPtr = 0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import = xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const libc::c_char as *const xmlChar,
                        ) as xmlSchemaImportPtr;
                    } else {
                        import = xmlHashLookup((*schema).schemasImports, nsName)
                            as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = xmlHashLookup((*(*import).schema).notaDecl, name)
                            as xmlSchemaNotationPtr;
                    }
                }
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaGetIDC(
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
) -> xmlSchemaIDCPtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaIDCPtr = 0 as xmlSchemaIDCPtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaIDCPtr;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret = xmlHashLookup((*schema).idcDef, name) as xmlSchemaIDCPtr;
            if !ret.is_null() {
                current_block = 6863404656786974296;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            6863404656786974296 => {}
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as libc::c_int {
                    let mut import: xmlSchemaImportPtr = 0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import = xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const libc::c_char as *const xmlChar,
                        ) as xmlSchemaImportPtr;
                    } else {
                        import = xmlHashLookup((*schema).schemasImports, nsName)
                            as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = xmlHashLookup((*(*import).schema).idcDef, name)
                            as xmlSchemaIDCPtr;
                    }
                }
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaGetNamedComponent(
    mut schema: xmlSchemaPtr,
    mut itemType: xmlSchemaTypeType,
    mut name: *const xmlChar,
    mut targetNs: *const xmlChar,
) -> xmlSchemaBasicItemPtr {
    match itemType as libc::c_uint {
        17 => return xmlSchemaGetGroup(schema, name, targetNs) as xmlSchemaBasicItemPtr,
        14 => return xmlSchemaGetElem(schema, name, targetNs) as xmlSchemaBasicItemPtr,
        _ => {
            (*__xmlGenericError())
                .expect(
                    "non-null function pointer",
                )(
                *__xmlGenericErrorContext(),
                b"Unimplemented block at %s:%d\n\0" as *const u8 as *const libc::c_char,
                b"xmlschemas.c\0" as *const u8 as *const libc::c_char,
                5063 as libc::c_int,
            );
            return 0 as xmlSchemaBasicItemPtr;
        }
    };
}
unsafe extern "C" fn xmlSchemaIsBlank(
    mut str: *mut xmlChar,
    mut len: libc::c_int,
) -> libc::c_int {
    if str.is_null() {
        return 1 as libc::c_int;
    }
    if len < 0 as libc::c_int {
        while *str as libc::c_int != 0 as libc::c_int {
            if !(*str as libc::c_int == 0x20 as libc::c_int
                || 0x9 as libc::c_int <= *str as libc::c_int
                    && *str as libc::c_int <= 0xa as libc::c_int
                || *str as libc::c_int == 0xd as libc::c_int)
            {
                return 0 as libc::c_int;
            }
            str = str.offset(1);
        }
    } else {
        while *str as libc::c_int != 0 as libc::c_int && len != 0 as libc::c_int {
            if !(*str as libc::c_int == 0x20 as libc::c_int
                || 0x9 as libc::c_int <= *str as libc::c_int
                    && *str as libc::c_int <= 0xa as libc::c_int
                || *str as libc::c_int == 0xd as libc::c_int)
            {
                return 0 as libc::c_int;
            }
            str = str.offset(1);
            len -= 1;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaFindRedefCompInGraph(
    mut bucket: xmlSchemaBucketPtr,
    mut type_0: xmlSchemaTypeType,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
) -> xmlSchemaBasicItemPtr {
    let mut ret: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    let mut i: libc::c_int = 0;
    if bucket.is_null() || name.is_null() {
        return 0 as xmlSchemaBasicItemPtr;
    }
    if !(((*bucket).globals).is_null()
        || (*(*bucket).globals).nbItems == 0 as libc::c_int)
    {
        i = 0 as libc::c_int;
        while i < (*(*bucket).globals).nbItems {
            ret = *((*(*bucket).globals).items).offset(i as isize)
                as xmlSchemaBasicItemPtr;
            if (*ret).type_0 as libc::c_uint == type_0 as libc::c_uint {
                match type_0 as libc::c_uint {
                    5 | 4 => {
                        if (*(ret as xmlSchemaTypePtr)).name == name
                            && (*(ret as xmlSchemaTypePtr)).targetNamespace == nsName
                        {
                            return ret;
                        }
                    }
                    17 => {
                        if (*(ret as xmlSchemaModelGroupDefPtr)).name == name
                            && (*(ret as xmlSchemaModelGroupDefPtr)).targetNamespace
                                == nsName
                        {
                            return ret;
                        }
                    }
                    16 => {
                        if (*(ret as xmlSchemaAttributeGroupPtr)).name == name
                            && (*(ret as xmlSchemaAttributeGroupPtr)).targetNamespace
                                == nsName
                        {
                            return ret;
                        }
                    }
                    _ => return 0 as xmlSchemaBasicItemPtr,
                }
            }
            i += 1;
        }
    }
    if !((*bucket).relations).is_null() {
        let mut rel: xmlSchemaSchemaRelationPtr = (*bucket).relations;
        (*bucket).flags |= (1 as libc::c_int) << 0 as libc::c_int;
        loop {
            if !((*rel).bucket).is_null()
                && (*(*rel).bucket).flags & (1 as libc::c_int) << 0 as libc::c_int
                    == 0 as libc::c_int
            {
                ret = xmlSchemaFindRedefCompInGraph((*rel).bucket, type_0, name, nsName);
                if !ret.is_null() {
                    return ret;
                }
            }
            rel = (*rel).next;
            if rel.is_null() {
                break;
            }
        }
        (*bucket).flags ^= (1 as libc::c_int) << 0 as libc::c_int;
    }
    return 0 as xmlSchemaBasicItemPtr;
}
unsafe extern "C" fn xmlSchemaAddNotation(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
    mut node: xmlNodePtr,
) -> xmlSchemaNotationPtr {
    let mut ret: xmlSchemaNotationPtr = 0 as xmlSchemaNotationPtr;
    if ctxt.is_null() || schema.is_null() || name.is_null() {
        return 0 as xmlSchemaNotationPtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaNotation>() as libc::c_ulong)
        as xmlSchemaNotationPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"add annotation\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaNotationPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaNotation>() as libc::c_ulong,
    );
    (*ret).type_0 = XML_SCHEMA_TYPE_NOTATION;
    let ref mut fresh43 = (*ret).name;
    *fresh43 = name;
    let ref mut fresh44 = (*ret).targetNamespace;
    *fresh44 = nsName;
    xmlSchemaAddItemSize(
        &mut (*(*(*ctxt).constructor).bucket).globals,
        5 as libc::c_int,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaAddAttribute(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
    mut node: xmlNodePtr,
    mut topLevel: libc::c_int,
) -> xmlSchemaAttributePtr {
    let mut ret: xmlSchemaAttributePtr = 0 as xmlSchemaAttributePtr;
    if ctxt.is_null() || schema.is_null() {
        return 0 as xmlSchemaAttributePtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaAttribute>() as libc::c_ulong)
        as xmlSchemaAttributePtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating attribute\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaAttributePtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaAttribute>() as libc::c_ulong,
    );
    (*ret).type_0 = XML_SCHEMA_TYPE_ATTRIBUTE;
    let ref mut fresh45 = (*ret).node;
    *fresh45 = node;
    let ref mut fresh46 = (*ret).name;
    *fresh46 = name;
    let ref mut fresh47 = (*ret).targetNamespace;
    *fresh47 = nsName;
    if topLevel != 0 {
        xmlSchemaAddItemSize(
            &mut (*(*(*ctxt).constructor).bucket).globals,
            5 as libc::c_int,
            ret as *mut libc::c_void,
        );
    } else {
        xmlSchemaAddItemSize(
            &mut (*(*(*ctxt).constructor).bucket).locals,
            10 as libc::c_int,
            ret as *mut libc::c_void,
        );
    }
    xmlSchemaAddItemSize(
        &mut (*(*ctxt).constructor).pending,
        10 as libc::c_int,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaAddAttributeUse(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaAttributeUsePtr {
    let mut ret: xmlSchemaAttributeUsePtr = 0 as xmlSchemaAttributeUsePtr;
    if pctxt.is_null() {
        return 0 as xmlSchemaAttributeUsePtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaAttributeUse>() as libc::c_ulong)
        as xmlSchemaAttributeUsePtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            pctxt,
            b"allocating attribute\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaAttributeUsePtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaAttributeUse>() as libc::c_ulong,
    );
    (*ret).type_0 = XML_SCHEMA_TYPE_ATTRIBUTE_USE;
    let ref mut fresh48 = (*ret).node;
    *fresh48 = node;
    xmlSchemaAddItemSize(
        &mut (*(*(*pctxt).constructor).bucket).locals,
        10 as libc::c_int,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaAddRedef(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut targetBucket: xmlSchemaBucketPtr,
    mut item: *mut libc::c_void,
    mut refName: *const xmlChar,
    mut refTargetNs: *const xmlChar,
) -> xmlSchemaRedefPtr {
    let mut ret: xmlSchemaRedefPtr = 0 as *mut xmlSchemaRedef;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaRedef>() as libc::c_ulong) as xmlSchemaRedefPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            pctxt,
            b"allocating redefinition info\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaRedefPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaRedef>() as libc::c_ulong,
    );
    let ref mut fresh49 = (*ret).item;
    *fresh49 = item as xmlSchemaBasicItemPtr;
    let ref mut fresh50 = (*ret).targetBucket;
    *fresh50 = targetBucket;
    let ref mut fresh51 = (*ret).refName;
    *fresh51 = refName;
    let ref mut fresh52 = (*ret).refTargetNs;
    *fresh52 = refTargetNs;
    if ((*(*pctxt).constructor).redefs).is_null() {
        let ref mut fresh53 = (*(*pctxt).constructor).redefs;
        *fresh53 = ret;
    } else {
        let ref mut fresh54 = (*(*(*pctxt).constructor).lastRedef).next;
        *fresh54 = ret;
    }
    let ref mut fresh55 = (*(*pctxt).constructor).lastRedef;
    *fresh55 = ret;
    return ret;
}
unsafe extern "C" fn xmlSchemaAddAttributeGroupDefinition(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
    mut node: xmlNodePtr,
) -> xmlSchemaAttributeGroupPtr {
    let mut ret: xmlSchemaAttributeGroupPtr = 0 as xmlSchemaAttributeGroupPtr;
    if pctxt.is_null() || name.is_null() {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaAttributeGroup>() as libc::c_ulong)
        as xmlSchemaAttributeGroupPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            pctxt,
            b"allocating attribute group\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaAttributeGroup>() as libc::c_ulong,
    );
    (*ret).type_0 = XML_SCHEMA_TYPE_ATTRIBUTEGROUP;
    let ref mut fresh56 = (*ret).name;
    *fresh56 = name;
    let ref mut fresh57 = (*ret).targetNamespace;
    *fresh57 = nsName;
    let ref mut fresh58 = (*ret).node;
    *fresh58 = node;
    (*ret).flags |= (1 as libc::c_int) << 1 as libc::c_int;
    if (*pctxt).isRedefine != 0 {
        let ref mut fresh59 = (*pctxt).redef;
        *fresh59 = xmlSchemaAddRedef(
            pctxt,
            (*pctxt).redefined,
            ret as *mut libc::c_void,
            name,
            nsName,
        );
        if ((*pctxt).redef).is_null() {
            xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void);
            return 0 as xmlSchemaAttributeGroupPtr;
        }
        (*pctxt).redefCounter = 0 as libc::c_int;
    }
    xmlSchemaAddItemSize(
        &mut (*(*(*pctxt).constructor).bucket).globals,
        5 as libc::c_int,
        ret as *mut libc::c_void,
    );
    xmlSchemaAddItemSize(
        &mut (*(*pctxt).constructor).pending,
        10 as libc::c_int,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaAddElement(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
    mut node: xmlNodePtr,
    mut topLevel: libc::c_int,
) -> xmlSchemaElementPtr {
    let mut ret: xmlSchemaElementPtr = 0 as xmlSchemaElementPtr;
    if ctxt.is_null() || name.is_null() {
        return 0 as xmlSchemaElementPtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaElement>() as libc::c_ulong)
        as xmlSchemaElementPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating element\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaElementPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaElement>() as libc::c_ulong,
    );
    (*ret).type_0 = XML_SCHEMA_TYPE_ELEMENT;
    let ref mut fresh60 = (*ret).name;
    *fresh60 = name;
    let ref mut fresh61 = (*ret).targetNamespace;
    *fresh61 = nsName;
    let ref mut fresh62 = (*ret).node;
    *fresh62 = node;
    if topLevel != 0 {
        xmlSchemaAddItemSize(
            &mut (*(*(*ctxt).constructor).bucket).globals,
            5 as libc::c_int,
            ret as *mut libc::c_void,
        );
    } else {
        xmlSchemaAddItemSize(
            &mut (*(*(*ctxt).constructor).bucket).locals,
            10 as libc::c_int,
            ret as *mut libc::c_void,
        );
    }
    xmlSchemaAddItemSize(
        &mut (*(*ctxt).constructor).pending,
        10 as libc::c_int,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaAddType(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut type_0: xmlSchemaTypeType,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
    mut node: xmlNodePtr,
    mut topLevel: libc::c_int,
) -> xmlSchemaTypePtr {
    let mut ret: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
    if ctxt.is_null() || schema.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaType>() as libc::c_ulong) as xmlSchemaTypePtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating type\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaTypePtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaType>() as libc::c_ulong,
    );
    (*ret).type_0 = type_0;
    let ref mut fresh63 = (*ret).name;
    *fresh63 = name;
    let ref mut fresh64 = (*ret).targetNamespace;
    *fresh64 = nsName;
    let ref mut fresh65 = (*ret).node;
    *fresh65 = node;
    if topLevel != 0 {
        if (*ctxt).isRedefine != 0 {
            let ref mut fresh66 = (*ctxt).redef;
            *fresh66 = xmlSchemaAddRedef(
                ctxt,
                (*ctxt).redefined,
                ret as *mut libc::c_void,
                name,
                nsName,
            );
            if ((*ctxt).redef).is_null() {
                xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void);
                return 0 as xmlSchemaTypePtr;
            }
            (*ctxt).redefCounter = 0 as libc::c_int;
        }
        xmlSchemaAddItemSize(
            &mut (*(*(*ctxt).constructor).bucket).globals,
            5 as libc::c_int,
            ret as *mut libc::c_void,
        );
    } else {
        xmlSchemaAddItemSize(
            &mut (*(*(*ctxt).constructor).bucket).locals,
            10 as libc::c_int,
            ret as *mut libc::c_void,
        );
    }
    xmlSchemaAddItemSize(
        &mut (*(*ctxt).constructor).pending,
        10 as libc::c_int,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaNewQNameRef(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut refType: xmlSchemaTypeType,
    mut refName: *const xmlChar,
    mut refNs: *const xmlChar,
) -> xmlSchemaQNameRefPtr {
    let mut ret: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaQNameRef>() as libc::c_ulong)
        as xmlSchemaQNameRefPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            pctxt,
            b"allocating QName reference item\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaQNameRefPtr;
    }
    let ref mut fresh67 = (*ret).node;
    *fresh67 = 0 as xmlNodePtr;
    (*ret).type_0 = XML_SCHEMA_EXTRA_QNAMEREF;
    let ref mut fresh68 = (*ret).name;
    *fresh68 = refName;
    let ref mut fresh69 = (*ret).targetNamespace;
    *fresh69 = refNs;
    let ref mut fresh70 = (*ret).item;
    *fresh70 = 0 as xmlSchemaBasicItemPtr;
    (*ret).itemType = refType;
    xmlSchemaAddItemSize(
        &mut (*(*(*pctxt).constructor).bucket).locals,
        10 as libc::c_int,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaAddAttributeUseProhib(
    mut pctxt: xmlSchemaParserCtxtPtr,
) -> xmlSchemaAttributeUseProhibPtr {
    let mut ret: xmlSchemaAttributeUseProhibPtr = 0 as *mut xmlSchemaAttributeUseProhib;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaAttributeUseProhib>() as libc::c_ulong)
        as xmlSchemaAttributeUseProhibPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            pctxt,
            b"allocating attribute use prohibition\0" as *const u8
                as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaAttributeUseProhibPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaAttributeUseProhib>() as libc::c_ulong,
    );
    (*ret).type_0 = XML_SCHEMA_EXTRA_ATTR_USE_PROHIB;
    xmlSchemaAddItemSize(
        &mut (*(*(*pctxt).constructor).bucket).locals,
        10 as libc::c_int,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaAddModelGroup(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut type_0: xmlSchemaTypeType,
    mut node: xmlNodePtr,
) -> xmlSchemaModelGroupPtr {
    let mut ret: xmlSchemaModelGroupPtr = 0 as xmlSchemaModelGroupPtr;
    if ctxt.is_null() || schema.is_null() {
        return 0 as xmlSchemaModelGroupPtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaModelGroup>() as libc::c_ulong)
        as xmlSchemaModelGroupPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating model group component\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaModelGroupPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaModelGroup>() as libc::c_ulong,
    );
    (*ret).type_0 = type_0;
    let ref mut fresh71 = (*ret).node;
    *fresh71 = node;
    xmlSchemaAddItemSize(
        &mut (*(*(*ctxt).constructor).bucket).locals,
        10 as libc::c_int,
        ret as *mut libc::c_void,
    );
    if type_0 as libc::c_uint == XML_SCHEMA_TYPE_SEQUENCE as libc::c_int as libc::c_uint
        || type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_CHOICE as libc::c_int as libc::c_uint
    {
        xmlSchemaAddItemSize(
            &mut (*(*ctxt).constructor).pending,
            10 as libc::c_int,
            ret as *mut libc::c_void,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaAddParticle(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut min: libc::c_int,
    mut max: libc::c_int,
) -> xmlSchemaParticlePtr {
    let mut ret: xmlSchemaParticlePtr = 0 as xmlSchemaParticlePtr;
    if ctxt.is_null() {
        return 0 as xmlSchemaParticlePtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaParticle>() as libc::c_ulong)
        as xmlSchemaParticlePtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating particle component\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaParticlePtr;
    }
    (*ret).type_0 = XML_SCHEMA_TYPE_PARTICLE;
    let ref mut fresh72 = (*ret).annot;
    *fresh72 = 0 as xmlSchemaAnnotPtr;
    let ref mut fresh73 = (*ret).node;
    *fresh73 = node;
    (*ret).minOccurs = min;
    (*ret).maxOccurs = max;
    let ref mut fresh74 = (*ret).next;
    *fresh74 = 0 as xmlSchemaTreeItemPtr;
    let ref mut fresh75 = (*ret).children;
    *fresh75 = 0 as xmlSchemaTreeItemPtr;
    xmlSchemaAddItemSize(
        &mut (*(*(*ctxt).constructor).bucket).locals,
        10 as libc::c_int,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaAddModelGroupDefinition(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
    mut node: xmlNodePtr,
) -> xmlSchemaModelGroupDefPtr {
    let mut ret: xmlSchemaModelGroupDefPtr = 0 as xmlSchemaModelGroupDefPtr;
    if ctxt.is_null() || schema.is_null() || name.is_null() {
        return 0 as xmlSchemaModelGroupDefPtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaModelGroupDef>() as libc::c_ulong)
        as xmlSchemaModelGroupDefPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"adding group\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaModelGroupDefPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaModelGroupDef>() as libc::c_ulong,
    );
    let ref mut fresh76 = (*ret).name;
    *fresh76 = name;
    (*ret).type_0 = XML_SCHEMA_TYPE_GROUP;
    let ref mut fresh77 = (*ret).node;
    *fresh77 = node;
    let ref mut fresh78 = (*ret).targetNamespace;
    *fresh78 = nsName;
    if (*ctxt).isRedefine != 0 {
        let ref mut fresh79 = (*ctxt).redef;
        *fresh79 = xmlSchemaAddRedef(
            ctxt,
            (*ctxt).redefined,
            ret as *mut libc::c_void,
            name,
            nsName,
        );
        if ((*ctxt).redef).is_null() {
            xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void);
            return 0 as xmlSchemaModelGroupDefPtr;
        }
        (*ctxt).redefCounter = 0 as libc::c_int;
    }
    xmlSchemaAddItemSize(
        &mut (*(*(*ctxt).constructor).bucket).globals,
        5 as libc::c_int,
        ret as *mut libc::c_void,
    );
    xmlSchemaAddItemSize(
        &mut (*(*ctxt).constructor).pending,
        10 as libc::c_int,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaNewWildcardNsConstraint(
    mut ctxt: xmlSchemaParserCtxtPtr,
) -> xmlSchemaWildcardNsPtr {
    let mut ret: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaWildcardNs>() as libc::c_ulong)
        as xmlSchemaWildcardNsPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"creating wildcard namespace constraint\0" as *const u8
                as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaWildcardNsPtr;
    }
    let ref mut fresh80 = (*ret).value;
    *fresh80 = 0 as *const xmlChar;
    let ref mut fresh81 = (*ret).next;
    *fresh81 = 0 as *mut _xmlSchemaWildcardNs;
    return ret;
}
unsafe extern "C" fn xmlSchemaAddIDC(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
    mut category: libc::c_int,
    mut node: xmlNodePtr,
) -> xmlSchemaIDCPtr {
    let mut ret: xmlSchemaIDCPtr = 0 as xmlSchemaIDCPtr;
    if ctxt.is_null() || schema.is_null() || name.is_null() {
        return 0 as xmlSchemaIDCPtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaIDC>() as libc::c_ulong) as xmlSchemaIDCPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating an identity-constraint definition\0" as *const u8
                as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaIDCPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaIDC>() as libc::c_ulong,
    );
    let ref mut fresh82 = (*ret).targetNamespace;
    *fresh82 = nsName;
    let ref mut fresh83 = (*ret).name;
    *fresh83 = name;
    (*ret).type_0 = category as xmlSchemaTypeType;
    let ref mut fresh84 = (*ret).node;
    *fresh84 = node;
    xmlSchemaAddItemSize(
        &mut (*(*(*ctxt).constructor).bucket).globals,
        5 as libc::c_int,
        ret as *mut libc::c_void,
    );
    if category == XML_SCHEMA_TYPE_IDC_KEYREF as libc::c_int {
        xmlSchemaAddItemSize(
            &mut (*(*ctxt).constructor).pending,
            10 as libc::c_int,
            ret as *mut libc::c_void,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaAddWildcard(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut type_0: xmlSchemaTypeType,
    mut node: xmlNodePtr,
) -> xmlSchemaWildcardPtr {
    let mut ret: xmlSchemaWildcardPtr = 0 as xmlSchemaWildcardPtr;
    if ctxt.is_null() || schema.is_null() {
        return 0 as xmlSchemaWildcardPtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaWildcard>() as libc::c_ulong)
        as xmlSchemaWildcardPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"adding wildcard\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaWildcardPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaWildcard>() as libc::c_ulong,
    );
    (*ret).type_0 = type_0;
    let ref mut fresh85 = (*ret).node;
    *fresh85 = node;
    xmlSchemaAddItemSize(
        &mut (*(*(*ctxt).constructor).bucket).locals,
        10 as libc::c_int,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaSubstGroupFree(mut group: xmlSchemaSubstGroupPtr) {
    if group.is_null() {
        return;
    }
    if !((*group).members).is_null() {
        xmlSchemaItemListFree((*group).members);
    }
    xmlFree.expect("non-null function pointer")(group as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaSubstGroupFreeEntry(
    mut group: *mut libc::c_void,
    mut name: *const xmlChar,
) {
    xmlSchemaSubstGroupFree(group as xmlSchemaSubstGroupPtr);
}
unsafe extern "C" fn xmlSchemaSubstGroupAdd(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut head: xmlSchemaElementPtr,
) -> xmlSchemaSubstGroupPtr {
    let mut ret: xmlSchemaSubstGroupPtr = 0 as *mut xmlSchemaSubstGroup;
    if ((*(*pctxt).constructor).substGroups).is_null() {
        let ref mut fresh86 = (*(*pctxt).constructor).substGroups;
        *fresh86 = xmlHashCreateDict(10 as libc::c_int, (*pctxt).dict);
        if ((*(*pctxt).constructor).substGroups).is_null() {
            return 0 as xmlSchemaSubstGroupPtr;
        }
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaSubstGroup>() as libc::c_ulong)
        as xmlSchemaSubstGroupPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating a substitution group container\0" as *const u8
                as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaSubstGroupPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaSubstGroup>() as libc::c_ulong,
    );
    let ref mut fresh87 = (*ret).head;
    *fresh87 = head;
    let ref mut fresh88 = (*ret).members;
    *fresh88 = xmlSchemaItemListCreate();
    if ((*ret).members).is_null() {
        xmlSchemaSubstGroupFree(ret);
        return 0 as xmlSchemaSubstGroupPtr;
    }
    if xmlHashAddEntry2(
        (*(*pctxt).constructor).substGroups,
        (*head).name,
        (*head).targetNamespace,
        ret as *mut libc::c_void,
    ) != 0 as libc::c_int
    {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaSubstGroupAdd\0" as *const u8 as *const libc::c_char,
            b"failed to add a new substitution container\0" as *const u8
                as *const libc::c_char,
        );
        xmlSchemaSubstGroupFree(ret);
        return 0 as xmlSchemaSubstGroupPtr;
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaSubstGroupGet(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut head: xmlSchemaElementPtr,
) -> xmlSchemaSubstGroupPtr {
    if ((*(*pctxt).constructor).substGroups).is_null() {
        return 0 as xmlSchemaSubstGroupPtr;
    }
    return xmlHashLookup2(
        (*(*pctxt).constructor).substGroups,
        (*head).name,
        (*head).targetNamespace,
    ) as xmlSchemaSubstGroupPtr;
}
unsafe extern "C" fn xmlSchemaAddElementSubstitutionMember(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut head: xmlSchemaElementPtr,
    mut member: xmlSchemaElementPtr,
) -> libc::c_int {
    let mut substGroup: xmlSchemaSubstGroupPtr = 0 as xmlSchemaSubstGroupPtr;
    if pctxt.is_null() || head.is_null() || member.is_null() {
        return -(1 as libc::c_int);
    }
    substGroup = xmlSchemaSubstGroupGet(pctxt, head);
    if substGroup.is_null() {
        substGroup = xmlSchemaSubstGroupAdd(pctxt, head);
    }
    if substGroup.is_null() {
        return -(1 as libc::c_int);
    }
    if xmlSchemaItemListAdd((*substGroup).members, member as *mut libc::c_void)
        == -(1 as libc::c_int)
    {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaPValAttrNodeQNameValue(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut attr: xmlAttrPtr,
    mut value: *const xmlChar,
    mut uri: *mut *const xmlChar,
    mut local: *mut *const xmlChar,
) -> libc::c_int {
    let mut pref: *const xmlChar = 0 as *const xmlChar;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut len: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    *uri = 0 as *const xmlChar;
    *local = 0 as *const xmlChar;
    ret = xmlValidateQName(value, 1 as libc::c_int);
    if ret > 0 as libc::c_int {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            ownerItem,
            attr as xmlNodePtr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),
            0 as *const libc::c_char,
            value,
            0 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        *local = value;
        return (*ctxt).err;
    } else {
        if ret < 0 as libc::c_int {
            return -(1 as libc::c_int);
        }
    }
    if (strchr(value as *mut libc::c_char, ':' as i32)).is_null() {
        ns = xmlSearchNs((*attr).doc, (*attr).parent, 0 as *const xmlChar);
        if !ns.is_null() && !((*ns).href).is_null()
            && *((*ns).href).offset(0 as libc::c_int as isize) as libc::c_int != 0
        {
            *uri = xmlDictLookup((*ctxt).dict, (*ns).href, -(1 as libc::c_int));
        } else if (*schema).flags & (1 as libc::c_int) << 9 as libc::c_int != 0 {
            *uri = (*ctxt).targetNamespace;
        }
        *local = xmlDictLookup((*ctxt).dict, value, -(1 as libc::c_int));
        return 0 as libc::c_int;
    }
    *local = xmlSplitQName3(value, &mut len);
    *local = xmlDictLookup((*ctxt).dict, *local, -(1 as libc::c_int));
    pref = xmlDictLookup((*ctxt).dict, value, len);
    ns = xmlSearchNs((*attr).doc, (*attr).parent, pref);
    if ns.is_null() {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            ownerItem,
            attr as xmlNodePtr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),
            0 as *const libc::c_char,
            value,
            b"The value '%s' of simple type 'xs:QName' has no corresponding namespace declaration in scope\0"
                as *const u8 as *const libc::c_char,
            value,
            0 as *const xmlChar,
        );
        return (*ctxt).err;
    } else {
        *uri = xmlDictLookup((*ctxt).dict, (*ns).href, -(1 as libc::c_int));
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaPValAttrNodeQName(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut attr: xmlAttrPtr,
    mut uri: *mut *const xmlChar,
    mut local: *mut *const xmlChar,
) -> libc::c_int {
    let mut value: *const xmlChar = 0 as *const xmlChar;
    value = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    return xmlSchemaPValAttrNodeQNameValue(
        ctxt,
        schema,
        ownerItem,
        attr,
        value,
        uri,
        local,
    );
}
unsafe extern "C" fn xmlSchemaPValAttrQName(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut ownerElem: xmlNodePtr,
    mut name: *const libc::c_char,
    mut uri: *mut *const xmlChar,
    mut local: *mut *const xmlChar,
) -> libc::c_int {
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    attr = xmlSchemaGetPropNode(ownerElem, name);
    if attr.is_null() {
        *local = 0 as *const xmlChar;
        *uri = 0 as *const xmlChar;
        return 0 as libc::c_int;
    }
    return xmlSchemaPValAttrNodeQName(ctxt, schema, ownerItem, attr, uri, local);
}
unsafe extern "C" fn xmlSchemaPValAttrNodeID(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut attr: xmlAttrPtr,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    let mut value: *const xmlChar = 0 as *const xmlChar;
    if attr.is_null() {
        return 0 as libc::c_int;
    }
    value = xmlSchemaGetNodeContentNoDict(attr as xmlNodePtr);
    ret = xmlValidateNCName(value, 1 as libc::c_int);
    if ret == 0 as libc::c_int {
        if (*attr).atype as libc::c_uint
            != XML_ATTRIBUTE_ID as libc::c_int as libc::c_uint
        {
            let mut res: xmlIDPtr = 0 as *mut xmlID;
            let mut strip: *mut xmlChar = 0 as *mut xmlChar;
            strip = xmlSchemaCollapseString(value);
            if !strip.is_null() {
                xmlFree
                    .expect(
                        "non-null function pointer",
                    )(value as *mut xmlChar as *mut libc::c_void);
                value = strip;
            }
            res = xmlAddID(0 as xmlValidCtxtPtr, (*attr).doc, value, attr);
            if res.is_null() {
                ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as libc::c_int;
                xmlSchemaPSimpleTypeErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                    0 as xmlSchemaBasicItemPtr,
                    attr as xmlNodePtr,
                    xmlSchemaGetBuiltInType(XML_SCHEMAS_ID),
                    0 as *const libc::c_char,
                    0 as *const xmlChar,
                    b"Duplicate value '%s' of simple type 'xs:ID'\0" as *const u8
                        as *const libc::c_char,
                    value,
                    0 as *const xmlChar,
                );
            } else {
                (*attr).atype = XML_ATTRIBUTE_ID;
            }
        }
    } else if ret > 0 as libc::c_int {
        ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as libc::c_int;
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_ID),
            0 as *const libc::c_char,
            0 as *const xmlChar,
            b"The value '%s' of simple type 'xs:ID' is not a valid 'xs:NCName'\0"
                as *const u8 as *const libc::c_char,
            value,
            0 as *const xmlChar,
        );
    }
    if !value.is_null() {
        xmlFree
            .expect(
                "non-null function pointer",
            )(value as *mut xmlChar as *mut libc::c_void);
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaPValAttrID(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut ownerElem: xmlNodePtr,
    mut name: *const xmlChar,
) -> libc::c_int {
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    attr = xmlSchemaGetPropNode(ownerElem, name as *const libc::c_char);
    if attr.is_null() {
        return 0 as libc::c_int;
    }
    return xmlSchemaPValAttrNodeID(ctxt, attr);
}
unsafe extern "C" fn xmlGetMaxOccurs(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut min: libc::c_int,
    mut max: libc::c_int,
    mut def: libc::c_int,
    mut expected: *const libc::c_char,
) -> libc::c_int {
    let mut val: *const xmlChar = 0 as *const xmlChar;
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    attr = xmlSchemaGetPropNode(
        node,
        b"maxOccurs\0" as *const u8 as *const libc::c_char,
    );
    if attr.is_null() {
        return def;
    }
    val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    if xmlStrEqual(
        val,
        b"unbounded\0" as *const u8 as *const libc::c_char as *const xmlChar,
    ) != 0
    {
        if max != (1 as libc::c_int) << 30 as libc::c_int {
            xmlSchemaPSimpleTypeErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                0 as xmlSchemaBasicItemPtr,
                attr as xmlNodePtr,
                0 as xmlSchemaTypePtr,
                expected,
                val,
                0 as *const libc::c_char,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return def;
        } else {
            return (1 as libc::c_int) << 30 as libc::c_int
        }
    }
    cur = val;
    while *cur as libc::c_int == 0x20 as libc::c_int
        || 0x9 as libc::c_int <= *cur as libc::c_int
            && *cur as libc::c_int <= 0xa as libc::c_int
        || *cur as libc::c_int == 0xd as libc::c_int
    {
        cur = cur.offset(1);
    }
    if *cur as libc::c_int == 0 as libc::c_int {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            0 as xmlSchemaTypePtr,
            expected,
            val,
            0 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return def;
    }
    while *cur as libc::c_int >= '0' as i32 && *cur as libc::c_int <= '9' as i32 {
        if ret > 2147483647 as libc::c_int / 10 as libc::c_int {
            ret = 2147483647 as libc::c_int;
        } else {
            let mut digit: libc::c_int = *cur as libc::c_int - '0' as i32;
            ret *= 10 as libc::c_int;
            if ret > 2147483647 as libc::c_int - digit {
                ret = 2147483647 as libc::c_int;
            } else {
                ret += digit;
            }
        }
        cur = cur.offset(1);
    }
    while *cur as libc::c_int == 0x20 as libc::c_int
        || 0x9 as libc::c_int <= *cur as libc::c_int
            && *cur as libc::c_int <= 0xa as libc::c_int
        || *cur as libc::c_int == 0xd as libc::c_int
    {
        cur = cur.offset(1);
    }
    if *cur as libc::c_int != 0 as libc::c_int || ret < min
        || max != -(1 as libc::c_int) && ret > max
    {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            0 as xmlSchemaTypePtr,
            expected,
            val,
            0 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return def;
    }
    return ret;
}
unsafe extern "C" fn xmlGetMinOccurs(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut min: libc::c_int,
    mut max: libc::c_int,
    mut def: libc::c_int,
    mut expected: *const libc::c_char,
) -> libc::c_int {
    let mut val: *const xmlChar = 0 as *const xmlChar;
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    attr = xmlSchemaGetPropNode(
        node,
        b"minOccurs\0" as *const u8 as *const libc::c_char,
    );
    if attr.is_null() {
        return def;
    }
    val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    cur = val;
    while *cur as libc::c_int == 0x20 as libc::c_int
        || 0x9 as libc::c_int <= *cur as libc::c_int
            && *cur as libc::c_int <= 0xa as libc::c_int
        || *cur as libc::c_int == 0xd as libc::c_int
    {
        cur = cur.offset(1);
    }
    if *cur as libc::c_int == 0 as libc::c_int {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            0 as xmlSchemaTypePtr,
            expected,
            val,
            0 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return def;
    }
    while *cur as libc::c_int >= '0' as i32 && *cur as libc::c_int <= '9' as i32 {
        if ret > 2147483647 as libc::c_int / 10 as libc::c_int {
            ret = 2147483647 as libc::c_int;
        } else {
            let mut digit: libc::c_int = *cur as libc::c_int - '0' as i32;
            ret *= 10 as libc::c_int;
            if ret > 2147483647 as libc::c_int - digit {
                ret = 2147483647 as libc::c_int;
            } else {
                ret += digit;
            }
        }
        cur = cur.offset(1);
    }
    while *cur as libc::c_int == 0x20 as libc::c_int
        || 0x9 as libc::c_int <= *cur as libc::c_int
            && *cur as libc::c_int <= 0xa as libc::c_int
        || *cur as libc::c_int == 0xd as libc::c_int
    {
        cur = cur.offset(1);
    }
    if *cur as libc::c_int != 0 as libc::c_int || ret < min
        || max != -(1 as libc::c_int) && ret > max
    {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            0 as xmlSchemaTypePtr,
            expected,
            val,
            0 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return def;
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaPGetBoolNodeValue(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut node: xmlNodePtr,
) -> libc::c_int {
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut res: libc::c_int = 0 as libc::c_int;
    value = xmlNodeGetContent(node as *const xmlNode);
    if xmlStrEqual(value, b"true\0" as *const u8 as *const libc::c_char as *mut xmlChar)
        != 0
    {
        res = 1 as libc::c_int;
    } else if xmlStrEqual(
            value,
            b"false\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        ) != 0
        {
        res = 0 as libc::c_int;
    } else if xmlStrEqual(
            value,
            b"1\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        ) != 0
        {
        res = 1 as libc::c_int;
    } else if xmlStrEqual(
            value,
            b"0\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        ) != 0
        {
        res = 0 as libc::c_int;
    } else {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_INVALID_BOOLEAN,
            ownerItem,
            node,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
            0 as *const libc::c_char,
            value,
            0 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    if !value.is_null() {
        xmlFree.expect("non-null function pointer")(value as *mut libc::c_void);
    }
    return res;
}
unsafe extern "C" fn xmlGetBooleanProp(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut name: *const libc::c_char,
    mut def: libc::c_int,
) -> libc::c_int {
    let mut val: *const xmlChar = 0 as *const xmlChar;
    val = xmlSchemaGetProp(ctxt, node, name);
    if val.is_null() {
        return def;
    }
    if xmlStrEqual(val, b"true\0" as *const u8 as *const libc::c_char as *mut xmlChar)
        != 0
    {
        def = 1 as libc::c_int;
    } else if xmlStrEqual(
            val,
            b"false\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        ) != 0
        {
        def = 0 as libc::c_int;
    } else if xmlStrEqual(
            val,
            b"1\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        ) != 0
        {
        def = 1 as libc::c_int;
    } else if xmlStrEqual(
            val,
            b"0\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        ) != 0
        {
        def = 0 as libc::c_int;
    } else {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_INVALID_BOOLEAN,
            0 as xmlSchemaBasicItemPtr,
            xmlSchemaGetPropNode(node, name) as xmlNodePtr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
            0 as *const libc::c_char,
            val,
            0 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    return def;
}
unsafe extern "C" fn xmlSchemaPValAttrNodeValue(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut attr: xmlAttrPtr,
    mut value: *const xmlChar,
    mut type_0: xmlSchemaTypePtr,
) -> libc::c_int {
    let mut ret: libc::c_int = 0 as libc::c_int;
    if pctxt.is_null() || type_0.is_null() || attr.is_null() {
        return -(1 as libc::c_int);
    }
    if (*type_0).type_0 as libc::c_uint
        != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
    {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaPValAttrNodeValue\0" as *const u8 as *const libc::c_char,
            b"the given type is not a built-in type\0" as *const u8
                as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    match (*type_0).builtInType {
        22 | 21 | 29 | 16 | 17 => {
            ret = xmlSchemaValPredefTypeNode(
                type_0,
                value,
                0 as *mut xmlSchemaValPtr,
                attr as xmlNodePtr,
            );
        }
        _ => {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaPValAttrNodeValue\0" as *const u8 as *const libc::c_char,
                b"validation using the given type is not supported while parsing a schema\0"
                    as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    }
    if ret < 0 as libc::c_int {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaPValAttrNodeValue\0" as *const u8 as *const libc::c_char,
            b"failed to validate a schema attribute value\0" as *const u8
                as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    } else {
        if ret > 0 as libc::c_int {
            if (*type_0).flags & (1 as libc::c_int) << 6 as libc::c_int != 0 {
                ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as libc::c_int;
            } else {
                ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as libc::c_int;
            }
            xmlSchemaPSimpleTypeErr(
                pctxt,
                ret as xmlParserErrors,
                ownerItem,
                attr as xmlNodePtr,
                type_0,
                0 as *const libc::c_char,
                value,
                0 as *const libc::c_char,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaPValAttrNode(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut attr: xmlAttrPtr,
    mut type_0: xmlSchemaTypePtr,
    mut value: *mut *const xmlChar,
) -> libc::c_int {
    let mut val: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || type_0.is_null() || attr.is_null() {
        return -(1 as libc::c_int);
    }
    val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    if !value.is_null() {
        *value = val;
    }
    return xmlSchemaPValAttrNodeValue(ctxt, ownerItem, attr, val, type_0);
}
unsafe extern "C" fn xmlSchemaPValAttr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut ownerElem: xmlNodePtr,
    mut name: *const libc::c_char,
    mut type_0: xmlSchemaTypePtr,
    mut value: *mut *const xmlChar,
) -> libc::c_int {
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || type_0.is_null() {
        if !value.is_null() {
            *value = 0 as *const xmlChar;
        }
        return -(1 as libc::c_int);
    }
    if (*type_0).type_0 as libc::c_uint
        != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
    {
        if !value.is_null() {
            *value = 0 as *const xmlChar;
        }
        xmlSchemaPErr(
            ctxt,
            ownerElem,
            XML_SCHEMAP_INTERNAL as libc::c_int,
            b"Internal error: xmlSchemaPValAttr, the given type '%s' is not a built-in type.\n\0"
                as *const u8 as *const libc::c_char,
            (*type_0).name,
            0 as *const xmlChar,
        );
        return -(1 as libc::c_int);
    }
    attr = xmlSchemaGetPropNode(ownerElem, name);
    if attr.is_null() {
        if !value.is_null() {
            *value = 0 as *const xmlChar;
        }
        return 0 as libc::c_int;
    }
    return xmlSchemaPValAttrNode(ctxt, ownerItem, attr, type_0, value);
}
unsafe extern "C" fn xmlSchemaCheckReference(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut attr: xmlAttrPtr,
    mut namespaceName: *const xmlChar,
) -> libc::c_int {
    if xmlStrEqual((*pctxt).targetNamespace, namespaceName) != 0 {
        return 0 as libc::c_int;
    }
    if xmlStrEqual(xmlSchemaNs, namespaceName) != 0 {
        return 0 as libc::c_int;
    }
    if !((*(*(*pctxt).constructor).bucket).relations).is_null() {
        let mut rel: xmlSchemaSchemaRelationPtr = 0 as *mut xmlSchemaSchemaRelation;
        rel = (*(*(*pctxt).constructor).bucket).relations;
        loop {
            if ((*rel).type_0 == 0 as libc::c_int || (*rel).type_0 == 1 as libc::c_int)
                && xmlStrEqual(namespaceName, (*rel).importNamespace) != 0
            {
                return 0 as libc::c_int;
            }
            rel = (*rel).next;
            if rel.is_null() {
                break;
            }
        }
    }
    let mut n: xmlNodePtr = if !attr.is_null() { attr as xmlNodePtr } else { node };
    if namespaceName.is_null() {
        xmlSchemaCustomErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_SRC_RESOLVE,
            n,
            0 as xmlSchemaBasicItemPtr,
            b"References from this schema to components in no namespace are not allowed, since not indicated by an import statement\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    } else {
        xmlSchemaCustomErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_SRC_RESOLVE,
            n,
            0 as xmlSchemaBasicItemPtr,
            b"References from this schema to components in the namespace '%s' are not allowed, since not indicated by an import statement\0"
                as *const u8 as *const libc::c_char,
            namespaceName,
            0 as *const xmlChar,
        );
    }
    return XML_SCHEMAP_SRC_RESOLVE as libc::c_int;
}
unsafe extern "C" fn xmlSchemaParseLocalAttributes(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut child: *mut xmlNodePtr,
    mut list: *mut xmlSchemaItemListPtr,
    mut parentType: libc::c_int,
    mut hasRefs: *mut libc::c_int,
) -> libc::c_int {
    let mut item: *mut libc::c_void = 0 as *mut libc::c_void;
    while !(*child).is_null() && !((**child).ns).is_null()
        && xmlStrEqual(
            (**child).name,
            b"attribute\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(**child).ns).href, xmlSchemaNs) != 0
        || !(*child).is_null() && !((**child).ns).is_null()
            && xmlStrEqual(
                (**child).name,
                b"attributeGroup\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(**child).ns).href, xmlSchemaNs) != 0
    {
        if !(*child).is_null() && !((**child).ns).is_null()
            && xmlStrEqual(
                (**child).name,
                b"attribute\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(**child).ns).href, xmlSchemaNs) != 0
        {
            item = xmlSchemaParseLocalAttribute(ctxt, schema, *child, *list, parentType)
                as *mut libc::c_void;
        } else {
            item = xmlSchemaParseAttributeGroupRef(ctxt, schema, *child)
                as *mut libc::c_void;
            if !item.is_null() && !hasRefs.is_null() {
                *hasRefs = 1 as libc::c_int;
            }
        }
        if !item.is_null() {
            if (*list).is_null() {
                *list = xmlSchemaItemListCreate();
                if (*list).is_null() {
                    return -(1 as libc::c_int);
                }
            }
            if xmlSchemaItemListAddSize(*list, 2 as libc::c_int, item)
                == -(1 as libc::c_int)
            {
                return -(1 as libc::c_int);
            }
        }
        *child = (**child).next;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaParseAnnotation(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut needed: libc::c_int,
) -> xmlSchemaAnnotPtr {
    let mut ret: xmlSchemaAnnotPtr = 0 as *mut xmlSchemaAnnot;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut barked: libc::c_int = 0 as libc::c_int;
    if ctxt.is_null() || node.is_null() {
        return 0 as xmlSchemaAnnotPtr;
    }
    if needed != 0 {
        ret = xmlSchemaNewAnnot(ctxt, node);
    } else {
        ret = 0 as xmlSchemaAnnotPtr;
    }
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null()
            && xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
            || !((*attr).ns).is_null()
                && xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0
        {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    child = (*node).children;
    while !child.is_null() {
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"appinfo\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            attr = (*child).properties;
            while !attr.is_null() {
                if ((*attr).ns).is_null()
                    && xmlStrEqual(
                        (*attr).name,
                        b"source\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    ) == 0
                    || !((*attr).ns).is_null()
                        && xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0
                {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        0 as xmlSchemaBasicItemPtr,
                        attr,
                    );
                }
                attr = (*attr).next;
            }
            xmlSchemaPValAttr(
                ctxt,
                0 as xmlSchemaBasicItemPtr,
                child,
                b"source\0" as *const u8 as *const libc::c_char,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
                0 as *mut *const xmlChar,
            );
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"documentation\0" as *const u8 as *const libc::c_char
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            attr = (*child).properties;
            while !attr.is_null() {
                if ((*attr).ns).is_null() {
                    if xmlStrEqual(
                        (*attr).name,
                        b"source\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    ) == 0
                    {
                        xmlSchemaPIllegalAttrErr(
                            ctxt,
                            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                            0 as xmlSchemaBasicItemPtr,
                            attr,
                        );
                    }
                } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0
                        || xmlStrEqual(
                            (*attr).name,
                            b"lang\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                        ) != 0
                            && xmlStrEqual(
                                (*(*attr).ns).href,
                                b"http://www.w3.org/XML/1998/namespace\0" as *const u8
                                    as *const libc::c_char as *const xmlChar,
                            ) == 0
                    {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        0 as xmlSchemaBasicItemPtr,
                        attr,
                    );
                }
                attr = (*attr).next;
            }
            attr = xmlSchemaGetPropNodeNs(
                child,
                b"http://www.w3.org/XML/1998/namespace\0" as *const u8
                    as *const libc::c_char as *const xmlChar as *const libc::c_char,
                b"lang\0" as *const u8 as *const libc::c_char,
            );
            if !attr.is_null() {
                xmlSchemaPValAttrNode(
                    ctxt,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                    xmlSchemaGetBuiltInType(XML_SCHEMAS_LANGUAGE),
                    0 as *mut *const xmlChar,
                );
            }
            child = (*child).next;
        } else {
            if barked == 0 {
                xmlSchemaPContentErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    child,
                    0 as *const libc::c_char,
                    b"(appinfo | documentation)*\0" as *const u8 as *const libc::c_char,
                );
            }
            barked = 1 as libc::c_int;
            child = (*child).next;
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaParseFacet(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaFacetPtr {
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut value: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaFacetPtr;
    }
    facet = xmlSchemaNewFacet();
    if facet.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating facet\0" as *const u8 as *const libc::c_char,
            node,
        );
        return 0 as xmlSchemaFacetPtr;
    }
    let ref mut fresh89 = (*facet).node;
    *fresh89 = node;
    value = xmlSchemaGetProp(ctxt, node, b"value\0" as *const u8 as *const libc::c_char);
    if value.is_null() {
        xmlSchemaPErr2(
            ctxt,
            node,
            child,
            XML_SCHEMAP_FACET_NO_VALUE as libc::c_int,
            b"Facet %s has no value\n\0" as *const u8 as *const libc::c_char,
            (*node).name,
            0 as *const xmlChar,
        );
        xmlSchemaFreeFacet(facet);
        return 0 as xmlSchemaFacetPtr;
    }
    if !node.is_null() && !((*node).ns).is_null()
        && xmlStrEqual(
            (*node).name,
            b"minInclusive\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
    {
        (*facet).type_0 = XML_SCHEMA_FACET_MININCLUSIVE;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"minExclusive\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_MINEXCLUSIVE;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"maxInclusive\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_MAXINCLUSIVE;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"maxExclusive\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_MAXEXCLUSIVE;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"totalDigits\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_TOTALDIGITS;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"fractionDigits\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_FRACTIONDIGITS;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"pattern\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_PATTERN;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"enumeration\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_ENUMERATION;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"whiteSpace\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_WHITESPACE;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"length\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_LENGTH;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"maxLength\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_MAXLENGTH;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"minLength\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_MINLENGTH;
    } else {
        xmlSchemaPErr2(
            ctxt,
            node,
            child,
            XML_SCHEMAP_UNKNOWN_FACET_TYPE as libc::c_int,
            b"Unknown facet type %s\n\0" as *const u8 as *const libc::c_char,
            (*node).name,
            0 as *const xmlChar,
        );
        xmlSchemaFreeFacet(facet);
        return 0 as xmlSchemaFacetPtr;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    let ref mut fresh90 = (*facet).value;
    *fresh90 = value;
    if (*facet).type_0 as libc::c_uint
        != XML_SCHEMA_FACET_PATTERN as libc::c_int as libc::c_uint
        && (*facet).type_0 as libc::c_uint
            != XML_SCHEMA_FACET_ENUMERATION as libc::c_int as libc::c_uint
    {
        let mut fixed: *const xmlChar = 0 as *const xmlChar;
        fixed = xmlSchemaGetProp(
            ctxt,
            node,
            b"fixed\0" as *const u8 as *const libc::c_char,
        );
        if !fixed.is_null() {
            if xmlStrEqual(
                fixed,
                b"true\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) != 0
            {
                (*facet).fixed = 1 as libc::c_int;
            }
        }
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let ref mut fresh91 = (*facet).annot;
        *fresh91 = xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int);
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPErr2(
            ctxt,
            node,
            child,
            XML_SCHEMAP_UNKNOWN_FACET_CHILD as libc::c_int,
            b"Facet %s has unexpected child content\n\0" as *const u8
                as *const libc::c_char,
            (*node).name,
            0 as *const xmlChar,
        );
    }
    return facet;
}
unsafe extern "C" fn xmlSchemaParseWildcardNs(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut wildc: xmlSchemaWildcardPtr,
    mut node: xmlNodePtr,
) -> libc::c_int {
    let mut pc: *const xmlChar = 0 as *const xmlChar;
    let mut ns: *const xmlChar = 0 as *const xmlChar;
    let mut dictnsItem: *const xmlChar = 0 as *const xmlChar;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut nsItem: *mut xmlChar = 0 as *mut xmlChar;
    let mut tmp: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut lastNs: xmlSchemaWildcardNsPtr = 0 as xmlSchemaWildcardNsPtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    pc = xmlSchemaGetProp(
        ctxt,
        node,
        b"processContents\0" as *const u8 as *const libc::c_char,
    );
    if pc.is_null()
        || xmlStrEqual(
            pc,
            b"strict\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0
    {
        (*wildc).processContents = 3 as libc::c_int;
    } else if xmlStrEqual(
            pc,
            b"skip\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0
        {
        (*wildc).processContents = 1 as libc::c_int;
    } else if xmlStrEqual(
            pc,
            b"lax\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0
        {
        (*wildc).processContents = 2 as libc::c_int;
    } else {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            node,
            0 as xmlSchemaTypePtr,
            b"(strict | skip | lax)\0" as *const u8 as *const libc::c_char,
            pc,
            0 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        (*wildc).processContents = 3 as libc::c_int;
        ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as libc::c_int;
    }
    attr = xmlSchemaGetPropNode(
        node,
        b"namespace\0" as *const u8 as *const libc::c_char,
    );
    ns = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    if attr.is_null()
        || xmlStrEqual(
            ns,
            b"##any\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        ) != 0
    {
        (*wildc).any = 1 as libc::c_int;
    } else if xmlStrEqual(
            ns,
            b"##other\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        ) != 0
        {
        let ref mut fresh92 = (*wildc).negNsSet;
        *fresh92 = xmlSchemaNewWildcardNsConstraint(ctxt);
        if ((*wildc).negNsSet).is_null() {
            return -(1 as libc::c_int);
        }
        let ref mut fresh93 = (*(*wildc).negNsSet).value;
        *fresh93 = (*ctxt).targetNamespace;
    } else {
        let mut end: *const xmlChar = 0 as *const xmlChar;
        let mut cur: *const xmlChar = 0 as *const xmlChar;
        cur = ns;
        loop {
            while *cur as libc::c_int == 0x20 as libc::c_int
                || 0x9 as libc::c_int <= *cur as libc::c_int
                    && *cur as libc::c_int <= 0xa as libc::c_int
                || *cur as libc::c_int == 0xd as libc::c_int
            {
                cur = cur.offset(1);
            }
            end = cur;
            while *end as libc::c_int != 0 as libc::c_int
                && !(*end as libc::c_int == 0x20 as libc::c_int
                    || 0x9 as libc::c_int <= *end as libc::c_int
                        && *end as libc::c_int <= 0xa as libc::c_int
                    || *end as libc::c_int == 0xd as libc::c_int)
            {
                end = end.offset(1);
            }
            if end == cur {
                break;
            }
            nsItem = xmlStrndup(
                cur,
                end.offset_from(cur) as libc::c_long as libc::c_int,
            );
            if xmlStrEqual(
                nsItem,
                b"##other\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) != 0
                || xmlStrEqual(
                    nsItem,
                    b"##any\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) != 0
            {
                xmlSchemaPSimpleTypeErr(
                    ctxt,
                    XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER,
                    0 as xmlSchemaBasicItemPtr,
                    attr as xmlNodePtr,
                    0 as xmlSchemaTypePtr,
                    b"((##any | ##other) | List of (xs:anyURI | (##targetNamespace | ##local)))\0"
                        as *const u8 as *const libc::c_char,
                    nsItem,
                    0 as *const libc::c_char,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
                ret = XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER as libc::c_int;
            } else {
                if xmlStrEqual(
                    nsItem,
                    b"##targetNamespace\0" as *const u8 as *const libc::c_char
                        as *mut xmlChar,
                ) != 0
                {
                    dictnsItem = (*ctxt).targetNamespace;
                } else if xmlStrEqual(
                        nsItem,
                        b"##local\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    ) != 0
                    {
                    dictnsItem = 0 as *const xmlChar;
                } else {
                    xmlSchemaPValAttrNodeValue(
                        ctxt,
                        0 as xmlSchemaBasicItemPtr,
                        attr,
                        nsItem,
                        xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
                    );
                    dictnsItem = xmlDictLookup(
                        (*ctxt).dict,
                        nsItem,
                        -(1 as libc::c_int),
                    );
                }
                tmp = (*wildc).nsSet;
                while !tmp.is_null() {
                    if dictnsItem == (*tmp).value {
                        break;
                    }
                    tmp = (*tmp).next;
                }
                if tmp.is_null() {
                    tmp = xmlSchemaNewWildcardNsConstraint(ctxt);
                    if tmp.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(nsItem as *mut libc::c_void);
                        return -(1 as libc::c_int);
                    }
                    let ref mut fresh94 = (*tmp).value;
                    *fresh94 = dictnsItem;
                    let ref mut fresh95 = (*tmp).next;
                    *fresh95 = 0 as *mut _xmlSchemaWildcardNs;
                    if ((*wildc).nsSet).is_null() {
                        let ref mut fresh96 = (*wildc).nsSet;
                        *fresh96 = tmp;
                    } else if !lastNs.is_null() {
                        let ref mut fresh97 = (*lastNs).next;
                        *fresh97 = tmp;
                    }
                    lastNs = tmp;
                }
            }
            xmlFree.expect("non-null function pointer")(nsItem as *mut libc::c_void);
            cur = end;
            if !(*cur as libc::c_int != 0 as libc::c_int) {
                break;
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaPCheckParticleCorrect_2(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut item: xmlSchemaParticlePtr,
    mut node: xmlNodePtr,
    mut minOccurs: libc::c_int,
    mut maxOccurs: libc::c_int,
) -> libc::c_int {
    if maxOccurs == 0 as libc::c_int && minOccurs == 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    if maxOccurs != (1 as libc::c_int) << 30 as libc::c_int {
        if maxOccurs < 1 as libc::c_int {
            xmlSchemaPCustomAttrErr(
                ctxt,
                XML_SCHEMAP_P_PROPS_CORRECT_2_2,
                0 as *mut *mut xmlChar,
                0 as xmlSchemaBasicItemPtr,
                xmlSchemaGetPropNode(
                    node,
                    b"maxOccurs\0" as *const u8 as *const libc::c_char,
                ),
                b"The value must be greater than or equal to 1\0" as *const u8
                    as *const libc::c_char,
            );
            return XML_SCHEMAP_P_PROPS_CORRECT_2_2 as libc::c_int;
        } else {
            if minOccurs > maxOccurs {
                xmlSchemaPCustomAttrErr(
                    ctxt,
                    XML_SCHEMAP_P_PROPS_CORRECT_2_1,
                    0 as *mut *mut xmlChar,
                    0 as xmlSchemaBasicItemPtr,
                    xmlSchemaGetPropNode(
                        node,
                        b"minOccurs\0" as *const u8 as *const libc::c_char,
                    ),
                    b"The value must not be greater than the value of 'maxOccurs'\0"
                        as *const u8 as *const libc::c_char,
                );
                return XML_SCHEMAP_P_PROPS_CORRECT_2_1 as libc::c_int;
            }
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaParseAny(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaParticlePtr {
    let mut particle: xmlSchemaParticlePtr = 0 as *mut xmlSchemaParticle;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut wild: xmlSchemaWildcardPtr = 0 as *mut xmlSchemaWildcard;
    let mut min: libc::c_int = 0;
    let mut max: libc::c_int = 0;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut annot: xmlSchemaAnnotPtr = 0 as xmlSchemaAnnotPtr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaParticlePtr;
    }
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"minOccurs\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"maxOccurs\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"namespace\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"processContents\0" as *const u8 as *const libc::c_char
                        as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    max = xmlGetMaxOccurs(
        ctxt,
        node,
        0 as libc::c_int,
        (1 as libc::c_int) << 30 as libc::c_int,
        1 as libc::c_int,
        b"(xs:nonNegativeInteger | unbounded)\0" as *const u8 as *const libc::c_char,
    );
    min = xmlGetMinOccurs(
        ctxt,
        node,
        0 as libc::c_int,
        -(1 as libc::c_int),
        1 as libc::c_int,
        b"xs:nonNegativeInteger\0" as *const u8 as *const libc::c_char,
    );
    xmlSchemaPCheckParticleCorrect_2(ctxt, 0 as xmlSchemaParticlePtr, node, min, max);
    wild = xmlSchemaAddWildcard(ctxt, schema, XML_SCHEMA_TYPE_ANY, node);
    if wild.is_null() {
        return 0 as xmlSchemaParticlePtr;
    }
    xmlSchemaParseWildcardNs(ctxt, schema, wild, node);
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        annot = xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int);
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?)\0" as *const u8 as *const libc::c_char,
        );
    }
    if min == 0 as libc::c_int && max == 0 as libc::c_int {
        return 0 as xmlSchemaParticlePtr;
    }
    particle = xmlSchemaAddParticle(ctxt, node, min, max);
    if particle.is_null() {
        return 0 as xmlSchemaParticlePtr;
    }
    let ref mut fresh98 = (*particle).annot;
    *fresh98 = annot;
    let ref mut fresh99 = (*particle).children;
    *fresh99 = wild as xmlSchemaTreeItemPtr;
    return particle;
}
unsafe extern "C" fn xmlSchemaParseNotation(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaNotationPtr {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut ret: xmlSchemaNotationPtr = 0 as *mut xmlSchemaNotation;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaNotationPtr;
    }
    name = xmlSchemaGetProp(ctxt, node, b"name\0" as *const u8 as *const libc::c_char);
    if name.is_null() {
        xmlSchemaPErr2(
            ctxt,
            node,
            child,
            XML_SCHEMAP_NOTATION_NO_NAME as libc::c_int,
            b"Notation has no name\n\0" as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return 0 as xmlSchemaNotationPtr;
    }
    ret = xmlSchemaAddNotation(ctxt, schema, name, (*ctxt).targetNamespace, node);
    if ret.is_null() {
        return 0 as xmlSchemaNotationPtr;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let ref mut fresh100 = (*ret).annot;
        *fresh100 = xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int);
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?)\0" as *const u8 as *const libc::c_char,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaParseAnyAttribute(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaWildcardPtr {
    let mut ret: xmlSchemaWildcardPtr = 0 as *mut xmlSchemaWildcard;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaWildcardPtr;
    }
    ret = xmlSchemaAddWildcard(ctxt, schema, XML_SCHEMA_TYPE_ANY_ATTRIBUTE, node);
    if ret.is_null() {
        return 0 as xmlSchemaWildcardPtr;
    }
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"namespace\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"processContents\0" as *const u8 as *const libc::c_char
                        as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    if xmlSchemaParseWildcardNs(ctxt, schema, ret, node) != 0 as libc::c_int {
        return 0 as xmlSchemaWildcardPtr;
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let ref mut fresh101 = (*ret).annot;
        *fresh101 = xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int);
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?)\0" as *const u8 as *const libc::c_char,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaParseLocalAttribute(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut uses: xmlSchemaItemListPtr,
    mut parentType: libc::c_int,
) -> xmlSchemaBasicItemPtr {
    let mut current_block: u64;
    let mut attrValue: *const xmlChar = 0 as *const xmlChar;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut ns: *const xmlChar = 0 as *const xmlChar;
    let mut use_0: xmlSchemaAttributeUsePtr = 0 as xmlSchemaAttributeUsePtr;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut tmpNs: *const xmlChar = 0 as *const xmlChar;
    let mut tmpName: *const xmlChar = 0 as *const xmlChar;
    let mut defValue: *const xmlChar = 0 as *const xmlChar;
    let mut isRef: libc::c_int = 0 as libc::c_int;
    let mut occurs: libc::c_int = 2 as libc::c_int;
    let mut nberrors: libc::c_int = 0;
    let mut hasForm: libc::c_int = 0 as libc::c_int;
    let mut defValueType: libc::c_int = 0 as libc::c_int;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaBasicItemPtr;
    }
    attr = xmlSchemaGetPropNode(node, b"ref\0" as *const u8 as *const libc::c_char);
    if !attr.is_null() {
        if xmlSchemaPValAttrNodeQName(
            pctxt,
            schema,
            0 as xmlSchemaBasicItemPtr,
            attr,
            &mut tmpNs,
            &mut tmpName,
        ) != 0 as libc::c_int
        {
            return 0 as xmlSchemaBasicItemPtr;
        }
        if xmlSchemaCheckReference(pctxt, schema, node, attr, tmpNs) != 0 as libc::c_int
        {
            return 0 as xmlSchemaBasicItemPtr;
        }
        isRef = 1 as libc::c_int;
    }
    nberrors = (*pctxt).nberrors;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if isRef != 0 {
                if xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) != 0
                {
                    xmlSchemaPValAttrNodeID(pctxt, attr);
                    current_block = 7049889939919688114;
                } else if xmlStrEqual(
                        (*attr).name,
                        b"ref\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    ) != 0
                    {
                    current_block = 7049889939919688114;
                } else {
                    current_block = 9007357115414505193;
                }
            } else if xmlStrEqual(
                    (*attr).name,
                    b"name\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) != 0
                {
                current_block = 7049889939919688114;
            } else if xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) != 0
                {
                xmlSchemaPValAttrNodeID(pctxt, attr);
                current_block = 7049889939919688114;
            } else if xmlStrEqual(
                    (*attr).name,
                    b"type\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) != 0
                {
                xmlSchemaPValAttrNodeQName(
                    pctxt,
                    schema,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                    &mut tmpNs,
                    &mut tmpName,
                );
                current_block = 7049889939919688114;
            } else if xmlStrEqual(
                    (*attr).name,
                    b"form\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) != 0
                {
                hasForm = 1 as libc::c_int;
                attrValue = xmlSchemaGetNodeContent(pctxt, attr as xmlNodePtr);
                if xmlStrEqual(
                    attrValue,
                    b"qualified\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) != 0
                {
                    ns = (*pctxt).targetNamespace;
                } else if xmlStrEqual(
                        attrValue,
                        b"unqualified\0" as *const u8 as *const libc::c_char
                            as *mut xmlChar,
                    ) == 0
                    {
                    xmlSchemaPSimpleTypeErr(
                        pctxt,
                        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                        0 as xmlSchemaBasicItemPtr,
                        attr as xmlNodePtr,
                        0 as xmlSchemaTypePtr,
                        b"(qualified | unqualified)\0" as *const u8
                            as *const libc::c_char,
                        attrValue,
                        0 as *const libc::c_char,
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                }
                current_block = 7049889939919688114;
            } else {
                current_block = 9007357115414505193;
            }
            match current_block {
                7049889939919688114 => {}
                _ => {
                    if xmlStrEqual(
                        (*attr).name,
                        b"use\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    ) != 0
                    {
                        attrValue = xmlSchemaGetNodeContent(pctxt, attr as xmlNodePtr);
                        if xmlStrEqual(
                            attrValue,
                            b"optional\0" as *const u8 as *const libc::c_char
                                as *mut xmlChar,
                        ) != 0
                        {
                            occurs = 2 as libc::c_int;
                        } else if xmlStrEqual(
                                attrValue,
                                b"prohibited\0" as *const u8 as *const libc::c_char
                                    as *mut xmlChar,
                            ) != 0
                            {
                            occurs = 0 as libc::c_int;
                        } else if xmlStrEqual(
                                attrValue,
                                b"required\0" as *const u8 as *const libc::c_char
                                    as *mut xmlChar,
                            ) != 0
                            {
                            occurs = 1 as libc::c_int;
                        } else {
                            xmlSchemaPSimpleTypeErr(
                                pctxt,
                                XML_SCHEMAP_INVALID_ATTR_USE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr,
                                0 as xmlSchemaTypePtr,
                                b"(optional | prohibited | required)\0" as *const u8
                                    as *const libc::c_char,
                                attrValue,
                                0 as *const libc::c_char,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        }
                        current_block = 7049889939919688114;
                    } else if xmlStrEqual(
                            (*attr).name,
                            b"default\0" as *const u8 as *const libc::c_char
                                as *mut xmlChar,
                        ) != 0
                        {
                        if !defValue.is_null() {
                            xmlSchemaPMutualExclAttrErr(
                                pctxt,
                                XML_SCHEMAP_SRC_ATTRIBUTE_1,
                                0 as xmlSchemaBasicItemPtr,
                                attr,
                                b"default\0" as *const u8 as *const libc::c_char,
                                b"fixed\0" as *const u8 as *const libc::c_char,
                            );
                        } else {
                            defValue = xmlSchemaGetNodeContent(
                                pctxt,
                                attr as xmlNodePtr,
                            );
                            defValueType = 1 as libc::c_int;
                        }
                        current_block = 7049889939919688114;
                    } else if xmlStrEqual(
                            (*attr).name,
                            b"fixed\0" as *const u8 as *const libc::c_char
                                as *mut xmlChar,
                        ) != 0
                        {
                        if !defValue.is_null() {
                            xmlSchemaPMutualExclAttrErr(
                                pctxt,
                                XML_SCHEMAP_SRC_ATTRIBUTE_1,
                                0 as xmlSchemaBasicItemPtr,
                                attr,
                                b"default\0" as *const u8 as *const libc::c_char,
                                b"fixed\0" as *const u8 as *const libc::c_char,
                            );
                        } else {
                            defValue = xmlSchemaGetNodeContent(
                                pctxt,
                                attr as xmlNodePtr,
                            );
                            defValueType = 2 as libc::c_int;
                        }
                        current_block = 7049889939919688114;
                    } else {
                        current_block = 981995395831942902;
                    }
                }
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) == 0 {
            current_block = 7049889939919688114;
        } else {
            current_block = 981995395831942902;
        }
        match current_block {
            981995395831942902 => {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
            _ => {}
        }
        attr = (*attr).next;
    }
    if defValueType == 1 as libc::c_int && occurs != 2 as libc::c_int {
        xmlSchemaPSimpleTypeErr(
            pctxt,
            XML_SCHEMAP_SRC_ATTRIBUTE_2,
            0 as xmlSchemaBasicItemPtr,
            node,
            0 as xmlSchemaTypePtr,
            b"(optional | prohibited | required)\0" as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
            b"The value of the attribute 'use' must be 'optional' if the attribute 'default' is present\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    if nberrors != (*pctxt).nberrors {
        return 0 as xmlSchemaBasicItemPtr;
    }
    if isRef == 0 {
        let mut attrDecl: xmlSchemaAttributePtr = 0 as *mut xmlSchemaAttribute;
        if hasForm == 0 && (*schema).flags & (1 as libc::c_int) << 1 as libc::c_int != 0
        {
            ns = (*pctxt).targetNamespace;
        }
        if xmlStrEqual(ns, xmlSchemaInstanceNs) != 0 {
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_NO_XSI,
                node,
                0 as xmlSchemaBasicItemPtr,
                b"The target namespace must not match '%s'\0" as *const u8
                    as *const libc::c_char,
                xmlSchemaInstanceNs,
                0 as *const xmlChar,
            );
        }
        attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const libc::c_char);
        if attr.is_null() {
            xmlSchemaPMissingAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"name\0" as *const u8 as *const libc::c_char,
                0 as *const libc::c_char,
            );
            return 0 as xmlSchemaBasicItemPtr;
        }
        if xmlSchemaPValAttrNode(
            pctxt,
            0 as xmlSchemaBasicItemPtr,
            attr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
            &mut name,
        ) != 0 as libc::c_int
        {
            return 0 as xmlSchemaBasicItemPtr;
        }
        if xmlStrEqual(
            name,
            b"xmlns\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        ) != 0
        {
            xmlSchemaPSimpleTypeErr(
                pctxt,
                XML_SCHEMAP_NO_XMLNS,
                0 as xmlSchemaBasicItemPtr,
                attr as xmlNodePtr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                0 as *const libc::c_char,
                0 as *const xmlChar,
                b"The value of the attribute must not match 'xmlns'\0" as *const u8
                    as *const libc::c_char,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return 0 as xmlSchemaBasicItemPtr;
        }
        if !(occurs == 0 as libc::c_int) {
            use_0 = xmlSchemaAddAttributeUse(pctxt, node);
            if use_0.is_null() {
                return 0 as xmlSchemaBasicItemPtr;
            }
            (*use_0).occurs = occurs;
            attrDecl = xmlSchemaAddAttribute(
                pctxt,
                schema,
                name,
                ns,
                node,
                0 as libc::c_int,
            );
            if attrDecl.is_null() {
                return 0 as xmlSchemaBasicItemPtr;
            }
            if !tmpName.is_null() {
                let ref mut fresh102 = (*attrDecl).typeName;
                *fresh102 = tmpName;
                let ref mut fresh103 = (*attrDecl).typeNs;
                *fresh103 = tmpNs;
            }
            let ref mut fresh104 = (*use_0).attrDecl;
            *fresh104 = attrDecl;
            if !defValue.is_null() {
                let ref mut fresh105 = (*attrDecl).defValue;
                *fresh105 = defValue;
                if defValueType == 2 as libc::c_int {
                    (*attrDecl).flags |= (1 as libc::c_int) << 9 as libc::c_int;
                }
            }
        }
    } else if occurs != 0 as libc::c_int {
        let mut ref_0: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
        use_0 = xmlSchemaAddAttributeUse(pctxt, node);
        if use_0.is_null() {
            return 0 as xmlSchemaBasicItemPtr;
        }
        xmlSchemaAddItemSize(
            &mut (*(*pctxt).constructor).pending,
            10 as libc::c_int,
            use_0 as *mut libc::c_void,
        );
        (*use_0).occurs = occurs;
        ref_0 = xmlSchemaNewQNameRef(pctxt, XML_SCHEMA_TYPE_ATTRIBUTE, tmpName, tmpNs);
        if ref_0.is_null() {
            return 0 as xmlSchemaBasicItemPtr;
        }
        let ref mut fresh106 = (*use_0).attrDecl;
        *fresh106 = ref_0 as xmlSchemaAttributePtr;
        if !defValue.is_null() {
            let ref mut fresh107 = (*use_0).defValue;
            *fresh107 = defValue;
        }
        if defValueType == 2 as libc::c_int {
            (*use_0).flags |= (1 as libc::c_int) << 0 as libc::c_int;
        }
    }
    child = (*node).children;
    if occurs == 0 as libc::c_int {
        let mut prohib: xmlSchemaAttributeUseProhibPtr = 0
            as *mut xmlSchemaAttributeUseProhib;
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            xmlSchemaParseAnnotation(pctxt, child, 0 as libc::c_int);
            child = (*child).next;
        }
        if !child.is_null() {
            xmlSchemaPContentErr(
                pctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const libc::c_char,
                b"(annotation?)\0" as *const u8 as *const libc::c_char,
            );
        }
        if parentType == XML_SCHEMA_TYPE_ATTRIBUTEGROUP as libc::c_int {
            xmlSchemaCustomWarning(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
                node,
                0 as xmlSchemaTypePtr,
                b"Skipping attribute use prohibition, since it is pointless inside an <attributeGroup>\0"
                    as *const u8 as *const libc::c_char,
                0 as *const xmlChar,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return 0 as xmlSchemaBasicItemPtr;
        } else {
            if parentType == XML_SCHEMA_TYPE_EXTENSION as libc::c_int {
                xmlSchemaCustomWarning(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
                    node,
                    0 as xmlSchemaTypePtr,
                    b"Skipping attribute use prohibition, since it is pointless when extending a type\0"
                        as *const u8 as *const libc::c_char,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
                return 0 as xmlSchemaBasicItemPtr;
            }
        }
        if isRef == 0 {
            tmpName = name;
            tmpNs = ns;
        }
        if !uses.is_null() {
            let mut i: libc::c_int = 0;
            i = 0 as libc::c_int;
            while i < (*uses).nbItems {
                use_0 = *((*uses).items).offset(i as isize) as xmlSchemaAttributeUsePtr;
                if (*use_0).type_0 as libc::c_uint
                    == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB as libc::c_int as libc::c_uint
                    && tmpName == (*(use_0 as xmlSchemaAttributeUseProhibPtr)).name
                    && tmpNs
                        == (*(use_0 as xmlSchemaAttributeUseProhibPtr)).targetNamespace
                {
                    let mut str: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaCustomWarning(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
                        node,
                        0 as xmlSchemaTypePtr,
                        b"Skipping duplicate attribute use prohibition '%s'\0"
                            as *const u8 as *const libc::c_char,
                        xmlSchemaFormatQName(&mut str, tmpNs, tmpName),
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                    if !str.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str as *mut libc::c_void);
                        str = 0 as *mut xmlChar;
                    }
                    return 0 as xmlSchemaBasicItemPtr;
                }
                i += 1;
            }
        }
        prohib = xmlSchemaAddAttributeUseProhib(pctxt);
        if prohib.is_null() {
            return 0 as xmlSchemaBasicItemPtr;
        }
        let ref mut fresh108 = (*prohib).node;
        *fresh108 = node;
        let ref mut fresh109 = (*prohib).name;
        *fresh109 = tmpName;
        let ref mut fresh110 = (*prohib).targetNamespace;
        *fresh110 = tmpNs;
        if isRef != 0 {
            xmlSchemaAddItemSize(
                &mut (*(*pctxt).constructor).pending,
                10 as libc::c_int,
                prohib as *mut libc::c_void,
            );
        }
        return prohib as xmlSchemaBasicItemPtr;
    } else {
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            let ref mut fresh111 = (*use_0).annot;
            *fresh111 = xmlSchemaParseAnnotation(pctxt, child, 1 as libc::c_int);
            child = (*child).next;
        }
        if isRef != 0 {
            if !child.is_null() {
                if !child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"simpleType\0" as *const u8 as *const libc::c_char
                            as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                {
                    xmlSchemaPContentErr(
                        pctxt,
                        XML_SCHEMAP_SRC_ATTRIBUTE_3_2,
                        0 as xmlSchemaBasicItemPtr,
                        node,
                        child,
                        0 as *const libc::c_char,
                        b"(annotation?)\0" as *const u8 as *const libc::c_char,
                    );
                } else {
                    xmlSchemaPContentErr(
                        pctxt,
                        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                        0 as xmlSchemaBasicItemPtr,
                        node,
                        child,
                        0 as *const libc::c_char,
                        b"(annotation?)\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
        } else {
            if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"simpleType\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
                if !((*(*use_0).attrDecl).typeName).is_null() {
                    xmlSchemaPContentErr(
                        pctxt,
                        XML_SCHEMAP_SRC_ATTRIBUTE_4,
                        0 as xmlSchemaBasicItemPtr,
                        node,
                        child,
                        b"The attribute 'type' and the <simpleType> child are mutually exclusive\0"
                            as *const u8 as *const libc::c_char,
                        0 as *const libc::c_char,
                    );
                } else {
                    let ref mut fresh112 = (*(*use_0).attrDecl).subtypes;
                    *fresh112 = xmlSchemaParseSimpleType(
                        pctxt,
                        schema,
                        child,
                        0 as libc::c_int,
                    );
                }
                child = (*child).next;
            }
            if !child.is_null() {
                xmlSchemaPContentErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    child,
                    0 as *const libc::c_char,
                    b"(annotation?, simpleType?)\0" as *const u8 as *const libc::c_char,
                );
            }
        }
    }
    return use_0 as xmlSchemaBasicItemPtr;
}
unsafe extern "C" fn xmlSchemaParseGlobalAttribute(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaAttributePtr {
    let mut attrValue: *const xmlChar = 0 as *const xmlChar;
    let mut ret: xmlSchemaAttributePtr = 0 as *mut xmlSchemaAttribute;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaAttributePtr;
    }
    attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const libc::c_char);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"name\0" as *const u8 as *const libc::c_char,
            0 as *const libc::c_char,
        );
        return 0 as xmlSchemaAttributePtr;
    }
    if xmlSchemaPValAttrNode(
        pctxt,
        0 as xmlSchemaBasicItemPtr,
        attr,
        xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
        &mut attrValue,
    ) != 0 as libc::c_int
    {
        return 0 as xmlSchemaAttributePtr;
    }
    if xmlStrEqual(
        attrValue,
        b"xmlns\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    ) != 0
    {
        xmlSchemaPSimpleTypeErr(
            pctxt,
            XML_SCHEMAP_NO_XMLNS,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
            0 as *const libc::c_char,
            0 as *const xmlChar,
            b"The value of the attribute must not match 'xmlns'\0" as *const u8
                as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return 0 as xmlSchemaAttributePtr;
    }
    if xmlStrEqual((*pctxt).targetNamespace, xmlSchemaInstanceNs) != 0 {
        xmlSchemaCustomErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_NO_XSI,
            node,
            0 as xmlSchemaBasicItemPtr,
            b"The target namespace must not match '%s'\0" as *const u8
                as *const libc::c_char,
            xmlSchemaInstanceNs,
            0 as *const xmlChar,
        );
    }
    ret = xmlSchemaAddAttribute(
        pctxt,
        schema,
        attrValue,
        (*pctxt).targetNamespace,
        node,
        1 as libc::c_int,
    );
    if ret.is_null() {
        return 0 as xmlSchemaAttributePtr;
    }
    (*ret).flags |= (1 as libc::c_int) << 0 as libc::c_int;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"default\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"fixed\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"name\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"type\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrQName(
        pctxt,
        schema,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"type\0" as *const u8 as *const libc::c_char,
        &mut (*ret).typeNs,
        &mut (*ret).typeName,
    );
    xmlSchemaPValAttrID(
        pctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    let ref mut fresh113 = (*ret).defValue;
    *fresh113 = xmlSchemaGetProp(
        pctxt,
        node,
        b"fixed\0" as *const u8 as *const libc::c_char,
    );
    if !((*ret).defValue).is_null() {
        (*ret).flags |= (1 as libc::c_int) << 9 as libc::c_int;
    }
    attr = xmlSchemaGetPropNode(node, b"default\0" as *const u8 as *const libc::c_char);
    if !attr.is_null() {
        if (*ret).flags & (1 as libc::c_int) << 9 as libc::c_int != 0 {
            xmlSchemaPMutualExclAttrErr(
                pctxt,
                XML_SCHEMAP_SRC_ATTRIBUTE_1,
                ret as xmlSchemaBasicItemPtr,
                attr,
                b"default\0" as *const u8 as *const libc::c_char,
                b"fixed\0" as *const u8 as *const libc::c_char,
            );
        } else {
            let ref mut fresh114 = (*ret).defValue;
            *fresh114 = xmlSchemaGetNodeContent(pctxt, attr as xmlNodePtr);
        }
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let ref mut fresh115 = (*ret).annot;
        *fresh115 = xmlSchemaParseAnnotation(pctxt, child, 1 as libc::c_int);
        child = (*child).next;
    }
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"simpleType\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        if !((*ret).typeName).is_null() {
            xmlSchemaPContentErr(
                pctxt,
                XML_SCHEMAP_SRC_ATTRIBUTE_4,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                b"The attribute 'type' and the <simpleType> child are mutually exclusive\0"
                    as *const u8 as *const libc::c_char,
                0 as *const libc::c_char,
            );
        } else {
            let ref mut fresh116 = (*ret).subtypes;
            *fresh116 = xmlSchemaParseSimpleType(pctxt, schema, child, 0 as libc::c_int);
        }
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            pctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?, simpleType?)\0" as *const u8 as *const libc::c_char,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaParseAttributeGroupRef(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaQNameRefPtr {
    let mut ret: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut refNs: *const xmlChar = 0 as *const xmlChar;
    let mut ref_0: *const xmlChar = 0 as *const xmlChar;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaQNameRefPtr;
    }
    attr = xmlSchemaGetPropNode(node, b"ref\0" as *const u8 as *const libc::c_char);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"ref\0" as *const u8 as *const libc::c_char,
            0 as *const libc::c_char,
        );
        return 0 as xmlSchemaQNameRefPtr;
    }
    xmlSchemaPValAttrNodeQName(
        pctxt,
        schema,
        0 as xmlSchemaBasicItemPtr,
        attr,
        &mut refNs,
        &mut ref_0,
    );
    if xmlSchemaCheckReference(pctxt, schema, node, attr, refNs) != 0 as libc::c_int {
        return 0 as xmlSchemaQNameRefPtr;
    }
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"ref\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        pctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaParseAnnotation(pctxt, child, 0 as libc::c_int);
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            pctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?)\0" as *const u8 as *const libc::c_char,
        );
    }
    if (*pctxt).isRedefine != 0 && !((*pctxt).redef).is_null()
        && (*(*(*pctxt).redef).item).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_ATTRIBUTEGROUP as libc::c_int as libc::c_uint
        && ref_0 == (*(*pctxt).redef).refName && refNs == (*(*pctxt).redef).refTargetNs
    {
        if (*pctxt).redefCounter != 0 as libc::c_int {
            let mut str: *mut xmlChar = 0 as *mut xmlChar;
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_SRC_REDEFINE,
                node,
                0 as xmlSchemaBasicItemPtr,
                b"The redefining attribute group definition '%s' must not contain more than one reference to the redefined definition\0"
                    as *const u8 as *const libc::c_char,
                xmlSchemaFormatQName(&mut str, refNs, ref_0),
                0 as *const xmlChar,
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
            return 0 as xmlSchemaQNameRefPtr;
        }
        let ref mut fresh117 = (*pctxt).redefCounter;
        *fresh117 += 1;
        ret = xmlSchemaNewQNameRef(pctxt, XML_SCHEMA_TYPE_ATTRIBUTEGROUP, ref_0, refNs);
        if ret.is_null() {
            return 0 as xmlSchemaQNameRefPtr;
        }
        let ref mut fresh118 = (*ret).node;
        *fresh118 = node;
        let ref mut fresh119 = (*(*pctxt).redef).reference;
        *fresh119 = ret as xmlSchemaBasicItemPtr;
    } else {
        ret = xmlSchemaNewQNameRef(pctxt, XML_SCHEMA_TYPE_ATTRIBUTEGROUP, ref_0, refNs);
        if ret.is_null() {
            return 0 as xmlSchemaQNameRefPtr;
        }
        let ref mut fresh120 = (*ret).node;
        *fresh120 = node;
        xmlSchemaAddItemSize(
            &mut (*(*pctxt).constructor).pending,
            10 as libc::c_int,
            ret as *mut libc::c_void,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaParseAttributeGroupDefinition(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaAttributeGroupPtr {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut ret: xmlSchemaAttributeGroupPtr = 0 as *mut xmlSchemaAttributeGroup;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut hasRefs: libc::c_int = 0 as libc::c_int;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const libc::c_char);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"name\0" as *const u8 as *const libc::c_char,
            0 as *const libc::c_char,
        );
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    if xmlSchemaPValAttrNode(
        pctxt,
        0 as xmlSchemaBasicItemPtr,
        attr,
        xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
        &mut name,
    ) != 0 as libc::c_int
    {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    ret = xmlSchemaAddAttributeGroupDefinition(
        pctxt,
        schema,
        name,
        (*pctxt).targetNamespace,
        node,
    );
    if ret.is_null() {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"name\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        pctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let ref mut fresh121 = (*ret).annot;
        *fresh121 = xmlSchemaParseAnnotation(pctxt, child, 1 as libc::c_int);
        child = (*child).next;
    }
    if xmlSchemaParseLocalAttributes(
        pctxt,
        schema,
        &mut child,
        &mut (*ret).attrUses as *mut *mut libc::c_void as *mut xmlSchemaItemListPtr,
        XML_SCHEMA_TYPE_ATTRIBUTEGROUP as libc::c_int,
        &mut hasRefs,
    ) == -(1 as libc::c_int)
    {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    if hasRefs != 0 {
        (*ret).flags |= (1 as libc::c_int) << 4 as libc::c_int;
    }
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"anyAttribute\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let ref mut fresh122 = (*ret).attributeWildcard;
        *fresh122 = xmlSchemaParseAnyAttribute(pctxt, schema, child);
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            pctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?, ((attribute | attributeGroup)*, anyAttribute?))\0"
                as *const u8 as *const libc::c_char,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaPValAttrFormDefault(
    mut value: *const xmlChar,
    mut flags: *mut libc::c_int,
    mut flagQualified: libc::c_int,
) -> libc::c_int {
    if xmlStrEqual(
        value,
        b"qualified\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    ) != 0
    {
        if *flags & flagQualified == 0 as libc::c_int {
            *flags |= flagQualified;
        }
    } else if xmlStrEqual(
            value,
            b"unqualified\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        ) == 0
        {
        return 1 as libc::c_int
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaPValAttrBlockFinal(
    mut value: *const xmlChar,
    mut flags: *mut libc::c_int,
    mut flagAll: libc::c_int,
    mut flagExtension: libc::c_int,
    mut flagRestriction: libc::c_int,
    mut flagSubstitution: libc::c_int,
    mut flagList: libc::c_int,
    mut flagUnion: libc::c_int,
) -> libc::c_int {
    let mut ret: libc::c_int = 0 as libc::c_int;
    if flags.is_null() || value.is_null() {
        return -(1 as libc::c_int);
    }
    if *value.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    if xmlStrEqual(value, b"#all\0" as *const u8 as *const libc::c_char as *mut xmlChar)
        != 0
    {
        if flagAll != -(1 as libc::c_int) {
            *flags |= flagAll;
        } else {
            if flagExtension != -(1 as libc::c_int) {
                *flags |= flagExtension;
            }
            if flagRestriction != -(1 as libc::c_int) {
                *flags |= flagRestriction;
            }
            if flagSubstitution != -(1 as libc::c_int) {
                *flags |= flagSubstitution;
            }
            if flagList != -(1 as libc::c_int) {
                *flags |= flagList;
            }
            if flagUnion != -(1 as libc::c_int) {
                *flags |= flagUnion;
            }
        }
    } else {
        let mut end: *const xmlChar = 0 as *const xmlChar;
        let mut cur: *const xmlChar = value;
        let mut item: *mut xmlChar = 0 as *mut xmlChar;
        loop {
            while *cur as libc::c_int == 0x20 as libc::c_int
                || 0x9 as libc::c_int <= *cur as libc::c_int
                    && *cur as libc::c_int <= 0xa as libc::c_int
                || *cur as libc::c_int == 0xd as libc::c_int
            {
                cur = cur.offset(1);
            }
            end = cur;
            while *end as libc::c_int != 0 as libc::c_int
                && !(*end as libc::c_int == 0x20 as libc::c_int
                    || 0x9 as libc::c_int <= *end as libc::c_int
                        && *end as libc::c_int <= 0xa as libc::c_int
                    || *end as libc::c_int == 0xd as libc::c_int)
            {
                end = end.offset(1);
            }
            if end == cur {
                break;
            }
            item = xmlStrndup(cur, end.offset_from(cur) as libc::c_long as libc::c_int);
            if xmlStrEqual(
                item,
                b"extension\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) != 0
            {
                if flagExtension != -(1 as libc::c_int) {
                    if *flags & flagExtension == 0 as libc::c_int {
                        *flags |= flagExtension;
                    }
                } else {
                    ret = 1 as libc::c_int;
                }
            } else if xmlStrEqual(
                    item,
                    b"restriction\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) != 0
                {
                if flagRestriction != -(1 as libc::c_int) {
                    if *flags & flagRestriction == 0 as libc::c_int {
                        *flags |= flagRestriction;
                    }
                } else {
                    ret = 1 as libc::c_int;
                }
            } else if xmlStrEqual(
                    item,
                    b"substitution\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) != 0
                {
                if flagSubstitution != -(1 as libc::c_int) {
                    if *flags & flagSubstitution == 0 as libc::c_int {
                        *flags |= flagSubstitution;
                    }
                } else {
                    ret = 1 as libc::c_int;
                }
            } else if xmlStrEqual(
                    item,
                    b"list\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) != 0
                {
                if flagList != -(1 as libc::c_int) {
                    if *flags & flagList == 0 as libc::c_int {
                        *flags |= flagList;
                    }
                } else {
                    ret = 1 as libc::c_int;
                }
            } else if xmlStrEqual(
                    item,
                    b"union\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) != 0
                {
                if flagUnion != -(1 as libc::c_int) {
                    if *flags & flagUnion == 0 as libc::c_int {
                        *flags |= flagUnion;
                    }
                } else {
                    ret = 1 as libc::c_int;
                }
            } else {
                ret = 1 as libc::c_int;
            }
            if !item.is_null() {
                xmlFree.expect("non-null function pointer")(item as *mut libc::c_void);
            }
            cur = end;
            if !(ret == 0 as libc::c_int && *cur as libc::c_int != 0 as libc::c_int) {
                break;
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaCheckCSelectorXPath(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut idc: xmlSchemaIDCPtr,
    mut selector: xmlSchemaIDCSelectPtr,
    mut attr: xmlAttrPtr,
    mut isField: libc::c_int,
) -> libc::c_int {
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    if selector.is_null() {
        xmlSchemaPErr(
            ctxt,
            (*idc).node,
            XML_SCHEMAP_INTERNAL as libc::c_int,
            b"Internal error: xmlSchemaCheckCSelectorXPath, the selector is not specified.\n\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return -(1 as libc::c_int);
    }
    if attr.is_null() {
        node = (*idc).node;
    } else {
        node = attr as xmlNodePtr;
    }
    if ((*selector).xpath).is_null() {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"The XPath expression of the selector is not valid\0" as *const u8
                as *const libc::c_char,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as libc::c_int;
    } else {
        let mut nsArray: *mut *const xmlChar = 0 as *mut *const xmlChar;
        let mut nsList: *mut xmlNsPtr = 0 as *mut xmlNsPtr;
        if attr.is_null() {
            nsList = 0 as *mut xmlNsPtr;
        } else {
            nsList = xmlGetNsList((*attr).doc, (*attr).parent);
        }
        if !nsList.is_null() {
            let mut i: libc::c_int = 0;
            let mut count: libc::c_int = 0 as libc::c_int;
            i = 0 as libc::c_int;
            while !(*nsList.offset(i as isize)).is_null() {
                count += 1;
                i += 1;
            }
            nsArray = xmlMalloc
                .expect(
                    "non-null function pointer",
                )(
                ((count * 2 as libc::c_int + 1 as libc::c_int) as libc::c_ulong)
                    .wrapping_mul(
                        ::std::mem::size_of::<*const xmlChar>() as libc::c_ulong,
                    ),
            ) as *mut *const xmlChar;
            if nsArray.is_null() {
                xmlSchemaPErrMemory(
                    ctxt,
                    b"allocating a namespace array\0" as *const u8
                        as *const libc::c_char,
                    0 as xmlNodePtr,
                );
                xmlFree.expect("non-null function pointer")(nsList as *mut libc::c_void);
                return -(1 as libc::c_int);
            }
            i = 0 as libc::c_int;
            while i < count {
                let ref mut fresh123 = *nsArray.offset((2 as libc::c_int * i) as isize);
                *fresh123 = (**nsList.offset(i as isize)).href;
                let ref mut fresh124 = *nsArray
                    .offset((2 as libc::c_int * i + 1 as libc::c_int) as isize);
                *fresh124 = (**nsList.offset(i as isize)).prefix;
                i += 1;
            }
            let ref mut fresh125 = *nsArray.offset((count * 2 as libc::c_int) as isize);
            *fresh125 = 0 as *const xmlChar;
            xmlFree.expect("non-null function pointer")(nsList as *mut libc::c_void);
        }
        if isField != 0 {
            let ref mut fresh126 = (*selector).xpathComp;
            *fresh126 = xmlPatterncompile(
                (*selector).xpath,
                0 as *mut xmlDict,
                XML_PATTERN_XSFIELD as libc::c_int,
                nsArray,
            ) as *mut libc::c_void;
        } else {
            let ref mut fresh127 = (*selector).xpathComp;
            *fresh127 = xmlPatterncompile(
                (*selector).xpath,
                0 as *mut xmlDict,
                XML_PATTERN_XSSEL as libc::c_int,
                nsArray,
            ) as *mut libc::c_void;
        }
        if !nsArray.is_null() {
            xmlFree
                .expect(
                    "non-null function pointer",
                )(nsArray as *mut *mut xmlChar as *mut libc::c_void);
        }
        if ((*selector).xpathComp).is_null() {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"The XPath expression '%s' could not be compiled\0" as *const u8
                    as *const libc::c_char,
                (*selector).xpath,
            );
            return XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaAddAnnotation(
    mut annItem: xmlSchemaAnnotItemPtr,
    mut annot: xmlSchemaAnnotPtr,
) -> xmlSchemaAnnotPtr {
    if annItem.is_null() || annot.is_null() {
        return 0 as xmlSchemaAnnotPtr;
    }
    match (*annItem).type_0 as libc::c_uint {
        14 => {
            let mut item: xmlSchemaElementPtr = annItem as xmlSchemaElementPtr;
            let mut cur: xmlSchemaAnnotPtr = (*item).annot;
            if ((*item).annot).is_null() {
                let ref mut fresh128 = (*item).annot;
                *fresh128 = annot;
                return annot;
            }
            cur = (*item).annot;
            if !((*cur).next).is_null() {
                cur = (*cur).next;
            }
            let ref mut fresh129 = (*cur).next;
            *fresh129 = annot;
        }
        15 => {
            let mut item_0: xmlSchemaAttributePtr = annItem as xmlSchemaAttributePtr;
            let mut cur_0: xmlSchemaAnnotPtr = (*item_0).annot;
            if ((*item_0).annot).is_null() {
                let ref mut fresh130 = (*item_0).annot;
                *fresh130 = annot;
                return annot;
            }
            cur_0 = (*item_0).annot;
            if !((*cur_0).next).is_null() {
                cur_0 = (*cur_0).next;
            }
            let ref mut fresh131 = (*cur_0).next;
            *fresh131 = annot;
        }
        21 | 2 => {
            let mut item_1: xmlSchemaWildcardPtr = annItem as xmlSchemaWildcardPtr;
            let mut cur_1: xmlSchemaAnnotPtr = (*item_1).annot;
            if ((*item_1).annot).is_null() {
                let ref mut fresh132 = (*item_1).annot;
                *fresh132 = annot;
                return annot;
            }
            cur_1 = (*item_1).annot;
            if !((*cur_1).next).is_null() {
                cur_1 = (*cur_1).next;
            }
            let ref mut fresh133 = (*cur_1).next;
            *fresh133 = annot;
        }
        25 | 23 | 24 | 22 => {
            let mut item_2: xmlSchemaAnnotItemPtr = annItem;
            let mut cur_2: xmlSchemaAnnotPtr = (*item_2).annot;
            if ((*item_2).annot).is_null() {
                let ref mut fresh134 = (*item_2).annot;
                *fresh134 = annot;
                return annot;
            }
            cur_2 = (*item_2).annot;
            if !((*cur_2).next).is_null() {
                cur_2 = (*cur_2).next;
            }
            let ref mut fresh135 = (*cur_2).next;
            *fresh135 = annot;
        }
        16 => {
            let mut item_3: xmlSchemaAttributeGroupPtr = annItem
                as xmlSchemaAttributeGroupPtr;
            let mut cur_3: xmlSchemaAnnotPtr = (*item_3).annot;
            if ((*item_3).annot).is_null() {
                let ref mut fresh136 = (*item_3).annot;
                *fresh136 = annot;
                return annot;
            }
            cur_3 = (*item_3).annot;
            if !((*cur_3).next).is_null() {
                cur_3 = (*cur_3).next;
            }
            let ref mut fresh137 = (*cur_3).next;
            *fresh137 = annot;
        }
        18 => {
            let mut item_4: xmlSchemaNotationPtr = annItem as xmlSchemaNotationPtr;
            let mut cur_4: xmlSchemaAnnotPtr = (*item_4).annot;
            if ((*item_4).annot).is_null() {
                let ref mut fresh138 = (*item_4).annot;
                *fresh138 = annot;
                return annot;
            }
            cur_4 = (*item_4).annot;
            if !((*cur_4).next).is_null() {
                cur_4 = (*cur_4).next;
            }
            let ref mut fresh139 = (*cur_4).next;
            *fresh139 = annot;
        }
        1000 | 1001 | 1002 | 1003 | 1004 | 1005 | 1006 | 1007 | 1008 | 1009 | 1010
        | 1011 => {
            let mut item_5: xmlSchemaFacetPtr = annItem as xmlSchemaFacetPtr;
            let mut cur_5: xmlSchemaAnnotPtr = (*item_5).annot;
            if ((*item_5).annot).is_null() {
                let ref mut fresh140 = (*item_5).annot;
                *fresh140 = annot;
                return annot;
            }
            cur_5 = (*item_5).annot;
            if !((*cur_5).next).is_null() {
                cur_5 = (*cur_5).next;
            }
            let ref mut fresh141 = (*cur_5).next;
            *fresh141 = annot;
        }
        4 | 5 => {
            let mut item_6: xmlSchemaTypePtr = annItem as xmlSchemaTypePtr;
            let mut cur_6: xmlSchemaAnnotPtr = (*item_6).annot;
            if ((*item_6).annot).is_null() {
                let ref mut fresh142 = (*item_6).annot;
                *fresh142 = annot;
                return annot;
            }
            cur_6 = (*item_6).annot;
            if !((*cur_6).next).is_null() {
                cur_6 = (*cur_6).next;
            }
            let ref mut fresh143 = (*cur_6).next;
            *fresh143 = annot;
        }
        17 => {
            let mut item_7: xmlSchemaModelGroupDefPtr = annItem
                as xmlSchemaModelGroupDefPtr;
            let mut cur_7: xmlSchemaAnnotPtr = (*item_7).annot;
            if ((*item_7).annot).is_null() {
                let ref mut fresh144 = (*item_7).annot;
                *fresh144 = annot;
                return annot;
            }
            cur_7 = (*item_7).annot;
            if !((*cur_7).next).is_null() {
                cur_7 = (*cur_7).next;
            }
            let ref mut fresh145 = (*cur_7).next;
            *fresh145 = annot;
        }
        6 | 7 | 8 => {
            let mut item_8: xmlSchemaModelGroupPtr = annItem as xmlSchemaModelGroupPtr;
            let mut cur_8: xmlSchemaAnnotPtr = (*item_8).annot;
            if ((*item_8).annot).is_null() {
                let ref mut fresh146 = (*item_8).annot;
                *fresh146 = annot;
                return annot;
            }
            cur_8 = (*item_8).annot;
            if !((*cur_8).next).is_null() {
                cur_8 = (*cur_8).next;
            }
            let ref mut fresh147 = (*cur_8).next;
            *fresh147 = annot;
        }
        _ => {
            xmlSchemaPCustomErr(
                0 as xmlSchemaParserCtxtPtr,
                XML_SCHEMAP_INTERNAL,
                0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"Internal error: xmlSchemaAddAnnotation, The item is not a annotated schema component\0"
                    as *const u8 as *const libc::c_char,
                0 as *const xmlChar,
            );
        }
    }
    return annot;
}
unsafe extern "C" fn xmlSchemaParseIDCSelectorAndField(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut idc: xmlSchemaIDCPtr,
    mut node: xmlNodePtr,
    mut isField: libc::c_int,
) -> xmlSchemaIDCSelectPtr {
    let mut item: xmlSchemaIDCSelectPtr = 0 as *mut xmlSchemaIDCSelect;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"xpath\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    item = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaIDCSelect>() as libc::c_ulong)
        as xmlSchemaIDCSelectPtr;
    if item.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating a 'selector' of an identity-constraint definition\0"
                as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaIDCSelectPtr;
    }
    memset(
        item as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaIDCSelect>() as libc::c_ulong,
    );
    attr = xmlSchemaGetPropNode(node, b"xpath\0" as *const u8 as *const libc::c_char);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"name\0" as *const u8 as *const libc::c_char,
            0 as *const libc::c_char,
        );
    } else {
        let ref mut fresh148 = (*item).xpath;
        *fresh148 = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
        if xmlSchemaCheckCSelectorXPath(ctxt, idc, item, attr, isField)
            == -(1 as libc::c_int)
        {
            xmlSchemaPErr(
                ctxt,
                attr as xmlNodePtr,
                XML_SCHEMAP_INTERNAL as libc::c_int,
                b"Internal error: xmlSchemaParseIDCSelectorAndField, validating the XPath expression of a IDC selector.\n\0"
                    as *const u8 as *const libc::c_char,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
        }
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaAddAnnotation(
            idc as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int),
        );
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?)\0" as *const u8 as *const libc::c_char,
        );
    }
    return item;
}
unsafe extern "C" fn xmlSchemaParseIDC(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut idcCategory: xmlSchemaTypeType,
    mut targetNamespace: *const xmlChar,
) -> xmlSchemaIDCPtr {
    let mut item: xmlSchemaIDCPtr = 0 as xmlSchemaIDCPtr;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut field: xmlSchemaIDCSelectPtr = 0 as xmlSchemaIDCSelectPtr;
    let mut lastField: xmlSchemaIDCSelectPtr = 0 as xmlSchemaIDCSelectPtr;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"name\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
                && (idcCategory as libc::c_uint
                    != XML_SCHEMA_TYPE_IDC_KEYREF as libc::c_int as libc::c_uint
                    || xmlStrEqual(
                        (*attr).name,
                        b"refer\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    ) == 0)
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const libc::c_char);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"name\0" as *const u8 as *const libc::c_char,
            0 as *const libc::c_char,
        );
        return 0 as xmlSchemaIDCPtr;
    } else {
        if xmlSchemaPValAttrNode(
            ctxt,
            0 as xmlSchemaBasicItemPtr,
            attr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
            &mut name,
        ) != 0 as libc::c_int
        {
            return 0 as xmlSchemaIDCPtr;
        }
    }
    item = xmlSchemaAddIDC(
        ctxt,
        schema,
        name,
        targetNamespace,
        idcCategory as libc::c_int,
        node,
    );
    if item.is_null() {
        return 0 as xmlSchemaIDCPtr;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    if idcCategory as libc::c_uint
        == XML_SCHEMA_TYPE_IDC_KEYREF as libc::c_int as libc::c_uint
    {
        attr = xmlSchemaGetPropNode(
            node,
            b"refer\0" as *const u8 as *const libc::c_char,
        );
        if attr.is_null() {
            xmlSchemaPMissingAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"refer\0" as *const u8 as *const libc::c_char,
                0 as *const libc::c_char,
            );
        } else {
            let ref mut fresh149 = (*item).ref_0;
            *fresh149 = xmlSchemaNewQNameRef(
                ctxt,
                XML_SCHEMA_TYPE_IDC_KEY,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            if ((*item).ref_0).is_null() {
                return 0 as xmlSchemaIDCPtr;
            }
            xmlSchemaPValAttrNodeQName(
                ctxt,
                schema,
                0 as xmlSchemaBasicItemPtr,
                attr,
                &mut (*(*item).ref_0).targetNamespace,
                &mut (*(*item).ref_0).name,
            );
            xmlSchemaCheckReference(
                ctxt,
                schema,
                node,
                attr,
                (*(*item).ref_0).targetNamespace,
            );
        }
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let ref mut fresh150 = (*item).annot;
        *fresh150 = xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int);
        child = (*child).next;
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            b"A child element is missing\0" as *const u8 as *const libc::c_char,
            b"(annotation?, (selector, field+))\0" as *const u8 as *const libc::c_char,
        );
    }
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"selector\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let ref mut fresh151 = (*item).selector;
        *fresh151 = xmlSchemaParseIDCSelectorAndField(
            ctxt,
            item,
            child,
            0 as libc::c_int,
        );
        child = (*child).next;
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"field\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            loop {
                field = xmlSchemaParseIDCSelectorAndField(
                    ctxt,
                    item,
                    child,
                    1 as libc::c_int,
                );
                if !field.is_null() {
                    (*field).index = (*item).nbFields;
                    let ref mut fresh152 = (*item).nbFields;
                    *fresh152 += 1;
                    if !lastField.is_null() {
                        let ref mut fresh153 = (*lastField).next;
                        *fresh153 = field;
                    } else {
                        let ref mut fresh154 = (*item).fields;
                        *fresh154 = field;
                    }
                    lastField = field;
                }
                child = (*child).next;
                if !(!child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"field\0" as *const u8 as *const libc::c_char as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0)
                {
                    break;
                }
            }
        } else {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const libc::c_char,
                b"(annotation?, (selector, field+))\0" as *const u8
                    as *const libc::c_char,
            );
        }
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?, (selector, field+))\0" as *const u8 as *const libc::c_char,
        );
    }
    return item;
}
unsafe extern "C" fn xmlSchemaParseElement(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut isElemRef: *mut libc::c_int,
    mut topLevel: libc::c_int,
) -> xmlSchemaBasicItemPtr {
    let mut current_block: u64;
    let mut decl: xmlSchemaElementPtr = 0 as xmlSchemaElementPtr;
    let mut particle: xmlSchemaParticlePtr = 0 as xmlSchemaParticlePtr;
    let mut annot: xmlSchemaAnnotPtr = 0 as xmlSchemaAnnotPtr;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut nameAttr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut min: libc::c_int = 0;
    let mut max: libc::c_int = 0;
    let mut isRef: libc::c_int = 0 as libc::c_int;
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaBasicItemPtr;
    }
    if !isElemRef.is_null() {
        *isElemRef = 0 as libc::c_int;
    }
    nameAttr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const libc::c_char);
    attr = xmlSchemaGetPropNode(node, b"ref\0" as *const u8 as *const libc::c_char);
    if topLevel != 0 || attr.is_null() {
        if nameAttr.is_null() {
            xmlSchemaPMissingAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"name\0" as *const u8 as *const libc::c_char,
                0 as *const libc::c_char,
            );
            return 0 as xmlSchemaBasicItemPtr;
        }
    } else {
        isRef = 1 as libc::c_int;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        annot = xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int);
        child = (*child).next;
    }
    if topLevel != 0 {
        current_block = 10380409671385728102;
    } else {
        min = xmlGetMinOccurs(
            ctxt,
            node,
            0 as libc::c_int,
            -(1 as libc::c_int),
            1 as libc::c_int,
            b"xs:nonNegativeInteger\0" as *const u8 as *const libc::c_char,
        );
        max = xmlGetMaxOccurs(
            ctxt,
            node,
            0 as libc::c_int,
            (1 as libc::c_int) << 30 as libc::c_int,
            1 as libc::c_int,
            b"(xs:nonNegativeInteger | unbounded)\0" as *const u8 as *const libc::c_char,
        );
        xmlSchemaPCheckParticleCorrect_2(
            ctxt,
            0 as xmlSchemaParticlePtr,
            node,
            min,
            max,
        );
        particle = xmlSchemaAddParticle(ctxt, node, min, max);
        if particle.is_null() {
            current_block = 6846348394768048216;
        } else if isRef != 0 {
            let mut refNs: *const xmlChar = 0 as *const xmlChar;
            let mut ref_0: *const xmlChar = 0 as *const xmlChar;
            let mut refer: xmlSchemaQNameRefPtr = 0 as xmlSchemaQNameRefPtr;
            if !isElemRef.is_null() {
                *isElemRef = 1 as libc::c_int;
            }
            xmlSchemaPValAttrNodeQName(
                ctxt,
                schema,
                0 as xmlSchemaBasicItemPtr,
                attr,
                &mut refNs,
                &mut ref_0,
            );
            xmlSchemaCheckReference(ctxt, schema, node, attr, refNs);
            if !nameAttr.is_null() {
                xmlSchemaPMutualExclAttrErr(
                    ctxt,
                    XML_SCHEMAP_SRC_ELEMENT_2_1,
                    0 as xmlSchemaBasicItemPtr,
                    nameAttr,
                    b"ref\0" as *const u8 as *const libc::c_char,
                    b"name\0" as *const u8 as *const libc::c_char,
                );
            }
            attr = (*node).properties;
            while !attr.is_null() {
                if ((*attr).ns).is_null() {
                    if xmlStrEqual(
                        (*attr).name,
                        b"ref\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    ) != 0
                        || xmlStrEqual(
                            (*attr).name,
                            b"name\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                        ) != 0
                        || xmlStrEqual(
                            (*attr).name,
                            b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                        ) != 0
                        || xmlStrEqual(
                            (*attr).name,
                            b"maxOccurs\0" as *const u8 as *const libc::c_char
                                as *mut xmlChar,
                        ) != 0
                        || xmlStrEqual(
                            (*attr).name,
                            b"minOccurs\0" as *const u8 as *const libc::c_char
                                as *mut xmlChar,
                        ) != 0
                    {
                        attr = (*attr).next;
                    } else {
                        xmlSchemaPCustomAttrErr(
                            ctxt,
                            XML_SCHEMAP_SRC_ELEMENT_2_2,
                            0 as *mut *mut xmlChar,
                            0 as xmlSchemaBasicItemPtr,
                            attr,
                            b"Only the attributes 'minOccurs', 'maxOccurs' and 'id' are allowed in addition to 'ref'\0"
                                as *const u8 as *const libc::c_char,
                        );
                        break;
                    }
                } else {
                    if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                        xmlSchemaPIllegalAttrErr(
                            ctxt,
                            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                            0 as xmlSchemaBasicItemPtr,
                            attr,
                        );
                    }
                    attr = (*attr).next;
                }
            }
            if !child.is_null() {
                xmlSchemaPContentErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    child,
                    0 as *const libc::c_char,
                    b"(annotation?)\0" as *const u8 as *const libc::c_char,
                );
            }
            if min == 0 as libc::c_int && max == 0 as libc::c_int {
                current_block = 6846348394768048216;
            } else {
                refer = xmlSchemaNewQNameRef(
                    ctxt,
                    XML_SCHEMA_TYPE_ELEMENT,
                    ref_0,
                    refNs,
                );
                if refer.is_null() {
                    current_block = 6846348394768048216;
                } else {
                    let ref mut fresh155 = (*particle).children;
                    *fresh155 = refer as xmlSchemaTreeItemPtr;
                    let ref mut fresh156 = (*particle).annot;
                    *fresh156 = annot;
                    xmlSchemaAddItemSize(
                        &mut (*(*ctxt).constructor).pending,
                        10 as libc::c_int,
                        particle as *mut libc::c_void,
                    );
                    return particle as xmlSchemaBasicItemPtr;
                }
            }
        } else {
            current_block = 10380409671385728102;
        }
    }
    match current_block {
        10380409671385728102 => {
            let mut ns: *const xmlChar = 0 as *const xmlChar;
            let mut fixed: *const xmlChar = 0 as *const xmlChar;
            let mut name: *const xmlChar = 0 as *const xmlChar;
            let mut attrValue: *const xmlChar = 0 as *const xmlChar;
            let mut curIDC: xmlSchemaIDCPtr = 0 as xmlSchemaIDCPtr;
            let mut lastIDC: xmlSchemaIDCPtr = 0 as xmlSchemaIDCPtr;
            if !(xmlSchemaPValAttrNode(
                ctxt,
                0 as xmlSchemaBasicItemPtr,
                nameAttr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                &mut name,
            ) != 0 as libc::c_int)
            {
                if topLevel != 0 {
                    ns = (*ctxt).targetNamespace;
                } else {
                    attr = xmlSchemaGetPropNode(
                        node,
                        b"form\0" as *const u8 as *const libc::c_char,
                    );
                    if !attr.is_null() {
                        attrValue = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if xmlStrEqual(
                            attrValue,
                            b"qualified\0" as *const u8 as *const libc::c_char
                                as *mut xmlChar,
                        ) != 0
                        {
                            ns = (*ctxt).targetNamespace;
                        } else if xmlStrEqual(
                                attrValue,
                                b"unqualified\0" as *const u8 as *const libc::c_char
                                    as *mut xmlChar,
                            ) == 0
                            {
                            xmlSchemaPSimpleTypeErr(
                                ctxt,
                                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr,
                                0 as xmlSchemaTypePtr,
                                b"(qualified | unqualified)\0" as *const u8
                                    as *const libc::c_char,
                                attrValue,
                                0 as *const libc::c_char,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        }
                    } else if (*schema).flags & (1 as libc::c_int) << 0 as libc::c_int
                            != 0
                        {
                        ns = (*ctxt).targetNamespace;
                    }
                }
                decl = xmlSchemaAddElement(ctxt, name, ns, node, topLevel);
                if !decl.is_null() {
                    attr = (*node).properties;
                    while !attr.is_null() {
                        if ((*attr).ns).is_null() {
                            if xmlStrEqual(
                                (*attr).name,
                                b"name\0" as *const u8 as *const libc::c_char
                                    as *mut xmlChar,
                            ) == 0
                                && xmlStrEqual(
                                    (*attr).name,
                                    b"type\0" as *const u8 as *const libc::c_char
                                        as *mut xmlChar,
                                ) == 0
                                && xmlStrEqual(
                                    (*attr).name,
                                    b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                                ) == 0
                                && xmlStrEqual(
                                    (*attr).name,
                                    b"default\0" as *const u8 as *const libc::c_char
                                        as *mut xmlChar,
                                ) == 0
                                && xmlStrEqual(
                                    (*attr).name,
                                    b"fixed\0" as *const u8 as *const libc::c_char
                                        as *mut xmlChar,
                                ) == 0
                                && xmlStrEqual(
                                    (*attr).name,
                                    b"block\0" as *const u8 as *const libc::c_char
                                        as *mut xmlChar,
                                ) == 0
                                && xmlStrEqual(
                                    (*attr).name,
                                    b"nillable\0" as *const u8 as *const libc::c_char
                                        as *mut xmlChar,
                                ) == 0
                            {
                                if topLevel == 0 as libc::c_int {
                                    if xmlStrEqual(
                                        (*attr).name,
                                        b"maxOccurs\0" as *const u8 as *const libc::c_char
                                            as *mut xmlChar,
                                    ) == 0
                                        && xmlStrEqual(
                                            (*attr).name,
                                            b"minOccurs\0" as *const u8 as *const libc::c_char
                                                as *mut xmlChar,
                                        ) == 0
                                        && xmlStrEqual(
                                            (*attr).name,
                                            b"form\0" as *const u8 as *const libc::c_char
                                                as *mut xmlChar,
                                        ) == 0
                                    {
                                        xmlSchemaPIllegalAttrErr(
                                            ctxt,
                                            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                            0 as xmlSchemaBasicItemPtr,
                                            attr,
                                        );
                                    }
                                } else if xmlStrEqual(
                                        (*attr).name,
                                        b"final\0" as *const u8 as *const libc::c_char
                                            as *mut xmlChar,
                                    ) == 0
                                        && xmlStrEqual(
                                            (*attr).name,
                                            b"abstract\0" as *const u8 as *const libc::c_char
                                                as *mut xmlChar,
                                        ) == 0
                                        && xmlStrEqual(
                                            (*attr).name,
                                            b"substitutionGroup\0" as *const u8 as *const libc::c_char
                                                as *mut xmlChar,
                                        ) == 0
                                    {
                                    xmlSchemaPIllegalAttrErr(
                                        ctxt,
                                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                        0 as xmlSchemaBasicItemPtr,
                                        attr,
                                    );
                                }
                            }
                        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                            xmlSchemaPIllegalAttrErr(
                                ctxt,
                                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                0 as xmlSchemaBasicItemPtr,
                                attr,
                            );
                        }
                        attr = (*attr).next;
                    }
                    if topLevel != 0 {
                        (*decl).flags |= (1 as libc::c_int) << 1 as libc::c_int;
                        (*decl).flags |= (1 as libc::c_int) << 5 as libc::c_int;
                        xmlSchemaPValAttrQName(
                            ctxt,
                            schema,
                            0 as xmlSchemaBasicItemPtr,
                            node,
                            b"substitutionGroup\0" as *const u8 as *const libc::c_char,
                            &mut (*decl).substGroupNs,
                            &mut (*decl).substGroup,
                        );
                        if xmlGetBooleanProp(
                            ctxt,
                            node,
                            b"abstract\0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int,
                        ) != 0
                        {
                            (*decl).flags |= (1 as libc::c_int) << 4 as libc::c_int;
                        }
                        attr = xmlSchemaGetPropNode(
                            node,
                            b"final\0" as *const u8 as *const libc::c_char,
                        );
                        if attr.is_null() {
                            if (*schema).flags & (1 as libc::c_int) << 2 as libc::c_int
                                != 0
                            {
                                (*decl).flags |= (1 as libc::c_int) << 15 as libc::c_int;
                            }
                            if (*schema).flags & (1 as libc::c_int) << 3 as libc::c_int
                                != 0
                            {
                                (*decl).flags |= (1 as libc::c_int) << 16 as libc::c_int;
                            }
                        } else {
                            attrValue = xmlSchemaGetNodeContent(
                                ctxt,
                                attr as xmlNodePtr,
                            );
                            if xmlSchemaPValAttrBlockFinal(
                                attrValue,
                                &mut (*decl).flags,
                                -(1 as libc::c_int),
                                (1 as libc::c_int) << 15 as libc::c_int,
                                (1 as libc::c_int) << 16 as libc::c_int,
                                -(1 as libc::c_int),
                                -(1 as libc::c_int),
                                -(1 as libc::c_int),
                            ) != 0 as libc::c_int
                            {
                                xmlSchemaPSimpleTypeErr(
                                    ctxt,
                                    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                    0 as xmlSchemaBasicItemPtr,
                                    attr as xmlNodePtr,
                                    0 as xmlSchemaTypePtr,
                                    b"(#all | List of (extension | restriction))\0" as *const u8
                                        as *const libc::c_char,
                                    attrValue,
                                    0 as *const libc::c_char,
                                    0 as *const xmlChar,
                                    0 as *const xmlChar,
                                );
                            }
                        }
                    }
                    attr = xmlSchemaGetPropNode(
                        node,
                        b"block\0" as *const u8 as *const libc::c_char,
                    );
                    if attr.is_null() {
                        if (*schema).flags & (1 as libc::c_int) << 7 as libc::c_int != 0
                        {
                            (*decl).flags |= (1 as libc::c_int) << 12 as libc::c_int;
                        }
                        if (*schema).flags & (1 as libc::c_int) << 6 as libc::c_int != 0
                        {
                            (*decl).flags |= (1 as libc::c_int) << 11 as libc::c_int;
                        }
                        if (*schema).flags & (1 as libc::c_int) << 8 as libc::c_int != 0
                        {
                            (*decl).flags |= (1 as libc::c_int) << 13 as libc::c_int;
                        }
                    } else {
                        attrValue = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if xmlSchemaPValAttrBlockFinal(
                            attrValue,
                            &mut (*decl).flags,
                            -(1 as libc::c_int),
                            (1 as libc::c_int) << 11 as libc::c_int,
                            (1 as libc::c_int) << 12 as libc::c_int,
                            (1 as libc::c_int) << 13 as libc::c_int,
                            -(1 as libc::c_int),
                            -(1 as libc::c_int),
                        ) != 0 as libc::c_int
                        {
                            xmlSchemaPSimpleTypeErr(
                                ctxt,
                                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr,
                                0 as xmlSchemaTypePtr,
                                b"(#all | List of (extension | restriction | substitution))\0"
                                    as *const u8 as *const libc::c_char,
                                attrValue,
                                0 as *const libc::c_char,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        }
                    }
                    if xmlGetBooleanProp(
                        ctxt,
                        node,
                        b"nillable\0" as *const u8 as *const libc::c_char,
                        0 as libc::c_int,
                    ) != 0
                    {
                        (*decl).flags |= (1 as libc::c_int) << 0 as libc::c_int;
                    }
                    attr = xmlSchemaGetPropNode(
                        node,
                        b"type\0" as *const u8 as *const libc::c_char,
                    );
                    if !attr.is_null() {
                        xmlSchemaPValAttrNodeQName(
                            ctxt,
                            schema,
                            0 as xmlSchemaBasicItemPtr,
                            attr,
                            &mut (*decl).namedTypeNs,
                            &mut (*decl).namedType,
                        );
                        xmlSchemaCheckReference(
                            ctxt,
                            schema,
                            node,
                            attr,
                            (*decl).namedTypeNs,
                        );
                    }
                    let ref mut fresh157 = (*decl).value;
                    *fresh157 = xmlSchemaGetProp(
                        ctxt,
                        node,
                        b"default\0" as *const u8 as *const libc::c_char,
                    );
                    attr = xmlSchemaGetPropNode(
                        node,
                        b"fixed\0" as *const u8 as *const libc::c_char,
                    );
                    if !attr.is_null() {
                        fixed = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if !((*decl).value).is_null() {
                            xmlSchemaPMutualExclAttrErr(
                                ctxt,
                                XML_SCHEMAP_SRC_ELEMENT_1,
                                0 as xmlSchemaBasicItemPtr,
                                attr,
                                b"default\0" as *const u8 as *const libc::c_char,
                                b"fixed\0" as *const u8 as *const libc::c_char,
                            );
                        } else {
                            (*decl).flags |= (1 as libc::c_int) << 3 as libc::c_int;
                            let ref mut fresh158 = (*decl).value;
                            *fresh158 = fixed;
                        }
                    }
                    if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"complexType\0" as *const u8 as *const libc::c_char
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                        if !((*decl).namedType).is_null() {
                            xmlSchemaPContentErr(
                                ctxt,
                                XML_SCHEMAP_SRC_ELEMENT_3,
                                0 as xmlSchemaBasicItemPtr,
                                node,
                                child,
                                b"The attribute 'type' and the <complexType> child are mutually exclusive\0"
                                    as *const u8 as *const libc::c_char,
                                0 as *const libc::c_char,
                            );
                        } else {
                            let ref mut fresh159 = (*decl).subtypes;
                            *fresh159 = xmlSchemaParseComplexType(
                                ctxt,
                                schema,
                                child,
                                0 as libc::c_int,
                            );
                        }
                        child = (*child).next;
                    } else if !child.is_null() && !((*child).ns).is_null()
                            && xmlStrEqual(
                                (*child).name,
                                b"simpleType\0" as *const u8 as *const libc::c_char
                                    as *const xmlChar,
                            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                        {
                        if !((*decl).namedType).is_null() {
                            xmlSchemaPContentErr(
                                ctxt,
                                XML_SCHEMAP_SRC_ELEMENT_3,
                                0 as xmlSchemaBasicItemPtr,
                                node,
                                child,
                                b"The attribute 'type' and the <simpleType> child are mutually exclusive\0"
                                    as *const u8 as *const libc::c_char,
                                0 as *const libc::c_char,
                            );
                        } else {
                            let ref mut fresh160 = (*decl).subtypes;
                            *fresh160 = xmlSchemaParseSimpleType(
                                ctxt,
                                schema,
                                child,
                                0 as libc::c_int,
                            );
                        }
                        child = (*child).next;
                    }
                    while !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"unique\0" as *const u8 as *const libc::c_char
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                        || !child.is_null() && !((*child).ns).is_null()
                            && xmlStrEqual(
                                (*child).name,
                                b"key\0" as *const u8 as *const libc::c_char
                                    as *const xmlChar,
                            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                        || !child.is_null() && !((*child).ns).is_null()
                            && xmlStrEqual(
                                (*child).name,
                                b"keyref\0" as *const u8 as *const libc::c_char
                                    as *const xmlChar,
                            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                        if !child.is_null() && !((*child).ns).is_null()
                            && xmlStrEqual(
                                (*child).name,
                                b"unique\0" as *const u8 as *const libc::c_char
                                    as *const xmlChar,
                            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                        {
                            curIDC = xmlSchemaParseIDC(
                                ctxt,
                                schema,
                                child,
                                XML_SCHEMA_TYPE_IDC_UNIQUE,
                                (*decl).targetNamespace,
                            );
                        } else if !child.is_null() && !((*child).ns).is_null()
                                && xmlStrEqual(
                                    (*child).name,
                                    b"key\0" as *const u8 as *const libc::c_char
                                        as *const xmlChar,
                                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                            {
                            curIDC = xmlSchemaParseIDC(
                                ctxt,
                                schema,
                                child,
                                XML_SCHEMA_TYPE_IDC_KEY,
                                (*decl).targetNamespace,
                            );
                        } else if !child.is_null() && !((*child).ns).is_null()
                                && xmlStrEqual(
                                    (*child).name,
                                    b"keyref\0" as *const u8 as *const libc::c_char
                                        as *const xmlChar,
                                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                            {
                            curIDC = xmlSchemaParseIDC(
                                ctxt,
                                schema,
                                child,
                                XML_SCHEMA_TYPE_IDC_KEYREF,
                                (*decl).targetNamespace,
                            );
                        }
                        if !lastIDC.is_null() {
                            let ref mut fresh161 = (*lastIDC).next;
                            *fresh161 = curIDC;
                        } else {
                            let ref mut fresh162 = (*decl).idcs;
                            *fresh162 = curIDC as *mut libc::c_void;
                        }
                        lastIDC = curIDC;
                        child = (*child).next;
                    }
                    if !child.is_null() {
                        xmlSchemaPContentErr(
                            ctxt,
                            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                            0 as xmlSchemaBasicItemPtr,
                            node,
                            child,
                            0 as *const libc::c_char,
                            b"(annotation?, ((simpleType | complexType)?, (unique | key | keyref)*))\0"
                                as *const u8 as *const libc::c_char,
                        );
                    }
                    let ref mut fresh163 = (*decl).annot;
                    *fresh163 = annot;
                    if !des.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(des as *mut libc::c_void);
                        des = 0 as *mut xmlChar;
                    }
                    if topLevel != 0 {
                        return decl as xmlSchemaBasicItemPtr
                    } else {
                        let ref mut fresh164 = (*particle).children;
                        *fresh164 = decl as xmlSchemaTreeItemPtr;
                        return particle as xmlSchemaBasicItemPtr;
                    }
                }
            }
        }
        _ => {}
    }
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
        des = 0 as *mut xmlChar;
    }
    if !annot.is_null() {
        if !particle.is_null() {
            let ref mut fresh165 = (*particle).annot;
            *fresh165 = 0 as xmlSchemaAnnotPtr;
        }
        if !decl.is_null() {
            let ref mut fresh166 = (*decl).annot;
            *fresh166 = 0 as xmlSchemaAnnotPtr;
        }
        xmlSchemaFreeAnnot(annot);
    }
    return 0 as xmlSchemaBasicItemPtr;
}
unsafe extern "C" fn xmlSchemaParseUnion(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> libc::c_int {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return -(1 as libc::c_int);
    }
    type_0 = (*ctxt).ctxtType;
    (*type_0).flags |= (1 as libc::c_int) << 7 as libc::c_int;
    let ref mut fresh167 = (*type_0).baseType;
    *fresh167 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"memberTypes\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    attr = xmlSchemaGetPropNode(
        node,
        b"memberTypes\0" as *const u8 as *const libc::c_char,
    );
    if !attr.is_null() {
        let mut end: *const xmlChar = 0 as *const xmlChar;
        let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
        let mut localName: *const xmlChar = 0 as *const xmlChar;
        let mut nsName: *const xmlChar = 0 as *const xmlChar;
        let mut link: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
        let mut lastLink: xmlSchemaTypeLinkPtr = 0 as xmlSchemaTypeLinkPtr;
        let mut ref_0: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
        cur = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
        let ref mut fresh168 = (*type_0).base;
        *fresh168 = cur;
        loop {
            while *cur as libc::c_int == 0x20 as libc::c_int
                || 0x9 as libc::c_int <= *cur as libc::c_int
                    && *cur as libc::c_int <= 0xa as libc::c_int
                || *cur as libc::c_int == 0xd as libc::c_int
            {
                cur = cur.offset(1);
            }
            end = cur;
            while *end as libc::c_int != 0 as libc::c_int
                && !(*end as libc::c_int == 0x20 as libc::c_int
                    || 0x9 as libc::c_int <= *end as libc::c_int
                        && *end as libc::c_int <= 0xa as libc::c_int
                    || *end as libc::c_int == 0xd as libc::c_int)
            {
                end = end.offset(1);
            }
            if end == cur {
                break;
            }
            tmp = xmlStrndup(cur, end.offset_from(cur) as libc::c_long as libc::c_int);
            if xmlSchemaPValAttrNodeQNameValue(
                ctxt,
                schema,
                0 as xmlSchemaBasicItemPtr,
                attr,
                tmp,
                &mut nsName,
                &mut localName,
            ) == 0 as libc::c_int
            {
                link = xmlMalloc
                    .expect(
                        "non-null function pointer",
                    )(::std::mem::size_of::<xmlSchemaTypeLink>() as libc::c_ulong)
                    as xmlSchemaTypeLinkPtr;
                if link.is_null() {
                    xmlSchemaPErrMemory(
                        ctxt,
                        b"xmlSchemaParseUnion, allocating a type link\0" as *const u8
                            as *const libc::c_char,
                        0 as xmlNodePtr,
                    );
                    return -(1 as libc::c_int);
                }
                let ref mut fresh169 = (*link).type_0;
                *fresh169 = 0 as xmlSchemaTypePtr;
                let ref mut fresh170 = (*link).next;
                *fresh170 = 0 as *mut _xmlSchemaTypeLink;
                if lastLink.is_null() {
                    let ref mut fresh171 = (*type_0).memberTypes;
                    *fresh171 = link;
                } else {
                    let ref mut fresh172 = (*lastLink).next;
                    *fresh172 = link;
                }
                lastLink = link;
                ref_0 = xmlSchemaNewQNameRef(
                    ctxt,
                    XML_SCHEMA_TYPE_SIMPLE,
                    localName,
                    nsName,
                );
                if ref_0.is_null() {
                    if !tmp.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(tmp as *mut libc::c_void);
                        tmp = 0 as *mut xmlChar;
                    }
                    return -(1 as libc::c_int);
                }
                let ref mut fresh173 = (*link).type_0;
                *fresh173 = ref_0 as xmlSchemaTypePtr;
            }
            if !tmp.is_null() {
                xmlFree.expect("non-null function pointer")(tmp as *mut libc::c_void);
                tmp = 0 as *mut xmlChar;
            }
            cur = end;
            if !(*cur as libc::c_int != 0 as libc::c_int) {
                break;
            }
        }
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int),
        );
        child = (*child).next;
    }
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"simpleType\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let mut subtype: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        let mut last: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
        while !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"simpleType\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            subtype = xmlSchemaParseSimpleType(ctxt, schema, child, 0 as libc::c_int);
            if !subtype.is_null() {
                if last.is_null() {
                    let ref mut fresh174 = (*type_0).subtypes;
                    *fresh174 = subtype;
                    last = subtype;
                } else {
                    let ref mut fresh175 = (*last).next;
                    *fresh175 = subtype;
                    last = subtype;
                }
                let ref mut fresh176 = (*last).next;
                *fresh176 = 0 as *mut _xmlSchemaType;
            }
            child = (*child).next;
        }
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?, simpleType*)\0" as *const u8 as *const libc::c_char,
        );
    }
    if attr.is_null() && ((*type_0).subtypes).is_null() {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"Either the attribute 'memberTypes' or at least one <simpleType> child must be present\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaParseList(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaTypePtr {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    type_0 = (*ctxt).ctxtType;
    (*type_0).flags |= (1 as libc::c_int) << 6 as libc::c_int;
    let ref mut fresh177 = (*type_0).baseType;
    *fresh177 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"itemType\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    xmlSchemaPValAttrQName(
        ctxt,
        schema,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"itemType\0" as *const u8 as *const libc::c_char,
        &mut (*type_0).baseNs,
        &mut (*type_0).base,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int),
        );
        child = (*child).next;
    }
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"simpleType\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        if !((*type_0).base).is_null() {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"The attribute 'itemType' and the <simpleType> child are mutually exclusive\0"
                    as *const u8 as *const libc::c_char,
                0 as *const xmlChar,
            );
        } else {
            let ref mut fresh178 = (*type_0).subtypes;
            *fresh178 = xmlSchemaParseSimpleType(ctxt, schema, child, 0 as libc::c_int);
        }
        child = (*child).next;
    } else if ((*type_0).base).is_null() {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"Either the attribute 'itemType' or the <simpleType> child must be present\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
        );
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?, simpleType?)\0" as *const u8 as *const libc::c_char,
        );
    }
    if ((*type_0).base).is_null() && ((*type_0).subtypes).is_null()
        && (xmlSchemaGetPropNode(
            node,
            b"itemType\0" as *const u8 as *const libc::c_char,
        ))
            .is_null()
    {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"Either the attribute 'itemType' or the <simpleType> child must be present\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
        );
    }
    return 0 as xmlSchemaTypePtr;
}
unsafe extern "C" fn xmlSchemaParseSimpleType(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut topLevel: libc::c_int,
) -> xmlSchemaTypePtr {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut oldCtxtType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attrValue: *const xmlChar = 0 as *const xmlChar;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut hasRestriction: libc::c_int = 0 as libc::c_int;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    if topLevel != 0 {
        attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const libc::c_char);
        if attr.is_null() {
            xmlSchemaPMissingAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"name\0" as *const u8 as *const libc::c_char,
                0 as *const libc::c_char,
            );
            return 0 as xmlSchemaTypePtr;
        } else {
            if xmlSchemaPValAttrNode(
                ctxt,
                0 as xmlSchemaBasicItemPtr,
                attr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                &mut attrValue,
            ) != 0 as libc::c_int
            {
                return 0 as xmlSchemaTypePtr;
            }
            if (*ctxt).isS4S != 0 {
                let mut biType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
                if (*ctxt).isRedefine != 0 {
                    xmlSchemaPCustomErr(
                        ctxt,
                        XML_SCHEMAP_SRC_REDEFINE,
                        0 as xmlSchemaBasicItemPtr,
                        node,
                        b"Redefinition of built-in simple types is not supported\0"
                            as *const u8 as *const libc::c_char,
                        0 as *const xmlChar,
                    );
                    return 0 as xmlSchemaTypePtr;
                }
                biType = xmlSchemaGetPredefinedType(attrValue, xmlSchemaNs);
                if !biType.is_null() {
                    return biType;
                }
            }
        }
    }
    if topLevel == 0 as libc::c_int {
        type_0 = xmlSchemaAddType(
            ctxt,
            schema,
            XML_SCHEMA_TYPE_SIMPLE,
            0 as *const xmlChar,
            (*ctxt).targetNamespace,
            node,
            0 as libc::c_int,
        );
        if type_0.is_null() {
            return 0 as xmlSchemaTypePtr;
        }
        (*type_0).type_0 = XML_SCHEMA_TYPE_SIMPLE;
        (*type_0).contentType = XML_SCHEMA_CONTENT_SIMPLE;
        attr = (*node).properties;
        while !attr.is_null() {
            if ((*attr).ns).is_null() {
                if xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
                {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        0 as xmlSchemaBasicItemPtr,
                        attr,
                    );
                }
            } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
            attr = (*attr).next;
        }
    } else {
        type_0 = xmlSchemaAddType(
            ctxt,
            schema,
            XML_SCHEMA_TYPE_SIMPLE,
            attrValue,
            (*ctxt).targetNamespace,
            node,
            1 as libc::c_int,
        );
        if type_0.is_null() {
            return 0 as xmlSchemaTypePtr;
        }
        (*type_0).type_0 = XML_SCHEMA_TYPE_SIMPLE;
        (*type_0).contentType = XML_SCHEMA_CONTENT_SIMPLE;
        (*type_0).flags |= (1 as libc::c_int) << 3 as libc::c_int;
        attr = (*node).properties;
        while !attr.is_null() {
            if ((*attr).ns).is_null() {
                if xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
                    && xmlStrEqual(
                        (*attr).name,
                        b"name\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    ) == 0
                    && xmlStrEqual(
                        (*attr).name,
                        b"final\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    ) == 0
                {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        0 as xmlSchemaBasicItemPtr,
                        attr,
                    );
                }
            } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
            attr = (*attr).next;
        }
        attr = xmlSchemaGetPropNode(
            node,
            b"final\0" as *const u8 as *const libc::c_char,
        );
        if attr.is_null() {
            if (*schema).flags & (1 as libc::c_int) << 3 as libc::c_int != 0 {
                (*type_0).flags |= (1 as libc::c_int) << 10 as libc::c_int;
            }
            if (*schema).flags & (1 as libc::c_int) << 4 as libc::c_int != 0 {
                (*type_0).flags |= (1 as libc::c_int) << 11 as libc::c_int;
            }
            if (*schema).flags & (1 as libc::c_int) << 5 as libc::c_int != 0 {
                (*type_0).flags |= (1 as libc::c_int) << 12 as libc::c_int;
            }
        } else {
            attrValue = xmlSchemaGetProp(
                ctxt,
                node,
                b"final\0" as *const u8 as *const libc::c_char,
            );
            if xmlSchemaPValAttrBlockFinal(
                attrValue,
                &mut (*type_0).flags,
                -(1 as libc::c_int),
                -(1 as libc::c_int),
                (1 as libc::c_int) << 10 as libc::c_int,
                -(1 as libc::c_int),
                (1 as libc::c_int) << 11 as libc::c_int,
                (1 as libc::c_int) << 12 as libc::c_int,
            ) != 0 as libc::c_int
            {
                xmlSchemaPSimpleTypeErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                    type_0 as xmlSchemaBasicItemPtr,
                    attr as xmlNodePtr,
                    0 as xmlSchemaTypePtr,
                    b"(#all | List of (list | union | restriction)\0" as *const u8
                        as *const libc::c_char,
                    attrValue,
                    0 as *const libc::c_char,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
            }
        }
    }
    let ref mut fresh179 = (*type_0).targetNamespace;
    *fresh179 = (*ctxt).targetNamespace;
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    oldCtxtType = (*ctxt).ctxtType;
    let ref mut fresh180 = (*ctxt).ctxtType;
    *fresh180 = type_0;
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let ref mut fresh181 = (*type_0).annot;
        *fresh181 = xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int);
        child = (*child).next;
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?, (restriction | list | union))\0" as *const u8
                as *const libc::c_char,
        );
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"restriction\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        xmlSchemaParseRestriction(ctxt, schema, child, XML_SCHEMA_TYPE_SIMPLE);
        hasRestriction = 1 as libc::c_int;
        child = (*child).next;
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"list\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        xmlSchemaParseList(ctxt, schema, child);
        child = (*child).next;
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"union\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        xmlSchemaParseUnion(ctxt, schema, child);
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?, (restriction | list | union))\0" as *const u8
                as *const libc::c_char,
        );
    }
    if topLevel != 0 && (*ctxt).isRedefine != 0 && hasRestriction == 0 {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_SRC_REDEFINE,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"This is a redefinition, thus the <simpleType> must have a <restriction> child\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
        );
    }
    let ref mut fresh182 = (*ctxt).ctxtType;
    *fresh182 = oldCtxtType;
    return type_0;
}
unsafe extern "C" fn xmlSchemaParseModelGroupDefRef(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaTreeItemPtr {
    let mut item: xmlSchemaParticlePtr = 0 as *mut xmlSchemaParticle;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut ref_0: *const xmlChar = 0 as *const xmlChar;
    let mut refNs: *const xmlChar = 0 as *const xmlChar;
    let mut min: libc::c_int = 0;
    let mut max: libc::c_int = 0;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTreeItemPtr;
    }
    attr = xmlSchemaGetPropNode(node, b"ref\0" as *const u8 as *const libc::c_char);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"ref\0" as *const u8 as *const libc::c_char,
            0 as *const libc::c_char,
        );
        return 0 as xmlSchemaTreeItemPtr;
    } else {
        if xmlSchemaPValAttrNodeQName(
            ctxt,
            schema,
            0 as xmlSchemaBasicItemPtr,
            attr,
            &mut refNs,
            &mut ref_0,
        ) != 0 as libc::c_int
        {
            return 0 as xmlSchemaTreeItemPtr;
        }
    }
    xmlSchemaCheckReference(ctxt, schema, node, attr, refNs);
    min = xmlGetMinOccurs(
        ctxt,
        node,
        0 as libc::c_int,
        -(1 as libc::c_int),
        1 as libc::c_int,
        b"xs:nonNegativeInteger\0" as *const u8 as *const libc::c_char,
    );
    max = xmlGetMaxOccurs(
        ctxt,
        node,
        0 as libc::c_int,
        (1 as libc::c_int) << 30 as libc::c_int,
        1 as libc::c_int,
        b"(xs:nonNegativeInteger | unbounded)\0" as *const u8 as *const libc::c_char,
    );
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"ref\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"minOccurs\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"maxOccurs\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    item = xmlSchemaAddParticle(ctxt, node, min, max);
    if item.is_null() {
        return 0 as xmlSchemaTreeItemPtr;
    }
    let ref mut fresh183 = (*item).children;
    *fresh183 = xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_GROUP, ref_0, refNs)
        as xmlSchemaTreeItemPtr;
    xmlSchemaPCheckParticleCorrect_2(ctxt, item, node, min, max);
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let ref mut fresh184 = (*item).annot;
        *fresh184 = xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int);
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?)\0" as *const u8 as *const libc::c_char,
        );
    }
    if min == 0 as libc::c_int && max == 0 as libc::c_int {
        return 0 as xmlSchemaTreeItemPtr;
    }
    return item as xmlSchemaTreeItemPtr;
}
unsafe extern "C" fn xmlSchemaParseModelGroupDefinition(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaModelGroupDefPtr {
    let mut item: xmlSchemaModelGroupDefPtr = 0 as *mut xmlSchemaModelGroupDef;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaModelGroupDefPtr;
    }
    attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const libc::c_char);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"name\0" as *const u8 as *const libc::c_char,
            0 as *const libc::c_char,
        );
        return 0 as xmlSchemaModelGroupDefPtr;
    } else {
        if xmlSchemaPValAttrNode(
            ctxt,
            0 as xmlSchemaBasicItemPtr,
            attr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
            &mut name,
        ) != 0 as libc::c_int
        {
            return 0 as xmlSchemaModelGroupDefPtr;
        }
    }
    item = xmlSchemaAddModelGroupDefinition(
        ctxt,
        schema,
        name,
        (*ctxt).targetNamespace,
        node,
    );
    if item.is_null() {
        return 0 as xmlSchemaModelGroupDefPtr;
    }
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"name\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let ref mut fresh185 = (*item).annot;
        *fresh185 = xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int);
        child = (*child).next;
    }
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"all\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let ref mut fresh186 = (*item).children;
        *fresh186 = xmlSchemaParseModelGroup(
            ctxt,
            schema,
            child,
            XML_SCHEMA_TYPE_ALL,
            0 as libc::c_int,
        );
        child = (*child).next;
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"choice\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        let ref mut fresh187 = (*item).children;
        *fresh187 = xmlSchemaParseModelGroup(
            ctxt,
            schema,
            child,
            XML_SCHEMA_TYPE_CHOICE,
            0 as libc::c_int,
        );
        child = (*child).next;
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"sequence\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        let ref mut fresh188 = (*item).children;
        *fresh188 = xmlSchemaParseModelGroup(
            ctxt,
            schema,
            child,
            XML_SCHEMA_TYPE_SEQUENCE,
            0 as libc::c_int,
        );
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?, (all | choice | sequence)?)\0" as *const u8
                as *const libc::c_char,
        );
    }
    return item;
}
unsafe extern "C" fn xmlSchemaCleanupDoc(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut root: xmlNodePtr,
) {
    let mut delete: xmlNodePtr = 0 as *mut xmlNode;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    if ctxt.is_null() || root.is_null() {
        return;
    }
    delete = 0 as xmlNodePtr;
    cur = root;
    let mut current_block_21: u64;
    while !cur.is_null() {
        if !delete.is_null() {
            xmlUnlinkNode(delete);
            xmlFreeNode(delete);
            delete = 0 as xmlNodePtr;
        }
        if (*cur).type_0 as libc::c_uint == XML_TEXT_NODE as libc::c_int as libc::c_uint
        {
            if (*cur).type_0 as libc::c_uint
                == XML_TEXT_NODE as libc::c_int as libc::c_uint
                && xmlSchemaIsBlank((*cur).content, -(1 as libc::c_int)) != 0
            {
                if xmlNodeGetSpacePreserve(cur as *const xmlNode) != 1 as libc::c_int {
                    delete = cur;
                }
            }
            current_block_21 = 5689001924483802034;
        } else if (*cur).type_0 as libc::c_uint
                != XML_ELEMENT_NODE as libc::c_int as libc::c_uint
                && (*cur).type_0 as libc::c_uint
                    != XML_CDATA_SECTION_NODE as libc::c_int as libc::c_uint
            {
            delete = cur;
            current_block_21 = 11313137364425335962;
        } else {
            current_block_21 = 5689001924483802034;
        }
        match current_block_21 {
            5689001924483802034 => {
                if !((*cur).children).is_null() {
                    if (*(*cur).children).type_0 as libc::c_uint
                        != XML_ENTITY_DECL as libc::c_int as libc::c_uint
                        && (*(*cur).children).type_0 as libc::c_uint
                            != XML_ENTITY_REF_NODE as libc::c_int as libc::c_uint
                        && (*(*cur).children).type_0 as libc::c_uint
                            != XML_ENTITY_NODE as libc::c_int as libc::c_uint
                    {
                        cur = (*cur).children;
                        continue;
                    }
                }
            }
            _ => {}
        }
        if !((*cur).next).is_null() {
            cur = (*cur).next;
        } else {
            loop {
                cur = (*cur).parent;
                if cur.is_null() {
                    break;
                }
                if cur == root {
                    cur = 0 as xmlNodePtr;
                    break;
                } else if !((*cur).next).is_null() {
                    cur = (*cur).next;
                    break;
                } else if cur.is_null() {
                    break;
                }
            }
        }
    }
    if !delete.is_null() {
        xmlUnlinkNode(delete);
        xmlFreeNode(delete);
        delete = 0 as xmlNodePtr;
    }
}
unsafe extern "C" fn xmlSchemaClearSchemaDefaults(mut schema: xmlSchemaPtr) {
    if (*schema).flags & (1 as libc::c_int) << 0 as libc::c_int != 0 {
        (*schema).flags ^= (1 as libc::c_int) << 0 as libc::c_int;
    }
    if (*schema).flags & (1 as libc::c_int) << 1 as libc::c_int != 0 {
        (*schema).flags ^= (1 as libc::c_int) << 1 as libc::c_int;
    }
    if (*schema).flags & (1 as libc::c_int) << 2 as libc::c_int != 0 {
        (*schema).flags ^= (1 as libc::c_int) << 2 as libc::c_int;
    }
    if (*schema).flags & (1 as libc::c_int) << 3 as libc::c_int != 0 {
        (*schema).flags ^= (1 as libc::c_int) << 3 as libc::c_int;
    }
    if (*schema).flags & (1 as libc::c_int) << 4 as libc::c_int != 0 {
        (*schema).flags ^= (1 as libc::c_int) << 4 as libc::c_int;
    }
    if (*schema).flags & (1 as libc::c_int) << 5 as libc::c_int != 0 {
        (*schema).flags ^= (1 as libc::c_int) << 5 as libc::c_int;
    }
    if (*schema).flags & (1 as libc::c_int) << 6 as libc::c_int != 0 {
        (*schema).flags ^= (1 as libc::c_int) << 6 as libc::c_int;
    }
    if (*schema).flags & (1 as libc::c_int) << 7 as libc::c_int != 0 {
        (*schema).flags ^= (1 as libc::c_int) << 7 as libc::c_int;
    }
    if (*schema).flags & (1 as libc::c_int) << 8 as libc::c_int != 0 {
        (*schema).flags ^= (1 as libc::c_int) << 8 as libc::c_int;
    }
}
unsafe extern "C" fn xmlSchemaParseSchemaElement(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> libc::c_int {
    let mut current_block: u64;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut val: *const xmlChar = 0 as *const xmlChar;
    let mut res: libc::c_int = 0 as libc::c_int;
    let mut oldErrs: libc::c_int = (*ctxt).nberrors;
    res = xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    if !(res == -(1 as libc::c_int)) {
        attr = xmlSchemaGetPropNode(
            node,
            b"targetNamespace\0" as *const u8 as *const libc::c_char,
        );
        if !attr.is_null() {
            res = xmlSchemaPValAttrNode(
                ctxt,
                0 as xmlSchemaBasicItemPtr,
                attr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
                0 as *mut *const xmlChar,
            );
            if res == -(1 as libc::c_int) {
                current_block = 10376413147378688457;
            } else if res != 0 as libc::c_int {
                (*ctxt).stop = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as libc::c_int;
                current_block = 6156756840313318511;
            } else {
                current_block = 5399440093318478209;
            }
        } else {
            current_block = 5399440093318478209;
        }
        match current_block {
            10376413147378688457 => {}
            _ => {
                match current_block {
                    5399440093318478209 => {
                        attr = xmlSchemaGetPropNode(
                            node,
                            b"elementFormDefault\0" as *const u8 as *const libc::c_char,
                        );
                        if !attr.is_null() {
                            val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                            res = xmlSchemaPValAttrFormDefault(
                                val,
                                &mut (*schema).flags,
                                (1 as libc::c_int) << 0 as libc::c_int,
                            );
                            if res == -(1 as libc::c_int) {
                                current_block = 10376413147378688457;
                            } else {
                                if res != 0 as libc::c_int {
                                    xmlSchemaPSimpleTypeErr(
                                        ctxt,
                                        XML_SCHEMAP_ELEMFORMDEFAULT_VALUE,
                                        0 as xmlSchemaBasicItemPtr,
                                        attr as xmlNodePtr,
                                        0 as xmlSchemaTypePtr,
                                        b"(qualified | unqualified)\0" as *const u8
                                            as *const libc::c_char,
                                        val,
                                        0 as *const libc::c_char,
                                        0 as *const xmlChar,
                                        0 as *const xmlChar,
                                    );
                                }
                                current_block = 224731115979188411;
                            }
                        } else {
                            current_block = 224731115979188411;
                        }
                        match current_block {
                            10376413147378688457 => {}
                            _ => {
                                attr = xmlSchemaGetPropNode(
                                    node,
                                    b"attributeFormDefault\0" as *const u8
                                        as *const libc::c_char,
                                );
                                if !attr.is_null() {
                                    val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                                    res = xmlSchemaPValAttrFormDefault(
                                        val,
                                        &mut (*schema).flags,
                                        (1 as libc::c_int) << 1 as libc::c_int,
                                    );
                                    if res == -(1 as libc::c_int) {
                                        current_block = 10376413147378688457;
                                    } else {
                                        if res != 0 as libc::c_int {
                                            xmlSchemaPSimpleTypeErr(
                                                ctxt,
                                                XML_SCHEMAP_ATTRFORMDEFAULT_VALUE,
                                                0 as xmlSchemaBasicItemPtr,
                                                attr as xmlNodePtr,
                                                0 as xmlSchemaTypePtr,
                                                b"(qualified | unqualified)\0" as *const u8
                                                    as *const libc::c_char,
                                                val,
                                                0 as *const libc::c_char,
                                                0 as *const xmlChar,
                                                0 as *const xmlChar,
                                            );
                                        }
                                        current_block = 5689316957504528238;
                                    }
                                } else {
                                    current_block = 5689316957504528238;
                                }
                                match current_block {
                                    10376413147378688457 => {}
                                    _ => {
                                        attr = xmlSchemaGetPropNode(
                                            node,
                                            b"finalDefault\0" as *const u8 as *const libc::c_char,
                                        );
                                        if !attr.is_null() {
                                            val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                                            res = xmlSchemaPValAttrBlockFinal(
                                                val,
                                                &mut (*schema).flags,
                                                -(1 as libc::c_int),
                                                (1 as libc::c_int) << 2 as libc::c_int,
                                                (1 as libc::c_int) << 3 as libc::c_int,
                                                -(1 as libc::c_int),
                                                (1 as libc::c_int) << 4 as libc::c_int,
                                                (1 as libc::c_int) << 5 as libc::c_int,
                                            );
                                            if res == -(1 as libc::c_int) {
                                                current_block = 10376413147378688457;
                                            } else {
                                                if res != 0 as libc::c_int {
                                                    xmlSchemaPSimpleTypeErr(
                                                        ctxt,
                                                        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                                        0 as xmlSchemaBasicItemPtr,
                                                        attr as xmlNodePtr,
                                                        0 as xmlSchemaTypePtr,
                                                        b"(#all | List of (extension | restriction | list | union))\0"
                                                            as *const u8 as *const libc::c_char,
                                                        val,
                                                        0 as *const libc::c_char,
                                                        0 as *const xmlChar,
                                                        0 as *const xmlChar,
                                                    );
                                                }
                                                current_block = 3123434771885419771;
                                            }
                                        } else {
                                            current_block = 3123434771885419771;
                                        }
                                        match current_block {
                                            10376413147378688457 => {}
                                            _ => {
                                                attr = xmlSchemaGetPropNode(
                                                    node,
                                                    b"blockDefault\0" as *const u8 as *const libc::c_char,
                                                );
                                                if !attr.is_null() {
                                                    val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                                                    res = xmlSchemaPValAttrBlockFinal(
                                                        val,
                                                        &mut (*schema).flags,
                                                        -(1 as libc::c_int),
                                                        (1 as libc::c_int) << 6 as libc::c_int,
                                                        (1 as libc::c_int) << 7 as libc::c_int,
                                                        (1 as libc::c_int) << 8 as libc::c_int,
                                                        -(1 as libc::c_int),
                                                        -(1 as libc::c_int),
                                                    );
                                                    if res == -(1 as libc::c_int) {
                                                        current_block = 10376413147378688457;
                                                    } else {
                                                        if res != 0 as libc::c_int {
                                                            xmlSchemaPSimpleTypeErr(
                                                                ctxt,
                                                                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                                                0 as xmlSchemaBasicItemPtr,
                                                                attr as xmlNodePtr,
                                                                0 as xmlSchemaTypePtr,
                                                                b"(#all | List of (extension | restriction | substitution))\0"
                                                                    as *const u8 as *const libc::c_char,
                                                                val,
                                                                0 as *const libc::c_char,
                                                                0 as *const xmlChar,
                                                                0 as *const xmlChar,
                                                            );
                                                        }
                                                        current_block = 6156756840313318511;
                                                    }
                                                } else {
                                                    current_block = 6156756840313318511;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
                match current_block {
                    10376413147378688457 => {}
                    _ => {
                        if oldErrs != (*ctxt).nberrors {
                            res = (*ctxt).err;
                        }
                        return res;
                    }
                }
            }
        }
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn xmlSchemaParseSchemaTopLevel(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut nodes: xmlNodePtr,
) -> libc::c_int {
    let mut current_block: u64;
    let mut child: xmlNodePtr = 0 as *mut xmlNode;
    let mut annot: xmlSchemaAnnotPtr = 0 as *mut xmlSchemaAnnot;
    let mut res: libc::c_int = 0 as libc::c_int;
    let mut oldErrs: libc::c_int = 0;
    let mut tmpOldErrs: libc::c_int = 0;
    if ctxt.is_null() || schema.is_null() || nodes.is_null() {
        return -(1 as libc::c_int);
    }
    oldErrs = (*ctxt).nberrors;
    child = nodes;
    loop {
        if !(!child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"include\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"import\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"redefine\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0)
        {
            current_block = 14832935472441733737;
            break;
        }
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            annot = xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int);
            if ((*schema).annot).is_null() {
                let ref mut fresh189 = (*schema).annot;
                *fresh189 = annot;
            } else {
                xmlSchemaFreeAnnot(annot);
            }
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"import\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            tmpOldErrs = (*ctxt).nberrors;
            res = xmlSchemaParseImport(ctxt, schema, child);
            if res == -(1 as libc::c_int) {
                current_block = 17833631497414332109;
                break;
            }
            if (*ctxt).stop != 0 {
                current_block = 5749571351303500870;
                break;
            }
            if tmpOldErrs != (*ctxt).nberrors {
                current_block = 5749571351303500870;
                break;
            }
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"include\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            tmpOldErrs = (*ctxt).nberrors;
            res = xmlSchemaParseInclude(ctxt, schema, child);
            if res == -(1 as libc::c_int) {
                current_block = 17833631497414332109;
                break;
            }
            if (*ctxt).stop != 0 {
                current_block = 5749571351303500870;
                break;
            }
            if tmpOldErrs != (*ctxt).nberrors {
                current_block = 5749571351303500870;
                break;
            }
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"redefine\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            tmpOldErrs = (*ctxt).nberrors;
            res = xmlSchemaParseRedefine(ctxt, schema, child);
            if res == -(1 as libc::c_int) {
                current_block = 17833631497414332109;
                break;
            }
            if (*ctxt).stop != 0 {
                current_block = 5749571351303500870;
                break;
            }
            if tmpOldErrs != (*ctxt).nberrors {
                current_block = 5749571351303500870;
                break;
            }
        }
        child = (*child).next;
    }
    match current_block {
        14832935472441733737 => {
            while !child.is_null() {
                if !child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"complexType\0" as *const u8 as *const libc::c_char
                            as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                {
                    xmlSchemaParseComplexType(ctxt, schema, child, 1 as libc::c_int);
                    child = (*child).next;
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"simpleType\0" as *const u8 as *const libc::c_char
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseSimpleType(ctxt, schema, child, 1 as libc::c_int);
                    child = (*child).next;
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"element\0" as *const u8 as *const libc::c_char
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseElement(
                        ctxt,
                        schema,
                        child,
                        0 as *mut libc::c_int,
                        1 as libc::c_int,
                    );
                    child = (*child).next;
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"attribute\0" as *const u8 as *const libc::c_char
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseGlobalAttribute(ctxt, schema, child);
                    child = (*child).next;
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"attributeGroup\0" as *const u8 as *const libc::c_char
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseAttributeGroupDefinition(ctxt, schema, child);
                    child = (*child).next;
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"group\0" as *const u8 as *const libc::c_char
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseModelGroupDefinition(ctxt, schema, child);
                    child = (*child).next;
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"notation\0" as *const u8 as *const libc::c_char
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseNotation(ctxt, schema, child);
                    child = (*child).next;
                } else {
                    xmlSchemaPContentErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                        0 as xmlSchemaBasicItemPtr,
                        (*child).parent,
                        child,
                        0 as *const libc::c_char,
                        b"((include | import | redefine | annotation)*, (((simpleType | complexType | group | attributeGroup) | element | attribute | notation), annotation*)*)\0"
                            as *const u8 as *const libc::c_char,
                    );
                    child = (*child).next;
                }
                while !child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"annotation\0" as *const u8 as *const libc::c_char
                            as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                {
                    annot = xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int);
                    if ((*schema).annot).is_null() {
                        let ref mut fresh190 = (*schema).annot;
                        *fresh190 = annot;
                    } else {
                        xmlSchemaFreeAnnot(annot);
                    }
                    child = (*child).next;
                }
            }
        }
        17833631497414332109 => return -(1 as libc::c_int),
        _ => {}
    }
    let ref mut fresh191 = (*ctxt).ctxtType;
    *fresh191 = 0 as xmlSchemaTypePtr;
    if oldErrs != (*ctxt).nberrors {
        res = (*ctxt).err;
    }
    return res;
}
unsafe extern "C" fn xmlSchemaSchemaRelationCreate() -> xmlSchemaSchemaRelationPtr {
    let mut ret: xmlSchemaSchemaRelationPtr = 0 as *mut xmlSchemaSchemaRelation;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaSchemaRelation>() as libc::c_ulong)
        as xmlSchemaSchemaRelationPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating schema relation\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaSchemaRelationPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaSchemaRelation>() as libc::c_ulong,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaRedefListFree(mut redef: xmlSchemaRedefPtr) {
    let mut prev: xmlSchemaRedefPtr = 0 as *mut xmlSchemaRedef;
    while !redef.is_null() {
        prev = redef;
        redef = (*redef).next;
        xmlFree.expect("non-null function pointer")(prev as *mut libc::c_void);
    }
}
unsafe extern "C" fn xmlSchemaConstructionCtxtFree(
    mut con: xmlSchemaConstructionCtxtPtr,
) {
    if !((*con).buckets).is_null() {
        xmlSchemaItemListFree((*con).buckets);
    }
    if !((*con).pending).is_null() {
        xmlSchemaItemListFree((*con).pending);
    }
    if !((*con).substGroups).is_null() {
        xmlHashFree(
            (*con).substGroups,
            Some(
                xmlSchemaSubstGroupFreeEntry
                    as unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
            ),
        );
    }
    if !((*con).redefs).is_null() {
        xmlSchemaRedefListFree((*con).redefs);
    }
    if !((*con).dict).is_null() {
        xmlDictFree((*con).dict);
    }
    xmlFree.expect("non-null function pointer")(con as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaConstructionCtxtCreate(
    mut dict: xmlDictPtr,
) -> xmlSchemaConstructionCtxtPtr {
    let mut ret: xmlSchemaConstructionCtxtPtr = 0 as *mut xmlSchemaConstructionCtxt;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaConstructionCtxt>() as libc::c_ulong)
        as xmlSchemaConstructionCtxtPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating schema construction context\0" as *const u8
                as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaConstructionCtxtPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaConstructionCtxt>() as libc::c_ulong,
    );
    let ref mut fresh192 = (*ret).buckets;
    *fresh192 = xmlSchemaItemListCreate();
    if ((*ret).buckets).is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating list of schema buckets\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void);
        return 0 as xmlSchemaConstructionCtxtPtr;
    }
    let ref mut fresh193 = (*ret).pending;
    *fresh193 = xmlSchemaItemListCreate();
    if ((*ret).pending).is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating list of pending global components\0" as *const u8
                as *const libc::c_char,
            0 as xmlNodePtr,
        );
        xmlSchemaConstructionCtxtFree(ret);
        return 0 as xmlSchemaConstructionCtxtPtr;
    }
    let ref mut fresh194 = (*ret).dict;
    *fresh194 = dict;
    xmlDictReference(dict);
    return ret;
}
unsafe extern "C" fn xmlSchemaParserCtxtCreate() -> xmlSchemaParserCtxtPtr {
    let mut ret: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaParserCtxt>() as libc::c_ulong)
        as xmlSchemaParserCtxtPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating schema parser context\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaParserCtxtPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaParserCtxt>() as libc::c_ulong,
    );
    (*ret).type_0 = 1 as libc::c_int;
    let ref mut fresh195 = (*ret).attrProhibs;
    *fresh195 = xmlSchemaItemListCreate();
    if ((*ret).attrProhibs).is_null() {
        xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void);
        return 0 as xmlSchemaParserCtxtPtr;
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaNewParserCtxtUseDict(
    mut URL: *const libc::c_char,
    mut dict: xmlDictPtr,
) -> xmlSchemaParserCtxtPtr {
    let mut ret: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    ret = xmlSchemaParserCtxtCreate();
    if ret.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    let ref mut fresh196 = (*ret).dict;
    *fresh196 = dict;
    xmlDictReference(dict);
    if !URL.is_null() {
        let ref mut fresh197 = (*ret).URL;
        *fresh197 = xmlDictLookup(dict, URL as *const xmlChar, -(1 as libc::c_int));
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaCreatePCtxtOnVCtxt(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> libc::c_int {
    if ((*vctxt).pctxt).is_null() {
        if !((*vctxt).schema).is_null() {
            let ref mut fresh198 = (*vctxt).pctxt;
            *fresh198 = xmlSchemaNewParserCtxtUseDict(
                b"*\0" as *const u8 as *const libc::c_char,
                (*(*vctxt).schema).dict,
            );
        } else {
            let ref mut fresh199 = (*vctxt).pctxt;
            *fresh199 = xmlSchemaNewParserCtxt(
                b"*\0" as *const u8 as *const libc::c_char,
            );
        }
        if ((*vctxt).pctxt).is_null() {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaCreatePCtxtOnVCtxt\0" as *const u8 as *const libc::c_char,
                b"failed to create a temp. parser context\0" as *const u8
                    as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        xmlSchemaSetParserErrors(
            (*vctxt).pctxt,
            (*vctxt).error,
            (*vctxt).warning,
            (*vctxt).errCtxt,
        );
        xmlSchemaSetParserStructuredErrors(
            (*vctxt).pctxt,
            (*vctxt).serror,
            (*vctxt).errCtxt,
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaGetSchemaBucket(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schemaLocation: *const xmlChar,
) -> xmlSchemaBucketPtr {
    let mut cur: xmlSchemaBucketPtr = 0 as *mut xmlSchemaBucket;
    let mut list: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    list = (*(*pctxt).constructor).buckets;
    if (*list).nbItems == 0 as libc::c_int {
        return 0 as xmlSchemaBucketPtr
    } else {
        let mut i: libc::c_int = 0;
        i = 0 as libc::c_int;
        while i < (*list).nbItems {
            cur = *((*list).items).offset(i as isize) as xmlSchemaBucketPtr;
            if (*cur).schemaLocation == schemaLocation {
                return cur;
            }
            i += 1;
        }
    }
    return 0 as xmlSchemaBucketPtr;
}
unsafe extern "C" fn xmlSchemaGetChameleonSchemaBucket(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schemaLocation: *const xmlChar,
    mut targetNamespace: *const xmlChar,
) -> xmlSchemaBucketPtr {
    let mut cur: xmlSchemaBucketPtr = 0 as *mut xmlSchemaBucket;
    let mut list: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    list = (*(*pctxt).constructor).buckets;
    if (*list).nbItems == 0 as libc::c_int {
        return 0 as xmlSchemaBucketPtr
    } else {
        let mut i: libc::c_int = 0;
        i = 0 as libc::c_int;
        while i < (*list).nbItems {
            cur = *((*list).items).offset(i as isize) as xmlSchemaBucketPtr;
            if ((*cur).origTargetNamespace).is_null()
                && (*cur).schemaLocation == schemaLocation
                && (*cur).targetNamespace == targetNamespace
            {
                return cur;
            }
            i += 1;
        }
    }
    return 0 as xmlSchemaBucketPtr;
}
unsafe extern "C" fn xmlSchemaGetSchemaBucketByTNS(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut targetNamespace: *const xmlChar,
    mut imported: libc::c_int,
) -> xmlSchemaBucketPtr {
    let mut cur: xmlSchemaBucketPtr = 0 as *mut xmlSchemaBucket;
    let mut list: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    list = (*(*pctxt).constructor).buckets;
    if (*list).nbItems == 0 as libc::c_int {
        return 0 as xmlSchemaBucketPtr
    } else {
        let mut i: libc::c_int = 0;
        i = 0 as libc::c_int;
        while i < (*list).nbItems {
            cur = *((*list).items).offset(i as isize) as xmlSchemaBucketPtr;
            if !(((*cur).doc).is_null() && !((*cur).schemaLocation).is_null())
                && (*cur).origTargetNamespace == targetNamespace
                && (imported != 0 && (*cur).imported != 0
                    || imported == 0 && (*cur).imported == 0)
            {
                return cur;
            }
            i += 1;
        }
    }
    return 0 as xmlSchemaBucketPtr;
}
unsafe extern "C" fn xmlSchemaParseNewDocWithContext(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut bucket: xmlSchemaBucketPtr,
) -> libc::c_int {
    let mut oldFlags: libc::c_int = 0;
    let mut oldDoc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut ret: libc::c_int = 0;
    let mut oldErrs: libc::c_int = 0;
    let mut oldbucket: xmlSchemaBucketPtr = (*(*pctxt).constructor).bucket;
    oldFlags = (*schema).flags;
    oldDoc = (*schema).doc;
    if (*schema).flags != 0 as libc::c_int {
        xmlSchemaClearSchemaDefaults(schema);
    }
    let ref mut fresh200 = (*schema).doc;
    *fresh200 = (*bucket).doc;
    let ref mut fresh201 = (*pctxt).schema;
    *fresh201 = schema;
    let ref mut fresh202 = (*pctxt).targetNamespace;
    *fresh202 = (*bucket).targetNamespace;
    let ref mut fresh203 = (*(*pctxt).constructor).bucket;
    *fresh203 = bucket;
    if !((*bucket).targetNamespace).is_null()
        && xmlStrEqual((*bucket).targetNamespace, xmlSchemaNs) != 0
    {
        (*pctxt).isS4S = 1 as libc::c_int;
    }
    let ref mut fresh204 = (*bucket).parsed;
    *fresh204 += 1;
    node = xmlDocGetRootElement((*bucket).doc as *const xmlDoc);
    ret = xmlSchemaParseSchemaElement(pctxt, schema, node);
    if !(ret != 0 as libc::c_int) {
        if !((*node).children).is_null() {
            oldErrs = (*pctxt).nberrors;
            ret = xmlSchemaParseSchemaTopLevel(pctxt, schema, (*node).children);
            if !(ret != 0 as libc::c_int) {
                if ret == 0 as libc::c_int && oldErrs != (*pctxt).nberrors {
                    ret = (*pctxt).err;
                }
            }
        }
    }
    let ref mut fresh205 = (*(*pctxt).constructor).bucket;
    *fresh205 = oldbucket;
    let ref mut fresh206 = (*schema).doc;
    *fresh206 = oldDoc;
    (*schema).flags = oldFlags;
    return ret;
}
unsafe extern "C" fn xmlSchemaParseNewDoc(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut bucket: xmlSchemaBucketPtr,
) -> libc::c_int {
    let mut newpctxt: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut res: libc::c_int = 0 as libc::c_int;
    if bucket.is_null() {
        return 0 as libc::c_int;
    }
    if (*bucket).parsed != 0 {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaParseNewDoc\0" as *const u8 as *const libc::c_char,
            b"reparsing a schema doc\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    if ((*bucket).doc).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaParseNewDoc\0" as *const u8 as *const libc::c_char,
            b"parsing a schema doc, but there's no doc\0" as *const u8
                as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    if ((*pctxt).constructor).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaParseNewDoc\0" as *const u8 as *const libc::c_char,
            b"no constructor\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    newpctxt = xmlSchemaNewParserCtxtUseDict(
        (*bucket).schemaLocation as *const libc::c_char,
        (*pctxt).dict,
    );
    if newpctxt.is_null() {
        return -(1 as libc::c_int);
    }
    let ref mut fresh207 = (*newpctxt).constructor;
    *fresh207 = (*pctxt).constructor;
    let ref mut fresh208 = (*newpctxt).schema;
    *fresh208 = schema;
    xmlSchemaSetParserErrors(
        newpctxt,
        (*pctxt).error,
        (*pctxt).warning,
        (*pctxt).errCtxt,
    );
    xmlSchemaSetParserStructuredErrors(newpctxt, (*pctxt).serror, (*pctxt).errCtxt);
    (*newpctxt).counter = (*pctxt).counter;
    res = xmlSchemaParseNewDocWithContext(newpctxt, schema, bucket);
    if res != 0 as libc::c_int {
        (*pctxt).err = res;
    }
    (*pctxt).nberrors += (*newpctxt).nberrors;
    (*pctxt).counter = (*newpctxt).counter;
    let ref mut fresh209 = (*newpctxt).constructor;
    *fresh209 = 0 as xmlSchemaConstructionCtxtPtr;
    xmlSchemaFreeParserCtxt(newpctxt);
    return res;
}
unsafe extern "C" fn xmlSchemaSchemaRelationAddChild(
    mut bucket: xmlSchemaBucketPtr,
    mut rel: xmlSchemaSchemaRelationPtr,
) {
    let mut cur: xmlSchemaSchemaRelationPtr = (*bucket).relations;
    if cur.is_null() {
        let ref mut fresh210 = (*bucket).relations;
        *fresh210 = rel;
        return;
    }
    while !((*cur).next).is_null() {
        cur = (*cur).next;
    }
    let ref mut fresh211 = (*cur).next;
    *fresh211 = rel;
}
unsafe extern "C" fn xmlSchemaBuildAbsoluteURI(
    mut dict: xmlDictPtr,
    mut location: *const xmlChar,
    mut ctxtNode: xmlNodePtr,
) -> *const xmlChar {
    if !location.is_null() {
        if ctxtNode.is_null() {
            return location
        } else {
            let mut base: *mut xmlChar = 0 as *mut xmlChar;
            let mut URI: *mut xmlChar = 0 as *mut xmlChar;
            let mut ret: *const xmlChar = 0 as *const xmlChar;
            base = xmlNodeGetBase((*ctxtNode).doc, ctxtNode as *const xmlNode);
            if base.is_null() {
                URI = xmlBuildURI(location, (*(*ctxtNode).doc).URL);
            } else {
                URI = xmlBuildURI(location, base);
                xmlFree.expect("non-null function pointer")(base as *mut libc::c_void);
            }
            if !URI.is_null() {
                ret = xmlDictLookup(dict, URI, -(1 as libc::c_int));
                xmlFree.expect("non-null function pointer")(URI as *mut libc::c_void);
                return ret;
            }
        }
    }
    return 0 as *const xmlChar;
}
unsafe extern "C" fn xmlSchemaAddSchemaDoc(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: libc::c_int,
    mut schemaLocation: *const xmlChar,
    mut schemaDoc: xmlDocPtr,
    mut schemaBuffer: *const libc::c_char,
    mut schemaBufferLen: libc::c_int,
    mut invokingNode: xmlNodePtr,
    mut sourceTargetNamespace: *const xmlChar,
    mut importNamespace: *const xmlChar,
    mut bucket: *mut xmlSchemaBucketPtr,
) -> libc::c_int {
    let mut current_block: u64;
    let mut targetNamespace: *const xmlChar = 0 as *const xmlChar;
    let mut relation: xmlSchemaSchemaRelationPtr = 0 as xmlSchemaSchemaRelationPtr;
    let mut doc: xmlDocPtr = 0 as xmlDocPtr;
    let mut res: libc::c_int = 0 as libc::c_int;
    let mut err: libc::c_int = 0 as libc::c_int;
    let mut located: libc::c_int = 0 as libc::c_int;
    let mut preserveDoc: libc::c_int = 0 as libc::c_int;
    let mut bkt: xmlSchemaBucketPtr = 0 as xmlSchemaBucketPtr;
    if !bucket.is_null() {
        *bucket = 0 as xmlSchemaBucketPtr;
    }
    match type_0 {
        1 | 0 => {
            err = XML_SCHEMAP_SRC_IMPORT as libc::c_int;
        }
        2 => {
            err = XML_SCHEMAP_SRC_INCLUDE as libc::c_int;
        }
        3 => {
            err = XML_SCHEMAP_SRC_REDEFINE as libc::c_int;
        }
        _ => {}
    }
    if type_0 == 0 as libc::c_int
        || !(!((*(*pctxt).constructor).buckets).is_null()
            && (*(*(*pctxt).constructor).buckets).nbItems > 0 as libc::c_int)
    {
        current_block = 13370431095695323903;
    } else {
        if !schemaLocation.is_null() {
            bkt = xmlSchemaGetSchemaBucket(pctxt, schemaLocation);
            if !bkt.is_null() && (*(*pctxt).constructor).bucket == bkt {
                xmlSchemaCustomErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    err as xmlParserErrors,
                    invokingNode,
                    0 as xmlSchemaBasicItemPtr,
                    b"The schema must not import/include/redefine itself\0" as *const u8
                        as *const libc::c_char,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
                current_block = 16820852522665970781;
            } else {
                current_block = 17833034027772472439;
            }
        } else {
            current_block = 17833034027772472439;
        }
        match current_block {
            16820852522665970781 => {}
            _ => {
                relation = xmlSchemaSchemaRelationCreate();
                if relation.is_null() {
                    return -(1 as libc::c_int);
                }
                xmlSchemaSchemaRelationAddChild(
                    (*(*pctxt).constructor).bucket,
                    relation,
                );
                (*relation).type_0 = type_0;
                if type_0 == 0 as libc::c_int || type_0 == 1 as libc::c_int {
                    let ref mut fresh212 = (*relation).importNamespace;
                    *fresh212 = importNamespace;
                    if schemaLocation.is_null() {
                        current_block = 16820852522665970781;
                    } else {
                        targetNamespace = importNamespace;
                        current_block = 7056779235015430508;
                    }
                } else {
                    current_block = 7056779235015430508;
                }
                match current_block {
                    16820852522665970781 => {}
                    _ => {
                        if !bkt.is_null() {
                            if (type_0 == 0 as libc::c_int || type_0 == 1 as libc::c_int)
                                && (*bkt).imported == 0
                            {
                                if schemaLocation.is_null() {
                                    schemaLocation = b"in_memory_buffer\0" as *const u8
                                        as *const libc::c_char as *mut xmlChar;
                                }
                                if xmlStrEqual(schemaLocation, (*bkt).schemaLocation) == 0 {
                                    xmlSchemaCustomErr(
                                        pctxt as xmlSchemaAbstractCtxtPtr,
                                        err as xmlParserErrors,
                                        invokingNode,
                                        0 as xmlSchemaBasicItemPtr,
                                        b"The schema document '%s' cannot be imported, since it was already included or redefined\0"
                                            as *const u8 as *const libc::c_char,
                                        schemaLocation,
                                        0 as *const xmlChar,
                                    );
                                    current_block = 16820852522665970781;
                                } else {
                                    current_block = 6450597802325118133;
                                }
                            } else if !(type_0 == 0 as libc::c_int
                                    || type_0 == 1 as libc::c_int) && (*bkt).imported != 0
                                {
                                if schemaLocation.is_null() {
                                    schemaLocation = b"in_memory_buffer\0" as *const u8
                                        as *const libc::c_char as *mut xmlChar;
                                }
                                if xmlStrEqual(schemaLocation, (*bkt).schemaLocation) == 0 {
                                    xmlSchemaCustomErr(
                                        pctxt as xmlSchemaAbstractCtxtPtr,
                                        err as xmlParserErrors,
                                        invokingNode,
                                        0 as xmlSchemaBasicItemPtr,
                                        b"The schema document '%s' cannot be included or redefined, since it was already imported\0"
                                            as *const u8 as *const libc::c_char,
                                        schemaLocation,
                                        0 as *const xmlChar,
                                    );
                                    current_block = 16820852522665970781;
                                } else {
                                    current_block = 6450597802325118133;
                                }
                            } else {
                                current_block = 6450597802325118133;
                            }
                        } else {
                            current_block = 6450597802325118133;
                        }
                        match current_block {
                            16820852522665970781 => {}
                            _ => {
                                if type_0 == 0 as libc::c_int || type_0 == 1 as libc::c_int
                                {
                                    if !bkt.is_null() {
                                        let ref mut fresh213 = (*relation).bucket;
                                        *fresh213 = bkt;
                                        current_block = 16820852522665970781;
                                    } else {
                                        bkt = xmlSchemaGetSchemaBucketByTNS(
                                            pctxt,
                                            importNamespace,
                                            1 as libc::c_int,
                                        );
                                        if !bkt.is_null() {
                                            let ref mut fresh214 = (*relation).bucket;
                                            *fresh214 = bkt;
                                            if ((*bkt).schemaLocation).is_null() {
                                                let ref mut fresh215 = (*bkt).schemaLocation;
                                                *fresh215 = schemaLocation;
                                                current_block = 8869332144787829186;
                                            } else {
                                                if xmlStrEqual(schemaLocation, (*bkt).schemaLocation) == 0 {
                                                    if schemaLocation.is_null() {
                                                        schemaLocation = b"in_memory_buffer\0" as *const u8
                                                            as *const libc::c_char as *mut xmlChar;
                                                    }
                                                    xmlSchemaCustomWarning(
                                                        pctxt as xmlSchemaAbstractCtxtPtr,
                                                        XML_SCHEMAP_WARN_SKIP_SCHEMA,
                                                        invokingNode,
                                                        0 as xmlSchemaTypePtr,
                                                        b"Skipping import of schema located at '%s' for the namespace '%s', since this namespace was already imported with the schema located at '%s'\0"
                                                            as *const u8 as *const libc::c_char,
                                                        schemaLocation,
                                                        importNamespace,
                                                        (*bkt).schemaLocation,
                                                    );
                                                }
                                                current_block = 16820852522665970781;
                                            }
                                        } else {
                                            current_block = 8869332144787829186;
                                        }
                                    }
                                } else if !bkt.is_null() {
                                    if ((*bkt).origTargetNamespace).is_null()
                                        && (*bkt).targetNamespace != sourceTargetNamespace
                                    {
                                        let mut chamel: xmlSchemaBucketPtr = 0
                                            as *mut xmlSchemaBucket;
                                        chamel = xmlSchemaGetChameleonSchemaBucket(
                                            pctxt,
                                            schemaLocation,
                                            sourceTargetNamespace,
                                        );
                                        if !chamel.is_null() {
                                            let ref mut fresh216 = (*relation).bucket;
                                            *fresh216 = chamel;
                                            current_block = 16820852522665970781;
                                        } else {
                                            bkt = 0 as xmlSchemaBucketPtr;
                                            current_block = 8869332144787829186;
                                        }
                                    } else {
                                        let ref mut fresh217 = (*relation).bucket;
                                        *fresh217 = bkt;
                                        current_block = 16820852522665970781;
                                    }
                                } else {
                                    current_block = 8869332144787829186;
                                }
                                match current_block {
                                    16820852522665970781 => {}
                                    _ => {
                                        if !bkt.is_null() && !((*bkt).doc).is_null() {
                                            xmlSchemaInternalErr(
                                                pctxt as xmlSchemaAbstractCtxtPtr,
                                                b"xmlSchemaAddSchemaDoc\0" as *const u8
                                                    as *const libc::c_char,
                                                b"trying to load a schema doc, but a doc is already assigned to the schema bucket\0"
                                                    as *const u8 as *const libc::c_char,
                                            );
                                            current_block = 1545328529343146367;
                                        } else {
                                            current_block = 13370431095695323903;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    match current_block {
        13370431095695323903 => {
            if !schemaDoc.is_null() {
                doc = schemaDoc;
                preserveDoc = 1 as libc::c_int;
                if !((*schemaDoc).URL).is_null() {
                    schemaLocation = xmlDictLookup(
                        (*pctxt).dict,
                        (*schemaDoc).URL,
                        -(1 as libc::c_int),
                    );
                } else {
                    schemaLocation = b"in_memory_buffer\0" as *const u8
                        as *const libc::c_char as *mut xmlChar;
                }
                current_block = 14851765859726653900;
            } else if !schemaLocation.is_null() || !schemaBuffer.is_null() {
                let mut parserCtxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
                parserCtxt = xmlNewParserCtxt();
                if parserCtxt.is_null() {
                    xmlSchemaPErrMemory(
                        0 as xmlSchemaParserCtxtPtr,
                        b"xmlSchemaGetDoc, allocating a parser context\0" as *const u8
                            as *const libc::c_char,
                        0 as xmlNodePtr,
                    );
                    current_block = 1545328529343146367;
                } else {
                    if !((*pctxt).dict).is_null() && !((*parserCtxt).dict).is_null() {
                        xmlDictFree((*parserCtxt).dict);
                        let ref mut fresh218 = (*parserCtxt).dict;
                        *fresh218 = (*pctxt).dict;
                        xmlDictReference((*parserCtxt).dict);
                    }
                    if !schemaLocation.is_null() {
                        doc = xmlCtxtReadFile(
                            parserCtxt,
                            schemaLocation as *const libc::c_char,
                            0 as *const libc::c_char,
                            XML_PARSE_NOENT as libc::c_int,
                        );
                    } else if !schemaBuffer.is_null() {
                        doc = xmlCtxtReadMemory(
                            parserCtxt,
                            schemaBuffer,
                            schemaBufferLen,
                            0 as *const libc::c_char,
                            0 as *const libc::c_char,
                            XML_PARSE_NOENT as libc::c_int,
                        );
                        schemaLocation = b"in_memory_buffer\0" as *const u8
                            as *const libc::c_char as *mut xmlChar;
                        if !doc.is_null() {
                            let ref mut fresh219 = (*doc).URL;
                            *fresh219 = xmlStrdup(schemaLocation);
                        }
                    }
                    if doc.is_null() {
                        let mut lerr: xmlErrorPtr = 0 as *mut xmlError;
                        lerr = xmlGetLastError();
                        if lerr.is_null() || (*lerr).domain != XML_FROM_IO as libc::c_int
                        {
                            located = 1 as libc::c_int;
                            res = XML_SCHEMAP_SRC_IMPORT_2_1 as libc::c_int;
                            xmlSchemaCustomErr(
                                pctxt as xmlSchemaAbstractCtxtPtr,
                                res as xmlParserErrors,
                                invokingNode,
                                0 as xmlSchemaBasicItemPtr,
                                b"Failed to parse the XML resource '%s'\0" as *const u8
                                    as *const libc::c_char,
                                schemaLocation,
                                0 as *const xmlChar,
                            );
                        }
                    }
                    xmlFreeParserCtxt(parserCtxt);
                    if doc.is_null() && located != 0 {
                        current_block = 5528773336718582786;
                    } else {
                        current_block = 14851765859726653900;
                    }
                }
            } else {
                xmlSchemaPErr(
                    pctxt,
                    0 as xmlNodePtr,
                    XML_SCHEMAP_NOTHING_TO_PARSE as libc::c_int,
                    b"No information for parsing was provided with the given schema parser context.\n\0"
                        as *const u8 as *const libc::c_char,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
                current_block = 1545328529343146367;
            }
            match current_block {
                1545328529343146367 => {}
                _ => {
                    match current_block {
                        14851765859726653900 => {
                            if !doc.is_null() {
                                let mut docElem: xmlNodePtr = 0 as xmlNodePtr;
                                located = 1 as libc::c_int;
                                docElem = xmlDocGetRootElement(doc as *const xmlDoc);
                                if docElem.is_null() {
                                    xmlSchemaCustomErr(
                                        pctxt as xmlSchemaAbstractCtxtPtr,
                                        XML_SCHEMAP_NOROOT,
                                        invokingNode,
                                        0 as xmlSchemaBasicItemPtr,
                                        b"The document '%s' has no document element\0" as *const u8
                                            as *const libc::c_char,
                                        schemaLocation,
                                        0 as *const xmlChar,
                                    );
                                    current_block = 5528773336718582786;
                                } else {
                                    xmlSchemaCleanupDoc(pctxt, docElem);
                                    if !(!docElem.is_null() && !((*docElem).ns).is_null()
                                        && xmlStrEqual(
                                            (*docElem).name,
                                            b"schema\0" as *const u8 as *const libc::c_char
                                                as *const xmlChar,
                                        ) != 0
                                        && xmlStrEqual((*(*docElem).ns).href, xmlSchemaNs) != 0)
                                    {
                                        xmlSchemaCustomErr(
                                            pctxt as xmlSchemaAbstractCtxtPtr,
                                            XML_SCHEMAP_NOT_SCHEMA,
                                            invokingNode,
                                            0 as xmlSchemaBasicItemPtr,
                                            b"The XML document '%s' is not a schema document\0"
                                                as *const u8 as *const libc::c_char,
                                            schemaLocation,
                                            0 as *const xmlChar,
                                        );
                                        current_block = 5528773336718582786;
                                    } else {
                                        targetNamespace = xmlSchemaGetProp(
                                            pctxt,
                                            docElem,
                                            b"targetNamespace\0" as *const u8 as *const libc::c_char,
                                        );
                                        current_block = 2956972668325154207;
                                    }
                                }
                            } else {
                                current_block = 2956972668325154207;
                            }
                            match current_block {
                                5528773336718582786 => {}
                                _ => {
                                    if bkt.is_null() && located != 0 {
                                        bkt = xmlSchemaBucketCreate(pctxt, type_0, targetNamespace);
                                        if bkt.is_null() {
                                            current_block = 1545328529343146367;
                                        } else {
                                            current_block = 13505557363059842426;
                                        }
                                    } else {
                                        current_block = 13505557363059842426;
                                    }
                                    match current_block {
                                        1545328529343146367 => {}
                                        _ => {
                                            if !bkt.is_null() {
                                                let ref mut fresh220 = (*bkt).schemaLocation;
                                                *fresh220 = schemaLocation;
                                                (*bkt).located = located;
                                                if !doc.is_null() {
                                                    let ref mut fresh221 = (*bkt).doc;
                                                    *fresh221 = doc;
                                                    let ref mut fresh222 = (*bkt).targetNamespace;
                                                    *fresh222 = targetNamespace;
                                                    let ref mut fresh223 = (*bkt).origTargetNamespace;
                                                    *fresh223 = targetNamespace;
                                                    if preserveDoc != 0 {
                                                        (*bkt).preserveDoc = 1 as libc::c_int;
                                                    }
                                                }
                                                if type_0 == 0 as libc::c_int || type_0 == 1 as libc::c_int
                                                {
                                                    let ref mut fresh224 = (*bkt).imported;
                                                    *fresh224 += 1;
                                                }
                                                if !relation.is_null() {
                                                    let ref mut fresh225 = (*relation).bucket;
                                                    *fresh225 = bkt;
                                                }
                                            }
                                            current_block = 16820852522665970781;
                                        }
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        16820852522665970781 => {}
                        1545328529343146367 => {}
                        _ => {
                            if !doc.is_null() && preserveDoc == 0 {
                                xmlFreeDoc(doc);
                                if !bkt.is_null() {
                                    let ref mut fresh226 = (*bkt).doc;
                                    *fresh226 = 0 as xmlDocPtr;
                                }
                            }
                            return (*pctxt).err;
                        }
                    }
                }
            }
        }
        _ => {}
    }
    match current_block {
        1545328529343146367 => {
            if !doc.is_null() && preserveDoc == 0 {
                xmlFreeDoc(doc);
                if !bkt.is_null() {
                    let ref mut fresh227 = (*bkt).doc;
                    *fresh227 = 0 as xmlDocPtr;
                }
            }
            return -(1 as libc::c_int);
        }
        _ => {
            if !bucket.is_null() {
                *bucket = bkt;
            }
            return 0 as libc::c_int;
        }
    };
}
unsafe extern "C" fn xmlSchemaParseImport(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> libc::c_int {
    let mut child: xmlNodePtr = 0 as *mut xmlNode;
    let mut namespaceName: *const xmlChar = 0 as *const xmlChar;
    let mut schemaLocation: *const xmlChar = 0 as *const xmlChar;
    let mut thisTargetNamespace: *const xmlChar = 0 as *const xmlChar;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut bucket: xmlSchemaBucketPtr = 0 as xmlSchemaBucketPtr;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return -(1 as libc::c_int);
    }
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"namespace\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"schemaLocation\0" as *const u8 as *const libc::c_char
                        as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    if xmlSchemaPValAttr(
        pctxt,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"namespace\0" as *const u8 as *const libc::c_char,
        xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
        &mut namespaceName,
    ) != 0 as libc::c_int
    {
        xmlSchemaPSimpleTypeErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            node,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
            0 as *const libc::c_char,
            namespaceName,
            0 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*pctxt).err;
    }
    if xmlSchemaPValAttr(
        pctxt,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"schemaLocation\0" as *const u8 as *const libc::c_char,
        xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
        &mut schemaLocation,
    ) != 0 as libc::c_int
    {
        xmlSchemaPSimpleTypeErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            node,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
            0 as *const libc::c_char,
            schemaLocation,
            0 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*pctxt).err;
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            pctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?)\0" as *const u8 as *const libc::c_char,
        );
    }
    thisTargetNamespace = (*(*(*pctxt).constructor).bucket).origTargetNamespace;
    if !namespaceName.is_null() {
        if xmlStrEqual(thisTargetNamespace, namespaceName) != 0 {
            xmlSchemaPCustomErr(
                pctxt,
                XML_SCHEMAP_SRC_IMPORT_1_1,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"The value of the attribute 'namespace' must not match the target namespace '%s' of the importing schema\0"
                    as *const u8 as *const libc::c_char,
                thisTargetNamespace,
            );
            return (*pctxt).err;
        }
    } else if thisTargetNamespace.is_null() {
        xmlSchemaPCustomErr(
            pctxt,
            XML_SCHEMAP_SRC_IMPORT_1_2,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"The attribute 'namespace' must be existent if the importing schema has no target namespace\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
        );
        return (*pctxt).err;
    }
    if !schemaLocation.is_null() {
        schemaLocation = xmlSchemaBuildAbsoluteURI((*pctxt).dict, schemaLocation, node);
    }
    ret = xmlSchemaAddSchemaDoc(
        pctxt,
        1 as libc::c_int,
        schemaLocation,
        0 as xmlDocPtr,
        0 as *const libc::c_char,
        0 as libc::c_int,
        node,
        thisTargetNamespace,
        namespaceName,
        &mut bucket,
    );
    if ret != 0 as libc::c_int {
        return ret;
    }
    if bucket.is_null() && !schemaLocation.is_null() {
        xmlSchemaCustomWarning(
            pctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_WARN_UNLOCATED_SCHEMA,
            node,
            0 as xmlSchemaTypePtr,
            b"Failed to locate a schema at location '%s'. Skipping the import\0"
                as *const u8 as *const libc::c_char,
            schemaLocation,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    if !bucket.is_null()
        && (!((*bucket).doc).is_null() && (*bucket).parsed == 0 as libc::c_int)
    {
        ret = xmlSchemaParseNewDoc(pctxt, schema, bucket);
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaParseIncludeOrRedefineAttrs(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut schemaLocation: *mut *mut xmlChar,
    mut type_0: libc::c_int,
) -> libc::c_int {
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if pctxt.is_null() || schema.is_null() || node.is_null() || schemaLocation.is_null()
    {
        return -(1 as libc::c_int);
    }
    *schemaLocation = 0 as *mut xmlChar;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"schemaLocation\0" as *const u8 as *const libc::c_char
                        as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        pctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    attr = xmlSchemaGetPropNode(
        node,
        b"schemaLocation\0" as *const u8 as *const libc::c_char,
    );
    if !attr.is_null() {
        let mut base: *mut xmlChar = 0 as *mut xmlChar;
        let mut uri: *mut xmlChar = 0 as *mut xmlChar;
        if !(xmlSchemaPValAttrNode(
            pctxt,
            0 as xmlSchemaBasicItemPtr,
            attr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
            schemaLocation as *mut *const xmlChar,
        ) != 0 as libc::c_int)
        {
            base = xmlNodeGetBase((*node).doc, node as *const xmlNode);
            if base.is_null() {
                uri = xmlBuildURI(*schemaLocation, (*(*node).doc).URL);
            } else {
                uri = xmlBuildURI(*schemaLocation, base);
                xmlFree.expect("non-null function pointer")(base as *mut libc::c_void);
            }
            if uri.is_null() {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaParseIncludeOrRedefine\0" as *const u8
                        as *const libc::c_char,
                    b"could not build an URI from the schemaLocation\0" as *const u8
                        as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            } else {
                *schemaLocation = xmlDictLookup((*pctxt).dict, uri, -(1 as libc::c_int))
                    as *mut xmlChar;
                xmlFree.expect("non-null function pointer")(uri as *mut libc::c_void);
                if xmlStrEqual(*schemaLocation, (*pctxt).URL) != 0 {
                    if type_0 == 3 as libc::c_int {
                        xmlSchemaPCustomErr(
                            pctxt,
                            XML_SCHEMAP_SRC_REDEFINE,
                            0 as xmlSchemaBasicItemPtr,
                            node,
                            b"The schema document '%s' cannot redefine itself.\0"
                                as *const u8 as *const libc::c_char,
                            *schemaLocation,
                        );
                    } else {
                        xmlSchemaPCustomErr(
                            pctxt,
                            XML_SCHEMAP_SRC_INCLUDE,
                            0 as xmlSchemaBasicItemPtr,
                            node,
                            b"The schema document '%s' cannot include itself.\0"
                                as *const u8 as *const libc::c_char,
                            *schemaLocation,
                        );
                    }
                } else {
                    return 0 as libc::c_int
                }
            }
        }
    } else {
        xmlSchemaPMissingAttrErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"schemaLocation\0" as *const u8 as *const libc::c_char,
            0 as *const libc::c_char,
        );
    }
    return (*pctxt).err;
}
unsafe extern "C" fn xmlSchemaParseIncludeOrRedefine(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut type_0: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut schemaLocation: *const xmlChar = 0 as *const xmlChar;
    let mut res: libc::c_int = 0 as libc::c_int;
    let mut isChameleon: libc::c_int = 0 as libc::c_int;
    let mut wasChameleon: libc::c_int = 0 as libc::c_int;
    let mut bucket: xmlSchemaBucketPtr = 0 as xmlSchemaBucketPtr;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return -(1 as libc::c_int);
    }
    res = xmlSchemaParseIncludeOrRedefineAttrs(
        pctxt,
        schema,
        node,
        &mut schemaLocation as *mut *const xmlChar as *mut *mut xmlChar,
        type_0,
    );
    if res != 0 as libc::c_int {
        return res;
    }
    res = xmlSchemaAddSchemaDoc(
        pctxt,
        type_0,
        schemaLocation,
        0 as xmlDocPtr,
        0 as *const libc::c_char,
        0 as libc::c_int,
        node,
        (*pctxt).targetNamespace,
        0 as *const xmlChar,
        &mut bucket,
    );
    if res != 0 as libc::c_int {
        return res;
    }
    if bucket.is_null() || ((*bucket).doc).is_null() {
        if type_0 == 2 as libc::c_int {
            res = XML_SCHEMAP_SRC_INCLUDE as libc::c_int;
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                res as xmlParserErrors,
                node,
                0 as xmlSchemaBasicItemPtr,
                b"Failed to load the document '%s' for inclusion\0" as *const u8
                    as *const libc::c_char,
                schemaLocation,
                0 as *const xmlChar,
            );
        } else {
            res = XML_SCHEMAP_SRC_REDEFINE as libc::c_int;
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                res as xmlParserErrors,
                node,
                0 as xmlSchemaBasicItemPtr,
                b"Failed to load the document '%s' for redefinition\0" as *const u8
                    as *const libc::c_char,
                schemaLocation,
                0 as *const xmlChar,
            );
        }
    } else {
        if !((*bucket).origTargetNamespace).is_null() {
            if ((*pctxt).targetNamespace).is_null() {
                xmlSchemaCustomErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    XML_SCHEMAP_SRC_INCLUDE,
                    node,
                    0 as xmlSchemaBasicItemPtr,
                    b"The target namespace of the included/redefined schema '%s' has to be absent, since the including/redefining schema has no target namespace\0"
                        as *const u8 as *const libc::c_char,
                    schemaLocation,
                    0 as *const xmlChar,
                );
                current_block = 2122687029741063289;
            } else if xmlStrEqual(
                    (*bucket).origTargetNamespace,
                    (*pctxt).targetNamespace,
                ) == 0
                {
                xmlSchemaPCustomErrExt(
                    pctxt,
                    XML_SCHEMAP_SRC_INCLUDE,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    b"The target namespace '%s' of the included/redefined schema '%s' differs from '%s' of the including/redefining schema\0"
                        as *const u8 as *const libc::c_char,
                    (*bucket).origTargetNamespace,
                    schemaLocation,
                    (*pctxt).targetNamespace,
                );
                current_block = 2122687029741063289;
            } else {
                current_block = 8693738493027456495;
            }
        } else if !((*pctxt).targetNamespace).is_null() {
            isChameleon = 1 as libc::c_int;
            if (*bucket).parsed != 0 && !((*bucket).origTargetNamespace).is_null() {
                xmlSchemaCustomErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    XML_SCHEMAP_SRC_INCLUDE,
                    node,
                    0 as xmlSchemaBasicItemPtr,
                    b"The target namespace of the included/redefined schema '%s' has to be absent or the same as the including/redefining schema's target namespace\0"
                        as *const u8 as *const libc::c_char,
                    schemaLocation,
                    0 as *const xmlChar,
                );
                current_block = 2122687029741063289;
            } else {
                let ref mut fresh228 = (*bucket).targetNamespace;
                *fresh228 = (*pctxt).targetNamespace;
                current_block = 8693738493027456495;
            }
        } else {
            current_block = 8693738493027456495;
        }
        match current_block {
            8693738493027456495 => {}
            _ => return (*pctxt).err,
        }
    }
    if !bucket.is_null() && (*bucket).parsed == 0 && !((*bucket).doc).is_null() {
        if isChameleon != 0 {
            if (*schema).flags & (1 as libc::c_int) << 9 as libc::c_int
                == 0 as libc::c_int
            {
                (*schema).flags |= (1 as libc::c_int) << 9 as libc::c_int;
            } else {
                wasChameleon = 1 as libc::c_int;
            }
        }
        xmlSchemaParseNewDoc(pctxt, schema, bucket);
        if isChameleon != 0 && wasChameleon == 0 {
            (*schema).flags ^= (1 as libc::c_int) << 9 as libc::c_int;
        }
    }
    child = (*node).children;
    if type_0 == 3 as libc::c_int {
        let ref mut fresh229 = (*pctxt).redefined;
        *fresh229 = bucket;
        (*pctxt).isRedefine = 1 as libc::c_int;
        while !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"simpleType\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"complexType\0" as *const u8 as *const libc::c_char
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"group\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"attributeGroup\0" as *const u8 as *const libc::c_char
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            if !(!child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0)
            {
                if !child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"simpleType\0" as *const u8 as *const libc::c_char
                            as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                {
                    xmlSchemaParseSimpleType(pctxt, schema, child, 1 as libc::c_int);
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"complexType\0" as *const u8 as *const libc::c_char
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseComplexType(pctxt, schema, child, 1 as libc::c_int);
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"group\0" as *const u8 as *const libc::c_char
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseModelGroupDefinition(pctxt, schema, child);
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"attributeGroup\0" as *const u8 as *const libc::c_char
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseAttributeGroupDefinition(pctxt, schema, child);
                }
            }
            child = (*child).next;
        }
        let ref mut fresh230 = (*pctxt).redefined;
        *fresh230 = 0 as xmlSchemaBucketPtr;
        (*pctxt).isRedefine = 0 as libc::c_int;
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        child = (*child).next;
    }
    if !child.is_null() {
        res = XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED as libc::c_int;
        if type_0 == 3 as libc::c_int {
            xmlSchemaPContentErr(
                pctxt,
                res as xmlParserErrors,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const libc::c_char,
                b"(annotation | (simpleType | complexType | group | attributeGroup))*\0"
                    as *const u8 as *const libc::c_char,
            );
        } else {
            xmlSchemaPContentErr(
                pctxt,
                res as xmlParserErrors,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const libc::c_char,
                b"(annotation?)\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    return res;
}
unsafe extern "C" fn xmlSchemaParseRedefine(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    res = xmlSchemaParseIncludeOrRedefine(pctxt, schema, node, 3 as libc::c_int);
    if res != 0 as libc::c_int {
        return res;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaParseInclude(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> libc::c_int {
    let mut res: libc::c_int = 0;
    res = xmlSchemaParseIncludeOrRedefine(pctxt, schema, node, 2 as libc::c_int);
    if res != 0 as libc::c_int {
        return res;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaParseModelGroup(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut type_0: xmlSchemaTypeType,
    mut withParticle: libc::c_int,
) -> xmlSchemaTreeItemPtr {
    let mut item: xmlSchemaModelGroupPtr = 0 as *mut xmlSchemaModelGroup;
    let mut particle: xmlSchemaParticlePtr = 0 as xmlSchemaParticlePtr;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut min: libc::c_int = 1 as libc::c_int;
    let mut max: libc::c_int = 1 as libc::c_int;
    let mut isElemRef: libc::c_int = 0;
    let mut hasRefs: libc::c_int = 0 as libc::c_int;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTreeItemPtr;
    }
    item = xmlSchemaAddModelGroup(ctxt, schema, type_0, node);
    if item.is_null() {
        return 0 as xmlSchemaTreeItemPtr;
    }
    if withParticle != 0 {
        if type_0 as libc::c_uint == XML_SCHEMA_TYPE_ALL as libc::c_int as libc::c_uint {
            min = xmlGetMinOccurs(
                ctxt,
                node,
                0 as libc::c_int,
                1 as libc::c_int,
                1 as libc::c_int,
                b"(0 | 1)\0" as *const u8 as *const libc::c_char,
            );
            max = xmlGetMaxOccurs(
                ctxt,
                node,
                1 as libc::c_int,
                1 as libc::c_int,
                1 as libc::c_int,
                b"1\0" as *const u8 as *const libc::c_char,
            );
        } else {
            min = xmlGetMinOccurs(
                ctxt,
                node,
                0 as libc::c_int,
                -(1 as libc::c_int),
                1 as libc::c_int,
                b"xs:nonNegativeInteger\0" as *const u8 as *const libc::c_char,
            );
            max = xmlGetMaxOccurs(
                ctxt,
                node,
                0 as libc::c_int,
                (1 as libc::c_int) << 30 as libc::c_int,
                1 as libc::c_int,
                b"(xs:nonNegativeInteger | unbounded)\0" as *const u8
                    as *const libc::c_char,
            );
        }
        xmlSchemaPCheckParticleCorrect_2(
            ctxt,
            0 as xmlSchemaParticlePtr,
            node,
            min,
            max,
        );
        particle = xmlSchemaAddParticle(ctxt, node, min, max);
        if particle.is_null() {
            return 0 as xmlSchemaTreeItemPtr;
        }
        let ref mut fresh231 = (*particle).children;
        *fresh231 = item as xmlSchemaTreeItemPtr;
        attr = (*node).properties;
        while !attr.is_null() {
            if ((*attr).ns).is_null() {
                if xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
                    && xmlStrEqual(
                        (*attr).name,
                        b"maxOccurs\0" as *const u8 as *const libc::c_char
                            as *mut xmlChar,
                    ) == 0
                    && xmlStrEqual(
                        (*attr).name,
                        b"minOccurs\0" as *const u8 as *const libc::c_char
                            as *mut xmlChar,
                    ) == 0
                {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        0 as xmlSchemaBasicItemPtr,
                        attr,
                    );
                }
            } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
            attr = (*attr).next;
        }
    } else {
        attr = (*node).properties;
        while !attr.is_null() {
            if ((*attr).ns).is_null() {
                if xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
                {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        0 as xmlSchemaBasicItemPtr,
                        attr,
                    );
                }
            } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
            attr = (*attr).next;
        }
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let ref mut fresh232 = (*item).annot;
        *fresh232 = xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int);
        child = (*child).next;
    }
    if type_0 as libc::c_uint == XML_SCHEMA_TYPE_ALL as libc::c_int as libc::c_uint {
        let mut part: xmlSchemaParticlePtr = 0 as *mut xmlSchemaParticle;
        let mut last: xmlSchemaParticlePtr = 0 as xmlSchemaParticlePtr;
        while !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"element\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            part = xmlSchemaParseElement(
                ctxt,
                schema,
                child,
                &mut isElemRef,
                0 as libc::c_int,
            ) as xmlSchemaParticlePtr;
            if !part.is_null() {
                if isElemRef != 0 {
                    hasRefs += 1;
                }
                if (*part).minOccurs > 1 as libc::c_int {
                    xmlSchemaPCustomErr(
                        ctxt,
                        XML_SCHEMAP_COS_ALL_LIMITED,
                        0 as xmlSchemaBasicItemPtr,
                        child,
                        b"Invalid value for minOccurs (must be 0 or 1)\0" as *const u8
                            as *const libc::c_char,
                        0 as *const xmlChar,
                    );
                    (*part).minOccurs = 1 as libc::c_int;
                }
                if (*part).maxOccurs > 1 as libc::c_int {
                    xmlSchemaPCustomErr(
                        ctxt,
                        XML_SCHEMAP_COS_ALL_LIMITED,
                        0 as xmlSchemaBasicItemPtr,
                        child,
                        b"Invalid value for maxOccurs (must be 0 or 1)\0" as *const u8
                            as *const libc::c_char,
                        0 as *const xmlChar,
                    );
                    (*part).maxOccurs = 1 as libc::c_int;
                }
                if last.is_null() {
                    let ref mut fresh233 = (*item).children;
                    *fresh233 = part as xmlSchemaTreeItemPtr;
                } else {
                    let ref mut fresh234 = (*last).next;
                    *fresh234 = part as xmlSchemaTreeItemPtr;
                }
                last = part;
            }
            child = (*child).next;
        }
        if !child.is_null() {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const libc::c_char,
                b"(annotation?, (annotation?, element*)\0" as *const u8
                    as *const libc::c_char,
            );
        }
    } else {
        let mut part_0: xmlSchemaTreeItemPtr = 0 as xmlSchemaTreeItemPtr;
        let mut last_0: xmlSchemaTreeItemPtr = 0 as xmlSchemaTreeItemPtr;
        while !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"element\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"group\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"any\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"choice\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"sequence\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"element\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
                part_0 = xmlSchemaParseElement(
                    ctxt,
                    schema,
                    child,
                    &mut isElemRef,
                    0 as libc::c_int,
                ) as xmlSchemaTreeItemPtr;
                if !part_0.is_null() && isElemRef != 0 {
                    hasRefs += 1;
                }
            } else if !child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"group\0" as *const u8 as *const libc::c_char as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                {
                part_0 = xmlSchemaParseModelGroupDefRef(ctxt, schema, child);
                if !part_0.is_null() {
                    hasRefs += 1;
                }
                if (*ctxt).isRedefine != 0 && !((*ctxt).redef).is_null()
                    && (*(*(*ctxt).redef).item).type_0 as libc::c_uint
                        == XML_SCHEMA_TYPE_GROUP as libc::c_int as libc::c_uint
                    && !part_0.is_null() && !((*part_0).children).is_null()
                {
                    if (*((*part_0).children as xmlSchemaQNameRefPtr)).name
                        == (*(*ctxt).redef).refName
                        && (*((*part_0).children as xmlSchemaQNameRefPtr))
                            .targetNamespace == (*(*ctxt).redef).refTargetNs
                    {
                        if (*ctxt).redefCounter != 0 as libc::c_int {
                            let mut str: *mut xmlChar = 0 as *mut xmlChar;
                            xmlSchemaCustomErr(
                                ctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAP_SRC_REDEFINE,
                                child,
                                0 as xmlSchemaBasicItemPtr,
                                b"The redefining model group definition '%s' must not contain more than one reference to the redefined definition\0"
                                    as *const u8 as *const libc::c_char,
                                xmlSchemaFormatQName(
                                    &mut str,
                                    (*(*ctxt).redef).refTargetNs,
                                    (*(*ctxt).redef).refName,
                                ),
                                0 as *const xmlChar,
                            );
                            if !str.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(str as *mut libc::c_void);
                                str = 0 as *mut xmlChar;
                            }
                            part_0 = 0 as xmlSchemaTreeItemPtr;
                        } else if (*(part_0 as xmlSchemaParticlePtr)).minOccurs
                                != 1 as libc::c_int
                                || (*(part_0 as xmlSchemaParticlePtr)).maxOccurs
                                    != 1 as libc::c_int
                            {
                            let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                            xmlSchemaCustomErr(
                                ctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAP_SRC_REDEFINE,
                                child,
                                0 as xmlSchemaBasicItemPtr,
                                b"The redefining model group definition '%s' must not contain a reference to the redefined definition with a maxOccurs/minOccurs other than 1\0"
                                    as *const u8 as *const libc::c_char,
                                xmlSchemaFormatQName(
                                    &mut str_0,
                                    (*(*ctxt).redef).refTargetNs,
                                    (*(*ctxt).redef).refName,
                                ),
                                0 as *const xmlChar,
                            );
                            if !str_0.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(str_0 as *mut libc::c_void);
                                str_0 = 0 as *mut xmlChar;
                            }
                            part_0 = 0 as xmlSchemaTreeItemPtr;
                        }
                        let ref mut fresh235 = (*(*ctxt).redef).reference;
                        *fresh235 = part_0 as xmlSchemaBasicItemPtr;
                        let ref mut fresh236 = (*ctxt).redefCounter;
                        *fresh236 += 1;
                    }
                }
            } else if !child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"any\0" as *const u8 as *const libc::c_char as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                {
                part_0 = xmlSchemaParseAny(ctxt, schema, child) as xmlSchemaTreeItemPtr;
            } else if !child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"choice\0" as *const u8 as *const libc::c_char as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                {
                part_0 = xmlSchemaParseModelGroup(
                    ctxt,
                    schema,
                    child,
                    XML_SCHEMA_TYPE_CHOICE,
                    1 as libc::c_int,
                );
            } else if !child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"sequence\0" as *const u8 as *const libc::c_char
                            as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                {
                part_0 = xmlSchemaParseModelGroup(
                    ctxt,
                    schema,
                    child,
                    XML_SCHEMA_TYPE_SEQUENCE,
                    1 as libc::c_int,
                );
            }
            if !part_0.is_null() {
                if last_0.is_null() {
                    let ref mut fresh237 = (*item).children;
                    *fresh237 = part_0;
                } else {
                    let ref mut fresh238 = (*last_0).next;
                    *fresh238 = part_0;
                }
                last_0 = part_0;
            }
            child = (*child).next;
        }
        if !child.is_null() {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const libc::c_char,
                b"(annotation?, (element | group | choice | sequence | any)*)\0"
                    as *const u8 as *const libc::c_char,
            );
        }
    }
    if max == 0 as libc::c_int && min == 0 as libc::c_int {
        return 0 as xmlSchemaTreeItemPtr;
    }
    if hasRefs != 0 {
        xmlSchemaAddItemSize(
            &mut (*(*ctxt).constructor).pending,
            10 as libc::c_int,
            item as *mut libc::c_void,
        );
    }
    if withParticle != 0 {
        return particle as xmlSchemaTreeItemPtr
    } else {
        return item as xmlSchemaTreeItemPtr
    };
}
unsafe extern "C" fn xmlSchemaParseRestriction(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut parentType: xmlSchemaTypeType,
) -> xmlSchemaTypePtr {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    type_0 = (*ctxt).ctxtType;
    (*type_0).flags |= (1 as libc::c_int) << 2 as libc::c_int;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"base\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    if xmlSchemaPValAttrQName(
        ctxt,
        schema,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"base\0" as *const u8 as *const libc::c_char,
        &mut (*type_0).baseNs,
        &mut (*type_0).base,
    ) == 0 as libc::c_int
    {
        if ((*type_0).base).is_null()
            && (*type_0).type_0 as libc::c_uint
                == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
        {
            xmlSchemaPMissingAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"base\0" as *const u8 as *const libc::c_char,
                0 as *const libc::c_char,
            );
        } else if (*ctxt).isRedefine != 0
                && (*type_0).flags & (1 as libc::c_int) << 3 as libc::c_int != 0
            {
            if ((*type_0).base).is_null() {
                xmlSchemaPMissingAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_MISSING,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    b"base\0" as *const u8 as *const libc::c_char,
                    0 as *const libc::c_char,
                );
            } else if xmlStrEqual((*type_0).base, (*type_0).name) == 0
                    || xmlStrEqual((*type_0).baseNs, (*type_0).targetNamespace) == 0
                {
                let mut str1: *mut xmlChar = 0 as *mut xmlChar;
                let mut str2: *mut xmlChar = 0 as *mut xmlChar;
                xmlSchemaPCustomErrExt(
                    ctxt,
                    XML_SCHEMAP_SRC_REDEFINE,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    b"This is a redefinition, but the QName value '%s' of the 'base' attribute does not match the type's designation '%s'\0"
                        as *const u8 as *const libc::c_char,
                    xmlSchemaFormatQName(&mut str1, (*type_0).baseNs, (*type_0).base),
                    xmlSchemaFormatQName(
                        &mut str2,
                        (*type_0).targetNamespace,
                        (*type_0).name,
                    ),
                    0 as *const xmlChar,
                );
                if !str1.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str1 as *mut libc::c_void);
                    str1 = 0 as *mut xmlChar;
                }
                if !str2.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str2 as *mut libc::c_void);
                    str2 = 0 as *mut xmlChar;
                }
                let ref mut fresh239 = (*type_0).base;
                *fresh239 = 0 as *const xmlChar;
                let ref mut fresh240 = (*type_0).baseNs;
                *fresh240 = 0 as *const xmlChar;
            }
        }
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int),
        );
        child = (*child).next;
    }
    if parentType as libc::c_uint
        == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
    {
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"simpleType\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            if !((*type_0).base).is_null() {
                xmlSchemaPContentErr(
                    ctxt,
                    XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    child,
                    b"The attribute 'base' and the <simpleType> child are mutually exclusive\0"
                        as *const u8 as *const libc::c_char,
                    0 as *const libc::c_char,
                );
            } else {
                let ref mut fresh241 = (*type_0).baseType;
                *fresh241 = xmlSchemaParseSimpleType(
                    ctxt,
                    schema,
                    child,
                    0 as libc::c_int,
                );
            }
            child = (*child).next;
        } else if ((*type_0).base).is_null() {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                b"Either the attribute 'base' or a <simpleType> child must be present\0"
                    as *const u8 as *const libc::c_char,
                0 as *const libc::c_char,
            );
        }
    } else if parentType as libc::c_uint
            == XML_SCHEMA_TYPE_COMPLEX_CONTENT as libc::c_int as libc::c_uint
        {
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"all\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            let ref mut fresh242 = (*type_0).subtypes;
            *fresh242 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_ALL,
                1 as libc::c_int,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"choice\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let ref mut fresh243 = (*type_0).subtypes;
            *fresh243 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_CHOICE,
                1 as libc::c_int,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"sequence\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let ref mut fresh244 = (*type_0).subtypes;
            *fresh244 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_SEQUENCE,
                1 as libc::c_int,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"group\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let ref mut fresh245 = (*type_0).subtypes;
            *fresh245 = xmlSchemaParseModelGroupDefRef(ctxt, schema, child)
                as xmlSchemaTypePtr;
            child = (*child).next;
        }
    } else if parentType as libc::c_uint
            == XML_SCHEMA_TYPE_SIMPLE_CONTENT as libc::c_int as libc::c_uint
        {
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"simpleType\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            let ref mut fresh246 = (*type_0).contentTypeDef;
            *fresh246 = xmlSchemaParseSimpleType(ctxt, schema, child, 0 as libc::c_int);
            if ((*type_0).contentTypeDef).is_null() {
                return 0 as xmlSchemaTypePtr;
            }
            child = (*child).next;
        }
    }
    if parentType as libc::c_uint
        == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
        || parentType as libc::c_uint
            == XML_SCHEMA_TYPE_SIMPLE_CONTENT as libc::c_int as libc::c_uint
    {
        let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
        let mut lastfacet: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
        while !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"minInclusive\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"minExclusive\0" as *const u8 as *const libc::c_char
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"maxInclusive\0" as *const u8 as *const libc::c_char
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"maxExclusive\0" as *const u8 as *const libc::c_char
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"totalDigits\0" as *const u8 as *const libc::c_char
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"fractionDigits\0" as *const u8 as *const libc::c_char
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"pattern\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"enumeration\0" as *const u8 as *const libc::c_char
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"whiteSpace\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"length\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"maxLength\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"minLength\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            facet = xmlSchemaParseFacet(ctxt, schema, child);
            if !facet.is_null() {
                if lastfacet.is_null() {
                    let ref mut fresh247 = (*type_0).facets;
                    *fresh247 = facet;
                } else {
                    let ref mut fresh248 = (*lastfacet).next;
                    *fresh248 = facet;
                }
                lastfacet = facet;
                let ref mut fresh249 = (*lastfacet).next;
                *fresh249 = 0 as *mut _xmlSchemaFacet;
            }
            child = (*child).next;
        }
        if !((*type_0).facets).is_null() {
            let mut facetLink: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
            let mut lastFacetLink: xmlSchemaFacetLinkPtr = 0 as xmlSchemaFacetLinkPtr;
            facet = (*type_0).facets;
            loop {
                facetLink = xmlMalloc
                    .expect(
                        "non-null function pointer",
                    )(::std::mem::size_of::<xmlSchemaFacetLink>() as libc::c_ulong)
                    as xmlSchemaFacetLinkPtr;
                if facetLink.is_null() {
                    xmlSchemaPErrMemory(
                        ctxt,
                        b"allocating a facet link\0" as *const u8 as *const libc::c_char,
                        0 as xmlNodePtr,
                    );
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(facetLink as *mut libc::c_void);
                    return 0 as xmlSchemaTypePtr;
                }
                let ref mut fresh250 = (*facetLink).facet;
                *fresh250 = facet;
                let ref mut fresh251 = (*facetLink).next;
                *fresh251 = 0 as *mut _xmlSchemaFacetLink;
                if lastFacetLink.is_null() {
                    let ref mut fresh252 = (*type_0).facetSet;
                    *fresh252 = facetLink;
                } else {
                    let ref mut fresh253 = (*lastFacetLink).next;
                    *fresh253 = facetLink;
                }
                lastFacetLink = facetLink;
                facet = (*facet).next;
                if facet.is_null() {
                    break;
                }
            }
        }
    }
    if (*type_0).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
    {
        if xmlSchemaParseLocalAttributes(
            ctxt,
            schema,
            &mut child,
            &mut (*type_0).attrUses as *mut *mut libc::c_void
                as *mut xmlSchemaItemListPtr,
            XML_SCHEMA_TYPE_RESTRICTION as libc::c_int,
            0 as *mut libc::c_int,
        ) == -(1 as libc::c_int)
        {
            return 0 as xmlSchemaTypePtr;
        }
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"anyAttribute\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            let ref mut fresh254 = (*type_0).attributeWildcard;
            *fresh254 = xmlSchemaParseAnyAttribute(ctxt, schema, child);
            child = (*child).next;
        }
    }
    if !child.is_null() {
        if parentType as libc::c_uint
            == XML_SCHEMA_TYPE_COMPLEX_CONTENT as libc::c_int as libc::c_uint
        {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const libc::c_char,
                b"annotation?, (group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?))\0"
                    as *const u8 as *const libc::c_char,
            );
        } else if parentType as libc::c_uint
                == XML_SCHEMA_TYPE_SIMPLE_CONTENT as libc::c_int as libc::c_uint
            {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const libc::c_char,
                b"(annotation?, (simpleType?, (minExclusive | minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | length | minLength | maxLength | enumeration | whiteSpace | pattern)*)?, ((attribute | attributeGroup)*, anyAttribute?))\0"
                    as *const u8 as *const libc::c_char,
            );
        } else {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const libc::c_char,
                b"(annotation?, (simpleType?, (minExclusive | minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | length | minLength | maxLength | enumeration | whiteSpace | pattern)*))\0"
                    as *const u8 as *const libc::c_char,
            );
        }
    }
    return 0 as xmlSchemaTypePtr;
}
unsafe extern "C" fn xmlSchemaParseExtension(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut parentType: xmlSchemaTypeType,
) -> xmlSchemaTypePtr {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    type_0 = (*ctxt).ctxtType;
    (*type_0).flags |= (1 as libc::c_int) << 1 as libc::c_int;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"base\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    if xmlSchemaPValAttrQName(
        ctxt,
        schema,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"base\0" as *const u8 as *const libc::c_char,
        &mut (*type_0).baseNs,
        &mut (*type_0).base,
    ) == 0 as libc::c_int && ((*type_0).base).is_null()
    {
        xmlSchemaPMissingAttrErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"base\0" as *const u8 as *const libc::c_char,
            0 as *const libc::c_char,
        );
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int),
        );
        child = (*child).next;
    }
    if parentType as libc::c_uint
        == XML_SCHEMA_TYPE_COMPLEX_CONTENT as libc::c_int as libc::c_uint
    {
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"all\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            let ref mut fresh255 = (*type_0).subtypes;
            *fresh255 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_ALL,
                1 as libc::c_int,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"choice\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let ref mut fresh256 = (*type_0).subtypes;
            *fresh256 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_CHOICE,
                1 as libc::c_int,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"sequence\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let ref mut fresh257 = (*type_0).subtypes;
            *fresh257 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_SEQUENCE,
                1 as libc::c_int,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"group\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let ref mut fresh258 = (*type_0).subtypes;
            *fresh258 = xmlSchemaParseModelGroupDefRef(ctxt, schema, child)
                as xmlSchemaTypePtr;
            child = (*child).next;
        }
    }
    if !child.is_null() {
        if xmlSchemaParseLocalAttributes(
            ctxt,
            schema,
            &mut child,
            &mut (*type_0).attrUses as *mut *mut libc::c_void
                as *mut xmlSchemaItemListPtr,
            XML_SCHEMA_TYPE_EXTENSION as libc::c_int,
            0 as *mut libc::c_int,
        ) == -(1 as libc::c_int)
        {
            return 0 as xmlSchemaTypePtr;
        }
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"anyAttribute\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            let ref mut fresh259 = (*(*ctxt).ctxtType).attributeWildcard;
            *fresh259 = xmlSchemaParseAnyAttribute(ctxt, schema, child);
            child = (*child).next;
        }
    }
    if !child.is_null() {
        if parentType as libc::c_uint
            == XML_SCHEMA_TYPE_COMPLEX_CONTENT as libc::c_int as libc::c_uint
        {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const libc::c_char,
                b"(annotation?, ((group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?)))\0"
                    as *const u8 as *const libc::c_char,
            );
        } else {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const libc::c_char,
                b"(annotation?, ((attribute | attributeGroup)*, anyAttribute?))\0"
                    as *const u8 as *const libc::c_char,
            );
        }
    }
    return 0 as xmlSchemaTypePtr;
}
unsafe extern "C" fn xmlSchemaParseSimpleContent(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut hasRestrictionOrExtension: *mut libc::c_int,
) -> libc::c_int {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null()
        || hasRestrictionOrExtension.is_null()
    {
        return -(1 as libc::c_int);
    }
    *hasRestrictionOrExtension = 0 as libc::c_int;
    type_0 = (*ctxt).ctxtType;
    (*type_0).contentType = XML_SCHEMA_CONTENT_SIMPLE;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int),
        );
        child = (*child).next;
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            0 as xmlNodePtr,
            0 as *const libc::c_char,
            b"(annotation?, (restriction | extension))\0" as *const u8
                as *const libc::c_char,
        );
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            0 as xmlNodePtr,
            0 as *const libc::c_char,
            b"(annotation?, (restriction | extension))\0" as *const u8
                as *const libc::c_char,
        );
    }
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"restriction\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaParseRestriction(ctxt, schema, child, XML_SCHEMA_TYPE_SIMPLE_CONTENT);
        *hasRestrictionOrExtension = 1 as libc::c_int;
        child = (*child).next;
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"extension\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        xmlSchemaParseExtension(ctxt, schema, child, XML_SCHEMA_TYPE_SIMPLE_CONTENT);
        *hasRestrictionOrExtension = 1 as libc::c_int;
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?, (restriction | extension))\0" as *const u8
                as *const libc::c_char,
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaParseComplexContent(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut hasRestrictionOrExtension: *mut libc::c_int,
) -> libc::c_int {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null()
        || hasRestrictionOrExtension.is_null()
    {
        return -(1 as libc::c_int);
    }
    *hasRestrictionOrExtension = 0 as libc::c_int;
    type_0 = (*ctxt).ctxtType;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"mixed\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    if xmlGetBooleanProp(
        ctxt,
        node,
        b"mixed\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int,
    ) != 0
    {
        if (*type_0).flags & (1 as libc::c_int) << 0 as libc::c_int == 0 as libc::c_int {
            (*type_0).flags |= (1 as libc::c_int) << 0 as libc::c_int;
        }
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int),
        );
        child = (*child).next;
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            0 as xmlNodePtr,
            0 as *const libc::c_char,
            b"(annotation?, (restriction | extension))\0" as *const u8
                as *const libc::c_char,
        );
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            0 as xmlNodePtr,
            0 as *const libc::c_char,
            b"(annotation?, (restriction | extension))\0" as *const u8
                as *const libc::c_char,
        );
    }
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"restriction\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaParseRestriction(ctxt, schema, child, XML_SCHEMA_TYPE_COMPLEX_CONTENT);
        *hasRestrictionOrExtension = 1 as libc::c_int;
        child = (*child).next;
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"extension\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        xmlSchemaParseExtension(ctxt, schema, child, XML_SCHEMA_TYPE_COMPLEX_CONTENT);
        *hasRestrictionOrExtension = 1 as libc::c_int;
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?, (restriction | extension))\0" as *const u8
                as *const libc::c_char,
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaParseComplexType(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut topLevel: libc::c_int,
) -> xmlSchemaTypePtr {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ctxtType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut attrValue: *const xmlChar = 0 as *const xmlChar;
    let mut final_0: libc::c_int = 0 as libc::c_int;
    let mut block: libc::c_int = 0 as libc::c_int;
    let mut hasRestrictionOrExtension: libc::c_int = 0 as libc::c_int;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    ctxtType = (*ctxt).ctxtType;
    if topLevel != 0 {
        attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const libc::c_char);
        if attr.is_null() {
            xmlSchemaPMissingAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"name\0" as *const u8 as *const libc::c_char,
                0 as *const libc::c_char,
            );
            return 0 as xmlSchemaTypePtr;
        } else {
            if xmlSchemaPValAttrNode(
                ctxt,
                0 as xmlSchemaBasicItemPtr,
                attr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                &mut name,
            ) != 0 as libc::c_int
            {
                return 0 as xmlSchemaTypePtr;
            }
        }
    }
    if topLevel == 0 as libc::c_int {
        type_0 = xmlSchemaAddType(
            ctxt,
            schema,
            XML_SCHEMA_TYPE_COMPLEX,
            0 as *const xmlChar,
            (*ctxt).targetNamespace,
            node,
            0 as libc::c_int,
        );
        if type_0.is_null() {
            return 0 as xmlSchemaTypePtr;
        }
        name = (*type_0).name;
        let ref mut fresh260 = (*type_0).node;
        *fresh260 = node;
        (*type_0).type_0 = XML_SCHEMA_TYPE_COMPLEX;
    } else {
        type_0 = xmlSchemaAddType(
            ctxt,
            schema,
            XML_SCHEMA_TYPE_COMPLEX,
            name,
            (*ctxt).targetNamespace,
            node,
            1 as libc::c_int,
        );
        if type_0.is_null() {
            return 0 as xmlSchemaTypePtr;
        }
        let ref mut fresh261 = (*type_0).node;
        *fresh261 = node;
        (*type_0).type_0 = XML_SCHEMA_TYPE_COMPLEX;
        (*type_0).flags |= (1 as libc::c_int) << 3 as libc::c_int;
    }
    let ref mut fresh262 = (*type_0).targetNamespace;
    *fresh262 = (*ctxt).targetNamespace;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) != 0
            {
                xmlSchemaPValAttrID(
                    ctxt,
                    node,
                    b"id\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                );
            } else if xmlStrEqual(
                    (*attr).name,
                    b"mixed\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) != 0
                {
                if xmlSchemaPGetBoolNodeValue(
                    ctxt,
                    0 as xmlSchemaBasicItemPtr,
                    attr as xmlNodePtr,
                ) != 0
                {
                    (*type_0).flags |= (1 as libc::c_int) << 0 as libc::c_int;
                }
            } else if topLevel != 0 {
                if !(xmlStrEqual(
                    (*attr).name,
                    b"name\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) != 0)
                {
                    if xmlStrEqual(
                        (*attr).name,
                        b"abstract\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                    ) != 0
                    {
                        if xmlSchemaPGetBoolNodeValue(
                            ctxt,
                            0 as xmlSchemaBasicItemPtr,
                            attr as xmlNodePtr,
                        ) != 0
                        {
                            (*type_0).flags |= (1 as libc::c_int) << 20 as libc::c_int;
                        }
                    } else if xmlStrEqual(
                            (*attr).name,
                            b"final\0" as *const u8 as *const libc::c_char
                                as *mut xmlChar,
                        ) != 0
                        {
                        attrValue = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if xmlSchemaPValAttrBlockFinal(
                            attrValue,
                            &mut (*type_0).flags,
                            -(1 as libc::c_int),
                            (1 as libc::c_int) << 9 as libc::c_int,
                            (1 as libc::c_int) << 10 as libc::c_int,
                            -(1 as libc::c_int),
                            -(1 as libc::c_int),
                            -(1 as libc::c_int),
                        ) != 0 as libc::c_int
                        {
                            xmlSchemaPSimpleTypeErr(
                                ctxt,
                                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr,
                                0 as xmlSchemaTypePtr,
                                b"(#all | List of (extension | restriction))\0" as *const u8
                                    as *const libc::c_char,
                                attrValue,
                                0 as *const libc::c_char,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        } else {
                            final_0 = 1 as libc::c_int;
                        }
                    } else if xmlStrEqual(
                            (*attr).name,
                            b"block\0" as *const u8 as *const libc::c_char
                                as *mut xmlChar,
                        ) != 0
                        {
                        attrValue = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if xmlSchemaPValAttrBlockFinal(
                            attrValue,
                            &mut (*type_0).flags,
                            -(1 as libc::c_int),
                            (1 as libc::c_int) << 18 as libc::c_int,
                            (1 as libc::c_int) << 19 as libc::c_int,
                            -(1 as libc::c_int),
                            -(1 as libc::c_int),
                            -(1 as libc::c_int),
                        ) != 0 as libc::c_int
                        {
                            xmlSchemaPSimpleTypeErr(
                                ctxt,
                                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr,
                                0 as xmlSchemaTypePtr,
                                b"(#all | List of (extension | restriction)) \0"
                                    as *const u8 as *const libc::c_char,
                                attrValue,
                                0 as *const libc::c_char,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        } else {
                            block = 1 as libc::c_int;
                        }
                    } else {
                        xmlSchemaPIllegalAttrErr(
                            ctxt,
                            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                            0 as xmlSchemaBasicItemPtr,
                            attr,
                        );
                    }
                }
            } else {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    if block == 0 {
        if (*schema).flags & (1 as libc::c_int) << 7 as libc::c_int != 0 {
            (*type_0).flags |= (1 as libc::c_int) << 19 as libc::c_int;
        }
        if (*schema).flags & (1 as libc::c_int) << 6 as libc::c_int != 0 {
            (*type_0).flags |= (1 as libc::c_int) << 18 as libc::c_int;
        }
    }
    if final_0 == 0 {
        if (*schema).flags & (1 as libc::c_int) << 3 as libc::c_int != 0 {
            (*type_0).flags |= (1 as libc::c_int) << 10 as libc::c_int;
        }
        if (*schema).flags & (1 as libc::c_int) << 2 as libc::c_int != 0 {
            (*type_0).flags |= (1 as libc::c_int) << 9 as libc::c_int;
        }
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let ref mut fresh263 = (*type_0).annot;
        *fresh263 = xmlSchemaParseAnnotation(ctxt, child, 1 as libc::c_int);
        child = (*child).next;
    }
    let ref mut fresh264 = (*ctxt).ctxtType;
    *fresh264 = type_0;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"simpleContent\0" as *const u8 as *const libc::c_char as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        if (*type_0).flags & (1 as libc::c_int) << 0 as libc::c_int != 0 {
            (*type_0).flags ^= (1 as libc::c_int) << 0 as libc::c_int;
        }
        xmlSchemaParseSimpleContent(ctxt, schema, child, &mut hasRestrictionOrExtension);
        child = (*child).next;
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"complexContent\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        (*type_0).contentType = XML_SCHEMA_CONTENT_EMPTY;
        xmlSchemaParseComplexContent(
            ctxt,
            schema,
            child,
            &mut hasRestrictionOrExtension,
        );
        child = (*child).next;
    } else {
        let ref mut fresh265 = (*type_0).baseType;
        *fresh265 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
        (*type_0).flags |= (1 as libc::c_int) << 2 as libc::c_int;
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"all\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            let ref mut fresh266 = (*type_0).subtypes;
            *fresh266 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_ALL,
                1 as libc::c_int,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"choice\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let ref mut fresh267 = (*type_0).subtypes;
            *fresh267 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_CHOICE,
                1 as libc::c_int,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"sequence\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let ref mut fresh268 = (*type_0).subtypes;
            *fresh268 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_SEQUENCE,
                1 as libc::c_int,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"group\0" as *const u8 as *const libc::c_char as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let ref mut fresh269 = (*type_0).subtypes;
            *fresh269 = xmlSchemaParseModelGroupDefRef(ctxt, schema, child)
                as xmlSchemaTypePtr;
            child = (*child).next;
        }
        if xmlSchemaParseLocalAttributes(
            ctxt,
            schema,
            &mut child,
            &mut (*type_0).attrUses as *mut *mut libc::c_void
                as *mut xmlSchemaItemListPtr,
            XML_SCHEMA_TYPE_RESTRICTION as libc::c_int,
            0 as *mut libc::c_int,
        ) == -(1 as libc::c_int)
        {
            return 0 as xmlSchemaTypePtr;
        }
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"anyAttribute\0" as *const u8 as *const libc::c_char as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            let ref mut fresh270 = (*type_0).attributeWildcard;
            *fresh270 = xmlSchemaParseAnyAttribute(ctxt, schema, child);
            child = (*child).next;
        }
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const libc::c_char,
            b"(annotation?, (simpleContent | complexContent | ((group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?))))\0"
                as *const u8 as *const libc::c_char,
        );
    }
    if topLevel != 0 && (*ctxt).isRedefine != 0 && hasRestrictionOrExtension == 0 {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_SRC_REDEFINE,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"This is a redefinition, thus the <complexType> must have a <restriction> or <extension> grand-child\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
        );
    }
    let ref mut fresh271 = (*ctxt).ctxtType;
    *fresh271 = ctxtType;
    return type_0;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaNewParserCtxt(
    mut URL: *const libc::c_char,
) -> xmlSchemaParserCtxtPtr {
    let mut ret: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    if URL.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    ret = xmlSchemaParserCtxtCreate();
    if ret.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    let ref mut fresh272 = (*ret).dict;
    *fresh272 = xmlDictCreate();
    let ref mut fresh273 = (*ret).URL;
    *fresh273 = xmlDictLookup((*ret).dict, URL as *const xmlChar, -(1 as libc::c_int));
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaNewMemParserCtxt(
    mut buffer: *const libc::c_char,
    mut size: libc::c_int,
) -> xmlSchemaParserCtxtPtr {
    let mut ret: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    if buffer.is_null() || size <= 0 as libc::c_int {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    ret = xmlSchemaParserCtxtCreate();
    if ret.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    let ref mut fresh274 = (*ret).buffer;
    *fresh274 = buffer;
    (*ret).size = size;
    let ref mut fresh275 = (*ret).dict;
    *fresh275 = xmlDictCreate();
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaNewDocParserCtxt(
    mut doc: xmlDocPtr,
) -> xmlSchemaParserCtxtPtr {
    let mut ret: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    if doc.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    ret = xmlSchemaParserCtxtCreate();
    if ret.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    let ref mut fresh276 = (*ret).doc;
    *fresh276 = doc;
    let ref mut fresh277 = (*ret).dict;
    *fresh277 = xmlDictCreate();
    (*ret).preserve = 1 as libc::c_int;
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFreeParserCtxt(mut ctxt: xmlSchemaParserCtxtPtr) {
    if ctxt.is_null() {
        return;
    }
    if !((*ctxt).doc).is_null() && (*ctxt).preserve == 0 {
        xmlFreeDoc((*ctxt).doc);
    }
    if !((*ctxt).vctxt).is_null() {
        xmlSchemaFreeValidCtxt((*ctxt).vctxt);
    }
    if (*ctxt).ownsConstructor != 0 && !((*ctxt).constructor).is_null() {
        xmlSchemaConstructionCtxtFree((*ctxt).constructor);
        let ref mut fresh278 = (*ctxt).constructor;
        *fresh278 = 0 as xmlSchemaConstructionCtxtPtr;
        (*ctxt).ownsConstructor = 0 as libc::c_int;
    }
    if !((*ctxt).attrProhibs).is_null() {
        xmlSchemaItemListFree((*ctxt).attrProhibs);
    }
    xmlDictFree((*ctxt).dict);
    xmlFree.expect("non-null function pointer")(ctxt as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaBuildContentModelForSubstGroup(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut particle: xmlSchemaParticlePtr,
    mut counter: libc::c_int,
    mut end: xmlAutomataStatePtr,
) -> libc::c_int {
    let mut start: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
    let mut tmp: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
    let mut elemDecl: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
    let mut member: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
    let mut substGroup: xmlSchemaSubstGroupPtr = 0 as *mut xmlSchemaSubstGroup;
    let mut i: libc::c_int = 0;
    let mut ret: libc::c_int = 0 as libc::c_int;
    elemDecl = (*particle).children as xmlSchemaElementPtr;
    start = (*pctxt).state;
    if end.is_null() {
        end = xmlAutomataNewState((*pctxt).am);
    }
    substGroup = xmlSchemaSubstGroupGet(pctxt, elemDecl);
    if substGroup.is_null() {
        xmlSchemaPErr(
            pctxt,
            xmlSchemaGetComponentNode(particle as xmlSchemaBasicItemPtr),
            XML_SCHEMAP_INTERNAL as libc::c_int,
            b"Internal error: xmlSchemaBuildContentModelForSubstGroup, declaration is marked having a subst. group but none available.\n\0"
                as *const u8 as *const libc::c_char,
            (*elemDecl).name,
            0 as *const xmlChar,
        );
        return 0 as libc::c_int;
    }
    if counter >= 0 as libc::c_int {
        tmp = xmlAutomataNewCountedTrans(
            (*pctxt).am,
            start,
            0 as xmlAutomataStatePtr,
            counter,
        );
        xmlAutomataNewTransition2(
            (*pctxt).am,
            tmp,
            end,
            (*elemDecl).name,
            (*elemDecl).targetNamespace,
            elemDecl as *mut libc::c_void,
        );
        i = 0 as libc::c_int;
        while i < (*(*substGroup).members).nbItems {
            member = *((*(*substGroup).members).items).offset(i as isize)
                as xmlSchemaElementPtr;
            xmlAutomataNewTransition2(
                (*pctxt).am,
                tmp,
                end,
                (*member).name,
                (*member).targetNamespace,
                member as *mut libc::c_void,
            );
            i += 1;
        }
    } else if (*particle).maxOccurs == 1 as libc::c_int {
        xmlAutomataNewEpsilon(
            (*pctxt).am,
            xmlAutomataNewTransition2(
                (*pctxt).am,
                start,
                0 as xmlAutomataStatePtr,
                (*elemDecl).name,
                (*elemDecl).targetNamespace,
                elemDecl as *mut libc::c_void,
            ),
            end,
        );
        i = 0 as libc::c_int;
        while i < (*(*substGroup).members).nbItems {
            member = *((*(*substGroup).members).items).offset(i as isize)
                as xmlSchemaElementPtr;
            tmp = xmlAutomataNewTransition2(
                (*pctxt).am,
                start,
                0 as xmlAutomataStatePtr,
                (*member).name,
                (*member).targetNamespace,
                member as *mut libc::c_void,
            );
            xmlAutomataNewEpsilon((*pctxt).am, tmp, end);
            i += 1;
        }
    } else {
        let mut hop: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
        let mut maxOccurs: libc::c_int = if (*particle).maxOccurs
            == (1 as libc::c_int) << 30 as libc::c_int
        {
            (1 as libc::c_int) << 30 as libc::c_int
        } else {
            (*particle).maxOccurs - 1 as libc::c_int
        };
        let mut minOccurs: libc::c_int = if (*particle).minOccurs < 1 as libc::c_int {
            0 as libc::c_int
        } else {
            (*particle).minOccurs - 1 as libc::c_int
        };
        counter = xmlAutomataNewCounter((*pctxt).am, minOccurs, maxOccurs);
        hop = xmlAutomataNewState((*pctxt).am);
        xmlAutomataNewEpsilon(
            (*pctxt).am,
            xmlAutomataNewTransition2(
                (*pctxt).am,
                start,
                0 as xmlAutomataStatePtr,
                (*elemDecl).name,
                (*elemDecl).targetNamespace,
                elemDecl as *mut libc::c_void,
            ),
            hop,
        );
        i = 0 as libc::c_int;
        while i < (*(*substGroup).members).nbItems {
            member = *((*(*substGroup).members).items).offset(i as isize)
                as xmlSchemaElementPtr;
            xmlAutomataNewEpsilon(
                (*pctxt).am,
                xmlAutomataNewTransition2(
                    (*pctxt).am,
                    start,
                    0 as xmlAutomataStatePtr,
                    (*member).name,
                    (*member).targetNamespace,
                    member as *mut libc::c_void,
                ),
                hop,
            );
            i += 1;
        }
        xmlAutomataNewCountedTrans((*pctxt).am, hop, start, counter);
        xmlAutomataNewCounterTrans((*pctxt).am, hop, end, counter);
    }
    if (*particle).minOccurs == 0 as libc::c_int {
        xmlAutomataNewEpsilon((*pctxt).am, start, end);
        ret = 1 as libc::c_int;
    }
    let ref mut fresh279 = (*pctxt).state;
    *fresh279 = end;
    return ret;
}
unsafe extern "C" fn xmlSchemaBuildContentModelForElement(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut particle: xmlSchemaParticlePtr,
) -> libc::c_int {
    let mut ret: libc::c_int = 0 as libc::c_int;
    if (*((*particle).children as xmlSchemaElementPtr)).flags
        & (1 as libc::c_int) << 17 as libc::c_int != 0
    {
        ret = xmlSchemaBuildContentModelForSubstGroup(
            ctxt,
            particle,
            -(1 as libc::c_int),
            0 as xmlAutomataStatePtr,
        );
    } else {
        let mut elemDecl: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
        let mut start: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
        elemDecl = (*particle).children as xmlSchemaElementPtr;
        if (*elemDecl).flags & (1 as libc::c_int) << 4 as libc::c_int != 0 {
            return 0 as libc::c_int;
        }
        if (*particle).maxOccurs == 1 as libc::c_int {
            start = (*ctxt).state;
            let ref mut fresh280 = (*ctxt).state;
            *fresh280 = xmlAutomataNewTransition2(
                (*ctxt).am,
                start,
                0 as xmlAutomataStatePtr,
                (*elemDecl).name,
                (*elemDecl).targetNamespace,
                elemDecl as *mut libc::c_void,
            );
        } else if (*particle).maxOccurs >= (1 as libc::c_int) << 30 as libc::c_int
                && (*particle).minOccurs < 2 as libc::c_int
            {
            start = (*ctxt).state;
            let ref mut fresh281 = (*ctxt).state;
            *fresh281 = xmlAutomataNewTransition2(
                (*ctxt).am,
                start,
                0 as xmlAutomataStatePtr,
                (*elemDecl).name,
                (*elemDecl).targetNamespace,
                elemDecl as *mut libc::c_void,
            );
            let ref mut fresh282 = (*ctxt).state;
            *fresh282 = xmlAutomataNewTransition2(
                (*ctxt).am,
                (*ctxt).state,
                (*ctxt).state,
                (*elemDecl).name,
                (*elemDecl).targetNamespace,
                elemDecl as *mut libc::c_void,
            );
        } else {
            let mut counter: libc::c_int = 0;
            let mut maxOccurs: libc::c_int = if (*particle).maxOccurs
                == (1 as libc::c_int) << 30 as libc::c_int
            {
                (1 as libc::c_int) << 30 as libc::c_int
            } else {
                (*particle).maxOccurs - 1 as libc::c_int
            };
            let mut minOccurs: libc::c_int = if (*particle).minOccurs < 1 as libc::c_int
            {
                0 as libc::c_int
            } else {
                (*particle).minOccurs - 1 as libc::c_int
            };
            start = xmlAutomataNewEpsilon(
                (*ctxt).am,
                (*ctxt).state,
                0 as xmlAutomataStatePtr,
            );
            counter = xmlAutomataNewCounter((*ctxt).am, minOccurs, maxOccurs);
            let ref mut fresh283 = (*ctxt).state;
            *fresh283 = xmlAutomataNewTransition2(
                (*ctxt).am,
                start,
                0 as xmlAutomataStatePtr,
                (*elemDecl).name,
                (*elemDecl).targetNamespace,
                elemDecl as *mut libc::c_void,
            );
            xmlAutomataNewCountedTrans((*ctxt).am, (*ctxt).state, start, counter);
            let ref mut fresh284 = (*ctxt).state;
            *fresh284 = xmlAutomataNewCounterTrans(
                (*ctxt).am,
                (*ctxt).state,
                0 as xmlAutomataStatePtr,
                counter,
            );
        }
        if (*particle).minOccurs == 0 as libc::c_int {
            xmlAutomataNewEpsilon((*ctxt).am, start, (*ctxt).state);
            ret = 1 as libc::c_int;
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaBuildAContentModel(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut particle: xmlSchemaParticlePtr,
) -> libc::c_int {
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut tmp2: libc::c_int = 0;
    if particle.is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaBuildAContentModel\0" as *const u8 as *const libc::c_char,
            b"particle is NULL\0" as *const u8 as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    if ((*particle).children).is_null() {
        return 1 as libc::c_int;
    }
    match (*(*particle).children).type_0 as libc::c_uint {
        2 => {
            let mut start: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            let mut end: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            let mut wild: xmlSchemaWildcardPtr = 0 as *mut xmlSchemaWildcard;
            let mut ns: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
            wild = (*particle).children as xmlSchemaWildcardPtr;
            start = (*pctxt).state;
            end = xmlAutomataNewState((*pctxt).am);
            if (*particle).maxOccurs == 1 as libc::c_int {
                if (*wild).any == 1 as libc::c_int {
                    let ref mut fresh285 = (*pctxt).state;
                    *fresh285 = xmlAutomataNewTransition2(
                        (*pctxt).am,
                        start,
                        0 as xmlAutomataStatePtr,
                        b"*\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                        b"*\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                        wild as *mut libc::c_void,
                    );
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, end);
                    let ref mut fresh286 = (*pctxt).state;
                    *fresh286 = xmlAutomataNewTransition2(
                        (*pctxt).am,
                        start,
                        0 as xmlAutomataStatePtr,
                        b"*\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                        0 as *const xmlChar,
                        wild as *mut libc::c_void,
                    );
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, end);
                } else if !((*wild).nsSet).is_null() {
                    ns = (*wild).nsSet;
                    loop {
                        let ref mut fresh287 = (*pctxt).state;
                        *fresh287 = start;
                        let ref mut fresh288 = (*pctxt).state;
                        *fresh288 = xmlAutomataNewTransition2(
                            (*pctxt).am,
                            (*pctxt).state,
                            0 as xmlAutomataStatePtr,
                            b"*\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                            (*ns).value,
                            wild as *mut libc::c_void,
                        );
                        xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, end);
                        ns = (*ns).next;
                        if ns.is_null() {
                            break;
                        }
                    }
                } else if !((*wild).negNsSet).is_null() {
                    let ref mut fresh289 = (*pctxt).state;
                    *fresh289 = xmlAutomataNewNegTrans(
                        (*pctxt).am,
                        start,
                        end,
                        b"*\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                        (*(*wild).negNsSet).value,
                        wild as *mut libc::c_void,
                    );
                }
            } else {
                let mut counter: libc::c_int = 0;
                let mut hop: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
                let mut maxOccurs: libc::c_int = if (*particle).maxOccurs
                    == (1 as libc::c_int) << 30 as libc::c_int
                {
                    (1 as libc::c_int) << 30 as libc::c_int
                } else {
                    (*particle).maxOccurs - 1 as libc::c_int
                };
                let mut minOccurs: libc::c_int = if (*particle).minOccurs
                    < 1 as libc::c_int
                {
                    0 as libc::c_int
                } else {
                    (*particle).minOccurs - 1 as libc::c_int
                };
                counter = xmlAutomataNewCounter((*pctxt).am, minOccurs, maxOccurs);
                hop = xmlAutomataNewState((*pctxt).am);
                if (*wild).any == 1 as libc::c_int {
                    let ref mut fresh290 = (*pctxt).state;
                    *fresh290 = xmlAutomataNewTransition2(
                        (*pctxt).am,
                        start,
                        0 as xmlAutomataStatePtr,
                        b"*\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                        b"*\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                        wild as *mut libc::c_void,
                    );
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, hop);
                    let ref mut fresh291 = (*pctxt).state;
                    *fresh291 = xmlAutomataNewTransition2(
                        (*pctxt).am,
                        start,
                        0 as xmlAutomataStatePtr,
                        b"*\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                        0 as *const xmlChar,
                        wild as *mut libc::c_void,
                    );
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, hop);
                } else if !((*wild).nsSet).is_null() {
                    ns = (*wild).nsSet;
                    loop {
                        let ref mut fresh292 = (*pctxt).state;
                        *fresh292 = xmlAutomataNewTransition2(
                            (*pctxt).am,
                            start,
                            0 as xmlAutomataStatePtr,
                            b"*\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                            (*ns).value,
                            wild as *mut libc::c_void,
                        );
                        xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, hop);
                        ns = (*ns).next;
                        if ns.is_null() {
                            break;
                        }
                    }
                } else if !((*wild).negNsSet).is_null() {
                    let ref mut fresh293 = (*pctxt).state;
                    *fresh293 = xmlAutomataNewNegTrans(
                        (*pctxt).am,
                        start,
                        hop,
                        b"*\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                        (*(*wild).negNsSet).value,
                        wild as *mut libc::c_void,
                    );
                }
                xmlAutomataNewCountedTrans((*pctxt).am, hop, start, counter);
                xmlAutomataNewCounterTrans((*pctxt).am, hop, end, counter);
            }
            if (*particle).minOccurs == 0 as libc::c_int {
                xmlAutomataNewEpsilon((*pctxt).am, start, end);
                ret = 1 as libc::c_int;
            }
            let ref mut fresh294 = (*pctxt).state;
            *fresh294 = end;
        }
        14 => {
            ret = xmlSchemaBuildContentModelForElement(pctxt, particle);
        }
        6 => {
            let mut sub: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
            ret = 1 as libc::c_int;
            if (*particle).minOccurs == 1 as libc::c_int
                && (*particle).maxOccurs == 1 as libc::c_int
            {
                sub = (*(*particle).children).children;
                while !sub.is_null() {
                    tmp2 = xmlSchemaBuildAContentModel(
                        pctxt,
                        sub as xmlSchemaParticlePtr,
                    );
                    if tmp2 != 1 as libc::c_int {
                        ret = 0 as libc::c_int;
                    }
                    sub = (*sub).next;
                }
            } else {
                let mut oldstate: xmlAutomataStatePtr = (*pctxt).state;
                if (*particle).maxOccurs >= (1 as libc::c_int) << 30 as libc::c_int {
                    if (*particle).minOccurs > 1 as libc::c_int {
                        let mut tmp: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
                        let mut counter_0: libc::c_int = 0;
                        let ref mut fresh295 = (*pctxt).state;
                        *fresh295 = xmlAutomataNewEpsilon(
                            (*pctxt).am,
                            oldstate,
                            0 as xmlAutomataStatePtr,
                        );
                        oldstate = (*pctxt).state;
                        counter_0 = xmlAutomataNewCounter(
                            (*pctxt).am,
                            (*particle).minOccurs - 1 as libc::c_int,
                            (1 as libc::c_int) << 30 as libc::c_int,
                        );
                        sub = (*(*particle).children).children;
                        while !sub.is_null() {
                            tmp2 = xmlSchemaBuildAContentModel(
                                pctxt,
                                sub as xmlSchemaParticlePtr,
                            );
                            if tmp2 != 1 as libc::c_int {
                                ret = 0 as libc::c_int;
                            }
                            sub = (*sub).next;
                        }
                        tmp = (*pctxt).state;
                        xmlAutomataNewCountedTrans(
                            (*pctxt).am,
                            tmp,
                            oldstate,
                            counter_0,
                        );
                        let ref mut fresh296 = (*pctxt).state;
                        *fresh296 = xmlAutomataNewCounterTrans(
                            (*pctxt).am,
                            tmp,
                            0 as xmlAutomataStatePtr,
                            counter_0,
                        );
                        if ret == 1 as libc::c_int {
                            xmlAutomataNewEpsilon((*pctxt).am, oldstate, (*pctxt).state);
                        }
                    } else {
                        let ref mut fresh297 = (*pctxt).state;
                        *fresh297 = xmlAutomataNewEpsilon(
                            (*pctxt).am,
                            oldstate,
                            0 as xmlAutomataStatePtr,
                        );
                        oldstate = (*pctxt).state;
                        sub = (*(*particle).children).children;
                        while !sub.is_null() {
                            tmp2 = xmlSchemaBuildAContentModel(
                                pctxt,
                                sub as xmlSchemaParticlePtr,
                            );
                            if tmp2 != 1 as libc::c_int {
                                ret = 0 as libc::c_int;
                            }
                            sub = (*sub).next;
                        }
                        xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, oldstate);
                        let ref mut fresh298 = (*pctxt).state;
                        *fresh298 = xmlAutomataNewEpsilon(
                            (*pctxt).am,
                            (*pctxt).state,
                            0 as xmlAutomataStatePtr,
                        );
                        if (*particle).minOccurs == 0 as libc::c_int {
                            xmlAutomataNewEpsilon((*pctxt).am, oldstate, (*pctxt).state);
                            ret = 1 as libc::c_int;
                        }
                    }
                } else if (*particle).maxOccurs > 1 as libc::c_int
                        || (*particle).minOccurs > 1 as libc::c_int
                    {
                    let mut tmp_0: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
                    let mut counter_1: libc::c_int = 0;
                    let ref mut fresh299 = (*pctxt).state;
                    *fresh299 = xmlAutomataNewEpsilon(
                        (*pctxt).am,
                        oldstate,
                        0 as xmlAutomataStatePtr,
                    );
                    oldstate = (*pctxt).state;
                    counter_1 = xmlAutomataNewCounter(
                        (*pctxt).am,
                        (*particle).minOccurs - 1 as libc::c_int,
                        (*particle).maxOccurs - 1 as libc::c_int,
                    );
                    sub = (*(*particle).children).children;
                    while !sub.is_null() {
                        tmp2 = xmlSchemaBuildAContentModel(
                            pctxt,
                            sub as xmlSchemaParticlePtr,
                        );
                        if tmp2 != 1 as libc::c_int {
                            ret = 0 as libc::c_int;
                        }
                        sub = (*sub).next;
                    }
                    tmp_0 = (*pctxt).state;
                    xmlAutomataNewCountedTrans((*pctxt).am, tmp_0, oldstate, counter_1);
                    let ref mut fresh300 = (*pctxt).state;
                    *fresh300 = xmlAutomataNewCounterTrans(
                        (*pctxt).am,
                        tmp_0,
                        0 as xmlAutomataStatePtr,
                        counter_1,
                    );
                    if (*particle).minOccurs == 0 as libc::c_int
                        || ret == 1 as libc::c_int
                    {
                        xmlAutomataNewEpsilon((*pctxt).am, oldstate, (*pctxt).state);
                        ret = 1 as libc::c_int;
                    }
                } else {
                    sub = (*(*particle).children).children;
                    while !sub.is_null() {
                        tmp2 = xmlSchemaBuildAContentModel(
                            pctxt,
                            sub as xmlSchemaParticlePtr,
                        );
                        if tmp2 != 1 as libc::c_int {
                            ret = 0 as libc::c_int;
                        }
                        sub = (*sub).next;
                    }
                    let ref mut fresh301 = (*pctxt).state;
                    *fresh301 = xmlAutomataNewEpsilon(
                        (*pctxt).am,
                        (*pctxt).state,
                        0 as xmlAutomataStatePtr,
                    );
                    if (*particle).minOccurs == 0 as libc::c_int {
                        xmlAutomataNewEpsilon((*pctxt).am, oldstate, (*pctxt).state);
                        ret = 1 as libc::c_int;
                    }
                }
            }
        }
        7 => {
            let mut sub_0: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
            let mut start_0: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            let mut end_0: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            ret = 0 as libc::c_int;
            start_0 = (*pctxt).state;
            end_0 = xmlAutomataNewState((*pctxt).am);
            if (*particle).maxOccurs == 1 as libc::c_int {
                sub_0 = (*(*particle).children).children;
                while !sub_0.is_null() {
                    let ref mut fresh302 = (*pctxt).state;
                    *fresh302 = start_0;
                    tmp2 = xmlSchemaBuildAContentModel(
                        pctxt,
                        sub_0 as xmlSchemaParticlePtr,
                    );
                    if tmp2 == 1 as libc::c_int {
                        ret = 1 as libc::c_int;
                    }
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, end_0);
                    sub_0 = (*sub_0).next;
                }
            } else {
                let mut counter_2: libc::c_int = 0;
                let mut hop_0: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
                let mut base: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
                let mut maxOccurs_0: libc::c_int = if (*particle).maxOccurs
                    == (1 as libc::c_int) << 30 as libc::c_int
                {
                    (1 as libc::c_int) << 30 as libc::c_int
                } else {
                    (*particle).maxOccurs - 1 as libc::c_int
                };
                let mut minOccurs_0: libc::c_int = if (*particle).minOccurs
                    < 1 as libc::c_int
                {
                    0 as libc::c_int
                } else {
                    (*particle).minOccurs - 1 as libc::c_int
                };
                counter_2 = xmlAutomataNewCounter((*pctxt).am, minOccurs_0, maxOccurs_0);
                hop_0 = xmlAutomataNewState((*pctxt).am);
                base = xmlAutomataNewState((*pctxt).am);
                sub_0 = (*(*particle).children).children;
                while !sub_0.is_null() {
                    let ref mut fresh303 = (*pctxt).state;
                    *fresh303 = base;
                    tmp2 = xmlSchemaBuildAContentModel(
                        pctxt,
                        sub_0 as xmlSchemaParticlePtr,
                    );
                    if tmp2 == 1 as libc::c_int {
                        ret = 1 as libc::c_int;
                    }
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, hop_0);
                    sub_0 = (*sub_0).next;
                }
                xmlAutomataNewEpsilon((*pctxt).am, start_0, base);
                xmlAutomataNewCountedTrans((*pctxt).am, hop_0, base, counter_2);
                xmlAutomataNewCounterTrans((*pctxt).am, hop_0, end_0, counter_2);
                if ret == 1 as libc::c_int {
                    xmlAutomataNewEpsilon((*pctxt).am, base, end_0);
                }
            }
            if (*particle).minOccurs == 0 as libc::c_int {
                xmlAutomataNewEpsilon((*pctxt).am, start_0, end_0);
                ret = 1 as libc::c_int;
            }
            let ref mut fresh304 = (*pctxt).state;
            *fresh304 = end_0;
        }
        8 => {
            let mut start_1: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            let mut tmp_1: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            let mut sub_1: xmlSchemaParticlePtr = 0 as *mut xmlSchemaParticle;
            let mut elemDecl: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
            ret = 1 as libc::c_int;
            sub_1 = (*(*particle).children).children as xmlSchemaParticlePtr;
            if !sub_1.is_null() {
                ret = 0 as libc::c_int;
                start_1 = (*pctxt).state;
                tmp_1 = xmlAutomataNewState((*pctxt).am);
                xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, tmp_1);
                let ref mut fresh305 = (*pctxt).state;
                *fresh305 = tmp_1;
                while !sub_1.is_null() {
                    let ref mut fresh306 = (*pctxt).state;
                    *fresh306 = tmp_1;
                    elemDecl = (*sub_1).children as xmlSchemaElementPtr;
                    if elemDecl.is_null() {
                        xmlSchemaInternalErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaBuildAContentModel\0" as *const u8
                                as *const libc::c_char,
                            b"<element> particle has no term\0" as *const u8
                                as *const libc::c_char,
                        );
                        return ret;
                    }
                    if (*elemDecl).flags & (1 as libc::c_int) << 17 as libc::c_int != 0 {
                        let mut counter_3: libc::c_int = 0;
                        counter_3 = xmlAutomataNewCounter(
                            (*pctxt).am,
                            (*sub_1).minOccurs,
                            (*sub_1).maxOccurs,
                        );
                        xmlSchemaBuildContentModelForSubstGroup(
                            pctxt,
                            sub_1,
                            counter_3,
                            (*pctxt).state,
                        );
                    } else if (*sub_1).minOccurs == 1 as libc::c_int
                            && (*sub_1).maxOccurs == 1 as libc::c_int
                        {
                        xmlAutomataNewOnceTrans2(
                            (*pctxt).am,
                            (*pctxt).state,
                            (*pctxt).state,
                            (*elemDecl).name,
                            (*elemDecl).targetNamespace,
                            1 as libc::c_int,
                            1 as libc::c_int,
                            elemDecl as *mut libc::c_void,
                        );
                    } else if (*sub_1).minOccurs == 0 as libc::c_int
                            && (*sub_1).maxOccurs == 1 as libc::c_int
                        {
                        xmlAutomataNewCountTrans2(
                            (*pctxt).am,
                            (*pctxt).state,
                            (*pctxt).state,
                            (*elemDecl).name,
                            (*elemDecl).targetNamespace,
                            0 as libc::c_int,
                            1 as libc::c_int,
                            elemDecl as *mut libc::c_void,
                        );
                    }
                    sub_1 = (*sub_1).next as xmlSchemaParticlePtr;
                }
                let ref mut fresh307 = (*pctxt).state;
                *fresh307 = xmlAutomataNewAllTrans(
                    (*pctxt).am,
                    (*pctxt).state,
                    0 as xmlAutomataStatePtr,
                    0 as libc::c_int,
                );
                if (*particle).minOccurs == 0 as libc::c_int {
                    xmlAutomataNewEpsilon((*pctxt).am, start_1, (*pctxt).state);
                    ret = 1 as libc::c_int;
                }
            }
        }
        17 => {
            ret = 1 as libc::c_int;
        }
        _ => {
            xmlSchemaInternalErr2(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaBuildAContentModel\0" as *const u8 as *const libc::c_char,
                b"found unexpected term of type '%s' in content model\0" as *const u8
                    as *const libc::c_char,
                xmlSchemaGetComponentTypeStr(
                    (*particle).children as xmlSchemaBasicItemPtr,
                ),
                0 as *const xmlChar,
            );
            return ret;
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaBuildContentModel(
    mut type_0: xmlSchemaTypePtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) {
    if (*type_0).type_0 as libc::c_uint
        != XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
        || !((*type_0).contModel).is_null()
        || (*type_0).contentType as libc::c_uint
            != XML_SCHEMA_CONTENT_ELEMENTS as libc::c_int as libc::c_uint
            && (*type_0).contentType as libc::c_uint
                != XML_SCHEMA_CONTENT_MIXED as libc::c_int as libc::c_uint
    {
        return;
    }
    let ref mut fresh308 = (*ctxt).am;
    *fresh308 = 0 as xmlAutomataPtr;
    let ref mut fresh309 = (*ctxt).am;
    *fresh309 = xmlNewAutomata();
    if ((*ctxt).am).is_null() {
        (*__xmlGenericError())
            .expect(
                "non-null function pointer",
            )(
            *__xmlGenericErrorContext(),
            b"Cannot create automata for complex type %s\n\0" as *const u8
                as *const libc::c_char,
            (*type_0).name,
        );
        return;
    }
    let ref mut fresh310 = (*ctxt).state;
    *fresh310 = xmlAutomataGetInitState((*ctxt).am);
    xmlSchemaBuildAContentModel(ctxt, (*type_0).subtypes as xmlSchemaParticlePtr);
    xmlAutomataSetFinalState((*ctxt).am, (*ctxt).state);
    let ref mut fresh311 = (*type_0).contModel;
    *fresh311 = xmlAutomataCompile((*ctxt).am);
    if ((*type_0).contModel).is_null() {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_INTERNAL,
            type_0 as xmlSchemaBasicItemPtr,
            (*type_0).node,
            b"Failed to compile the content model\0" as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
        );
    } else if xmlRegexpIsDeterminist((*type_0).contModel) != 1 as libc::c_int {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_NOT_DETERMINISTIC,
            type_0 as xmlSchemaBasicItemPtr,
            (*type_0).node,
            b"The content model is not determinist\0" as *const u8
                as *const libc::c_char,
            0 as *const xmlChar,
        );
    }
    let ref mut fresh312 = (*ctxt).state;
    *fresh312 = 0 as xmlAutomataStatePtr;
    xmlFreeAutomata((*ctxt).am);
    let ref mut fresh313 = (*ctxt).am;
    *fresh313 = 0 as xmlAutomataPtr;
}
unsafe extern "C" fn xmlSchemaResolveElementReferences(
    mut elemDecl: xmlSchemaElementPtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) {
    if ctxt.is_null() || elemDecl.is_null()
        || !elemDecl.is_null()
            && (*elemDecl).flags & (1 as libc::c_int) << 8 as libc::c_int != 0
    {
        return;
    }
    (*elemDecl).flags |= (1 as libc::c_int) << 8 as libc::c_int;
    if ((*elemDecl).subtypes).is_null() && !((*elemDecl).namedType).is_null() {
        let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        type_0 = xmlSchemaGetType(
            (*ctxt).schema,
            (*elemDecl).namedType,
            (*elemDecl).namedTypeNs,
        );
        if type_0.is_null() {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                elemDecl as xmlSchemaBasicItemPtr,
                (*elemDecl).node,
                b"type\0" as *const u8 as *const libc::c_char,
                (*elemDecl).namedType,
                (*elemDecl).namedTypeNs,
                XML_SCHEMA_TYPE_BASIC,
                b"type definition\0" as *const u8 as *const libc::c_char,
            );
        } else {
            let ref mut fresh314 = (*elemDecl).subtypes;
            *fresh314 = type_0;
        }
    }
    if !((*elemDecl).substGroup).is_null() {
        let mut substHead: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
        substHead = xmlSchemaGetElem(
            (*ctxt).schema,
            (*elemDecl).substGroup,
            (*elemDecl).substGroupNs,
        );
        if substHead.is_null() {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                elemDecl as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"substitutionGroup\0" as *const u8 as *const libc::c_char,
                (*elemDecl).substGroup,
                (*elemDecl).substGroupNs,
                XML_SCHEMA_TYPE_ELEMENT,
                0 as *const libc::c_char,
            );
        } else {
            xmlSchemaResolveElementReferences(substHead, ctxt);
            let ref mut fresh315 = (*elemDecl).refDecl;
            *fresh315 = substHead;
            if ((*elemDecl).subtypes).is_null() {
                let ref mut fresh316 = (*elemDecl).subtypes;
                *fresh316 = (*substHead).subtypes;
            }
        }
    }
    if ((*elemDecl).subtypes).is_null() && ((*elemDecl).namedType).is_null()
        && ((*elemDecl).substGroup).is_null()
    {
        let ref mut fresh317 = (*elemDecl).subtypes;
        *fresh317 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
    }
}
unsafe extern "C" fn xmlSchemaResolveUnionMemberTypes(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> libc::c_int {
    let mut link: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut lastLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut newLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut memberType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    link = (*type_0).memberTypes;
    lastLink = 0 as xmlSchemaTypeLinkPtr;
    while !link.is_null() {
        let mut name: *const xmlChar = 0 as *const xmlChar;
        let mut nsName: *const xmlChar = 0 as *const xmlChar;
        name = (*((*link).type_0 as xmlSchemaQNameRefPtr)).name;
        nsName = (*((*link).type_0 as xmlSchemaQNameRefPtr)).targetNamespace;
        memberType = xmlSchemaGetType((*ctxt).schema, name, nsName);
        if memberType.is_null()
            || !((*memberType).type_0 as libc::c_uint
                == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
                || (*memberType).type_0 as libc::c_uint
                    == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                    && (*memberType).builtInType != XML_SCHEMAS_ANYTYPE as libc::c_int)
        {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                type_0 as xmlSchemaBasicItemPtr,
                (*type_0).node,
                b"memberTypes\0" as *const u8 as *const libc::c_char,
                name,
                nsName,
                XML_SCHEMA_TYPE_SIMPLE,
                0 as *const libc::c_char,
            );
            if lastLink.is_null() {
                let ref mut fresh318 = (*type_0).memberTypes;
                *fresh318 = (*link).next;
            } else {
                let ref mut fresh319 = (*lastLink).next;
                *fresh319 = (*link).next;
            }
            newLink = link;
            link = (*link).next;
            xmlFree.expect("non-null function pointer")(newLink as *mut libc::c_void);
        } else {
            let ref mut fresh320 = (*link).type_0;
            *fresh320 = memberType;
            lastLink = link;
            link = (*link).next;
        }
    }
    memberType = (*type_0).subtypes;
    while !memberType.is_null() {
        link = xmlMalloc
            .expect(
                "non-null function pointer",
            )(::std::mem::size_of::<xmlSchemaTypeLink>() as libc::c_ulong)
            as xmlSchemaTypeLinkPtr;
        if link.is_null() {
            xmlSchemaPErrMemory(
                ctxt,
                b"allocating a type link\0" as *const u8 as *const libc::c_char,
                0 as xmlNodePtr,
            );
            return -(1 as libc::c_int);
        }
        let ref mut fresh321 = (*link).type_0;
        *fresh321 = memberType;
        let ref mut fresh322 = (*link).next;
        *fresh322 = 0 as *mut _xmlSchemaTypeLink;
        if lastLink.is_null() {
            let ref mut fresh323 = (*type_0).memberTypes;
            *fresh323 = link;
        } else {
            let ref mut fresh324 = (*lastLink).next;
            *fresh324 = link;
        }
        lastLink = link;
        memberType = (*memberType).next;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaIsDerivedFromBuiltInType(
    mut type_0: xmlSchemaTypePtr,
    mut valType: libc::c_int,
) -> libc::c_int {
    if type_0.is_null() {
        return 0 as libc::c_int;
    }
    if (*type_0).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
        || (*type_0).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int
    {
        return 0 as libc::c_int;
    }
    if (*type_0).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
    {
        if (*type_0).builtInType == valType {
            return 1 as libc::c_int;
        }
        if (*type_0).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as libc::c_int
            || (*type_0).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int
        {
            return 0 as libc::c_int;
        }
        return xmlSchemaIsDerivedFromBuiltInType((*type_0).subtypes, valType);
    }
    return xmlSchemaIsDerivedFromBuiltInType((*type_0).subtypes, valType);
}
unsafe extern "C" fn xmlSchemaGetPrimitiveType(
    mut type_0: xmlSchemaTypePtr,
) -> xmlSchemaTypePtr {
    while !type_0.is_null() {
        if (*type_0).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as libc::c_int
            || (*type_0).flags & (1 as libc::c_int) << 14 as libc::c_int != 0
        {
            return type_0;
        }
        type_0 = (*type_0).baseType;
    }
    return 0 as xmlSchemaTypePtr;
}
unsafe extern "C" fn xmlSchemaCloneWildcardNsConstraints(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut dest: xmlSchemaWildcardPtr,
    mut source: xmlSchemaWildcardPtr,
) -> libc::c_int {
    let mut cur: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut tmp: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut last: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    if source.is_null() || dest.is_null() {
        return -(1 as libc::c_int);
    }
    (*dest).any = (*source).any;
    cur = (*source).nsSet;
    last = 0 as xmlSchemaWildcardNsPtr;
    while !cur.is_null() {
        tmp = xmlSchemaNewWildcardNsConstraint(ctxt);
        if tmp.is_null() {
            return -(1 as libc::c_int);
        }
        let ref mut fresh325 = (*tmp).value;
        *fresh325 = (*cur).value;
        if last.is_null() {
            let ref mut fresh326 = (*dest).nsSet;
            *fresh326 = tmp;
        } else {
            let ref mut fresh327 = (*last).next;
            *fresh327 = tmp;
        }
        last = tmp;
        cur = (*cur).next;
    }
    if !((*dest).negNsSet).is_null() {
        xmlSchemaFreeWildcardNsSet((*dest).negNsSet);
    }
    if !((*source).negNsSet).is_null() {
        let ref mut fresh328 = (*dest).negNsSet;
        *fresh328 = xmlSchemaNewWildcardNsConstraint(ctxt);
        if ((*dest).negNsSet).is_null() {
            return -(1 as libc::c_int);
        }
        let ref mut fresh329 = (*(*dest).negNsSet).value;
        *fresh329 = (*(*source).negNsSet).value;
    } else {
        let ref mut fresh330 = (*dest).negNsSet;
        *fresh330 = 0 as xmlSchemaWildcardNsPtr;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaUnionWildcards(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut completeWild: xmlSchemaWildcardPtr,
    mut curWild: xmlSchemaWildcardPtr,
) -> libc::c_int {
    let mut cur: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut curB: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut tmp: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    if (*completeWild).any == (*curWild).any
        && ((*completeWild).nsSet == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr)
            as libc::c_int
            == ((*curWild).nsSet == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr)
                as libc::c_int
        && ((*completeWild).negNsSet == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr)
            as libc::c_int
            == ((*curWild).negNsSet == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr)
                as libc::c_int
    {
        if ((*completeWild).negNsSet).is_null()
            || (*(*completeWild).negNsSet).value == (*(*curWild).negNsSet).value
        {
            if !((*completeWild).nsSet).is_null() {
                let mut found: libc::c_int = 0 as libc::c_int;
                cur = (*completeWild).nsSet;
                while !cur.is_null() {
                    found = 0 as libc::c_int;
                    curB = (*curWild).nsSet;
                    while !curB.is_null() {
                        if (*cur).value == (*curB).value {
                            found = 1 as libc::c_int;
                            break;
                        } else {
                            curB = (*curB).next;
                        }
                    }
                    if found == 0 {
                        break;
                    }
                    cur = (*cur).next;
                }
                if found != 0 {
                    return 0 as libc::c_int;
                }
            } else {
                return 0 as libc::c_int
            }
        }
    }
    if (*completeWild).any != (*curWild).any {
        if (*completeWild).any == 0 as libc::c_int {
            (*completeWild).any = 1 as libc::c_int;
            if !((*completeWild).nsSet).is_null() {
                xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                let ref mut fresh331 = (*completeWild).nsSet;
                *fresh331 = 0 as xmlSchemaWildcardNsPtr;
            }
            if !((*completeWild).negNsSet).is_null() {
                xmlFree
                    .expect(
                        "non-null function pointer",
                    )((*completeWild).negNsSet as *mut libc::c_void);
                let ref mut fresh332 = (*completeWild).negNsSet;
                *fresh332 = 0 as xmlSchemaWildcardNsPtr;
            }
        }
        return 0 as libc::c_int;
    }
    if !((*completeWild).nsSet).is_null() && !((*curWild).nsSet).is_null() {
        let mut found_0: libc::c_int = 0;
        let mut start: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
        cur = (*curWild).nsSet;
        start = (*completeWild).nsSet;
        while !cur.is_null() {
            found_0 = 0 as libc::c_int;
            curB = start;
            while !curB.is_null() {
                if (*cur).value == (*curB).value {
                    found_0 = 1 as libc::c_int;
                    break;
                } else {
                    curB = (*curB).next;
                }
            }
            if found_0 == 0 {
                tmp = xmlSchemaNewWildcardNsConstraint(ctxt);
                if tmp.is_null() {
                    return -(1 as libc::c_int);
                }
                let ref mut fresh333 = (*tmp).value;
                *fresh333 = (*cur).value;
                let ref mut fresh334 = (*tmp).next;
                *fresh334 = (*completeWild).nsSet;
                let ref mut fresh335 = (*completeWild).nsSet;
                *fresh335 = tmp;
            }
            cur = (*cur).next;
        }
        return 0 as libc::c_int;
    }
    if !((*completeWild).negNsSet).is_null() && !((*curWild).negNsSet).is_null()
        && (*(*completeWild).negNsSet).value != (*(*curWild).negNsSet).value
    {
        let ref mut fresh336 = (*(*completeWild).negNsSet).value;
        *fresh336 = 0 as *const xmlChar;
        return 0 as libc::c_int;
    }
    if !((*completeWild).negNsSet).is_null()
        && !((*(*completeWild).negNsSet).value).is_null()
        && !((*curWild).nsSet).is_null()
        || !((*curWild).negNsSet).is_null() && !((*(*curWild).negNsSet).value).is_null()
            && !((*completeWild).nsSet).is_null()
    {
        let mut nsFound: libc::c_int = 0;
        let mut absentFound: libc::c_int = 0 as libc::c_int;
        if !((*completeWild).nsSet).is_null() {
            cur = (*completeWild).nsSet;
            curB = (*curWild).negNsSet;
        } else {
            cur = (*curWild).nsSet;
            curB = (*completeWild).negNsSet;
        }
        nsFound = 0 as libc::c_int;
        while !cur.is_null() {
            if ((*cur).value).is_null() {
                absentFound = 1 as libc::c_int;
            } else if (*cur).value == (*curB).value {
                nsFound = 1 as libc::c_int;
            }
            if nsFound != 0 && absentFound != 0 {
                break;
            }
            cur = (*cur).next;
        }
        if nsFound != 0 && absentFound != 0 {
            (*completeWild).any = 1 as libc::c_int;
            if !((*completeWild).nsSet).is_null() {
                xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                let ref mut fresh337 = (*completeWild).nsSet;
                *fresh337 = 0 as xmlSchemaWildcardNsPtr;
            }
            if !((*completeWild).negNsSet).is_null() {
                xmlFree
                    .expect(
                        "non-null function pointer",
                    )((*completeWild).negNsSet as *mut libc::c_void);
                let ref mut fresh338 = (*completeWild).negNsSet;
                *fresh338 = 0 as xmlSchemaWildcardNsPtr;
            }
        } else if nsFound != 0 && absentFound == 0 {
            if !((*completeWild).nsSet).is_null() {
                xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                let ref mut fresh339 = (*completeWild).nsSet;
                *fresh339 = 0 as xmlSchemaWildcardNsPtr;
            }
            if ((*completeWild).negNsSet).is_null() {
                let ref mut fresh340 = (*completeWild).negNsSet;
                *fresh340 = xmlSchemaNewWildcardNsConstraint(ctxt);
                if ((*completeWild).negNsSet).is_null() {
                    return -(1 as libc::c_int);
                }
            }
            let ref mut fresh341 = (*(*completeWild).negNsSet).value;
            *fresh341 = 0 as *const xmlChar;
        } else if nsFound == 0 && absentFound != 0 {
            xmlSchemaPErr(
                ctxt,
                (*completeWild).node,
                XML_SCHEMAP_UNION_NOT_EXPRESSIBLE as libc::c_int,
                b"The union of the wildcard is not expressible.\n\0" as *const u8
                    as *const libc::c_char,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return XML_SCHEMAP_UNION_NOT_EXPRESSIBLE as libc::c_int;
        } else {
            if nsFound == 0 && absentFound == 0 {
                if ((*completeWild).negNsSet).is_null() {
                    if !((*completeWild).nsSet).is_null() {
                        xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                        let ref mut fresh342 = (*completeWild).nsSet;
                        *fresh342 = 0 as xmlSchemaWildcardNsPtr;
                    }
                    let ref mut fresh343 = (*completeWild).negNsSet;
                    *fresh343 = xmlSchemaNewWildcardNsConstraint(ctxt);
                    if ((*completeWild).negNsSet).is_null() {
                        return -(1 as libc::c_int);
                    }
                    let ref mut fresh344 = (*(*completeWild).negNsSet).value;
                    *fresh344 = (*(*curWild).negNsSet).value;
                }
            }
        }
        return 0 as libc::c_int;
    }
    if !((*completeWild).negNsSet).is_null()
        && ((*(*completeWild).negNsSet).value).is_null() && !((*curWild).nsSet).is_null()
        || !((*curWild).negNsSet).is_null() && ((*(*curWild).negNsSet).value).is_null()
            && !((*completeWild).nsSet).is_null()
    {
        if !((*completeWild).nsSet).is_null() {
            cur = (*completeWild).nsSet;
        } else {
            cur = (*curWild).nsSet;
        }
        while !cur.is_null() {
            if ((*cur).value).is_null() {
                (*completeWild).any = 1 as libc::c_int;
                if !((*completeWild).nsSet).is_null() {
                    xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                    let ref mut fresh345 = (*completeWild).nsSet;
                    *fresh345 = 0 as xmlSchemaWildcardNsPtr;
                }
                if !((*completeWild).negNsSet).is_null() {
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )((*completeWild).negNsSet as *mut libc::c_void);
                    let ref mut fresh346 = (*completeWild).negNsSet;
                    *fresh346 = 0 as xmlSchemaWildcardNsPtr;
                }
                return 0 as libc::c_int;
            }
            cur = (*cur).next;
        }
        if ((*completeWild).negNsSet).is_null() {
            if !((*completeWild).nsSet).is_null() {
                xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                let ref mut fresh347 = (*completeWild).nsSet;
                *fresh347 = 0 as xmlSchemaWildcardNsPtr;
            }
            let ref mut fresh348 = (*completeWild).negNsSet;
            *fresh348 = xmlSchemaNewWildcardNsConstraint(ctxt);
            if ((*completeWild).negNsSet).is_null() {
                return -(1 as libc::c_int);
            }
            let ref mut fresh349 = (*(*completeWild).negNsSet).value;
            *fresh349 = 0 as *const xmlChar;
        }
        return 0 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaIntersectWildcards(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut completeWild: xmlSchemaWildcardPtr,
    mut curWild: xmlSchemaWildcardPtr,
) -> libc::c_int {
    let mut cur: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut curB: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut prev: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut tmp: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    if (*completeWild).any == (*curWild).any
        && ((*completeWild).nsSet == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr)
            as libc::c_int
            == ((*curWild).nsSet == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr)
                as libc::c_int
        && ((*completeWild).negNsSet == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr)
            as libc::c_int
            == ((*curWild).negNsSet == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr)
                as libc::c_int
    {
        if ((*completeWild).negNsSet).is_null()
            || (*(*completeWild).negNsSet).value == (*(*curWild).negNsSet).value
        {
            if !((*completeWild).nsSet).is_null() {
                let mut found: libc::c_int = 0 as libc::c_int;
                cur = (*completeWild).nsSet;
                while !cur.is_null() {
                    found = 0 as libc::c_int;
                    curB = (*curWild).nsSet;
                    while !curB.is_null() {
                        if (*cur).value == (*curB).value {
                            found = 1 as libc::c_int;
                            break;
                        } else {
                            curB = (*curB).next;
                        }
                    }
                    if found == 0 {
                        break;
                    }
                    cur = (*cur).next;
                }
                if found != 0 {
                    return 0 as libc::c_int;
                }
            } else {
                return 0 as libc::c_int
            }
        }
    }
    if (*completeWild).any != (*curWild).any && (*completeWild).any != 0 {
        if xmlSchemaCloneWildcardNsConstraints(ctxt, completeWild, curWild)
            == -(1 as libc::c_int)
        {
            return -(1 as libc::c_int);
        }
        return 0 as libc::c_int;
    }
    if !((*completeWild).negNsSet).is_null() && !((*curWild).nsSet).is_null()
        || !((*curWild).negNsSet).is_null() && !((*completeWild).nsSet).is_null()
    {
        let mut neg: *const xmlChar = 0 as *const xmlChar;
        if ((*completeWild).nsSet).is_null() {
            neg = (*(*completeWild).negNsSet).value;
            if xmlSchemaCloneWildcardNsConstraints(ctxt, completeWild, curWild)
                == -(1 as libc::c_int)
            {
                return -(1 as libc::c_int);
            }
        } else {
            neg = (*(*curWild).negNsSet).value;
        }
        prev = 0 as xmlSchemaWildcardNsPtr;
        cur = (*completeWild).nsSet;
        while !cur.is_null() {
            if ((*cur).value).is_null() {
                if prev.is_null() {
                    let ref mut fresh350 = (*completeWild).nsSet;
                    *fresh350 = (*cur).next;
                } else {
                    let ref mut fresh351 = (*prev).next;
                    *fresh351 = (*cur).next;
                }
                xmlFree.expect("non-null function pointer")(cur as *mut libc::c_void);
                break;
            } else {
                prev = cur;
                cur = (*cur).next;
            }
        }
        if !neg.is_null() {
            prev = 0 as xmlSchemaWildcardNsPtr;
            cur = (*completeWild).nsSet;
            while !cur.is_null() {
                if (*cur).value == neg {
                    if prev.is_null() {
                        let ref mut fresh352 = (*completeWild).nsSet;
                        *fresh352 = (*cur).next;
                    } else {
                        let ref mut fresh353 = (*prev).next;
                        *fresh353 = (*cur).next;
                    }
                    xmlFree
                        .expect("non-null function pointer")(cur as *mut libc::c_void);
                    break;
                } else {
                    prev = cur;
                    cur = (*cur).next;
                }
            }
        }
        return 0 as libc::c_int;
    }
    if !((*completeWild).nsSet).is_null() && !((*curWild).nsSet).is_null() {
        let mut found_0: libc::c_int = 0;
        cur = (*completeWild).nsSet;
        prev = 0 as xmlSchemaWildcardNsPtr;
        while !cur.is_null() {
            found_0 = 0 as libc::c_int;
            curB = (*curWild).nsSet;
            while !curB.is_null() {
                if (*cur).value == (*curB).value {
                    found_0 = 1 as libc::c_int;
                    break;
                } else {
                    curB = (*curB).next;
                }
            }
            if found_0 == 0 {
                if prev.is_null() {
                    let ref mut fresh354 = (*completeWild).nsSet;
                    *fresh354 = (*cur).next;
                } else {
                    let ref mut fresh355 = (*prev).next;
                    *fresh355 = (*cur).next;
                }
                tmp = (*cur).next;
                xmlFree.expect("non-null function pointer")(cur as *mut libc::c_void);
                cur = tmp;
            } else {
                prev = cur;
                cur = (*cur).next;
            }
        }
        return 0 as libc::c_int;
    }
    if !((*completeWild).negNsSet).is_null() && !((*curWild).negNsSet).is_null()
        && (*(*completeWild).negNsSet).value != (*(*curWild).negNsSet).value
        && !((*(*completeWild).negNsSet).value).is_null()
        && !((*(*curWild).negNsSet).value).is_null()
    {
        xmlSchemaPErr(
            ctxt,
            (*completeWild).node,
            XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE as libc::c_int,
            b"The intersection of the wildcard is not expressible.\n\0" as *const u8
                as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE as libc::c_int;
    }
    if !((*completeWild).negNsSet).is_null() && !((*curWild).negNsSet).is_null()
        && (*(*completeWild).negNsSet).value != (*(*curWild).negNsSet).value
        && ((*(*completeWild).negNsSet).value).is_null()
    {
        let ref mut fresh356 = (*(*completeWild).negNsSet).value;
        *fresh356 = (*(*curWild).negNsSet).value;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaCheckCOSNSSubset(
    mut sub: xmlSchemaWildcardPtr,
    mut super_0: xmlSchemaWildcardPtr,
) -> libc::c_int {
    if (*super_0).any != 0 {
        return 0 as libc::c_int;
    }
    if !((*sub).negNsSet).is_null() && !((*super_0).negNsSet).is_null()
        && (*(*sub).negNsSet).value == (*(*super_0).negNsSet).value
    {
        return 0 as libc::c_int;
    }
    if !((*sub).nsSet).is_null() {
        if !((*super_0).nsSet).is_null() {
            let mut cur: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
            let mut curB: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
            let mut found: libc::c_int = 0 as libc::c_int;
            cur = (*sub).nsSet;
            while !cur.is_null() {
                found = 0 as libc::c_int;
                curB = (*super_0).nsSet;
                while !curB.is_null() {
                    if (*cur).value == (*curB).value {
                        found = 1 as libc::c_int;
                        break;
                    } else {
                        curB = (*curB).next;
                    }
                }
                if found == 0 {
                    return 1 as libc::c_int;
                }
                cur = (*cur).next;
            }
            if found != 0 {
                return 0 as libc::c_int;
            }
        } else if !((*super_0).negNsSet).is_null() {
            let mut cur_0: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
            cur_0 = (*sub).nsSet;
            while !cur_0.is_null() {
                if (*cur_0).value == (*(*super_0).negNsSet).value {
                    return 1 as libc::c_int;
                }
                cur_0 = (*cur_0).next;
            }
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaGetEffectiveValueConstraint(
    mut attruse: xmlSchemaAttributeUsePtr,
    mut fixed: *mut libc::c_int,
    mut value: *mut *const xmlChar,
    mut val: *mut xmlSchemaValPtr,
) -> libc::c_int {
    *fixed = 0 as libc::c_int;
    *value = 0 as *const xmlChar;
    if !val.is_null() {
        *val = 0 as xmlSchemaValPtr;
    }
    if !((*attruse).defValue).is_null() {
        *value = (*attruse).defValue;
        if !val.is_null() {
            *val = (*attruse).defVal;
        }
        if (*attruse).flags & (1 as libc::c_int) << 0 as libc::c_int != 0 {
            *fixed = 1 as libc::c_int;
        }
        return 1 as libc::c_int;
    } else {
        if !((*attruse).attrDecl).is_null()
            && !((*(*attruse).attrDecl).defValue).is_null()
        {
            *value = (*(*attruse).attrDecl).defValue;
            if !val.is_null() {
                *val = (*(*attruse).attrDecl).defVal;
            }
            if (*(*attruse).attrDecl).flags & (1 as libc::c_int) << 9 as libc::c_int != 0
            {
                *fixed = 1 as libc::c_int;
            }
            return 1 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaCheckCVCWildcardNamespace(
    mut wild: xmlSchemaWildcardPtr,
    mut ns: *const xmlChar,
) -> libc::c_int {
    if wild.is_null() {
        return -(1 as libc::c_int);
    }
    if (*wild).any != 0 {
        return 0 as libc::c_int
    } else {
        if !((*wild).nsSet).is_null() {
            let mut cur: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
            cur = (*wild).nsSet;
            while !cur.is_null() {
                if xmlStrEqual((*cur).value, ns) != 0 {
                    return 0 as libc::c_int;
                }
                cur = (*cur).next;
            }
        } else if !((*wild).negNsSet).is_null() && !ns.is_null()
                && xmlStrEqual((*(*wild).negNsSet).value, ns) == 0
            {
            return 0 as libc::c_int
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaCheckDerivationOKRestriction2to4(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut action: libc::c_int,
    mut item: xmlSchemaBasicItemPtr,
    mut baseItem: xmlSchemaBasicItemPtr,
    mut uses: xmlSchemaItemListPtr,
    mut baseUses: xmlSchemaItemListPtr,
    mut wild: xmlSchemaWildcardPtr,
    mut baseWild: xmlSchemaWildcardPtr,
) -> libc::c_int {
    let mut cur: xmlSchemaAttributeUsePtr = 0 as xmlSchemaAttributeUsePtr;
    let mut bcur: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut found: libc::c_int = 0;
    let mut bEffValue: *const xmlChar = 0 as *const xmlChar;
    let mut effFixed: libc::c_int = 0;
    if !uses.is_null() {
        i = 0 as libc::c_int;
        while i < (*uses).nbItems {
            cur = *((*uses).items).offset(i as isize) as xmlSchemaAttributeUsePtr;
            found = 0 as libc::c_int;
            if !baseUses.is_null() {
                j = 0 as libc::c_int;
                while j < (*baseUses).nbItems {
                    bcur = *((*baseUses).items).offset(j as isize)
                        as xmlSchemaAttributeUsePtr;
                    if (*(*cur).attrDecl).name == (*(*bcur).attrDecl).name
                        && (*(*cur).attrDecl).targetNamespace
                            == (*(*bcur).attrDecl).targetNamespace
                    {
                        found = 1 as libc::c_int;
                        if (*cur).occurs == 2 as libc::c_int
                            && (*bcur).occurs == 1 as libc::c_int
                        {
                            let mut str: *mut xmlChar = 0 as *mut xmlChar;
                            xmlSchemaPAttrUseErr4(
                                pctxt,
                                XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1,
                                xmlSchemaGetComponentNode(item),
                                item,
                                cur,
                                b"The 'optional' attribute use is inconsistent with the corresponding 'required' attribute use of the %s %s\0"
                                    as *const u8 as *const libc::c_char,
                                if action == 0 as libc::c_int {
                                    b"base\0" as *const u8 as *const libc::c_char
                                        as *const xmlChar
                                } else {
                                    b"redefined\0" as *const u8 as *const libc::c_char
                                        as *const xmlChar
                                },
                                xmlSchemaGetComponentDesignation(
                                    &mut str,
                                    baseItem as *mut libc::c_void,
                                ),
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                            if !str.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(str as *mut libc::c_void);
                                str = 0 as *mut xmlChar;
                            }
                        } else if xmlSchemaCheckCOSSTDerivedOK(
                                pctxt as xmlSchemaAbstractCtxtPtr,
                                (*(*cur).attrDecl).subtypes,
                                (*(*bcur).attrDecl).subtypes,
                                0 as libc::c_int,
                            ) != 0 as libc::c_int
                            {
                            let mut strA: *mut xmlChar = 0 as *mut xmlChar;
                            let mut strB: *mut xmlChar = 0 as *mut xmlChar;
                            let mut strC: *mut xmlChar = 0 as *mut xmlChar;
                            xmlSchemaPAttrUseErr4(
                                pctxt,
                                XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2,
                                xmlSchemaGetComponentNode(item),
                                item,
                                cur,
                                b"The attribute declaration's %s is not validly derived from the corresponding %s of the attribute declaration in the %s %s\0"
                                    as *const u8 as *const libc::c_char,
                                xmlSchemaGetComponentDesignation(
                                    &mut strA,
                                    (*(*cur).attrDecl).subtypes as *mut libc::c_void,
                                ),
                                xmlSchemaGetComponentDesignation(
                                    &mut strB,
                                    (*(*bcur).attrDecl).subtypes as *mut libc::c_void,
                                ),
                                if action == 0 as libc::c_int {
                                    b"base\0" as *const u8 as *const libc::c_char
                                        as *const xmlChar
                                } else {
                                    b"redefined\0" as *const u8 as *const libc::c_char
                                        as *const xmlChar
                                },
                                xmlSchemaGetComponentDesignation(
                                    &mut strC,
                                    baseItem as *mut libc::c_void,
                                ),
                            );
                            if !strA.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(strA as *mut libc::c_void);
                                strA = 0 as *mut xmlChar;
                            }
                            if !strB.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(strB as *mut libc::c_void);
                                strB = 0 as *mut xmlChar;
                            }
                            if !strC.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(strC as *mut libc::c_void);
                                strC = 0 as *mut xmlChar;
                            }
                        } else {
                            xmlSchemaGetEffectiveValueConstraint(
                                bcur,
                                &mut effFixed,
                                &mut bEffValue,
                                0 as *mut xmlSchemaValPtr,
                            );
                            if !bEffValue.is_null() && effFixed == 1 as libc::c_int {
                                let mut rEffValue: *const xmlChar = 0 as *const xmlChar;
                                xmlSchemaGetEffectiveValueConstraint(
                                    bcur,
                                    &mut effFixed,
                                    &mut rEffValue,
                                    0 as *mut xmlSchemaValPtr,
                                );
                                if effFixed == 0 as libc::c_int || !(rEffValue == bEffValue)
                                {
                                    let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                                    xmlSchemaPAttrUseErr4(
                                        pctxt,
                                        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3,
                                        xmlSchemaGetComponentNode(item),
                                        item,
                                        cur,
                                        b"The effective value constraint of the attribute use is inconsistent with its correspondent in the %s %s\0"
                                            as *const u8 as *const libc::c_char,
                                        if action == 0 as libc::c_int {
                                            b"base\0" as *const u8 as *const libc::c_char
                                                as *const xmlChar
                                        } else {
                                            b"redefined\0" as *const u8 as *const libc::c_char
                                                as *const xmlChar
                                        },
                                        xmlSchemaGetComponentDesignation(
                                            &mut str_0,
                                            baseItem as *mut libc::c_void,
                                        ),
                                        0 as *const xmlChar,
                                        0 as *const xmlChar,
                                    );
                                    if !str_0.is_null() {
                                        xmlFree
                                            .expect(
                                                "non-null function pointer",
                                            )(str_0 as *mut libc::c_void);
                                        str_0 = 0 as *mut xmlChar;
                                    }
                                }
                            }
                        }
                        break;
                    } else {
                        j += 1;
                    }
                }
            }
            if found == 0 {
                if baseWild.is_null()
                    || xmlSchemaCheckCVCWildcardNamespace(
                        baseWild,
                        (*(*cur).attrDecl).targetNamespace,
                    ) != 0 as libc::c_int
                {
                    let mut str_1: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaPAttrUseErr4(
                        pctxt,
                        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2,
                        xmlSchemaGetComponentNode(item),
                        item,
                        cur,
                        b"Neither a matching attribute use, nor a matching wildcard exists in the %s %s\0"
                            as *const u8 as *const libc::c_char,
                        if action == 0 as libc::c_int {
                            b"base\0" as *const u8 as *const libc::c_char
                                as *const xmlChar
                        } else {
                            b"redefined\0" as *const u8 as *const libc::c_char
                                as *const xmlChar
                        },
                        xmlSchemaGetComponentDesignation(
                            &mut str_1,
                            baseItem as *mut libc::c_void,
                        ),
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                    if !str_1.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str_1 as *mut libc::c_void);
                        str_1 = 0 as *mut xmlChar;
                    }
                }
            }
            i += 1;
        }
    }
    if !baseUses.is_null() {
        j = 0 as libc::c_int;
        while j < (*baseUses).nbItems {
            bcur = *((*baseUses).items).offset(j as isize) as xmlSchemaAttributeUsePtr;
            if !((*bcur).occurs != 1 as libc::c_int) {
                found = 0 as libc::c_int;
                if !uses.is_null() {
                    i = 0 as libc::c_int;
                    while i < (*uses).nbItems {
                        cur = *((*uses).items).offset(i as isize)
                            as xmlSchemaAttributeUsePtr;
                        if (*(*cur).attrDecl).name == (*(*bcur).attrDecl).name
                            && (*(*cur).attrDecl).targetNamespace
                                == (*(*bcur).attrDecl).targetNamespace
                        {
                            found = 1 as libc::c_int;
                            break;
                        } else {
                            i += 1;
                        }
                    }
                }
                if found == 0 {
                    let mut strA_0: *mut xmlChar = 0 as *mut xmlChar;
                    let mut strB_0: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaCustomErr4(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3,
                        0 as xmlNodePtr,
                        item,
                        b"A matching attribute use for the 'required' %s of the %s %s is missing\0"
                            as *const u8 as *const libc::c_char,
                        xmlSchemaGetComponentDesignation(
                            &mut strA_0,
                            bcur as *mut libc::c_void,
                        ),
                        if action == 0 as libc::c_int {
                            b"base\0" as *const u8 as *const libc::c_char
                                as *const xmlChar
                        } else {
                            b"redefined\0" as *const u8 as *const libc::c_char
                                as *const xmlChar
                        },
                        xmlSchemaGetComponentDesignation(
                            &mut strB_0,
                            baseItem as *mut libc::c_void,
                        ),
                        0 as *const xmlChar,
                    );
                    if !strA_0.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(strA_0 as *mut libc::c_void);
                        strA_0 = 0 as *mut xmlChar;
                    }
                    if !strB_0.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(strB_0 as *mut libc::c_void);
                        strB_0 = 0 as *mut xmlChar;
                    }
                }
            }
            j += 1;
        }
    }
    if !wild.is_null() {
        if baseWild.is_null() {
            let mut str_2: *mut xmlChar = 0 as *mut xmlChar;
            xmlSchemaCustomErr4(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1,
                0 as xmlNodePtr,
                item,
                b"The %s has an attribute wildcard, but the %s %s '%s' does not have one\0"
                    as *const u8 as *const libc::c_char,
                xmlSchemaGetComponentTypeStr(item),
                if action == 0 as libc::c_int {
                    b"base\0" as *const u8 as *const libc::c_char as *const xmlChar
                } else {
                    b"redefined\0" as *const u8 as *const libc::c_char as *const xmlChar
                },
                xmlSchemaGetComponentTypeStr(baseItem),
                xmlSchemaGetComponentQName(&mut str_2, baseItem as *mut libc::c_void),
            );
            if !str_2.is_null() {
                xmlFree.expect("non-null function pointer")(str_2 as *mut libc::c_void);
                str_2 = 0 as *mut xmlChar;
            }
            return (*pctxt).err;
        } else {
            if (*baseWild).any == 0 as libc::c_int
                && xmlSchemaCheckCOSNSSubset(wild, baseWild) != 0
            {
                let mut str_3: *mut xmlChar = 0 as *mut xmlChar;
                xmlSchemaCustomErr4(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2,
                    0 as xmlNodePtr,
                    item,
                    b"The attribute wildcard is not a valid subset of the wildcard in the %s %s '%s'\0"
                        as *const u8 as *const libc::c_char,
                    if action == 0 as libc::c_int {
                        b"base\0" as *const u8 as *const libc::c_char as *const xmlChar
                    } else {
                        b"redefined\0" as *const u8 as *const libc::c_char
                            as *const xmlChar
                    },
                    xmlSchemaGetComponentTypeStr(baseItem),
                    xmlSchemaGetComponentQName(
                        &mut str_3,
                        baseItem as *mut libc::c_void,
                    ),
                    0 as *const xmlChar,
                );
                if !str_3.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str_3 as *mut libc::c_void);
                    str_3 = 0 as *mut xmlChar;
                }
                return (*pctxt).err;
            }
        }
        if !((*baseItem).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
            && (*(baseItem as xmlSchemaTypePtr)).builtInType
                == XML_SCHEMAS_ANYTYPE as libc::c_int)
            && (*wild).processContents < (*baseWild).processContents
        {
            let mut str_4: *mut xmlChar = 0 as *mut xmlChar;
            xmlSchemaCustomErr4(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3,
                0 as xmlNodePtr,
                baseItem,
                b"The {process contents} of the attribute wildcard is weaker than the one in the %s %s '%s'\0"
                    as *const u8 as *const libc::c_char,
                if action == 0 as libc::c_int {
                    b"base\0" as *const u8 as *const libc::c_char as *const xmlChar
                } else {
                    b"redefined\0" as *const u8 as *const libc::c_char as *const xmlChar
                },
                xmlSchemaGetComponentTypeStr(baseItem),
                xmlSchemaGetComponentQName(&mut str_4, baseItem as *mut libc::c_void),
                0 as *const xmlChar,
            );
            if !str_4.is_null() {
                xmlFree.expect("non-null function pointer")(str_4 as *mut libc::c_void);
                str_4 = 0 as *mut xmlChar;
            }
            return (*pctxt).err;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaFixupTypeAttributeUses(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> libc::c_int {
    let mut current_block: u64;
    let mut baseType: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
    let mut use_0: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
    let mut uses: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    let mut baseUses: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    let mut prohibs: xmlSchemaItemListPtr = 0 as xmlSchemaItemListPtr;
    if ((*type_0).baseType).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaFixupTypeAttributeUses\0" as *const u8 as *const libc::c_char,
            b"no base type\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    baseType = (*type_0).baseType;
    if (*baseType).type_0 as libc::c_uint
        != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
        && (*baseType).flags & (1 as libc::c_int) << 22 as libc::c_int
            == 0 as libc::c_int
    {
        if xmlSchemaTypeFixup(baseType, pctxt as xmlSchemaAbstractCtxtPtr)
            == -(1 as libc::c_int)
        {
            return -(1 as libc::c_int);
        }
    }
    uses = (*type_0).attrUses as xmlSchemaItemListPtr;
    baseUses = (*baseType).attrUses as xmlSchemaItemListPtr;
    if !uses.is_null() {
        if (*type_0).flags & (1 as libc::c_int) << 2 as libc::c_int != 0 {
            if xmlSchemaExpandAttributeGroupRefs(
                pctxt,
                type_0 as xmlSchemaBasicItemPtr,
                &mut (*type_0).attributeWildcard,
                uses,
                (*pctxt).attrProhibs,
            ) == -(1 as libc::c_int)
            {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaFixupTypeAttributeUses\0" as *const u8
                        as *const libc::c_char,
                    b"failed to expand attributes\0" as *const u8 as *const libc::c_char,
                );
            }
            if (*(*pctxt).attrProhibs).nbItems != 0 as libc::c_int {
                prohibs = (*pctxt).attrProhibs;
            }
        } else if xmlSchemaExpandAttributeGroupRefs(
                pctxt,
                type_0 as xmlSchemaBasicItemPtr,
                &mut (*type_0).attributeWildcard,
                uses,
                0 as xmlSchemaItemListPtr,
            ) == -(1 as libc::c_int)
            {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaFixupTypeAttributeUses\0" as *const u8 as *const libc::c_char,
                b"failed to expand attributes\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    if !baseUses.is_null() {
        let mut i: libc::c_int = 0;
        let mut j: libc::c_int = 0;
        let mut pro: xmlSchemaAttributeUseProhibPtr = 0
            as *mut xmlSchemaAttributeUseProhib;
        if (*type_0).flags & (1 as libc::c_int) << 2 as libc::c_int != 0 {
            let mut usesCount: libc::c_int = 0;
            let mut tmp: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
            if !uses.is_null() {
                usesCount = (*uses).nbItems;
            } else {
                usesCount = 0 as libc::c_int;
            }
            i = 0 as libc::c_int;
            loop {
                if !(i < (*baseUses).nbItems) {
                    current_block = 1874315696050160458;
                    break;
                }
                use_0 = *((*baseUses).items).offset(i as isize)
                    as xmlSchemaAttributeUsePtr;
                if !prohibs.is_null() {
                    j = 0 as libc::c_int;
                    loop {
                        if !(j < (*prohibs).nbItems) {
                            current_block = 572715077006366937;
                            break;
                        }
                        pro = *((*prohibs).items).offset(j as isize)
                            as xmlSchemaAttributeUseProhibPtr;
                        if (*(*use_0).attrDecl).name == (*pro).name
                            && (*(*use_0).attrDecl).targetNamespace
                                == (*pro).targetNamespace
                        {
                            current_block = 3275366147856559585;
                            break;
                        }
                        j += 1;
                    }
                } else {
                    current_block = 572715077006366937;
                }
                match current_block {
                    572715077006366937 => {
                        if usesCount != 0 {
                            j = 0 as libc::c_int;
                            loop {
                                if !(j < usesCount) {
                                    current_block = 11763295167351361500;
                                    break;
                                }
                                tmp = *((*uses).items).offset(j as isize)
                                    as xmlSchemaAttributeUsePtr;
                                if (*(*use_0).attrDecl).name == (*(*tmp).attrDecl).name
                                    && (*(*use_0).attrDecl).targetNamespace
                                        == (*(*tmp).attrDecl).targetNamespace
                                {
                                    current_block = 3275366147856559585;
                                    break;
                                }
                                j += 1;
                            }
                        } else {
                            current_block = 11763295167351361500;
                        }
                        match current_block {
                            3275366147856559585 => {}
                            _ => {
                                if uses.is_null() {
                                    let ref mut fresh357 = (*type_0).attrUses;
                                    *fresh357 = xmlSchemaItemListCreate() as *mut libc::c_void;
                                    if ((*type_0).attrUses).is_null() {
                                        current_block = 6737818789714211697;
                                        break;
                                    }
                                    uses = (*type_0).attrUses as xmlSchemaItemListPtr;
                                }
                                xmlSchemaItemListAddSize(
                                    uses,
                                    2 as libc::c_int,
                                    use_0 as *mut libc::c_void,
                                );
                            }
                        }
                    }
                    _ => {}
                }
                i += 1;
            }
        } else {
            i = 0 as libc::c_int;
            loop {
                if !(i < (*baseUses).nbItems) {
                    current_block = 1874315696050160458;
                    break;
                }
                use_0 = *((*baseUses).items).offset(i as isize)
                    as xmlSchemaAttributeUsePtr;
                if uses.is_null() {
                    let ref mut fresh358 = (*type_0).attrUses;
                    *fresh358 = xmlSchemaItemListCreate() as *mut libc::c_void;
                    if ((*type_0).attrUses).is_null() {
                        current_block = 6737818789714211697;
                        break;
                    }
                    uses = (*type_0).attrUses as xmlSchemaItemListPtr;
                }
                xmlSchemaItemListAddSize(
                    uses,
                    (*baseUses).nbItems,
                    use_0 as *mut libc::c_void,
                );
                i += 1;
            }
        }
    } else {
        current_block = 1874315696050160458;
    }
    match current_block {
        1874315696050160458 => {
            if !uses.is_null() {
                if (*uses).nbItems == 0 as libc::c_int {
                    xmlSchemaItemListFree(uses);
                    let ref mut fresh359 = (*type_0).attrUses;
                    *fresh359 = 0 as *mut libc::c_void;
                }
            }
            if (*type_0).flags & (1 as libc::c_int) << 1 as libc::c_int != 0 {
                if !((*baseType).attributeWildcard).is_null() {
                    if !((*type_0).attributeWildcard).is_null() {
                        if xmlSchemaUnionWildcards(
                            pctxt,
                            (*type_0).attributeWildcard,
                            (*baseType).attributeWildcard,
                        ) == -(1 as libc::c_int)
                        {
                            current_block = 6737818789714211697;
                        } else {
                            current_block = 9705665520141849625;
                        }
                    } else {
                        let ref mut fresh360 = (*type_0).attributeWildcard;
                        *fresh360 = (*baseType).attributeWildcard;
                        current_block = 9705665520141849625;
                    }
                } else {
                    current_block = 9705665520141849625;
                }
            } else {
                current_block = 9705665520141849625;
            }
            match current_block {
                6737818789714211697 => {}
                _ => return 0 as libc::c_int,
            }
        }
        _ => {}
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn xmlSchemaTypeFinalContains(
    mut type_0: xmlSchemaTypePtr,
    mut final_0: libc::c_int,
) -> libc::c_int {
    if type_0.is_null() {
        return 0 as libc::c_int;
    }
    if (*type_0).flags & final_0 != 0 {
        return 1 as libc::c_int
    } else {
        return 0 as libc::c_int
    };
}
unsafe extern "C" fn xmlSchemaGetUnionSimpleTypeMemberTypes(
    mut type_0: xmlSchemaTypePtr,
) -> xmlSchemaTypeLinkPtr {
    while !type_0.is_null()
        && (*type_0).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
    {
        if !((*type_0).memberTypes).is_null() {
            return (*type_0).memberTypes
        } else {
            type_0 = (*type_0).baseType;
        }
    }
    return 0 as xmlSchemaTypeLinkPtr;
}
unsafe extern "C" fn xmlSchemaGetParticleEmptiable(
    mut particle: xmlSchemaParticlePtr,
) -> libc::c_int {
    let mut part: xmlSchemaParticlePtr = 0 as *mut xmlSchemaParticle;
    let mut emptiable: libc::c_int = 0;
    if ((*particle).children).is_null() || (*particle).minOccurs == 0 as libc::c_int {
        return 1 as libc::c_int;
    }
    part = (*(*particle).children).children as xmlSchemaParticlePtr;
    if part.is_null() {
        return 1 as libc::c_int;
    }
    while !part.is_null() {
        if (*(*part).children).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_ELEMENT as libc::c_int as libc::c_uint
            || (*(*part).children).type_0 as libc::c_uint
                == XML_SCHEMA_TYPE_ANY as libc::c_int as libc::c_uint
        {
            emptiable = ((*part).minOccurs == 0 as libc::c_int) as libc::c_int;
        } else {
            emptiable = xmlSchemaGetParticleEmptiable(part);
        }
        if (*(*particle).children).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_CHOICE as libc::c_int as libc::c_uint
        {
            if emptiable != 0 {
                return 1 as libc::c_int;
            }
        } else if emptiable == 0 {
            return 0 as libc::c_int
        }
        part = (*part).next as xmlSchemaParticlePtr;
    }
    if (*(*particle).children).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_CHOICE as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int
    } else {
        return 1 as libc::c_int
    };
}
unsafe extern "C" fn xmlSchemaIsParticleEmptiable(
    mut particle: xmlSchemaParticlePtr,
) -> libc::c_int {
    if particle.is_null() || (*particle).minOccurs == 0 as libc::c_int
        || ((*particle).children).is_null()
    {
        return 1 as libc::c_int;
    }
    if (*(*particle).children).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_SEQUENCE as libc::c_int as libc::c_uint
        || (*(*particle).children).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_CHOICE as libc::c_int as libc::c_uint
        || (*(*particle).children).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_ALL as libc::c_int as libc::c_uint
    {
        return xmlSchemaGetParticleEmptiable(particle);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaCheckCOSSTDerivedOK(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
    mut baseType: xmlSchemaTypePtr,
    mut subset: libc::c_int,
) -> libc::c_int {
    if type_0 == baseType {
        return 0 as libc::c_int;
    }
    if (*type_0).type_0 as libc::c_uint
        != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
        && (*type_0).flags & (1 as libc::c_int) << 22 as libc::c_int == 0 as libc::c_int
    {
        if xmlSchemaTypeFixup(type_0, actxt) == -(1 as libc::c_int) {
            return -(1 as libc::c_int);
        }
    }
    if (*baseType).type_0 as libc::c_uint
        != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
        && (*baseType).flags & (1 as libc::c_int) << 22 as libc::c_int
            == 0 as libc::c_int
    {
        if xmlSchemaTypeFixup(baseType, actxt) == -(1 as libc::c_int) {
            return -(1 as libc::c_int);
        }
    }
    if subset & (1 as libc::c_int) << 0 as libc::c_int != 0
        || xmlSchemaTypeFinalContains(
            (*type_0).baseType,
            (1 as libc::c_int) << 10 as libc::c_int,
        ) != 0
    {
        return XML_SCHEMAP_COS_ST_DERIVED_OK_2_1 as libc::c_int;
    }
    if (*type_0).baseType == baseType {
        return 0 as libc::c_int;
    }
    if !((*(*type_0).baseType).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
        && (*(*type_0).baseType).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int)
        && xmlSchemaCheckCOSSTDerivedOK(actxt, (*type_0).baseType, baseType, subset)
            == 0 as libc::c_int
    {
        return 0 as libc::c_int;
    }
    if (*baseType).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
        && (*baseType).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as libc::c_int
        && ((*type_0).flags & (1 as libc::c_int) << 6 as libc::c_int != 0
            || (*type_0).flags & (1 as libc::c_int) << 7 as libc::c_int != 0)
    {
        return 0 as libc::c_int;
    }
    if (*baseType).flags & (1 as libc::c_int) << 7 as libc::c_int != 0 {
        let mut cur: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
        cur = (*baseType).memberTypes;
        while !cur.is_null() {
            if (*(*cur).type_0).type_0 as libc::c_uint
                != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                && (*(*cur).type_0).flags & (1 as libc::c_int) << 22 as libc::c_int
                    == 0 as libc::c_int
            {
                if xmlSchemaTypeFixup((*cur).type_0, actxt) == -(1 as libc::c_int) {
                    return -(1 as libc::c_int);
                }
            }
            if xmlSchemaCheckCOSSTDerivedOK(actxt, type_0, (*cur).type_0, subset)
                == 0 as libc::c_int
            {
                return 0 as libc::c_int;
            }
            cur = (*cur).next;
        }
    }
    return XML_SCHEMAP_COS_ST_DERIVED_OK_2_2 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaCheckTypeDefCircularInternal(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut ctxtType: xmlSchemaTypePtr,
    mut ancestor: xmlSchemaTypePtr,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    if ancestor.is_null()
        || (*ancestor).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int;
    }
    if ctxtType == ancestor {
        xmlSchemaPCustomErr(
            pctxt,
            XML_SCHEMAP_ST_PROPS_CORRECT_2,
            ctxtType as xmlSchemaBasicItemPtr,
            xmlSchemaGetComponentNode(ctxtType as xmlSchemaBasicItemPtr),
            b"The definition is circular\0" as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_ST_PROPS_CORRECT_2 as libc::c_int;
    }
    if (*ancestor).flags & (1 as libc::c_int) << 16 as libc::c_int != 0 {
        return 0 as libc::c_int;
    }
    (*ancestor).flags |= (1 as libc::c_int) << 16 as libc::c_int;
    ret = xmlSchemaCheckTypeDefCircularInternal(pctxt, ctxtType, (*ancestor).baseType);
    (*ancestor).flags ^= (1 as libc::c_int) << 16 as libc::c_int;
    return ret;
}
unsafe extern "C" fn xmlSchemaCheckTypeDefCircular(
    mut item: xmlSchemaTypePtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) {
    if item.is_null()
        || (*item).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
        || ((*item).baseType).is_null()
    {
        return;
    }
    xmlSchemaCheckTypeDefCircularInternal(ctxt, item, (*item).baseType);
}
unsafe extern "C" fn xmlSchemaCheckUnionTypeDefCircularRecur(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut ctxType: xmlSchemaTypePtr,
    mut members: xmlSchemaTypeLinkPtr,
) -> libc::c_int {
    let mut member: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut memberType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    member = members;
    while !member.is_null() {
        memberType = (*member).type_0;
        while !memberType.is_null()
            && (*memberType).type_0 as libc::c_uint
                != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
        {
            if memberType == ctxType {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_SRC_SIMPLE_TYPE_4,
                    ctxType as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The union type definition is circular\0" as *const u8
                        as *const libc::c_char,
                    0 as *const xmlChar,
                );
                return XML_SCHEMAP_SRC_SIMPLE_TYPE_4 as libc::c_int;
            }
            if (*memberType).flags & (1 as libc::c_int) << 7 as libc::c_int != 0
                && (*memberType).flags & (1 as libc::c_int) << 16 as libc::c_int
                    == 0 as libc::c_int
            {
                let mut res: libc::c_int = 0;
                (*memberType).flags |= (1 as libc::c_int) << 16 as libc::c_int;
                res = xmlSchemaCheckUnionTypeDefCircularRecur(
                    pctxt,
                    ctxType,
                    xmlSchemaGetUnionSimpleTypeMemberTypes(memberType),
                );
                (*memberType).flags ^= (1 as libc::c_int) << 16 as libc::c_int;
                if res != 0 as libc::c_int {
                    return res;
                }
            }
            memberType = (*memberType).baseType;
        }
        member = (*member).next;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaCheckUnionTypeDefCircular(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> libc::c_int {
    if (*type_0).flags & (1 as libc::c_int) << 7 as libc::c_int == 0 {
        return 0 as libc::c_int;
    }
    return xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, type_0, (*type_0).memberTypes);
}
unsafe extern "C" fn xmlSchemaResolveTypeReferences(
    mut typeDef: xmlSchemaTypePtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) {
    if typeDef.is_null() {
        return;
    }
    if ((*typeDef).baseType).is_null() {
        let ref mut fresh361 = (*typeDef).baseType;
        *fresh361 = xmlSchemaGetType((*ctxt).schema, (*typeDef).base, (*typeDef).baseNs);
        if ((*typeDef).baseType).is_null() {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                typeDef as xmlSchemaBasicItemPtr,
                (*typeDef).node,
                b"base\0" as *const u8 as *const libc::c_char,
                (*typeDef).base,
                (*typeDef).baseNs,
                XML_SCHEMA_TYPE_SIMPLE,
                0 as *const libc::c_char,
            );
            return;
        }
    }
    if (*typeDef).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
        || (*typeDef).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
            && (*typeDef).builtInType != XML_SCHEMAS_ANYTYPE as libc::c_int
    {
        if (*typeDef).flags & (1 as libc::c_int) << 7 as libc::c_int != 0 {
            xmlSchemaResolveUnionMemberTypes(ctxt, typeDef);
            return;
        } else {
            if (*typeDef).flags & (1 as libc::c_int) << 6 as libc::c_int != 0 {
                if ((*typeDef).subtypes).is_null() && !((*typeDef).base).is_null() {
                    let ref mut fresh362 = (*typeDef).subtypes;
                    *fresh362 = xmlSchemaGetType(
                        (*ctxt).schema,
                        (*typeDef).base,
                        (*typeDef).baseNs,
                    );
                    if ((*typeDef).subtypes).is_null()
                        || !((*(*typeDef).subtypes).type_0 as libc::c_uint
                            == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
                            || (*(*typeDef).subtypes).type_0 as libc::c_uint
                                == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                                && (*(*typeDef).subtypes).builtInType
                                    != XML_SCHEMAS_ANYTYPE as libc::c_int)
                    {
                        let ref mut fresh363 = (*typeDef).subtypes;
                        *fresh363 = 0 as xmlSchemaTypePtr;
                        xmlSchemaPResCompAttrErr(
                            ctxt,
                            XML_SCHEMAP_SRC_RESOLVE,
                            typeDef as xmlSchemaBasicItemPtr,
                            (*typeDef).node,
                            b"itemType\0" as *const u8 as *const libc::c_char,
                            (*typeDef).base,
                            (*typeDef).baseNs,
                            XML_SCHEMA_TYPE_SIMPLE,
                            0 as *const libc::c_char,
                        );
                    }
                }
                return;
            }
        }
    } else if !((*typeDef).subtypes).is_null()
            && (*(*typeDef).subtypes).type_0 as libc::c_uint
                == XML_SCHEMA_TYPE_PARTICLE as libc::c_int as libc::c_uint
            && !((*((*typeDef).subtypes as xmlSchemaParticlePtr)).children).is_null()
            && (*(*((*typeDef).subtypes as xmlSchemaParticlePtr)).children).type_0
                as libc::c_uint
                == XML_SCHEMA_EXTRA_QNAMEREF as libc::c_int as libc::c_uint
        {
        let mut ref_0: xmlSchemaQNameRefPtr = (*((*typeDef).subtypes
            as xmlSchemaParticlePtr))
            .children as xmlSchemaQNameRefPtr;
        let mut groupDef: xmlSchemaModelGroupDefPtr = 0 as *mut xmlSchemaModelGroupDef;
        let ref mut fresh364 = (*((*typeDef).subtypes as xmlSchemaParticlePtr)).children;
        *fresh364 = 0 as xmlSchemaTreeItemPtr;
        groupDef = xmlSchemaGetNamedComponent(
            (*ctxt).schema,
            (*ref_0).itemType,
            (*ref_0).name,
            (*ref_0).targetNamespace,
        ) as xmlSchemaModelGroupDefPtr;
        if groupDef.is_null() {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                0 as xmlSchemaBasicItemPtr,
                xmlSchemaGetComponentNode(
                    (*typeDef).subtypes as xmlSchemaParticlePtr as xmlSchemaBasicItemPtr,
                ),
                b"ref\0" as *const u8 as *const libc::c_char,
                (*ref_0).name,
                (*ref_0).targetNamespace,
                (*ref_0).itemType,
                0 as *const libc::c_char,
            );
            let ref mut fresh365 = (*typeDef).subtypes;
            *fresh365 = 0 as xmlSchemaTypePtr;
        } else if ((*(groupDef as xmlSchemaModelGroupPtr)).children).is_null() {
            let ref mut fresh366 = (*typeDef).subtypes;
            *fresh366 = 0 as xmlSchemaTypePtr;
        } else {
            let ref mut fresh367 = (*((*typeDef).subtypes as xmlSchemaParticlePtr))
                .children;
            *fresh367 = (*(groupDef as xmlSchemaModelGroupPtr)).children;
            if (*(*(groupDef as xmlSchemaModelGroupPtr)).children).type_0 as libc::c_uint
                == XML_SCHEMA_TYPE_ALL as libc::c_int as libc::c_uint
            {
                if (*((*typeDef).subtypes as xmlSchemaParticlePtr)).maxOccurs
                    != 1 as libc::c_int
                {
                    xmlSchemaCustomErr(
                        ctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_COS_ALL_LIMITED,
                        xmlSchemaGetComponentNode(
                            (*typeDef).subtypes as xmlSchemaParticlePtr
                                as xmlSchemaBasicItemPtr,
                        ),
                        0 as xmlSchemaBasicItemPtr,
                        b"The particle's {max occurs} must be 1, since the reference resolves to an 'all' model group\0"
                            as *const u8 as *const libc::c_char,
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                }
            }
        }
    }
}
unsafe extern "C" fn xmlSchemaCheckSTPropsCorrect(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> libc::c_int {
    let mut baseType: xmlSchemaTypePtr = (*type_0).baseType;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    if baseType.is_null() {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_ST_PROPS_CORRECT_1,
            type_0 as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"No base type existent\0" as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_ST_PROPS_CORRECT_1 as libc::c_int;
    }
    if !((*baseType).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
        || (*baseType).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
            && (*baseType).builtInType != XML_SCHEMAS_ANYTYPE as libc::c_int)
    {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_ST_PROPS_CORRECT_1,
            type_0 as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"The base type '%s' is not a simple type\0" as *const u8
                as *const libc::c_char,
            xmlSchemaGetComponentQName(&mut str, baseType as *mut libc::c_void),
        );
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
        return XML_SCHEMAP_ST_PROPS_CORRECT_1 as libc::c_int;
    }
    if ((*type_0).flags & (1 as libc::c_int) << 6 as libc::c_int != 0
        || (*type_0).flags & (1 as libc::c_int) << 7 as libc::c_int != 0)
        && (*type_0).flags & (1 as libc::c_int) << 2 as libc::c_int == 0 as libc::c_int
        && (!((*baseType).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
            && (*baseType).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as libc::c_int)
            && (*baseType).type_0 as libc::c_uint
                != XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint)
    {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_ST_PROPS_CORRECT_1,
            type_0 as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"A type, derived by list or union, must have the simple ur-type definition as base type, not '%s'\0"
                as *const u8 as *const libc::c_char,
            xmlSchemaGetComponentQName(&mut str, baseType as *mut libc::c_void),
        );
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
        return XML_SCHEMAP_ST_PROPS_CORRECT_1 as libc::c_int;
    }
    if (*type_0).flags & (1 as libc::c_int) << 8 as libc::c_int == 0
        && (*type_0).flags & (1 as libc::c_int) << 7 as libc::c_int == 0
        && (*type_0).flags & (1 as libc::c_int) << 6 as libc::c_int == 0
    {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_ST_PROPS_CORRECT_1,
            type_0 as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"The variety is absent\0" as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_ST_PROPS_CORRECT_1 as libc::c_int;
    }
    if xmlSchemaTypeFinalContains(baseType, (1 as libc::c_int) << 10 as libc::c_int) != 0
    {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_ST_PROPS_CORRECT_3,
            type_0 as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"The 'final' of its base type '%s' must not contain 'restriction'\0"
                as *const u8 as *const libc::c_char,
            xmlSchemaGetComponentQName(&mut str, baseType as *mut libc::c_void),
        );
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
        return XML_SCHEMAP_ST_PROPS_CORRECT_3 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaCheckCOSSTRestricts(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> libc::c_int {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    if (*type_0).type_0 as libc::c_uint
        != XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
    {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaCheckCOSSTRestricts\0" as *const u8 as *const libc::c_char,
            b"given type is not a user-derived simpleType\0" as *const u8
                as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    if (*type_0).flags & (1 as libc::c_int) << 8 as libc::c_int != 0 {
        let mut primitive: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        if (*(*type_0).baseType).flags & (1 as libc::c_int) << 8 as libc::c_int == 0 {
            xmlSchemaPCustomErr(
                pctxt,
                XML_SCHEMAP_COS_ST_RESTRICTS_1_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The base type '%s' is not an atomic simple type\0" as *const u8
                    as *const libc::c_char,
                xmlSchemaGetComponentQName(
                    &mut str,
                    (*type_0).baseType as *mut libc::c_void,
                ),
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
            return XML_SCHEMAP_COS_ST_RESTRICTS_1_1 as libc::c_int;
        }
        if xmlSchemaTypeFinalContains(
            (*type_0).baseType,
            (1 as libc::c_int) << 10 as libc::c_int,
        ) != 0
        {
            xmlSchemaPCustomErr(
                pctxt,
                XML_SCHEMAP_COS_ST_RESTRICTS_1_2,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The final of its base type '%s' must not contain 'restriction'\0"
                    as *const u8 as *const libc::c_char,
                xmlSchemaGetComponentQName(
                    &mut str,
                    (*type_0).baseType as *mut libc::c_void,
                ),
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
            return XML_SCHEMAP_COS_ST_RESTRICTS_1_2 as libc::c_int;
        }
        if !((*type_0).facets).is_null() {
            let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
            let mut ok: libc::c_int = 1 as libc::c_int;
            primitive = xmlSchemaGetPrimitiveType(type_0);
            if primitive.is_null() {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaCheckCOSSTRestricts\0" as *const u8
                        as *const libc::c_char,
                    b"failed to get primitive type\0" as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            facet = (*type_0).facets;
            loop {
                if xmlSchemaIsBuiltInTypeFacet(primitive, (*facet).type_0 as libc::c_int)
                    == 0 as libc::c_int
                {
                    ok = 0 as libc::c_int;
                    xmlSchemaPIllegalFacetAtomicErr(
                        pctxt,
                        XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1,
                        type_0,
                        primitive,
                        facet,
                    );
                }
                facet = (*facet).next;
                if facet.is_null() {
                    break;
                }
            }
            if ok == 0 as libc::c_int {
                return XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1 as libc::c_int;
            }
        }
    } else if (*type_0).flags & (1 as libc::c_int) << 6 as libc::c_int != 0 {
        let mut itemType: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
        itemType = (*type_0).subtypes;
        if itemType.is_null()
            || !((*itemType).type_0 as libc::c_uint
                == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
                || (*itemType).type_0 as libc::c_uint
                    == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                    && (*itemType).builtInType != XML_SCHEMAS_ANYTYPE as libc::c_int)
        {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaCheckCOSSTRestricts\0" as *const u8 as *const libc::c_char,
                b"failed to evaluate the item type\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        if (*itemType).type_0 as libc::c_uint
            != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
            && (*itemType).flags & (1 as libc::c_int) << 22 as libc::c_int
                == 0 as libc::c_int
        {
            xmlSchemaTypeFixup(itemType, pctxt as xmlSchemaAbstractCtxtPtr);
        }
        if (*itemType).flags & (1 as libc::c_int) << 8 as libc::c_int == 0
            && (*itemType).flags & (1 as libc::c_int) << 7 as libc::c_int == 0
        {
            xmlSchemaPCustomErr(
                pctxt,
                XML_SCHEMAP_COS_ST_RESTRICTS_2_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The item type '%s' does not have a variety of atomic or union\0"
                    as *const u8 as *const libc::c_char,
                xmlSchemaGetComponentQName(&mut str, itemType as *mut libc::c_void),
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
            return XML_SCHEMAP_COS_ST_RESTRICTS_2_1 as libc::c_int;
        } else {
            if (*itemType).flags & (1 as libc::c_int) << 7 as libc::c_int != 0 {
                let mut member: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
                member = (*itemType).memberTypes;
                while !member.is_null() {
                    if (*(*member).type_0).flags & (1 as libc::c_int) << 8 as libc::c_int
                        == 0
                    {
                        xmlSchemaPCustomErr(
                            pctxt,
                            XML_SCHEMAP_COS_ST_RESTRICTS_2_1,
                            type_0 as xmlSchemaBasicItemPtr,
                            0 as xmlNodePtr,
                            b"The item type is a union type, but the member type '%s' of this item type is not atomic\0"
                                as *const u8 as *const libc::c_char,
                            xmlSchemaGetComponentQName(
                                &mut str,
                                (*member).type_0 as *mut libc::c_void,
                            ),
                        );
                        if !str.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(str as *mut libc::c_void);
                            str = 0 as *mut xmlChar;
                        }
                        return XML_SCHEMAP_COS_ST_RESTRICTS_2_1 as libc::c_int;
                    }
                    member = (*member).next;
                }
            }
        }
        if (*(*type_0).baseType).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
            && (*(*type_0).baseType).builtInType
                == XML_SCHEMAS_ANYSIMPLETYPE as libc::c_int
        {
            let mut facet_0: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
            if xmlSchemaTypeFinalContains(
                itemType,
                (1 as libc::c_int) << 11 as libc::c_int,
            ) != 0
            {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The final of its item type '%s' must not contain 'list'\0"
                        as *const u8 as *const libc::c_char,
                    xmlSchemaGetComponentQName(&mut str, itemType as *mut libc::c_void),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1 as libc::c_int;
            }
            if !((*type_0).facets).is_null() {
                facet_0 = (*type_0).facets;
                loop {
                    if (*facet_0).type_0 as libc::c_uint
                        != XML_SCHEMA_FACET_WHITESPACE as libc::c_int as libc::c_uint
                    {
                        xmlSchemaPIllegalFacetListUnionErr(
                            pctxt,
                            XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2,
                            type_0,
                            facet_0,
                        );
                        return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2 as libc::c_int;
                    }
                    facet_0 = (*facet_0).next;
                    if facet_0.is_null() {
                        break;
                    }
                }
            }
        } else {
            if (*(*type_0).baseType).flags & (1 as libc::c_int) << 6 as libc::c_int == 0
            {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The base type '%s' must be a list type\0" as *const u8
                        as *const libc::c_char,
                    xmlSchemaGetComponentQName(
                        &mut str,
                        (*type_0).baseType as *mut libc::c_void,
                    ),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1 as libc::c_int;
            }
            if xmlSchemaTypeFinalContains(
                (*type_0).baseType,
                (1 as libc::c_int) << 10 as libc::c_int,
            ) != 0
            {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The 'final' of the base type '%s' must not contain 'restriction'\0"
                        as *const u8 as *const libc::c_char,
                    xmlSchemaGetComponentQName(
                        &mut str,
                        (*type_0).baseType as *mut libc::c_void,
                    ),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2 as libc::c_int;
            }
            let mut baseItemType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
            baseItemType = (*(*type_0).baseType).subtypes;
            if baseItemType.is_null()
                || !((*baseItemType).type_0 as libc::c_uint
                    == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
                    || (*baseItemType).type_0 as libc::c_uint
                        == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                        && (*baseItemType).builtInType
                            != XML_SCHEMAS_ANYTYPE as libc::c_int)
            {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaCheckCOSSTRestricts\0" as *const u8
                        as *const libc::c_char,
                    b"failed to eval the item type of a base type\0" as *const u8
                        as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            if itemType != baseItemType
                && xmlSchemaCheckCOSSTDerivedOK(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    itemType,
                    baseItemType,
                    0 as libc::c_int,
                ) != 0 as libc::c_int
            {
                let mut strBIT: *mut xmlChar = 0 as *mut xmlChar;
                let mut strBT: *mut xmlChar = 0 as *mut xmlChar;
                xmlSchemaPCustomErrExt(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The item type '%s' is not validly derived from the item type '%s' of the base type '%s'\0"
                        as *const u8 as *const libc::c_char,
                    xmlSchemaGetComponentQName(&mut str, itemType as *mut libc::c_void),
                    xmlSchemaGetComponentQName(
                        &mut strBIT,
                        baseItemType as *mut libc::c_void,
                    ),
                    xmlSchemaGetComponentQName(
                        &mut strBT,
                        (*type_0).baseType as *mut libc::c_void,
                    ),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                if !strBIT.is_null() {
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(strBIT as *mut libc::c_void);
                    strBIT = 0 as *mut xmlChar;
                }
                if !strBT.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(strBT as *mut libc::c_void);
                    strBT = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3 as libc::c_int;
            }
            if !((*type_0).facets).is_null() {
                let mut facet_1: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
                let mut ok_0: libc::c_int = 1 as libc::c_int;
                facet_1 = (*type_0).facets;
                loop {
                    match (*facet_1).type_0 as libc::c_uint {
                        1009 | 1011 | 1010 | 1008 | 1006 | 1007 => {}
                        _ => {
                            xmlSchemaPIllegalFacetListUnionErr(
                                pctxt,
                                XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4,
                                type_0,
                                facet_1,
                            );
                            ok_0 = 0 as libc::c_int;
                        }
                    }
                    facet_1 = (*facet_1).next;
                    if facet_1.is_null() {
                        break;
                    }
                }
                if ok_0 == 0 as libc::c_int {
                    return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4 as libc::c_int;
                }
            }
        }
    } else if (*type_0).flags & (1 as libc::c_int) << 7 as libc::c_int != 0 {
        let mut member_0: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
        member_0 = (*type_0).memberTypes;
        while !member_0.is_null() {
            if (*(*member_0).type_0).type_0 as libc::c_uint
                != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                && (*(*member_0).type_0).flags & (1 as libc::c_int) << 22 as libc::c_int
                    == 0 as libc::c_int
            {
                xmlSchemaTypeFixup(
                    (*member_0).type_0,
                    pctxt as xmlSchemaAbstractCtxtPtr,
                );
            }
            if (*(*member_0).type_0).flags & (1 as libc::c_int) << 8 as libc::c_int == 0
                && (*(*member_0).type_0).flags & (1 as libc::c_int) << 6 as libc::c_int
                    == 0
            {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_3_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The member type '%s' is neither an atomic, nor a list type\0"
                        as *const u8 as *const libc::c_char,
                    xmlSchemaGetComponentQName(
                        &mut str,
                        (*member_0).type_0 as *mut libc::c_void,
                    ),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_3_1 as libc::c_int;
            }
            member_0 = (*member_0).next;
        }
        if (*(*type_0).baseType).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as libc::c_int
        {
            member_0 = (*type_0).memberTypes;
            while !member_0.is_null() {
                if xmlSchemaTypeFinalContains(
                    (*member_0).type_0,
                    (1 as libc::c_int) << 12 as libc::c_int,
                ) != 0
                {
                    xmlSchemaPCustomErr(
                        pctxt,
                        XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1,
                        type_0 as xmlSchemaBasicItemPtr,
                        0 as xmlNodePtr,
                        b"The 'final' of member type '%s' contains 'union'\0"
                            as *const u8 as *const libc::c_char,
                        xmlSchemaGetComponentQName(
                            &mut str,
                            (*member_0).type_0 as *mut libc::c_void,
                        ),
                    );
                    if !str.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str as *mut libc::c_void);
                        str = 0 as *mut xmlChar;
                    }
                    return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1 as libc::c_int;
                }
                member_0 = (*member_0).next;
            }
            if !((*type_0).facetSet).is_null() {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"No facets allowed\0" as *const u8 as *const libc::c_char,
                    0 as *const xmlChar,
                );
                return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2 as libc::c_int;
            }
        } else {
            if (*(*type_0).baseType).flags & (1 as libc::c_int) << 7 as libc::c_int == 0
            {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The base type '%s' is not a union type\0" as *const u8
                        as *const libc::c_char,
                    xmlSchemaGetComponentQName(
                        &mut str,
                        (*type_0).baseType as *mut libc::c_void,
                    ),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1 as libc::c_int;
            }
            if xmlSchemaTypeFinalContains(
                (*type_0).baseType,
                (1 as libc::c_int) << 10 as libc::c_int,
            ) != 0
            {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The 'final' of its base type '%s' must not contain 'restriction'\0"
                        as *const u8 as *const libc::c_char,
                    xmlSchemaGetComponentQName(
                        &mut str,
                        (*type_0).baseType as *mut libc::c_void,
                    ),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2 as libc::c_int;
            }
            let mut baseMember: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
            if !((*type_0).memberTypes).is_null() {
                member_0 = (*type_0).memberTypes;
                baseMember = xmlSchemaGetUnionSimpleTypeMemberTypes((*type_0).baseType);
                if member_0.is_null() && !baseMember.is_null() {
                    xmlSchemaInternalErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaCheckCOSSTRestricts\0" as *const u8
                            as *const libc::c_char,
                        b"different number of member types in base\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                while !member_0.is_null() {
                    if baseMember.is_null() {
                        xmlSchemaInternalErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaCheckCOSSTRestricts\0" as *const u8
                                as *const libc::c_char,
                            b"different number of member types in base\0" as *const u8
                                as *const libc::c_char,
                        );
                    } else if (*member_0).type_0 != (*baseMember).type_0
                            && xmlSchemaCheckCOSSTDerivedOK(
                                pctxt as xmlSchemaAbstractCtxtPtr,
                                (*member_0).type_0,
                                (*baseMember).type_0,
                                0 as libc::c_int,
                            ) != 0 as libc::c_int
                        {
                        let mut strBMT: *mut xmlChar = 0 as *mut xmlChar;
                        let mut strBT_0: *mut xmlChar = 0 as *mut xmlChar;
                        xmlSchemaPCustomErrExt(
                            pctxt,
                            XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3,
                            type_0 as xmlSchemaBasicItemPtr,
                            0 as xmlNodePtr,
                            b"The member type %s is not validly derived from its corresponding member type %s of the base type %s\0"
                                as *const u8 as *const libc::c_char,
                            xmlSchemaGetComponentQName(
                                &mut str,
                                (*member_0).type_0 as *mut libc::c_void,
                            ),
                            xmlSchemaGetComponentQName(
                                &mut strBMT,
                                (*baseMember).type_0 as *mut libc::c_void,
                            ),
                            xmlSchemaGetComponentQName(
                                &mut strBT_0,
                                (*type_0).baseType as *mut libc::c_void,
                            ),
                        );
                        if !str.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(str as *mut libc::c_void);
                            str = 0 as *mut xmlChar;
                        }
                        if !strBMT.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(strBMT as *mut libc::c_void);
                            strBMT = 0 as *mut xmlChar;
                        }
                        if !strBT_0.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(strBT_0 as *mut libc::c_void);
                            strBT_0 = 0 as *mut xmlChar;
                        }
                        return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3 as libc::c_int;
                    }
                    member_0 = (*member_0).next;
                    if !baseMember.is_null() {
                        baseMember = (*baseMember).next;
                    }
                }
            }
            if !((*type_0).facets).is_null() {
                let mut facet_2: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
                let mut ok_1: libc::c_int = 1 as libc::c_int;
                facet_2 = (*type_0).facets;
                loop {
                    if (*facet_2).type_0 as libc::c_uint
                        != XML_SCHEMA_FACET_PATTERN as libc::c_int as libc::c_uint
                        && (*facet_2).type_0 as libc::c_uint
                            != XML_SCHEMA_FACET_ENUMERATION as libc::c_int
                                as libc::c_uint
                    {
                        xmlSchemaPIllegalFacetListUnionErr(
                            pctxt,
                            XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4,
                            type_0,
                            facet_2,
                        );
                        ok_1 = 0 as libc::c_int;
                    }
                    facet_2 = (*facet_2).next;
                    if facet_2.is_null() {
                        break;
                    }
                }
                if ok_1 == 0 as libc::c_int {
                    return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4 as libc::c_int;
                }
            }
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaCreateVCtxtOnPCtxt(
    mut ctxt: xmlSchemaParserCtxtPtr,
) -> libc::c_int {
    if ((*ctxt).vctxt).is_null() {
        let ref mut fresh368 = (*ctxt).vctxt;
        *fresh368 = xmlSchemaNewValidCtxt(0 as xmlSchemaPtr);
        if ((*ctxt).vctxt).is_null() {
            xmlSchemaPErr(
                ctxt,
                0 as xmlNodePtr,
                XML_SCHEMAP_INTERNAL as libc::c_int,
                b"Internal error: xmlSchemaCreateVCtxtOnPCtxt, failed to create a temp. validation context.\n\0"
                    as *const u8 as *const libc::c_char,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return -(1 as libc::c_int);
        }
        xmlSchemaSetValidErrors(
            (*ctxt).vctxt,
            (*ctxt).error,
            (*ctxt).warning,
            (*ctxt).errCtxt,
        );
        xmlSchemaSetValidStructuredErrors(
            (*ctxt).vctxt,
            (*ctxt).serror,
            (*ctxt).errCtxt,
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaParseCheckCOSValidDefault(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut type_0: xmlSchemaTypePtr,
    mut value: *const xmlChar,
    mut val: *mut xmlSchemaValPtr,
) -> libc::c_int {
    let mut ret: libc::c_int = 0 as libc::c_int;
    if (*type_0).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
        || (*type_0).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int
    {
        if !((*type_0).contentType as libc::c_uint
            == XML_SCHEMA_CONTENT_SIMPLE as libc::c_int as libc::c_uint
            || (*type_0).contentType as libc::c_uint
                == XML_SCHEMA_CONTENT_BASIC as libc::c_int as libc::c_uint)
            && (!((*type_0).contentType as libc::c_uint
                == XML_SCHEMA_CONTENT_MIXED as libc::c_int as libc::c_uint)
                || xmlSchemaIsParticleEmptiable(
                    (*type_0).subtypes as xmlSchemaParticlePtr,
                ) == 0)
        {
            xmlSchemaPCustomErr(
                pctxt,
                XML_SCHEMAP_COS_VALID_DEFAULT_2_1,
                type_0 as xmlSchemaBasicItemPtr,
                (*type_0).node,
                b"For a string to be a valid default, the type definition must be a simple type or a complex type with mixed content and a particle emptiable\0"
                    as *const u8 as *const libc::c_char,
                0 as *const xmlChar,
            );
            return XML_SCHEMAP_COS_VALID_DEFAULT_2_1 as libc::c_int;
        }
    }
    if (*type_0).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
        || (*type_0).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
            && (*type_0).builtInType != XML_SCHEMAS_ANYTYPE as libc::c_int
    {
        ret = xmlSchemaVCheckCVCSimpleType(
            pctxt as xmlSchemaAbstractCtxtPtr,
            node,
            type_0,
            value,
            val,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int,
        );
    } else if (*type_0).contentType as libc::c_uint
            == XML_SCHEMA_CONTENT_SIMPLE as libc::c_int as libc::c_uint
            || (*type_0).contentType as libc::c_uint
                == XML_SCHEMA_CONTENT_BASIC as libc::c_int as libc::c_uint
        {
        ret = xmlSchemaVCheckCVCSimpleType(
            pctxt as xmlSchemaAbstractCtxtPtr,
            node,
            (*type_0).contentTypeDef,
            value,
            val,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int,
        );
    } else {
        return ret
    }
    if ret < 0 as libc::c_int {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaParseCheckCOSValidDefault\0" as *const u8 as *const libc::c_char,
            b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8
                as *const libc::c_char,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaCheckCTPropsCorrect(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> libc::c_int {
    let mut current_block: u64;
    if !((*type_0).baseType).is_null()
        && ((*(*type_0).baseType).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
            || (*(*type_0).baseType).type_0 as libc::c_uint
                == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                && (*(*type_0).baseType).builtInType
                    != XML_SCHEMAS_ANYTYPE as libc::c_int)
        && (*type_0).flags & (1 as libc::c_int) << 1 as libc::c_int == 0 as libc::c_int
    {
        xmlSchemaCustomErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_SRC_CT_1,
            0 as xmlNodePtr,
            type_0 as xmlSchemaBasicItemPtr,
            b"If the base type is a simple type, the derivation method must be 'extension'\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_SRC_CT_1 as libc::c_int;
    }
    if !((*type_0).attrUses).is_null()
        && (*((*type_0).attrUses as xmlSchemaItemListPtr)).nbItems > 1 as libc::c_int
    {
        let mut uses: xmlSchemaItemListPtr = (*type_0).attrUses as xmlSchemaItemListPtr;
        let mut use_0: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
        let mut tmp: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
        let mut i: libc::c_int = 0;
        let mut j: libc::c_int = 0;
        let mut hasId: libc::c_int = 0 as libc::c_int;
        i = (*uses).nbItems - 1 as libc::c_int;
        's_32: loop {
            if !(i >= 0 as libc::c_int) {
                current_block = 4090602189656566074;
                break;
            }
            use_0 = *((*uses).items).offset(i as isize) as xmlSchemaAttributeUsePtr;
            if i > 0 as libc::c_int {
                j = i - 1 as libc::c_int;
                loop {
                    if !(j >= 0 as libc::c_int) {
                        current_block = 18317007320854588510;
                        break;
                    }
                    tmp = *((*uses).items).offset(j as isize)
                        as xmlSchemaAttributeUsePtr;
                    if (*(*use_0).attrDecl).name == (*(*tmp).attrDecl).name
                        && (*(*use_0).attrDecl).targetNamespace
                            == (*(*tmp).attrDecl).targetNamespace
                    {
                        let mut str: *mut xmlChar = 0 as *mut xmlChar;
                        xmlSchemaCustomErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            XML_SCHEMAP_AG_PROPS_CORRECT,
                            0 as xmlNodePtr,
                            type_0 as xmlSchemaBasicItemPtr,
                            b"Duplicate %s\0" as *const u8 as *const libc::c_char,
                            xmlSchemaGetComponentDesignation(
                                &mut str,
                                use_0 as *mut libc::c_void,
                            ),
                            0 as *const xmlChar,
                        );
                        if !str.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(str as *mut libc::c_void);
                            str = 0 as *mut xmlChar;
                        }
                        if xmlSchemaItemListRemove(uses, i) == -(1 as libc::c_int) {
                            current_block = 13937361906707278470;
                            break 's_32;
                        } else {
                            current_block = 2473556513754201174;
                            break;
                        }
                    } else {
                        j -= 1;
                    }
                }
            } else {
                current_block = 18317007320854588510;
            }
            match current_block {
                18317007320854588510 => {
                    if !((*(*use_0).attrDecl).subtypes).is_null() {
                        if xmlSchemaIsDerivedFromBuiltInType(
                            (*(*use_0).attrDecl).subtypes,
                            XML_SCHEMAS_ID as libc::c_int,
                        ) != 0
                        {
                            if hasId != 0 {
                                let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                                xmlSchemaCustomErr(
                                    pctxt as xmlSchemaAbstractCtxtPtr,
                                    XML_SCHEMAP_AG_PROPS_CORRECT,
                                    0 as xmlNodePtr,
                                    type_0 as xmlSchemaBasicItemPtr,
                                    b"There must not exist more than one attribute declaration of type 'xs:ID' (or derived from 'xs:ID'). The %s violates this constraint\0"
                                        as *const u8 as *const libc::c_char,
                                    xmlSchemaGetComponentDesignation(
                                        &mut str_0,
                                        use_0 as *mut libc::c_void,
                                    ),
                                    0 as *const xmlChar,
                                );
                                if !str_0.is_null() {
                                    xmlFree
                                        .expect(
                                            "non-null function pointer",
                                        )(str_0 as *mut libc::c_void);
                                    str_0 = 0 as *mut xmlChar;
                                }
                                if xmlSchemaItemListRemove(uses, i) == -(1 as libc::c_int) {
                                    current_block = 13937361906707278470;
                                    break;
                                }
                            }
                            hasId = 1 as libc::c_int;
                        }
                    }
                }
                _ => {}
            }
            i -= 1;
        }
        match current_block {
            4090602189656566074 => {}
            _ => return -(1 as libc::c_int),
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaAreEqualTypes(
    mut typeA: xmlSchemaTypePtr,
    mut typeB: xmlSchemaTypePtr,
) -> libc::c_int {
    if typeA.is_null() || typeB.is_null() {
        return 0 as libc::c_int;
    }
    return (typeA == typeB) as libc::c_int;
}
unsafe extern "C" fn xmlSchemaCheckCOSCTDerivedOK(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
    mut baseType: xmlSchemaTypePtr,
    mut set: libc::c_int,
) -> libc::c_int {
    let mut equal: libc::c_int = xmlSchemaAreEqualTypes(type_0, baseType);
    if equal == 0 {
        if set & (1 as libc::c_int) << 1 as libc::c_int != 0
            && (*type_0).flags & (1 as libc::c_int) << 1 as libc::c_int != 0
            || set & (1 as libc::c_int) << 0 as libc::c_int != 0
                && (*type_0).flags & (1 as libc::c_int) << 2 as libc::c_int != 0
        {
            return 1 as libc::c_int;
        }
    } else {
        return 0 as libc::c_int
    }
    if (*type_0).baseType == baseType {
        return 0 as libc::c_int;
    }
    if (*(*type_0).baseType).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
        && (*(*type_0).baseType).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int
    {
        return 1 as libc::c_int;
    }
    if (*(*type_0).baseType).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
        || (*(*type_0).baseType).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int
    {
        return xmlSchemaCheckCOSCTDerivedOK(actxt, (*type_0).baseType, baseType, set)
    } else {
        return xmlSchemaCheckCOSSTDerivedOK(actxt, (*type_0).baseType, baseType, set)
    };
}
unsafe extern "C" fn xmlSchemaCheckCOSDerivedOK(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
    mut baseType: xmlSchemaTypePtr,
    mut set: libc::c_int,
) -> libc::c_int {
    if (*type_0).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
        || (*type_0).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
            && (*type_0).builtInType != XML_SCHEMAS_ANYTYPE as libc::c_int
    {
        return xmlSchemaCheckCOSSTDerivedOK(actxt, type_0, baseType, set)
    } else {
        return xmlSchemaCheckCOSCTDerivedOK(actxt, type_0, baseType, set)
    };
}
unsafe extern "C" fn xmlSchemaCheckCOSCTExtends(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> libc::c_int {
    let mut base: xmlSchemaTypePtr = (*type_0).baseType;
    if (*base).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
        || (*base).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int
    {
        if (*base).flags & (1 as libc::c_int) << 9 as libc::c_int != 0 {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The 'final' of the base type definition contains 'extension'\0"
                    as *const u8 as *const libc::c_char,
                0 as *const xmlChar,
            );
            return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as libc::c_int;
        }
        if !(!((*type_0).contentTypeDef).is_null()
            && (*type_0).contentTypeDef == (*base).contentTypeDef)
        {
            if !((*type_0).contentType as libc::c_uint
                == XML_SCHEMA_CONTENT_EMPTY as libc::c_int as libc::c_uint
                && (*base).contentType as libc::c_uint
                    == XML_SCHEMA_CONTENT_EMPTY as libc::c_int as libc::c_uint)
            {
                if ((*type_0).subtypes).is_null() {
                    xmlSchemaPCustomErr(
                        ctxt,
                        XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                        type_0 as xmlSchemaBasicItemPtr,
                        0 as xmlNodePtr,
                        b"The content type must specify a particle\0" as *const u8
                            as *const libc::c_char,
                        0 as *const xmlChar,
                    );
                    return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as libc::c_int;
                }
                if !((*base).contentType as libc::c_uint
                    == XML_SCHEMA_CONTENT_EMPTY as libc::c_int as libc::c_uint)
                {
                    if (*type_0).contentType as libc::c_uint
                        != (*base).contentType as libc::c_uint
                        || (*type_0).contentType as libc::c_uint
                            != XML_SCHEMA_CONTENT_MIXED as libc::c_int as libc::c_uint
                            && (*type_0).contentType as libc::c_uint
                                != XML_SCHEMA_CONTENT_ELEMENTS as libc::c_int
                                    as libc::c_uint
                    {
                        xmlSchemaPCustomErr(
                            ctxt,
                            XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                            type_0 as xmlSchemaBasicItemPtr,
                            0 as xmlNodePtr,
                            b"The content type of both, the type and its base type, must either 'mixed' or 'element-only'\0"
                                as *const u8 as *const libc::c_char,
                            0 as *const xmlChar,
                        );
                        return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as libc::c_int;
                    }
                }
            }
        }
    } else {
        if (*type_0).contentTypeDef != base {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The content type must be the simple base type\0" as *const u8
                    as *const libc::c_char,
                0 as *const xmlChar,
            );
            return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as libc::c_int;
        }
        if (*base).flags & (1 as libc::c_int) << 9 as libc::c_int != 0 {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The 'final' of the base type definition contains 'extension'\0"
                    as *const u8 as *const libc::c_char,
                0 as *const xmlChar,
            );
            return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaCheckDerivationOKRestriction(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> libc::c_int {
    let mut base: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    base = (*type_0).baseType;
    if !((*base).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
        || (*base).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int)
    {
        xmlSchemaCustomErr(
            ctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
            (*type_0).node,
            type_0 as xmlSchemaBasicItemPtr,
            b"The base type must be a complex type\0" as *const u8
                as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*ctxt).err;
    }
    if (*base).flags & (1 as libc::c_int) << 10 as libc::c_int != 0 {
        xmlSchemaCustomErr(
            ctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
            (*type_0).node,
            type_0 as xmlSchemaBasicItemPtr,
            b"The 'final' of the base type definition contains 'restriction'\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*ctxt).err;
    }
    if xmlSchemaCheckDerivationOKRestriction2to4(
        ctxt,
        0 as libc::c_int,
        type_0 as xmlSchemaBasicItemPtr,
        base as xmlSchemaBasicItemPtr,
        (*type_0).attrUses as xmlSchemaItemListPtr,
        (*base).attrUses as xmlSchemaItemListPtr,
        (*type_0).attributeWildcard,
        (*base).attributeWildcard,
    ) == -(1 as libc::c_int)
    {
        return -(1 as libc::c_int);
    }
    if !((*base).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int) {
        if (*type_0).contentType as libc::c_uint
            == XML_SCHEMA_CONTENT_SIMPLE as libc::c_int as libc::c_uint
            || (*type_0).contentType as libc::c_uint
                == XML_SCHEMA_CONTENT_BASIC as libc::c_int as libc::c_uint
        {
            if (*base).contentType as libc::c_uint
                == XML_SCHEMA_CONTENT_SIMPLE as libc::c_int as libc::c_uint
                || (*base).contentType as libc::c_uint
                    == XML_SCHEMA_CONTENT_BASIC as libc::c_int as libc::c_uint
            {
                let mut err: libc::c_int = 0;
                err = xmlSchemaCheckCOSSTDerivedOK(
                    ctxt as xmlSchemaAbstractCtxtPtr,
                    (*type_0).contentTypeDef,
                    (*base).contentTypeDef,
                    0 as libc::c_int,
                );
                if err != 0 as libc::c_int {
                    let mut strA: *mut xmlChar = 0 as *mut xmlChar;
                    let mut strB: *mut xmlChar = 0 as *mut xmlChar;
                    if err == -(1 as libc::c_int) {
                        return -(1 as libc::c_int);
                    }
                    xmlSchemaCustomErr(
                        ctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                        0 as xmlNodePtr,
                        type_0 as xmlSchemaBasicItemPtr,
                        b"The {content type} %s is not validly derived from the base type's {content type} %s\0"
                            as *const u8 as *const libc::c_char,
                        xmlSchemaGetComponentDesignation(
                            &mut strA,
                            (*type_0).contentTypeDef as *mut libc::c_void,
                        ),
                        xmlSchemaGetComponentDesignation(
                            &mut strB,
                            (*base).contentTypeDef as *mut libc::c_void,
                        ),
                    );
                    if !strA.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(strA as *mut libc::c_void);
                        strA = 0 as *mut xmlChar;
                    }
                    if !strB.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(strB as *mut libc::c_void);
                        strB = 0 as *mut xmlChar;
                    }
                    return (*ctxt).err;
                }
            } else if (*base).contentType as libc::c_uint
                    == XML_SCHEMA_CONTENT_MIXED as libc::c_int as libc::c_uint
                    && xmlSchemaIsParticleEmptiable(
                        (*base).subtypes as xmlSchemaParticlePtr,
                    ) != 0
                {} else {
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The content type of the base type must be either a simple type or 'mixed' and an emptiable particle\0"
                        as *const u8 as *const libc::c_char,
                    0 as *const xmlChar,
                );
                return (*ctxt).err;
            }
        } else if (*type_0).contentType as libc::c_uint
                == XML_SCHEMA_CONTENT_EMPTY as libc::c_int as libc::c_uint
            {
            if !((*base).contentType as libc::c_uint
                == XML_SCHEMA_CONTENT_EMPTY as libc::c_int as libc::c_uint)
            {
                if ((*base).contentType as libc::c_uint
                    == XML_SCHEMA_CONTENT_ELEMENTS as libc::c_int as libc::c_uint
                    || (*base).contentType as libc::c_uint
                        == XML_SCHEMA_CONTENT_MIXED as libc::c_int as libc::c_uint)
                    && xmlSchemaIsParticleEmptiable(
                        (*base).subtypes as xmlSchemaParticlePtr,
                    ) != 0
                {} else {
                    xmlSchemaPCustomErr(
                        ctxt,
                        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                        type_0 as xmlSchemaBasicItemPtr,
                        0 as xmlNodePtr,
                        b"The content type of the base type must be either empty or 'mixed' (or 'elements-only') and an emptiable particle\0"
                            as *const u8 as *const libc::c_char,
                        0 as *const xmlChar,
                    );
                    return (*ctxt).err;
                }
            }
        } else if (*type_0).contentType as libc::c_uint
                == XML_SCHEMA_CONTENT_ELEMENTS as libc::c_int as libc::c_uint
                || (*type_0).contentType as libc::c_uint
                    == XML_SCHEMA_CONTENT_MIXED as libc::c_int as libc::c_uint
            {
            if (*type_0).contentType as libc::c_uint
                == XML_SCHEMA_CONTENT_MIXED as libc::c_int as libc::c_uint
                && !((*base).contentType as libc::c_uint
                    == XML_SCHEMA_CONTENT_MIXED as libc::c_int as libc::c_uint)
            {
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"If the content type is 'mixed', then the content type of the base type must also be 'mixed'\0"
                        as *const u8 as *const libc::c_char,
                    0 as *const xmlChar,
                );
                return (*ctxt).err;
            }
        } else {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The type is not a valid restriction of its base type\0" as *const u8
                    as *const libc::c_char,
                0 as *const xmlChar,
            );
            return (*ctxt).err;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaCheckCTComponent(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    ret = xmlSchemaCheckCTPropsCorrect(ctxt, type_0);
    if ret != 0 as libc::c_int {
        return ret;
    }
    if (*type_0).flags & (1 as libc::c_int) << 1 as libc::c_int != 0 {
        ret = xmlSchemaCheckCOSCTExtends(ctxt, type_0);
    } else {
        ret = xmlSchemaCheckDerivationOKRestriction(ctxt, type_0);
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaCheckSRCCT(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> libc::c_int {
    let mut base: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ret: libc::c_int = 0 as libc::c_int;
    base = (*type_0).baseType;
    if !((*type_0).contentType as libc::c_uint
        == XML_SCHEMA_CONTENT_SIMPLE as libc::c_int as libc::c_uint
        || (*type_0).contentType as libc::c_uint
            == XML_SCHEMA_CONTENT_BASIC as libc::c_int as libc::c_uint)
    {
        if !((*base).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
            || (*base).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int)
        {
            let mut str: *mut xmlChar = 0 as *mut xmlChar;
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_SRC_CT_1,
                type_0 as xmlSchemaBasicItemPtr,
                (*type_0).node,
                b"If using <complexContent>, the base type is expected to be a complex type. The base type '%s' is a simple type\0"
                    as *const u8 as *const libc::c_char,
                xmlSchemaFormatQName(&mut str, (*base).targetNamespace, (*base).name),
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
            return XML_SCHEMAP_SRC_CT_1 as libc::c_int;
        }
    } else {
        if (*base).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
            || (*base).type_0 as libc::c_uint
                == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                && (*base).builtInType != XML_SCHEMAS_ANYTYPE as libc::c_int
        {
            if (*type_0).flags & (1 as libc::c_int) << 1 as libc::c_int
                == 0 as libc::c_int
            {
                let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_SRC_CT_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"If using <simpleContent> and <restriction>, the base type must be a complex type. The base type '%s' is a simple type\0"
                        as *const u8 as *const libc::c_char,
                    xmlSchemaFormatQName(
                        &mut str_0,
                        (*base).targetNamespace,
                        (*base).name,
                    ),
                );
                if !str_0.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str_0 as *mut libc::c_void);
                    str_0 = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_SRC_CT_1 as libc::c_int;
            }
        } else if (*base).contentType as libc::c_uint
                == XML_SCHEMA_CONTENT_SIMPLE as libc::c_int as libc::c_uint
                || (*base).contentType as libc::c_uint
                    == XML_SCHEMA_CONTENT_BASIC as libc::c_int as libc::c_uint
            {
            if ((*base).contentTypeDef).is_null() {
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_INTERNAL,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"Internal error: xmlSchemaCheckSRCCT, '%s', base type has no content type\0"
                        as *const u8 as *const libc::c_char,
                    (*type_0).name,
                );
                return -(1 as libc::c_int);
            }
        } else if (*base).contentType as libc::c_uint
                == XML_SCHEMA_CONTENT_MIXED as libc::c_int as libc::c_uint
                && (*type_0).flags & (1 as libc::c_int) << 2 as libc::c_int != 0
            {
            if xmlSchemaIsParticleEmptiable((*base).subtypes as xmlSchemaParticlePtr)
                == 0
            {
                ret = XML_SCHEMAP_SRC_CT_1 as libc::c_int;
            } else if ((*type_0).contentTypeDef).is_null() {
                let mut str_1: *mut xmlChar = 0 as *mut xmlChar;
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_SRC_CT_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"A <simpleType> is expected among the children of <restriction>, if <simpleContent> is used and the base type '%s' is a complex type\0"
                        as *const u8 as *const libc::c_char,
                    xmlSchemaFormatQName(
                        &mut str_1,
                        (*base).targetNamespace,
                        (*base).name,
                    ),
                );
                if !str_1.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str_1 as *mut libc::c_void);
                    str_1 = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_SRC_CT_1 as libc::c_int;
            }
        } else {
            ret = XML_SCHEMAP_SRC_CT_1 as libc::c_int;
        }
        if ret > 0 as libc::c_int {
            let mut str_2: *mut xmlChar = 0 as *mut xmlChar;
            if (*type_0).flags & (1 as libc::c_int) << 2 as libc::c_int != 0 {
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_SRC_CT_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"If <simpleContent> and <restriction> is used, the base type must be a simple type or a complex type with mixed content and particle emptiable. The base type '%s' is none of those\0"
                        as *const u8 as *const libc::c_char,
                    xmlSchemaFormatQName(
                        &mut str_2,
                        (*base).targetNamespace,
                        (*base).name,
                    ),
                );
            } else {
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_SRC_CT_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"If <simpleContent> and <extension> is used, the base type must be a simple type. The base type '%s' is a complex type\0"
                        as *const u8 as *const libc::c_char,
                    xmlSchemaFormatQName(
                        &mut str_2,
                        (*base).targetNamespace,
                        (*base).name,
                    ),
                );
            }
            if !str_2.is_null() {
                xmlFree.expect("non-null function pointer")(str_2 as *mut libc::c_void);
                str_2 = 0 as *mut xmlChar;
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaDeriveFacetErr(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut facet1: xmlSchemaFacetPtr,
    mut facet2: xmlSchemaFacetPtr,
    mut lessGreater: libc::c_int,
    mut orEqual: libc::c_int,
    mut ofBase: libc::c_int,
) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    msg = xmlStrdup(b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    msg = xmlStrcat(msg, xmlSchemaFacetTypeToString((*facet1).type_0));
    msg = xmlStrcat(
        msg,
        b"' has to be\0" as *const u8 as *const libc::c_char as *mut xmlChar,
    );
    if lessGreater == 0 as libc::c_int {
        msg = xmlStrcat(
            msg,
            b" equal to\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    }
    if lessGreater == 1 as libc::c_int {
        msg = xmlStrcat(
            msg,
            b" greater than\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    } else {
        msg = xmlStrcat(
            msg,
            b" less than\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    }
    if orEqual != 0 {
        msg = xmlStrcat(
            msg,
            b" or equal to\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    }
    msg = xmlStrcat(msg, b" '\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    msg = xmlStrcat(msg, xmlSchemaFacetTypeToString((*facet2).type_0));
    if ofBase != 0 {
        msg = xmlStrcat(
            msg,
            b"' of the base type\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
    } else {
        msg = xmlStrcat(msg, b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    }
    xmlSchemaPCustomErr(
        pctxt,
        XML_SCHEMAP_INVALID_FACET_VALUE,
        facet1 as xmlSchemaBasicItemPtr,
        0 as xmlNodePtr,
        msg as *const libc::c_char,
        0 as *const xmlChar,
    );
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
    }
}
unsafe extern "C" fn xmlSchemaDeriveAndValidateFacets(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> libc::c_int {
    let mut current_block: u64;
    let mut base: xmlSchemaTypePtr = (*type_0).baseType;
    let mut link: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
    let mut cur: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
    let mut last: xmlSchemaFacetLinkPtr = 0 as xmlSchemaFacetLinkPtr;
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut bfacet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut flength: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut ftotdig: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut ffracdig: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fmaxlen: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fminlen: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fmininc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fmaxinc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fminexc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fmaxexc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bflength: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bftotdig: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bffracdig: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfmaxlen: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfminlen: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfmininc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfmaxinc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfminexc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfmaxexc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut res: libc::c_int = 0;
    if ((*type_0).facetSet).is_null() && ((*base).facetSet).is_null() {
        return 0 as libc::c_int;
    }
    last = (*type_0).facetSet;
    if !last.is_null() {
        while !((*last).next).is_null() {
            last = (*last).next;
        }
    }
    cur = (*type_0).facetSet;
    while !cur.is_null() {
        facet = (*cur).facet;
        match (*facet).type_0 as libc::c_uint {
            1009 => {
                flength = facet;
            }
            1011 => {
                fminlen = facet;
            }
            1000 => {
                fmininc = facet;
            }
            1001 => {
                fminexc = facet;
            }
            1010 => {
                fmaxlen = facet;
            }
            1002 => {
                fmaxinc = facet;
            }
            1003 => {
                fmaxexc = facet;
            }
            1004 => {
                ftotdig = facet;
            }
            1005 => {
                ffracdig = facet;
            }
            _ => {}
        }
        cur = (*cur).next;
    }
    cur = (*base).facetSet;
    while !cur.is_null() {
        facet = (*cur).facet;
        match (*facet).type_0 as libc::c_uint {
            1009 => {
                bflength = facet;
            }
            1011 => {
                bfminlen = facet;
            }
            1000 => {
                bfmininc = facet;
            }
            1001 => {
                bfminexc = facet;
            }
            1010 => {
                bfmaxlen = facet;
            }
            1002 => {
                bfmaxinc = facet;
            }
            1003 => {
                bfmaxexc = facet;
            }
            1004 => {
                bftotdig = facet;
            }
            1005 => {
                bffracdig = facet;
            }
            _ => {}
        }
        cur = (*cur).next;
    }
    if !flength.is_null() && (!fminlen.is_null() || !fmaxlen.is_null()) {
        xmlSchemaPCustomErr(
            pctxt,
            XML_SCHEMAP_INVALID_FACET_VALUE,
            flength as xmlSchemaBasicItemPtr,
            (*flength).node,
            b"It is an error for both 'length' and either of 'minLength' or 'maxLength' to be specified on the same type definition\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
        );
    }
    if !fmaxinc.is_null() && !fmaxexc.is_null() {
        xmlSchemaPCustomErrExt(
            pctxt,
            XML_SCHEMAP_INVALID_FACET_VALUE,
            fmaxinc as xmlSchemaBasicItemPtr,
            (*fmaxinc).node,
            b"It is an error for both '%s' and '%s' to be specified on the same type definition\0"
                as *const u8 as *const libc::c_char,
            xmlSchemaFacetTypeToString((*fmaxinc).type_0) as *mut xmlChar,
            xmlSchemaFacetTypeToString((*fmaxexc).type_0) as *mut xmlChar,
            0 as *const xmlChar,
        );
    }
    if !fmininc.is_null() && !fminexc.is_null() {
        xmlSchemaPCustomErrExt(
            pctxt,
            XML_SCHEMAP_INVALID_FACET_VALUE,
            fmininc as xmlSchemaBasicItemPtr,
            (*fmininc).node,
            b"It is an error for both '%s' and '%s' to be specified on the same type definition\0"
                as *const u8 as *const libc::c_char,
            xmlSchemaFacetTypeToString((*fmininc).type_0) as *mut xmlChar,
            xmlSchemaFacetTypeToString((*fminexc).type_0) as *mut xmlChar,
            0 as *const xmlChar,
        );
    }
    if !flength.is_null() && !bflength.is_null() {
        res = xmlSchemaCompareValues((*flength).val, (*bflength).val);
        if res == -(2 as libc::c_int) {
            current_block = 6717603523453139513;
        } else {
            if res != 0 as libc::c_int {
                xmlSchemaDeriveFacetErr(
                    pctxt,
                    flength,
                    bflength,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    1 as libc::c_int,
                );
            }
            if res != 0 as libc::c_int && (*bflength).fixed != 0 {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_INVALID_FACET_VALUE,
                    flength as xmlSchemaBasicItemPtr,
                    (*flength).node,
                    b"The base type's facet is 'fixed', thus the value must not differ\0"
                        as *const u8 as *const libc::c_char,
                    0 as *const xmlChar,
                );
            }
            current_block = 317151059986244064;
        }
    } else {
        current_block = 317151059986244064;
    }
    match current_block {
        317151059986244064 => {
            if !fminlen.is_null() && !bfminlen.is_null() {
                res = xmlSchemaCompareValues((*fminlen).val, (*bfminlen).val);
                if res == -(2 as libc::c_int) {
                    current_block = 6717603523453139513;
                } else {
                    if res == -(1 as libc::c_int) {
                        xmlSchemaDeriveFacetErr(
                            pctxt,
                            fminlen,
                            bfminlen,
                            1 as libc::c_int,
                            1 as libc::c_int,
                            1 as libc::c_int,
                        );
                    }
                    if res != 0 as libc::c_int && (*bfminlen).fixed != 0 {
                        xmlSchemaPCustomErr(
                            pctxt,
                            XML_SCHEMAP_INVALID_FACET_VALUE,
                            fminlen as xmlSchemaBasicItemPtr,
                            (*fminlen).node,
                            b"The base type's facet is 'fixed', thus the value must not differ\0"
                                as *const u8 as *const libc::c_char,
                            0 as *const xmlChar,
                        );
                    }
                    current_block = 7385833325316299293;
                }
            } else {
                current_block = 7385833325316299293;
            }
            match current_block {
                6717603523453139513 => {}
                _ => {
                    if !fmaxlen.is_null() && !bfmaxlen.is_null() {
                        res = xmlSchemaCompareValues((*fmaxlen).val, (*bfmaxlen).val);
                        if res == -(2 as libc::c_int) {
                            current_block = 6717603523453139513;
                        } else {
                            if res == 1 as libc::c_int {
                                xmlSchemaDeriveFacetErr(
                                    pctxt,
                                    fmaxlen,
                                    bfmaxlen,
                                    -(1 as libc::c_int),
                                    1 as libc::c_int,
                                    1 as libc::c_int,
                                );
                            }
                            if res != 0 as libc::c_int && (*bfmaxlen).fixed != 0 {
                                xmlSchemaPCustomErr(
                                    pctxt,
                                    XML_SCHEMAP_INVALID_FACET_VALUE,
                                    fmaxlen as xmlSchemaBasicItemPtr,
                                    (*fmaxlen).node,
                                    b"The base type's facet is 'fixed', thus the value must not differ\0"
                                        as *const u8 as *const libc::c_char,
                                    0 as *const xmlChar,
                                );
                            }
                            current_block = 8732226822098929438;
                        }
                    } else {
                        current_block = 8732226822098929438;
                    }
                    match current_block {
                        6717603523453139513 => {}
                        _ => {
                            if flength.is_null() {
                                flength = bflength;
                            }
                            if !flength.is_null() {
                                if fminlen.is_null() {
                                    fminlen = bfminlen;
                                }
                                if !fminlen.is_null() {
                                    res = xmlSchemaCompareValues(
                                        (*flength).val,
                                        (*fminlen).val,
                                    );
                                    if res == -(2 as libc::c_int) {
                                        current_block = 6717603523453139513;
                                    } else {
                                        if res == -(1 as libc::c_int) {
                                            xmlSchemaDeriveFacetErr(
                                                pctxt,
                                                flength,
                                                fminlen,
                                                1 as libc::c_int,
                                                1 as libc::c_int,
                                                0 as libc::c_int,
                                            );
                                        }
                                        current_block = 2798392256336243897;
                                    }
                                } else {
                                    current_block = 2798392256336243897;
                                }
                                match current_block {
                                    6717603523453139513 => {}
                                    _ => {
                                        if fmaxlen.is_null() {
                                            fmaxlen = bfmaxlen;
                                        }
                                        if !fmaxlen.is_null() {
                                            res = xmlSchemaCompareValues(
                                                (*flength).val,
                                                (*fmaxlen).val,
                                            );
                                            if res == -(2 as libc::c_int) {
                                                current_block = 6717603523453139513;
                                            } else {
                                                if res == 1 as libc::c_int {
                                                    xmlSchemaDeriveFacetErr(
                                                        pctxt,
                                                        flength,
                                                        fmaxlen,
                                                        -(1 as libc::c_int),
                                                        1 as libc::c_int,
                                                        0 as libc::c_int,
                                                    );
                                                }
                                                current_block = 2945622622075328793;
                                            }
                                        } else {
                                            current_block = 2945622622075328793;
                                        }
                                    }
                                }
                            } else {
                                current_block = 2945622622075328793;
                            }
                            match current_block {
                                6717603523453139513 => {}
                                _ => {
                                    if !fmaxinc.is_null() {
                                        if !fmininc.is_null() {
                                            res = xmlSchemaCompareValues(
                                                (*fmaxinc).val,
                                                (*fmininc).val,
                                            );
                                            if res == -(2 as libc::c_int) {
                                                current_block = 6717603523453139513;
                                            } else {
                                                if res == -(1 as libc::c_int) {
                                                    xmlSchemaDeriveFacetErr(
                                                        pctxt,
                                                        fmaxinc,
                                                        fmininc,
                                                        1 as libc::c_int,
                                                        1 as libc::c_int,
                                                        0 as libc::c_int,
                                                    );
                                                }
                                                current_block = 3024367268842933116;
                                            }
                                        } else {
                                            current_block = 3024367268842933116;
                                        }
                                        match current_block {
                                            6717603523453139513 => {}
                                            _ => {
                                                if !bfmaxinc.is_null() {
                                                    res = xmlSchemaCompareValues(
                                                        (*fmaxinc).val,
                                                        (*bfmaxinc).val,
                                                    );
                                                    if res == -(2 as libc::c_int) {
                                                        current_block = 6717603523453139513;
                                                    } else {
                                                        if res == 1 as libc::c_int {
                                                            xmlSchemaDeriveFacetErr(
                                                                pctxt,
                                                                fmaxinc,
                                                                bfmaxinc,
                                                                -(1 as libc::c_int),
                                                                1 as libc::c_int,
                                                                1 as libc::c_int,
                                                            );
                                                        }
                                                        if res != 0 as libc::c_int && (*bfmaxinc).fixed != 0 {
                                                            xmlSchemaPCustomErr(
                                                                pctxt,
                                                                XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                fmaxinc as xmlSchemaBasicItemPtr,
                                                                (*fmaxinc).node,
                                                                b"The base type's facet is 'fixed', thus the value must not differ\0"
                                                                    as *const u8 as *const libc::c_char,
                                                                0 as *const xmlChar,
                                                            );
                                                        }
                                                        current_block = 16778110326724371720;
                                                    }
                                                } else {
                                                    current_block = 16778110326724371720;
                                                }
                                                match current_block {
                                                    6717603523453139513 => {}
                                                    _ => {
                                                        if !bfmaxexc.is_null() {
                                                            res = xmlSchemaCompareValues(
                                                                (*fmaxinc).val,
                                                                (*bfmaxexc).val,
                                                            );
                                                            if res == -(2 as libc::c_int) {
                                                                current_block = 6717603523453139513;
                                                            } else {
                                                                if res != -(1 as libc::c_int) {
                                                                    xmlSchemaDeriveFacetErr(
                                                                        pctxt,
                                                                        fmaxinc,
                                                                        bfmaxexc,
                                                                        -(1 as libc::c_int),
                                                                        0 as libc::c_int,
                                                                        1 as libc::c_int,
                                                                    );
                                                                }
                                                                current_block = 9180031981464905198;
                                                            }
                                                        } else {
                                                            current_block = 9180031981464905198;
                                                        }
                                                        match current_block {
                                                            6717603523453139513 => {}
                                                            _ => {
                                                                if !bfmininc.is_null() {
                                                                    res = xmlSchemaCompareValues(
                                                                        (*fmaxinc).val,
                                                                        (*bfmininc).val,
                                                                    );
                                                                    if res == -(2 as libc::c_int) {
                                                                        current_block = 6717603523453139513;
                                                                    } else {
                                                                        if res == -(1 as libc::c_int) {
                                                                            xmlSchemaDeriveFacetErr(
                                                                                pctxt,
                                                                                fmaxinc,
                                                                                bfmininc,
                                                                                1 as libc::c_int,
                                                                                1 as libc::c_int,
                                                                                1 as libc::c_int,
                                                                            );
                                                                        }
                                                                        current_block = 6584656659744957450;
                                                                    }
                                                                } else {
                                                                    current_block = 6584656659744957450;
                                                                }
                                                                match current_block {
                                                                    6717603523453139513 => {}
                                                                    _ => {
                                                                        if !bfminexc.is_null() {
                                                                            res = xmlSchemaCompareValues(
                                                                                (*fmaxinc).val,
                                                                                (*bfminexc).val,
                                                                            );
                                                                            if res == -(2 as libc::c_int) {
                                                                                current_block = 6717603523453139513;
                                                                            } else {
                                                                                if res != 1 as libc::c_int {
                                                                                    xmlSchemaDeriveFacetErr(
                                                                                        pctxt,
                                                                                        fmaxinc,
                                                                                        bfminexc,
                                                                                        1 as libc::c_int,
                                                                                        0 as libc::c_int,
                                                                                        1 as libc::c_int,
                                                                                    );
                                                                                }
                                                                                current_block = 10938659635288570931;
                                                                            }
                                                                        } else {
                                                                            current_block = 10938659635288570931;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        current_block = 10938659635288570931;
                                    }
                                    match current_block {
                                        6717603523453139513 => {}
                                        _ => {
                                            if !fmaxexc.is_null() {
                                                if !fminexc.is_null() {
                                                    res = xmlSchemaCompareValues(
                                                        (*fmaxexc).val,
                                                        (*fminexc).val,
                                                    );
                                                    if res == -(2 as libc::c_int) {
                                                        current_block = 6717603523453139513;
                                                    } else {
                                                        if res == -(1 as libc::c_int) {
                                                            xmlSchemaDeriveFacetErr(
                                                                pctxt,
                                                                fmaxexc,
                                                                fminexc,
                                                                1 as libc::c_int,
                                                                1 as libc::c_int,
                                                                0 as libc::c_int,
                                                            );
                                                        }
                                                        current_block = 7545150590528655645;
                                                    }
                                                } else {
                                                    current_block = 7545150590528655645;
                                                }
                                                match current_block {
                                                    6717603523453139513 => {}
                                                    _ => {
                                                        if !bfmaxexc.is_null() {
                                                            res = xmlSchemaCompareValues(
                                                                (*fmaxexc).val,
                                                                (*bfmaxexc).val,
                                                            );
                                                            if res == -(2 as libc::c_int) {
                                                                current_block = 6717603523453139513;
                                                            } else {
                                                                if res == 1 as libc::c_int {
                                                                    xmlSchemaDeriveFacetErr(
                                                                        pctxt,
                                                                        fmaxexc,
                                                                        bfmaxexc,
                                                                        -(1 as libc::c_int),
                                                                        1 as libc::c_int,
                                                                        1 as libc::c_int,
                                                                    );
                                                                }
                                                                if res != 0 as libc::c_int && (*bfmaxexc).fixed != 0 {
                                                                    xmlSchemaPCustomErr(
                                                                        pctxt,
                                                                        XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                        fmaxexc as xmlSchemaBasicItemPtr,
                                                                        (*fmaxexc).node,
                                                                        b"The base type's facet is 'fixed', thus the value must not differ\0"
                                                                            as *const u8 as *const libc::c_char,
                                                                        0 as *const xmlChar,
                                                                    );
                                                                }
                                                                current_block = 1421636490742020198;
                                                            }
                                                        } else {
                                                            current_block = 1421636490742020198;
                                                        }
                                                        match current_block {
                                                            6717603523453139513 => {}
                                                            _ => {
                                                                if !bfmaxinc.is_null() {
                                                                    res = xmlSchemaCompareValues(
                                                                        (*fmaxexc).val,
                                                                        (*bfmaxinc).val,
                                                                    );
                                                                    if res == -(2 as libc::c_int) {
                                                                        current_block = 6717603523453139513;
                                                                    } else {
                                                                        if res == 1 as libc::c_int {
                                                                            xmlSchemaDeriveFacetErr(
                                                                                pctxt,
                                                                                fmaxexc,
                                                                                bfmaxinc,
                                                                                -(1 as libc::c_int),
                                                                                1 as libc::c_int,
                                                                                1 as libc::c_int,
                                                                            );
                                                                        }
                                                                        current_block = 12129449210080749085;
                                                                    }
                                                                } else {
                                                                    current_block = 12129449210080749085;
                                                                }
                                                                match current_block {
                                                                    6717603523453139513 => {}
                                                                    _ => {
                                                                        if !bfmininc.is_null() {
                                                                            res = xmlSchemaCompareValues(
                                                                                (*fmaxexc).val,
                                                                                (*bfmininc).val,
                                                                            );
                                                                            if res == -(2 as libc::c_int) {
                                                                                current_block = 6717603523453139513;
                                                                            } else {
                                                                                if res != 1 as libc::c_int {
                                                                                    xmlSchemaDeriveFacetErr(
                                                                                        pctxt,
                                                                                        fmaxexc,
                                                                                        bfmininc,
                                                                                        1 as libc::c_int,
                                                                                        0 as libc::c_int,
                                                                                        1 as libc::c_int,
                                                                                    );
                                                                                }
                                                                                current_block = 11508203296038873488;
                                                                            }
                                                                        } else {
                                                                            current_block = 11508203296038873488;
                                                                        }
                                                                        match current_block {
                                                                            6717603523453139513 => {}
                                                                            _ => {
                                                                                if !bfminexc.is_null() {
                                                                                    res = xmlSchemaCompareValues(
                                                                                        (*fmaxexc).val,
                                                                                        (*bfminexc).val,
                                                                                    );
                                                                                    if res == -(2 as libc::c_int) {
                                                                                        current_block = 6717603523453139513;
                                                                                    } else {
                                                                                        if res != 1 as libc::c_int {
                                                                                            xmlSchemaDeriveFacetErr(
                                                                                                pctxt,
                                                                                                fmaxexc,
                                                                                                bfminexc,
                                                                                                1 as libc::c_int,
                                                                                                0 as libc::c_int,
                                                                                                1 as libc::c_int,
                                                                                            );
                                                                                        }
                                                                                        current_block = 5482373152242628851;
                                                                                    }
                                                                                } else {
                                                                                    current_block = 5482373152242628851;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            } else {
                                                current_block = 5482373152242628851;
                                            }
                                            match current_block {
                                                6717603523453139513 => {}
                                                _ => {
                                                    if !fminexc.is_null() {
                                                        if !fmaxinc.is_null() {
                                                            res = xmlSchemaCompareValues(
                                                                (*fminexc).val,
                                                                (*fmaxinc).val,
                                                            );
                                                            if res == -(2 as libc::c_int) {
                                                                current_block = 6717603523453139513;
                                                            } else {
                                                                if res != -(1 as libc::c_int) {
                                                                    xmlSchemaDeriveFacetErr(
                                                                        pctxt,
                                                                        fminexc,
                                                                        fmaxinc,
                                                                        -(1 as libc::c_int),
                                                                        0 as libc::c_int,
                                                                        0 as libc::c_int,
                                                                    );
                                                                }
                                                                current_block = 2925215368761540503;
                                                            }
                                                        } else {
                                                            current_block = 2925215368761540503;
                                                        }
                                                        match current_block {
                                                            6717603523453139513 => {}
                                                            _ => {
                                                                if !bfminexc.is_null() {
                                                                    res = xmlSchemaCompareValues(
                                                                        (*fminexc).val,
                                                                        (*bfminexc).val,
                                                                    );
                                                                    if res == -(2 as libc::c_int) {
                                                                        current_block = 6717603523453139513;
                                                                    } else {
                                                                        if res == -(1 as libc::c_int) {
                                                                            xmlSchemaDeriveFacetErr(
                                                                                pctxt,
                                                                                fminexc,
                                                                                bfminexc,
                                                                                1 as libc::c_int,
                                                                                1 as libc::c_int,
                                                                                1 as libc::c_int,
                                                                            );
                                                                        }
                                                                        if res != 0 as libc::c_int && (*bfminexc).fixed != 0 {
                                                                            xmlSchemaPCustomErr(
                                                                                pctxt,
                                                                                XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                fminexc as xmlSchemaBasicItemPtr,
                                                                                (*fminexc).node,
                                                                                b"The base type's facet is 'fixed', thus the value must not differ\0"
                                                                                    as *const u8 as *const libc::c_char,
                                                                                0 as *const xmlChar,
                                                                            );
                                                                        }
                                                                        current_block = 12299212226970775842;
                                                                    }
                                                                } else {
                                                                    current_block = 12299212226970775842;
                                                                }
                                                                match current_block {
                                                                    6717603523453139513 => {}
                                                                    _ => {
                                                                        if !bfmaxinc.is_null() {
                                                                            res = xmlSchemaCompareValues(
                                                                                (*fminexc).val,
                                                                                (*bfmaxinc).val,
                                                                            );
                                                                            if res == -(2 as libc::c_int) {
                                                                                current_block = 6717603523453139513;
                                                                            } else {
                                                                                if res == 1 as libc::c_int {
                                                                                    xmlSchemaDeriveFacetErr(
                                                                                        pctxt,
                                                                                        fminexc,
                                                                                        bfmaxinc,
                                                                                        -(1 as libc::c_int),
                                                                                        1 as libc::c_int,
                                                                                        1 as libc::c_int,
                                                                                    );
                                                                                }
                                                                                current_block = 16813369756331276724;
                                                                            }
                                                                        } else {
                                                                            current_block = 16813369756331276724;
                                                                        }
                                                                        match current_block {
                                                                            6717603523453139513 => {}
                                                                            _ => {
                                                                                if !bfmininc.is_null() {
                                                                                    res = xmlSchemaCompareValues(
                                                                                        (*fminexc).val,
                                                                                        (*bfmininc).val,
                                                                                    );
                                                                                    if res == -(2 as libc::c_int) {
                                                                                        current_block = 6717603523453139513;
                                                                                    } else {
                                                                                        if res == -(1 as libc::c_int) {
                                                                                            xmlSchemaDeriveFacetErr(
                                                                                                pctxt,
                                                                                                fminexc,
                                                                                                bfmininc,
                                                                                                1 as libc::c_int,
                                                                                                1 as libc::c_int,
                                                                                                1 as libc::c_int,
                                                                                            );
                                                                                        }
                                                                                        current_block = 5267916556966421873;
                                                                                    }
                                                                                } else {
                                                                                    current_block = 5267916556966421873;
                                                                                }
                                                                                match current_block {
                                                                                    6717603523453139513 => {}
                                                                                    _ => {
                                                                                        if !bfmaxexc.is_null() {
                                                                                            res = xmlSchemaCompareValues(
                                                                                                (*fminexc).val,
                                                                                                (*bfmaxexc).val,
                                                                                            );
                                                                                            if res == -(2 as libc::c_int) {
                                                                                                current_block = 6717603523453139513;
                                                                                            } else {
                                                                                                if res != -(1 as libc::c_int) {
                                                                                                    xmlSchemaDeriveFacetErr(
                                                                                                        pctxt,
                                                                                                        fminexc,
                                                                                                        bfmaxexc,
                                                                                                        -(1 as libc::c_int),
                                                                                                        0 as libc::c_int,
                                                                                                        1 as libc::c_int,
                                                                                                    );
                                                                                                }
                                                                                                current_block = 6091595930016798176;
                                                                                            }
                                                                                        } else {
                                                                                            current_block = 6091595930016798176;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        current_block = 6091595930016798176;
                                                    }
                                                    match current_block {
                                                        6717603523453139513 => {}
                                                        _ => {
                                                            if !fmininc.is_null() {
                                                                if !fmaxexc.is_null() {
                                                                    res = xmlSchemaCompareValues(
                                                                        (*fmininc).val,
                                                                        (*fmaxexc).val,
                                                                    );
                                                                    if res == -(2 as libc::c_int) {
                                                                        current_block = 6717603523453139513;
                                                                    } else {
                                                                        if res != -(1 as libc::c_int) {
                                                                            xmlSchemaDeriveFacetErr(
                                                                                pctxt,
                                                                                fmininc,
                                                                                fmaxexc,
                                                                                -(1 as libc::c_int),
                                                                                0 as libc::c_int,
                                                                                0 as libc::c_int,
                                                                            );
                                                                        }
                                                                        current_block = 6497888915984600225;
                                                                    }
                                                                } else {
                                                                    current_block = 6497888915984600225;
                                                                }
                                                                match current_block {
                                                                    6717603523453139513 => {}
                                                                    _ => {
                                                                        if !bfmininc.is_null() {
                                                                            res = xmlSchemaCompareValues(
                                                                                (*fmininc).val,
                                                                                (*bfmininc).val,
                                                                            );
                                                                            if res == -(2 as libc::c_int) {
                                                                                current_block = 6717603523453139513;
                                                                            } else {
                                                                                if res == -(1 as libc::c_int) {
                                                                                    xmlSchemaDeriveFacetErr(
                                                                                        pctxt,
                                                                                        fmininc,
                                                                                        bfmininc,
                                                                                        1 as libc::c_int,
                                                                                        1 as libc::c_int,
                                                                                        1 as libc::c_int,
                                                                                    );
                                                                                }
                                                                                if res != 0 as libc::c_int && (*bfmininc).fixed != 0 {
                                                                                    xmlSchemaPCustomErr(
                                                                                        pctxt,
                                                                                        XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                        fmininc as xmlSchemaBasicItemPtr,
                                                                                        (*fmininc).node,
                                                                                        b"The base type's facet is 'fixed', thus the value must not differ\0"
                                                                                            as *const u8 as *const libc::c_char,
                                                                                        0 as *const xmlChar,
                                                                                    );
                                                                                }
                                                                                current_block = 9350489878244555550;
                                                                            }
                                                                        } else {
                                                                            current_block = 9350489878244555550;
                                                                        }
                                                                        match current_block {
                                                                            6717603523453139513 => {}
                                                                            _ => {
                                                                                if !bfmaxinc.is_null() {
                                                                                    res = xmlSchemaCompareValues(
                                                                                        (*fmininc).val,
                                                                                        (*bfmaxinc).val,
                                                                                    );
                                                                                    if res == -(2 as libc::c_int) {
                                                                                        current_block = 6717603523453139513;
                                                                                    } else {
                                                                                        if res == 1 as libc::c_int {
                                                                                            xmlSchemaDeriveFacetErr(
                                                                                                pctxt,
                                                                                                fmininc,
                                                                                                bfmaxinc,
                                                                                                -(1 as libc::c_int),
                                                                                                1 as libc::c_int,
                                                                                                1 as libc::c_int,
                                                                                            );
                                                                                        }
                                                                                        current_block = 11364608634565542496;
                                                                                    }
                                                                                } else {
                                                                                    current_block = 11364608634565542496;
                                                                                }
                                                                                match current_block {
                                                                                    6717603523453139513 => {}
                                                                                    _ => {
                                                                                        if !bfminexc.is_null() {
                                                                                            res = xmlSchemaCompareValues(
                                                                                                (*fmininc).val,
                                                                                                (*bfminexc).val,
                                                                                            );
                                                                                            if res == -(2 as libc::c_int) {
                                                                                                current_block = 6717603523453139513;
                                                                                            } else {
                                                                                                if res != 1 as libc::c_int {
                                                                                                    xmlSchemaDeriveFacetErr(
                                                                                                        pctxt,
                                                                                                        fmininc,
                                                                                                        bfminexc,
                                                                                                        1 as libc::c_int,
                                                                                                        0 as libc::c_int,
                                                                                                        1 as libc::c_int,
                                                                                                    );
                                                                                                }
                                                                                                current_block = 3304481414499905106;
                                                                                            }
                                                                                        } else {
                                                                                            current_block = 3304481414499905106;
                                                                                        }
                                                                                        match current_block {
                                                                                            6717603523453139513 => {}
                                                                                            _ => {
                                                                                                if !bfmaxexc.is_null() {
                                                                                                    res = xmlSchemaCompareValues(
                                                                                                        (*fmininc).val,
                                                                                                        (*bfmaxexc).val,
                                                                                                    );
                                                                                                    if res == -(2 as libc::c_int) {
                                                                                                        current_block = 6717603523453139513;
                                                                                                    } else {
                                                                                                        if res != -(1 as libc::c_int) {
                                                                                                            xmlSchemaDeriveFacetErr(
                                                                                                                pctxt,
                                                                                                                fmininc,
                                                                                                                bfmaxexc,
                                                                                                                -(1 as libc::c_int),
                                                                                                                0 as libc::c_int,
                                                                                                                1 as libc::c_int,
                                                                                                            );
                                                                                                        }
                                                                                                        current_block = 1707335883933721018;
                                                                                                    }
                                                                                                } else {
                                                                                                    current_block = 1707335883933721018;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            } else {
                                                                current_block = 1707335883933721018;
                                                            }
                                                            match current_block {
                                                                6717603523453139513 => {}
                                                                _ => {
                                                                    if !ftotdig.is_null() && !bftotdig.is_null() {
                                                                        res = xmlSchemaCompareValues(
                                                                            (*ftotdig).val,
                                                                            (*bftotdig).val,
                                                                        );
                                                                        if res == -(2 as libc::c_int) {
                                                                            current_block = 6717603523453139513;
                                                                        } else {
                                                                            if res == 1 as libc::c_int {
                                                                                xmlSchemaDeriveFacetErr(
                                                                                    pctxt,
                                                                                    ftotdig,
                                                                                    bftotdig,
                                                                                    -(1 as libc::c_int),
                                                                                    1 as libc::c_int,
                                                                                    1 as libc::c_int,
                                                                                );
                                                                            }
                                                                            if res != 0 as libc::c_int && (*bftotdig).fixed != 0 {
                                                                                xmlSchemaPCustomErr(
                                                                                    pctxt,
                                                                                    XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                    ftotdig as xmlSchemaBasicItemPtr,
                                                                                    (*ftotdig).node,
                                                                                    b"The base type's facet is 'fixed', thus the value must not differ\0"
                                                                                        as *const u8 as *const libc::c_char,
                                                                                    0 as *const xmlChar,
                                                                                );
                                                                            }
                                                                            current_block = 2606663910910355487;
                                                                        }
                                                                    } else {
                                                                        current_block = 2606663910910355487;
                                                                    }
                                                                    match current_block {
                                                                        6717603523453139513 => {}
                                                                        _ => {
                                                                            if !ffracdig.is_null() && !bffracdig.is_null() {
                                                                                res = xmlSchemaCompareValues(
                                                                                    (*ffracdig).val,
                                                                                    (*bffracdig).val,
                                                                                );
                                                                                if res == -(2 as libc::c_int) {
                                                                                    current_block = 6717603523453139513;
                                                                                } else {
                                                                                    if res == 1 as libc::c_int {
                                                                                        xmlSchemaDeriveFacetErr(
                                                                                            pctxt,
                                                                                            ffracdig,
                                                                                            bffracdig,
                                                                                            -(1 as libc::c_int),
                                                                                            1 as libc::c_int,
                                                                                            1 as libc::c_int,
                                                                                        );
                                                                                    }
                                                                                    if res != 0 as libc::c_int && (*bffracdig).fixed != 0 {
                                                                                        xmlSchemaPCustomErr(
                                                                                            pctxt,
                                                                                            XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                            ffracdig as xmlSchemaBasicItemPtr,
                                                                                            (*ffracdig).node,
                                                                                            b"The base type's facet is 'fixed', thus the value must not differ\0"
                                                                                                as *const u8 as *const libc::c_char,
                                                                                            0 as *const xmlChar,
                                                                                        );
                                                                                    }
                                                                                    current_block = 5913497314667414582;
                                                                                }
                                                                            } else {
                                                                                current_block = 5913497314667414582;
                                                                            }
                                                                            match current_block {
                                                                                6717603523453139513 => {}
                                                                                _ => {
                                                                                    if ftotdig.is_null() {
                                                                                        ftotdig = bftotdig;
                                                                                    }
                                                                                    if ffracdig.is_null() {
                                                                                        ffracdig = bffracdig;
                                                                                    }
                                                                                    if !ftotdig.is_null() && !ffracdig.is_null() {
                                                                                        res = xmlSchemaCompareValues(
                                                                                            (*ffracdig).val,
                                                                                            (*ftotdig).val,
                                                                                        );
                                                                                        if res == -(2 as libc::c_int) {
                                                                                            current_block = 6717603523453139513;
                                                                                        } else {
                                                                                            if res == 1 as libc::c_int {
                                                                                                xmlSchemaDeriveFacetErr(
                                                                                                    pctxt,
                                                                                                    ffracdig,
                                                                                                    ftotdig,
                                                                                                    -(1 as libc::c_int),
                                                                                                    1 as libc::c_int,
                                                                                                    0 as libc::c_int,
                                                                                                );
                                                                                            }
                                                                                            current_block = 9190931632177426379;
                                                                                        }
                                                                                    } else {
                                                                                        current_block = 9190931632177426379;
                                                                                    }
                                                                                    match current_block {
                                                                                        6717603523453139513 => {}
                                                                                        _ => {
                                                                                            cur = (*base).facetSet;
                                                                                            while !cur.is_null() {
                                                                                                bfacet = (*cur).facet;
                                                                                                if !((*bfacet).type_0 as libc::c_uint
                                                                                                    == XML_SCHEMA_FACET_PATTERN as libc::c_int as libc::c_uint
                                                                                                    || (*bfacet).type_0 as libc::c_uint
                                                                                                        == XML_SCHEMA_FACET_ENUMERATION as libc::c_int
                                                                                                            as libc::c_uint)
                                                                                                {
                                                                                                    link = (*type_0).facetSet;
                                                                                                    while !link.is_null() {
                                                                                                        facet = (*link).facet;
                                                                                                        if (*facet).type_0 as libc::c_uint
                                                                                                            == (*bfacet).type_0 as libc::c_uint
                                                                                                        {
                                                                                                            match (*facet).type_0 as libc::c_uint {
                                                                                                                1008 => {
                                                                                                                    if (*facet).whitespace < (*bfacet).whitespace {
                                                                                                                        xmlSchemaPCustomErr(
                                                                                                                            pctxt,
                                                                                                                            XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                                                            facet as xmlSchemaBasicItemPtr,
                                                                                                                            (*facet).node,
                                                                                                                            b"The 'whitespace' value has to be equal to or stronger than the 'whitespace' value of the base type\0"
                                                                                                                                as *const u8 as *const libc::c_char,
                                                                                                                            0 as *const xmlChar,
                                                                                                                        );
                                                                                                                    }
                                                                                                                    if (*bfacet).fixed != 0
                                                                                                                        && (*facet).whitespace != (*bfacet).whitespace
                                                                                                                    {
                                                                                                                        xmlSchemaPCustomErr(
                                                                                                                            pctxt,
                                                                                                                            XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                                                            facet as xmlSchemaBasicItemPtr,
                                                                                                                            (*facet).node,
                                                                                                                            b"The base type's facet is 'fixed', thus the value must not differ\0"
                                                                                                                                as *const u8 as *const libc::c_char,
                                                                                                                            0 as *const xmlChar,
                                                                                                                        );
                                                                                                                    }
                                                                                                                }
                                                                                                                _ => {}
                                                                                                            }
                                                                                                            break;
                                                                                                        } else {
                                                                                                            link = (*link).next;
                                                                                                        }
                                                                                                    }
                                                                                                    if link.is_null() {
                                                                                                        link = xmlMalloc
                                                                                                            .expect(
                                                                                                                "non-null function pointer",
                                                                                                            )(
                                                                                                            ::std::mem::size_of::<xmlSchemaFacetLink>() as libc::c_ulong,
                                                                                                        ) as xmlSchemaFacetLinkPtr;
                                                                                                        if link.is_null() {
                                                                                                            xmlSchemaPErrMemory(
                                                                                                                pctxt,
                                                                                                                b"deriving facets, creating a facet link\0" as *const u8
                                                                                                                    as *const libc::c_char,
                                                                                                                0 as xmlNodePtr,
                                                                                                            );
                                                                                                            return -(1 as libc::c_int);
                                                                                                        }
                                                                                                        let ref mut fresh369 = (*link).facet;
                                                                                                        *fresh369 = (*cur).facet;
                                                                                                        let ref mut fresh370 = (*link).next;
                                                                                                        *fresh370 = 0 as *mut _xmlSchemaFacetLink;
                                                                                                        if last.is_null() {
                                                                                                            let ref mut fresh371 = (*type_0).facetSet;
                                                                                                            *fresh371 = link;
                                                                                                        } else {
                                                                                                            let ref mut fresh372 = (*last).next;
                                                                                                            *fresh372 = link;
                                                                                                        }
                                                                                                        last = link;
                                                                                                    }
                                                                                                }
                                                                                                cur = (*cur).next;
                                                                                            }
                                                                                            return 0 as libc::c_int;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    xmlSchemaInternalErr(
        pctxt as xmlSchemaAbstractCtxtPtr,
        b"xmlSchemaDeriveAndValidateFacets\0" as *const u8 as *const libc::c_char,
        b"an error occurred\0" as *const u8 as *const libc::c_char,
    );
    return -(1 as libc::c_int);
}
unsafe extern "C" fn xmlSchemaFinishMemberTypeDefinitionsProperty(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> libc::c_int {
    let mut link: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut lastLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut prevLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut subLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut newLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    link = (*type_0).memberTypes;
    while !link.is_null() {
        if (*(*link).type_0).type_0 as libc::c_uint
            != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
            && (*(*link).type_0).flags & (1 as libc::c_int) << 22 as libc::c_int
                == 0 as libc::c_int
        {
            xmlSchemaTypeFixup((*link).type_0, pctxt as xmlSchemaAbstractCtxtPtr);
        }
        if (*(*link).type_0).flags & (1 as libc::c_int) << 7 as libc::c_int != 0 {
            subLink = xmlSchemaGetUnionSimpleTypeMemberTypes((*link).type_0);
            if !subLink.is_null() {
                let ref mut fresh373 = (*link).type_0;
                *fresh373 = (*subLink).type_0;
                if !((*subLink).next).is_null() {
                    lastLink = (*link).next;
                    subLink = (*subLink).next;
                    prevLink = link;
                    while !subLink.is_null() {
                        newLink = xmlMalloc
                            .expect(
                                "non-null function pointer",
                            )(
                            ::std::mem::size_of::<xmlSchemaTypeLink>() as libc::c_ulong,
                        ) as xmlSchemaTypeLinkPtr;
                        if newLink.is_null() {
                            xmlSchemaPErrMemory(
                                pctxt,
                                b"allocating a type link\0" as *const u8
                                    as *const libc::c_char,
                                0 as xmlNodePtr,
                            );
                            return -(1 as libc::c_int);
                        }
                        let ref mut fresh374 = (*newLink).type_0;
                        *fresh374 = (*subLink).type_0;
                        let ref mut fresh375 = (*prevLink).next;
                        *fresh375 = newLink;
                        prevLink = newLink;
                        let ref mut fresh376 = (*newLink).next;
                        *fresh376 = lastLink;
                        subLink = (*subLink).next;
                    }
                }
            }
        }
        link = (*link).next;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaTypeFixupOptimFacets(mut type_0: xmlSchemaTypePtr) {
    let mut has: libc::c_int = 0 as libc::c_int;
    let mut needVal: libc::c_int = 0 as libc::c_int;
    let mut normVal: libc::c_int = 0 as libc::c_int;
    has = if (*(*type_0).baseType).flags & (1 as libc::c_int) << 27 as libc::c_int != 0 {
        1 as libc::c_int
    } else {
        0 as libc::c_int
    };
    if has != 0 {
        needVal = if (*(*type_0).baseType).flags
            & (1 as libc::c_int) << 21 as libc::c_int != 0
        {
            1 as libc::c_int
        } else {
            0 as libc::c_int
        };
        normVal = if (*(*type_0).baseType).flags
            & (1 as libc::c_int) << 28 as libc::c_int != 0
        {
            1 as libc::c_int
        } else {
            0 as libc::c_int
        };
    }
    if !((*type_0).facets).is_null() {
        let mut fac: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
        fac = (*type_0).facets;
        while !fac.is_null() {
            match (*fac).type_0 as libc::c_uint {
                1008 => {}
                1006 => {
                    normVal = 1 as libc::c_int;
                    has = 1 as libc::c_int;
                }
                1007 => {
                    needVal = 1 as libc::c_int;
                    normVal = 1 as libc::c_int;
                    has = 1 as libc::c_int;
                }
                _ => {
                    has = 1 as libc::c_int;
                }
            }
            fac = (*fac).next;
        }
    }
    if normVal != 0 {
        (*type_0).flags |= (1 as libc::c_int) << 28 as libc::c_int;
    }
    if needVal != 0 {
        (*type_0).flags |= (1 as libc::c_int) << 21 as libc::c_int;
    }
    if has != 0 {
        (*type_0).flags |= (1 as libc::c_int) << 27 as libc::c_int;
    }
    if has != 0 && needVal == 0
        && (*type_0).flags & (1 as libc::c_int) << 8 as libc::c_int != 0
    {
        let mut prim: xmlSchemaTypePtr = xmlSchemaGetPrimitiveType(type_0);
        if (*prim).builtInType != XML_SCHEMAS_ANYSIMPLETYPE as libc::c_int
            && (*prim).builtInType != XML_SCHEMAS_STRING as libc::c_int
        {
            (*type_0).flags |= (1 as libc::c_int) << 21 as libc::c_int;
        }
    }
}
unsafe extern "C" fn xmlSchemaTypeFixupWhitespace(
    mut type_0: xmlSchemaTypePtr,
) -> libc::c_int {
    if (*type_0).flags & (1 as libc::c_int) << 6 as libc::c_int != 0 {
        (*type_0).flags |= (1 as libc::c_int) << 26 as libc::c_int;
        return 0 as libc::c_int;
    } else {
        if (*type_0).flags & (1 as libc::c_int) << 7 as libc::c_int != 0 {
            return 0 as libc::c_int;
        }
    }
    if !((*type_0).facetSet).is_null() {
        let mut lin: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
        lin = (*type_0).facetSet;
        while !lin.is_null() {
            if (*(*lin).facet).type_0 as libc::c_uint
                == XML_SCHEMA_FACET_WHITESPACE as libc::c_int as libc::c_uint
            {
                match (*(*lin).facet).whitespace {
                    1 => {
                        (*type_0).flags |= (1 as libc::c_int) << 24 as libc::c_int;
                    }
                    2 => {
                        (*type_0).flags |= (1 as libc::c_int) << 25 as libc::c_int;
                    }
                    3 => {
                        (*type_0).flags |= (1 as libc::c_int) << 26 as libc::c_int;
                    }
                    _ => return -(1 as libc::c_int),
                }
                return 0 as libc::c_int;
            }
            lin = (*lin).next;
        }
    }
    let mut anc: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    anc = (*type_0).baseType;
    while !anc.is_null() && (*anc).builtInType != XML_SCHEMAS_ANYTYPE as libc::c_int {
        if (*anc).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
        {
            if (*anc).builtInType == XML_SCHEMAS_NORMSTRING as libc::c_int {
                (*type_0).flags |= (1 as libc::c_int) << 25 as libc::c_int;
            } else if (*anc).builtInType == XML_SCHEMAS_STRING as libc::c_int
                    || (*anc).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as libc::c_int
                {
                (*type_0).flags |= (1 as libc::c_int) << 24 as libc::c_int;
            } else {
                (*type_0).flags |= (1 as libc::c_int) << 26 as libc::c_int;
            }
            break;
        } else {
            anc = (*anc).baseType;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaFixupSimpleTypeStageOne(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> libc::c_int {
    if (*type_0).type_0 as libc::c_uint
        != XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int;
    }
    if !((*type_0).type_0 as libc::c_uint
        != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
        && (*type_0).flags & (1 as libc::c_int) << 29 as libc::c_int == 0 as libc::c_int)
    {
        return 0 as libc::c_int;
    }
    (*type_0).flags |= (1 as libc::c_int) << 29 as libc::c_int;
    if (*type_0).flags & (1 as libc::c_int) << 6 as libc::c_int != 0 {
        if ((*type_0).subtypes).is_null() {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaFixupSimpleTypeStageOne\0" as *const u8
                    as *const libc::c_char,
                b"list type has no item-type assigned\0" as *const u8
                    as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    } else if (*type_0).flags & (1 as libc::c_int) << 7 as libc::c_int != 0 {
        if ((*type_0).memberTypes).is_null() {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaFixupSimpleTypeStageOne\0" as *const u8
                    as *const libc::c_char,
                b"union type has no member-types assigned\0" as *const u8
                    as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
    } else {
        if ((*type_0).baseType).is_null() {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaFixupSimpleTypeStageOne\0" as *const u8
                    as *const libc::c_char,
                b"type has no base-type assigned\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        if (*(*type_0).baseType).type_0 as libc::c_uint
            != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
            && (*(*type_0).baseType).flags & (1 as libc::c_int) << 29 as libc::c_int
                == 0 as libc::c_int
        {
            if xmlSchemaFixupSimpleTypeStageOne(pctxt, (*type_0).baseType)
                == -(1 as libc::c_int)
            {
                return -(1 as libc::c_int);
            }
        }
        if (*(*type_0).baseType).flags & (1 as libc::c_int) << 8 as libc::c_int != 0 {
            (*type_0).flags |= (1 as libc::c_int) << 8 as libc::c_int;
        } else if (*(*type_0).baseType).flags & (1 as libc::c_int) << 6 as libc::c_int
                != 0
            {
            (*type_0).flags |= (1 as libc::c_int) << 6 as libc::c_int;
            let ref mut fresh377 = (*type_0).subtypes;
            *fresh377 = (*(*type_0).baseType).subtypes;
        } else if (*(*type_0).baseType).flags & (1 as libc::c_int) << 7 as libc::c_int
                != 0
            {
            (*type_0).flags |= (1 as libc::c_int) << 7 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaFixupSimpleTypeStageTwo(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> libc::c_int {
    let mut current_block: u64;
    let mut res: libc::c_int = 0;
    let mut olderrs: libc::c_int = (*pctxt).nberrors;
    if (*type_0).type_0 as libc::c_uint
        != XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
    {
        return -(1 as libc::c_int);
    }
    if !((*type_0).type_0 as libc::c_uint
        != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
        && (*type_0).flags & (1 as libc::c_int) << 22 as libc::c_int == 0 as libc::c_int)
    {
        return 0 as libc::c_int;
    }
    (*type_0).flags |= (1 as libc::c_int) << 22 as libc::c_int;
    (*type_0).contentType = XML_SCHEMA_CONTENT_SIMPLE;
    if ((*type_0).baseType).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaFixupSimpleTypeStageTwo\0" as *const u8 as *const libc::c_char,
            b"missing baseType\0" as *const u8 as *const libc::c_char,
        );
    } else {
        if (*(*type_0).baseType).type_0 as libc::c_uint
            != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
            && (*(*type_0).baseType).flags & (1 as libc::c_int) << 22 as libc::c_int
                == 0 as libc::c_int
        {
            xmlSchemaTypeFixup((*type_0).baseType, pctxt as xmlSchemaAbstractCtxtPtr);
        }
        if !((*type_0).memberTypes).is_null()
            && xmlSchemaFinishMemberTypeDefinitionsProperty(pctxt, type_0)
                == -(1 as libc::c_int)
        {
            return -(1 as libc::c_int);
        }
        res = xmlSchemaCheckSTPropsCorrect(pctxt, type_0);
        if !(res == -(1 as libc::c_int)) {
            if res != 0 as libc::c_int {
                current_block = 16935711101380438426;
            } else {
                res = xmlSchemaCheckCOSSTRestricts(pctxt, type_0);
                if res == -(1 as libc::c_int) {
                    current_block = 7438021731138147780;
                } else if res != 0 as libc::c_int {
                    current_block = 16935711101380438426;
                } else {
                    res = xmlSchemaCheckFacetValues(type_0, pctxt);
                    if res == -(1 as libc::c_int) {
                        current_block = 7438021731138147780;
                    } else if res != 0 as libc::c_int {
                        current_block = 16935711101380438426;
                    } else {
                        if !((*type_0).facetSet).is_null()
                            || !((*(*type_0).baseType).facetSet).is_null()
                        {
                            res = xmlSchemaDeriveAndValidateFacets(pctxt, type_0);
                            if res == -(1 as libc::c_int) {
                                current_block = 7438021731138147780;
                            } else if res != 0 as libc::c_int {
                                current_block = 16935711101380438426;
                            } else {
                                current_block = 4068382217303356765;
                            }
                        } else {
                            current_block = 4068382217303356765;
                        }
                        match current_block {
                            16935711101380438426 => {}
                            7438021731138147780 => {}
                            _ => {
                                res = xmlSchemaTypeFixupWhitespace(type_0);
                                if res == -(1 as libc::c_int) {
                                    current_block = 7438021731138147780;
                                } else if res != 0 as libc::c_int {
                                    current_block = 16935711101380438426;
                                } else {
                                    xmlSchemaTypeFixupOptimFacets(type_0);
                                    current_block = 16935711101380438426;
                                }
                            }
                        }
                    }
                }
            }
            match current_block {
                7438021731138147780 => {}
                _ => {
                    if olderrs != (*pctxt).nberrors {
                        return (*pctxt).err;
                    }
                    return 0 as libc::c_int;
                }
            }
        }
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn xmlSchemaFixupComplexType(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> libc::c_int {
    let mut current_block: u64;
    let mut res: libc::c_int = 0 as libc::c_int;
    let mut olderrs: libc::c_int = (*pctxt).nberrors;
    let mut baseType: xmlSchemaTypePtr = (*type_0).baseType;
    if !((*type_0).type_0 as libc::c_uint
        != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
        && (*type_0).flags & (1 as libc::c_int) << 22 as libc::c_int == 0 as libc::c_int)
    {
        return 0 as libc::c_int;
    }
    (*type_0).flags |= (1 as libc::c_int) << 22 as libc::c_int;
    if baseType.is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaFixupComplexType\0" as *const u8 as *const libc::c_char,
            b"missing baseType\0" as *const u8 as *const libc::c_char,
        );
    } else {
        if (*baseType).type_0 as libc::c_uint
            != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
            && (*baseType).flags & (1 as libc::c_int) << 22 as libc::c_int
                == 0 as libc::c_int
        {
            xmlSchemaTypeFixup(baseType, pctxt as xmlSchemaAbstractCtxtPtr);
        }
        if (*baseType).flags & (1 as libc::c_int) << 23 as libc::c_int != 0 {
            return 0 as libc::c_int;
        }
        res = xmlSchemaCheckSRCCT(pctxt, type_0);
        if !(res == -(1 as libc::c_int)) {
            if res != 0 as libc::c_int {
                current_block = 6926858937233525393;
            } else {
                if (*type_0).contentType as libc::c_uint
                    == XML_SCHEMA_CONTENT_SIMPLE as libc::c_int as libc::c_uint
                {
                    if ((*baseType).type_0 as libc::c_uint
                        == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
                        || (*baseType).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int)
                        && !((*baseType).contentTypeDef).is_null()
                        && (*type_0).flags & (1 as libc::c_int) << 2 as libc::c_int != 0
                    {
                        let mut contentBase: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
                        let mut content: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
                        if !((*type_0).contentTypeDef).is_null() {
                            contentBase = (*type_0).contentTypeDef;
                            let ref mut fresh378 = (*type_0).contentTypeDef;
                            *fresh378 = 0 as xmlSchemaTypePtr;
                        } else {
                            contentBase = (*baseType).contentTypeDef;
                        }
                        content = xmlSchemaAddType(
                            pctxt,
                            (*pctxt).schema,
                            XML_SCHEMA_TYPE_SIMPLE,
                            0 as *const xmlChar,
                            (*type_0).targetNamespace,
                            (*type_0).node,
                            0 as libc::c_int,
                        );
                        if content.is_null() {
                            current_block = 345336241299298347;
                        } else {
                            (*content).type_0 = XML_SCHEMA_TYPE_SIMPLE;
                            let ref mut fresh379 = (*content).baseType;
                            *fresh379 = contentBase;
                            let ref mut fresh380 = (*content).facets;
                            *fresh380 = (*type_0).facets;
                            let ref mut fresh381 = (*type_0).facets;
                            *fresh381 = 0 as xmlSchemaFacetPtr;
                            let ref mut fresh382 = (*content).facetSet;
                            *fresh382 = (*type_0).facetSet;
                            let ref mut fresh383 = (*type_0).facetSet;
                            *fresh383 = 0 as xmlSchemaFacetLinkPtr;
                            let ref mut fresh384 = (*type_0).contentTypeDef;
                            *fresh384 = content;
                            if (*contentBase).type_0 as libc::c_uint
                                != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                                && (*contentBase).flags
                                    & (1 as libc::c_int) << 22 as libc::c_int
                                    == 0 as libc::c_int
                            {
                                xmlSchemaTypeFixup(
                                    contentBase,
                                    pctxt as xmlSchemaAbstractCtxtPtr,
                                );
                            }
                            res = xmlSchemaFixupSimpleTypeStageOne(pctxt, content);
                            if res == -(1 as libc::c_int) {
                                current_block = 345336241299298347;
                            } else if res != 0 as libc::c_int {
                                current_block = 6926858937233525393;
                            } else {
                                res = xmlSchemaFixupSimpleTypeStageTwo(pctxt, content);
                                if res == -(1 as libc::c_int) {
                                    current_block = 345336241299298347;
                                } else if res != 0 as libc::c_int {
                                    current_block = 6926858937233525393;
                                } else {
                                    current_block = 5265702136860997526;
                                }
                            }
                        }
                    } else if ((*baseType).type_0 as libc::c_uint
                            == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
                            || (*baseType).builtInType
                                == XML_SCHEMAS_ANYTYPE as libc::c_int)
                            && (*baseType).contentType as libc::c_uint
                                == XML_SCHEMA_CONTENT_MIXED as libc::c_int as libc::c_uint
                            && (*type_0).flags & (1 as libc::c_int) << 2 as libc::c_int
                                != 0
                        {
                        if ((*type_0).contentTypeDef).is_null()
                            || ((*(*type_0).contentTypeDef).baseType).is_null()
                        {
                            xmlSchemaPCustomErr(
                                pctxt,
                                XML_SCHEMAP_INTERNAL,
                                type_0 as xmlSchemaBasicItemPtr,
                                0 as xmlNodePtr,
                                b"Internal error: xmlSchemaTypeFixup, complex type '%s': the <simpleContent><restriction> is missing a <simpleType> child, but was not caught by xmlSchemaCheckSRCCT()\0"
                                    as *const u8 as *const libc::c_char,
                                (*type_0).name,
                            );
                            current_block = 345336241299298347;
                        } else {
                            current_block = 5265702136860997526;
                        }
                    } else if ((*baseType).type_0 as libc::c_uint
                            == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
                            || (*baseType).builtInType
                                == XML_SCHEMAS_ANYTYPE as libc::c_int)
                            && (*type_0).flags & (1 as libc::c_int) << 1 as libc::c_int
                                != 0
                        {
                        if ((*baseType).contentTypeDef).is_null() {
                            xmlSchemaPCustomErr(
                                pctxt,
                                XML_SCHEMAP_INTERNAL,
                                type_0 as xmlSchemaBasicItemPtr,
                                0 as xmlNodePtr,
                                b"Internal error: xmlSchemaTypeFixup, complex type '%s': the <extension>ed base type is a complex type with no simple content type\0"
                                    as *const u8 as *const libc::c_char,
                                (*type_0).name,
                            );
                            current_block = 345336241299298347;
                        } else {
                            let ref mut fresh385 = (*type_0).contentTypeDef;
                            *fresh385 = (*baseType).contentTypeDef;
                            current_block = 5265702136860997526;
                        }
                    } else if ((*baseType).type_0 as libc::c_uint
                            == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
                            || (*baseType).type_0 as libc::c_uint
                                == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                                && (*baseType).builtInType
                                    != XML_SCHEMAS_ANYTYPE as libc::c_int)
                            && (*type_0).flags & (1 as libc::c_int) << 1 as libc::c_int
                                != 0
                        {
                        let ref mut fresh386 = (*type_0).contentTypeDef;
                        *fresh386 = baseType;
                        current_block = 5265702136860997526;
                    } else {
                        xmlSchemaPCustomErr(
                            pctxt,
                            XML_SCHEMAP_INTERNAL,
                            type_0 as xmlSchemaBasicItemPtr,
                            0 as xmlNodePtr,
                            b"Internal error: xmlSchemaTypeFixup, complex type '%s' with <simpleContent>: unhandled derivation case\0"
                                as *const u8 as *const libc::c_char,
                            (*type_0).name,
                        );
                        current_block = 345336241299298347;
                    }
                } else {
                    let mut dummySequence: libc::c_int = 0 as libc::c_int;
                    let mut particle: xmlSchemaParticlePtr = (*type_0).subtypes
                        as xmlSchemaParticlePtr;
                    if particle.is_null()
                        || (*particle).type_0 as libc::c_uint
                            == XML_SCHEMA_TYPE_PARTICLE as libc::c_int as libc::c_uint
                            && ((*(*particle).children).type_0 as libc::c_uint
                                == XML_SCHEMA_TYPE_ALL as libc::c_int as libc::c_uint
                                || (*(*particle).children).type_0 as libc::c_uint
                                    == XML_SCHEMA_TYPE_SEQUENCE as libc::c_int as libc::c_uint
                                || (*(*particle).children).type_0 as libc::c_uint
                                    == XML_SCHEMA_TYPE_CHOICE as libc::c_int as libc::c_uint
                                    && (*particle).minOccurs == 0 as libc::c_int)
                            && ((*(*particle).children).children).is_null()
                    {
                        if (*type_0).flags & (1 as libc::c_int) << 0 as libc::c_int != 0
                        {
                            if particle.is_null()
                                || (*(*particle).children).type_0 as libc::c_uint
                                    != XML_SCHEMA_TYPE_SEQUENCE as libc::c_int as libc::c_uint
                            {
                                particle = xmlSchemaAddParticle(
                                    pctxt,
                                    (*type_0).node,
                                    1 as libc::c_int,
                                    1 as libc::c_int,
                                );
                                if particle.is_null() {
                                    current_block = 345336241299298347;
                                } else {
                                    let ref mut fresh387 = (*particle).children;
                                    *fresh387 = xmlSchemaAddModelGroup(
                                        pctxt,
                                        (*pctxt).schema,
                                        XML_SCHEMA_TYPE_SEQUENCE,
                                        (*type_0).node,
                                    ) as xmlSchemaTreeItemPtr;
                                    if ((*particle).children).is_null() {
                                        current_block = 345336241299298347;
                                    } else {
                                        let ref mut fresh388 = (*type_0).subtypes;
                                        *fresh388 = particle as xmlSchemaTypePtr;
                                        current_block = 17075014677070940716;
                                    }
                                }
                            } else {
                                current_block = 17075014677070940716;
                            }
                            match current_block {
                                345336241299298347 => {}
                                _ => {
                                    dummySequence = 1 as libc::c_int;
                                    (*type_0).contentType = XML_SCHEMA_CONTENT_ELEMENTS;
                                    current_block = 4216521074440650966;
                                }
                            }
                        } else {
                            (*type_0).contentType = XML_SCHEMA_CONTENT_EMPTY;
                            current_block = 4216521074440650966;
                        }
                    } else {
                        (*type_0).contentType = XML_SCHEMA_CONTENT_ELEMENTS;
                        current_block = 4216521074440650966;
                    }
                    match current_block {
                        345336241299298347 => {}
                        _ => {
                            if (*type_0).flags & (1 as libc::c_int) << 2 as libc::c_int
                                != 0
                            {
                                if (*type_0).contentType as libc::c_uint
                                    != XML_SCHEMA_CONTENT_EMPTY as libc::c_int as libc::c_uint
                                {
                                    if (*type_0).flags & (1 as libc::c_int) << 0 as libc::c_int
                                        != 0
                                    {
                                        (*type_0).contentType = XML_SCHEMA_CONTENT_MIXED;
                                    }
                                }
                                current_block = 5265702136860997526;
                            } else if (*type_0).contentType as libc::c_uint
                                    == XML_SCHEMA_CONTENT_EMPTY as libc::c_int as libc::c_uint
                                {
                                (*type_0).contentType = (*baseType).contentType;
                                let ref mut fresh389 = (*type_0).subtypes;
                                *fresh389 = (*baseType).subtypes;
                                let ref mut fresh390 = (*type_0).contentTypeDef;
                                *fresh390 = (*baseType).contentTypeDef;
                                current_block = 5265702136860997526;
                            } else if (*baseType).contentType as libc::c_uint
                                    == XML_SCHEMA_CONTENT_EMPTY as libc::c_int as libc::c_uint
                                {
                                if (*type_0).flags & (1 as libc::c_int) << 0 as libc::c_int
                                    != 0
                                {
                                    (*type_0).contentType = XML_SCHEMA_CONTENT_MIXED;
                                }
                                current_block = 5265702136860997526;
                            } else {
                                if (*type_0).flags & (1 as libc::c_int) << 0 as libc::c_int
                                    != 0
                                {
                                    (*type_0).contentType = XML_SCHEMA_CONTENT_MIXED;
                                }
                                if !((*type_0).subtypes as xmlSchemaParticlePtr).is_null()
                                    && !((*((*type_0).subtypes as xmlSchemaParticlePtr))
                                        .children)
                                        .is_null()
                                    && (*(*((*type_0).subtypes as xmlSchemaParticlePtr))
                                        .children)
                                        .type_0 as libc::c_uint
                                        == XML_SCHEMA_TYPE_ALL as libc::c_int as libc::c_uint
                                {
                                    xmlSchemaCustomErr(
                                        pctxt as xmlSchemaAbstractCtxtPtr,
                                        XML_SCHEMAP_COS_ALL_LIMITED,
                                        xmlSchemaGetComponentNode(type_0 as xmlSchemaBasicItemPtr),
                                        0 as xmlSchemaBasicItemPtr,
                                        b"The type has an 'all' model group in its {content type} and thus cannot be derived from a non-empty type, since this would produce a 'sequence' model group containing the 'all' model group; 'all' model groups are not allowed to appear inside other model groups\0"
                                            as *const u8 as *const libc::c_char,
                                        0 as *const xmlChar,
                                        0 as *const xmlChar,
                                    );
                                    current_block = 5265702136860997526;
                                } else if !((*baseType).subtypes as xmlSchemaParticlePtr)
                                        .is_null()
                                        && !((*((*baseType).subtypes as xmlSchemaParticlePtr))
                                            .children)
                                            .is_null()
                                        && (*(*((*baseType).subtypes as xmlSchemaParticlePtr))
                                            .children)
                                            .type_0 as libc::c_uint
                                            == XML_SCHEMA_TYPE_ALL as libc::c_int as libc::c_uint
                                    {
                                    xmlSchemaCustomErr(
                                        pctxt as xmlSchemaAbstractCtxtPtr,
                                        XML_SCHEMAP_COS_ALL_LIMITED,
                                        xmlSchemaGetComponentNode(type_0 as xmlSchemaBasicItemPtr),
                                        0 as xmlSchemaBasicItemPtr,
                                        b"A type cannot be derived by extension from a type which has an 'all' model group in its {content type}, since this would produce a 'sequence' model group containing the 'all' model group; 'all' model groups are not allowed to appear inside other model groups\0"
                                            as *const u8 as *const libc::c_char,
                                        0 as *const xmlChar,
                                        0 as *const xmlChar,
                                    );
                                    current_block = 5265702136860997526;
                                } else if dummySequence == 0 {
                                    let mut effectiveContent: xmlSchemaTreeItemPtr = (*type_0)
                                        .subtypes as xmlSchemaTreeItemPtr;
                                    particle = xmlSchemaAddParticle(
                                        pctxt,
                                        (*type_0).node,
                                        1 as libc::c_int,
                                        1 as libc::c_int,
                                    );
                                    if particle.is_null() {
                                        current_block = 345336241299298347;
                                    } else {
                                        let ref mut fresh391 = (*particle).children;
                                        *fresh391 = xmlSchemaAddModelGroup(
                                            pctxt,
                                            (*pctxt).schema,
                                            XML_SCHEMA_TYPE_SEQUENCE,
                                            (*type_0).node,
                                        ) as xmlSchemaTreeItemPtr;
                                        if ((*particle).children).is_null() {
                                            current_block = 345336241299298347;
                                        } else {
                                            let ref mut fresh392 = (*type_0).subtypes;
                                            *fresh392 = particle as xmlSchemaTypePtr;
                                            let ref mut fresh393 = (*(*particle).children).children;
                                            *fresh393 = xmlSchemaAddParticle(
                                                pctxt,
                                                (*type_0).node,
                                                (*((*baseType).subtypes as xmlSchemaParticlePtr)).minOccurs,
                                                (*((*baseType).subtypes as xmlSchemaParticlePtr)).maxOccurs,
                                            ) as xmlSchemaTreeItemPtr;
                                            if ((*(*particle).children).children).is_null() {
                                                current_block = 345336241299298347;
                                            } else {
                                                particle = (*(*particle).children).children
                                                    as xmlSchemaParticlePtr;
                                                let ref mut fresh394 = (*particle).children;
                                                *fresh394 = (*((*baseType).subtypes
                                                    as xmlSchemaParticlePtr))
                                                    .children;
                                                let ref mut fresh395 = (*particle).next;
                                                *fresh395 = effectiveContent;
                                                current_block = 5265702136860997526;
                                            }
                                        }
                                    }
                                } else {
                                    let ref mut fresh396 = (*(*particle).children).children;
                                    *fresh396 = (*baseType).subtypes as xmlSchemaTreeItemPtr;
                                    current_block = 5265702136860997526;
                                }
                            }
                        }
                    }
                }
                match current_block {
                    345336241299298347 => {}
                    6926858937233525393 => {}
                    _ => {
                        res = xmlSchemaFixupTypeAttributeUses(pctxt, type_0);
                        if res == -(1 as libc::c_int) {
                            current_block = 345336241299298347;
                        } else if res != 0 as libc::c_int {
                            current_block = 6926858937233525393;
                        } else {
                            res = xmlSchemaCheckCTComponent(pctxt, type_0);
                            if res == -(1 as libc::c_int) {
                                current_block = 345336241299298347;
                            } else if res != 0 as libc::c_int {
                                current_block = 6926858937233525393;
                            } else if olderrs != (*pctxt).nberrors {
                                return (*pctxt).err
                            } else {
                                return 0 as libc::c_int
                            }
                        }
                    }
                }
            }
            match current_block {
                345336241299298347 => {}
                _ => {
                    (*type_0).flags |= (1 as libc::c_int) << 23 as libc::c_int;
                    return (*pctxt).err;
                }
            }
        }
    }
    (*type_0).flags |= (1 as libc::c_int) << 23 as libc::c_int;
    return -(1 as libc::c_int);
}
unsafe extern "C" fn xmlSchemaTypeFixup(
    mut type_0: xmlSchemaTypePtr,
    mut actxt: xmlSchemaAbstractCtxtPtr,
) -> libc::c_int {
    if type_0.is_null() {
        return 0 as libc::c_int;
    }
    if (*actxt).type_0 != 1 as libc::c_int {
        xmlSchemaInternalErr(
            actxt,
            b"xmlSchemaTypeFixup\0" as *const u8 as *const libc::c_char,
            b"this function needs a parser context\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    if !((*type_0).type_0 as libc::c_uint
        != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
        && (*type_0).flags & (1 as libc::c_int) << 22 as libc::c_int == 0 as libc::c_int)
    {
        return 0 as libc::c_int;
    }
    if (*type_0).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
    {
        return xmlSchemaFixupComplexType(actxt as xmlSchemaParserCtxtPtr, type_0)
    } else {
        if (*type_0).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
        {
            return xmlSchemaFixupSimpleTypeStageTwo(
                actxt as xmlSchemaParserCtxtPtr,
                type_0,
            );
        }
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaCheckFacet(
    mut facet: xmlSchemaFacetPtr,
    mut typeDecl: xmlSchemaTypePtr,
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut name: *const xmlChar,
) -> libc::c_int {
    let mut current_block: u64;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut ctxtGiven: libc::c_int = 0;
    if facet.is_null() || typeDecl.is_null() {
        return -(1 as libc::c_int);
    }
    if pctxt.is_null() {
        ctxtGiven = 0 as libc::c_int;
    } else {
        ctxtGiven = 1 as libc::c_int;
    }
    match (*facet).type_0 as libc::c_uint {
        1000 | 1001 | 1002 | 1003 | 1007 => {
            let mut base: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
            if (*typeDecl).type_0 as libc::c_uint
                != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
            {
                base = (*typeDecl).baseType;
                if base.is_null() {
                    xmlSchemaInternalErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaCheckFacet\0" as *const u8 as *const libc::c_char,
                        b"a type user derived type has no base type\0" as *const u8
                            as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
            } else {
                base = typeDecl;
            }
            if ctxtGiven == 0 {
                pctxt = xmlSchemaNewParserCtxt(
                    b"*\0" as *const u8 as *const libc::c_char,
                );
                if pctxt.is_null() {
                    return -(1 as libc::c_int);
                }
            }
            ret = xmlSchemaVCheckCVCSimpleType(
                pctxt as xmlSchemaAbstractCtxtPtr,
                (*facet).node,
                base,
                (*facet).value,
                &mut (*facet).val,
                1 as libc::c_int,
                1 as libc::c_int,
                0 as libc::c_int,
            );
            if ret != 0 as libc::c_int {
                if ret < 0 as libc::c_int {
                    if ctxtGiven != 0 {
                        xmlSchemaCustomErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            XML_SCHEMAP_INTERNAL,
                            (*facet).node,
                            0 as xmlSchemaBasicItemPtr,
                            b"Internal error: xmlSchemaCheckFacet, failed to validate the value '%s' of the facet '%s' against the base type\0"
                                as *const u8 as *const libc::c_char,
                            (*facet).value,
                            xmlSchemaFacetTypeToString((*facet).type_0),
                        );
                    }
                    current_block = 5348683486121694512;
                } else {
                    ret = XML_SCHEMAP_INVALID_FACET_VALUE as libc::c_int;
                    if ctxtGiven != 0 {
                        let mut str: *mut xmlChar = 0 as *mut xmlChar;
                        xmlSchemaCustomErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            ret as xmlParserErrors,
                            (*facet).node,
                            facet as xmlSchemaBasicItemPtr,
                            b"The value '%s' of the facet does not validate against the base type '%s'\0"
                                as *const u8 as *const libc::c_char,
                            (*facet).value,
                            xmlSchemaFormatQName(
                                &mut str,
                                (*base).targetNamespace,
                                (*base).name,
                            ),
                        );
                        if !str.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(str as *mut libc::c_void);
                            str = 0 as *mut xmlChar;
                        }
                    }
                    current_block = 15604527402135937264;
                }
            } else {
                if ((*facet).val).is_null() {
                    if ctxtGiven != 0 {
                        xmlSchemaInternalErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaCheckFacet\0" as *const u8 as *const libc::c_char,
                            b"value was not computed\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    (*__xmlGenericError())
                        .expect(
                            "non-null function pointer",
                        )(
                        *__xmlGenericErrorContext(),
                        b"Unimplemented block at %s:%d\n\0" as *const u8
                            as *const libc::c_char,
                        b"xmlschemas.c\0" as *const u8 as *const libc::c_char,
                        18869 as libc::c_int,
                    );
                }
                current_block = 15604527402135937264;
            }
        }
        1006 => {
            let ref mut fresh397 = (*facet).regexp;
            *fresh397 = xmlRegexpCompile((*facet).value);
            if ((*facet).regexp).is_null() {
                ret = XML_SCHEMAP_REGEXP_INVALID as libc::c_int;
                if ctxtGiven != 0 {
                    xmlSchemaCustomErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        ret as xmlParserErrors,
                        (*facet).node,
                        typeDecl as xmlSchemaBasicItemPtr,
                        b"The value '%s' of the facet 'pattern' is not a valid regular expression\0"
                            as *const u8 as *const libc::c_char,
                        (*facet).value,
                        0 as *const xmlChar,
                    );
                }
            }
            current_block = 15604527402135937264;
        }
        1004 | 1005 | 1009 | 1010 | 1011 => {
            if (*facet).type_0 as libc::c_uint
                == XML_SCHEMA_FACET_TOTALDIGITS as libc::c_int as libc::c_uint
            {
                ret = xmlSchemaValidatePredefinedType(
                    xmlSchemaGetBuiltInType(XML_SCHEMAS_PINTEGER),
                    (*facet).value,
                    &mut (*facet).val,
                );
            } else {
                ret = xmlSchemaValidatePredefinedType(
                    xmlSchemaGetBuiltInType(XML_SCHEMAS_NNINTEGER),
                    (*facet).value,
                    &mut (*facet).val,
                );
            }
            if ret != 0 as libc::c_int {
                if ret < 0 as libc::c_int {
                    if ctxtGiven != 0 {
                        xmlSchemaInternalErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaCheckFacet\0" as *const u8 as *const libc::c_char,
                            b"validating facet value\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    current_block = 5348683486121694512;
                } else {
                    ret = XML_SCHEMAP_INVALID_FACET_VALUE as libc::c_int;
                    if ctxtGiven != 0 {
                        xmlSchemaCustomErr4(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            ret as xmlParserErrors,
                            (*facet).node,
                            typeDecl as xmlSchemaBasicItemPtr,
                            b"The value '%s' of the facet '%s' is not a valid '%s'\0"
                                as *const u8 as *const libc::c_char,
                            (*facet).value,
                            xmlSchemaFacetTypeToString((*facet).type_0),
                            if (*facet).type_0 as libc::c_uint
                                != XML_SCHEMA_FACET_TOTALDIGITS as libc::c_int
                                    as libc::c_uint
                            {
                                b"nonNegativeInteger\0" as *const u8 as *const libc::c_char
                                    as *mut xmlChar
                            } else {
                                b"positiveInteger\0" as *const u8 as *const libc::c_char
                                    as *mut xmlChar
                            },
                            0 as *const xmlChar,
                        );
                    }
                    current_block = 15604527402135937264;
                }
            } else {
                current_block = 15604527402135937264;
            }
        }
        1008 => {
            if xmlStrEqual(
                (*facet).value,
                b"preserve\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) != 0
            {
                (*facet).whitespace = 1 as libc::c_int;
            } else if xmlStrEqual(
                    (*facet).value,
                    b"replace\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) != 0
                {
                (*facet).whitespace = 2 as libc::c_int;
            } else if xmlStrEqual(
                    (*facet).value,
                    b"collapse\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) != 0
                {
                (*facet).whitespace = 3 as libc::c_int;
            } else {
                ret = XML_SCHEMAP_INVALID_FACET_VALUE as libc::c_int;
                if ctxtGiven != 0 {
                    xmlSchemaCustomErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        ret as xmlParserErrors,
                        (*facet).node,
                        typeDecl as xmlSchemaBasicItemPtr,
                        b"The value '%s' of the facet 'whitespace' is not valid\0"
                            as *const u8 as *const libc::c_char,
                        (*facet).value,
                        0 as *const xmlChar,
                    );
                }
            }
            current_block = 15604527402135937264;
        }
        _ => {
            current_block = 15604527402135937264;
        }
    }
    match current_block {
        5348683486121694512 => {
            if ctxtGiven == 0 && !pctxt.is_null() {
                xmlSchemaFreeParserCtxt(pctxt);
            }
            return -(1 as libc::c_int);
        }
        _ => {
            if ctxtGiven == 0 && !pctxt.is_null() {
                xmlSchemaFreeParserCtxt(pctxt);
            }
            return ret;
        }
    };
}
unsafe extern "C" fn xmlSchemaCheckFacetValues(
    mut typeDecl: xmlSchemaTypePtr,
    mut pctxt: xmlSchemaParserCtxtPtr,
) -> libc::c_int {
    let mut current_block: u64;
    let mut res: libc::c_int = 0;
    let mut olderrs: libc::c_int = (*pctxt).nberrors;
    let mut name: *const xmlChar = (*typeDecl).name;
    if !((*typeDecl).facets).is_null() {
        let mut facet: xmlSchemaFacetPtr = (*typeDecl).facets;
        if ((*pctxt).vctxt).is_null() {
            if xmlSchemaCreateVCtxtOnPCtxt(pctxt) == -(1 as libc::c_int) {
                return -(1 as libc::c_int);
            }
        }
        let ref mut fresh398 = (*(*pctxt).vctxt).schema;
        *fresh398 = (*pctxt).schema;
        loop {
            if facet.is_null() {
                current_block = 7746791466490516765;
                break;
            }
            res = xmlSchemaCheckFacet(facet, typeDecl, pctxt, name);
            if res == -(1 as libc::c_int) {
                current_block = 966742325134978464;
                break;
            }
            facet = (*facet).next;
        }
        match current_block {
            966742325134978464 => return -(1 as libc::c_int),
            _ => {
                let ref mut fresh399 = (*(*pctxt).vctxt).schema;
                *fresh399 = 0 as xmlSchemaPtr;
            }
        }
    }
    if olderrs != (*pctxt).nberrors {
        return (*pctxt).err;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaGetCircModelGrDefRef(
    mut groupDef: xmlSchemaModelGroupDefPtr,
    mut particle: xmlSchemaTreeItemPtr,
) -> xmlSchemaTreeItemPtr {
    let mut circ: xmlSchemaTreeItemPtr = 0 as xmlSchemaTreeItemPtr;
    let mut term: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
    let mut gdef: xmlSchemaModelGroupDefPtr = 0 as *mut xmlSchemaModelGroupDef;
    let mut current_block_13: u64;
    while !particle.is_null() {
        term = (*particle).children;
        if !term.is_null() {
            match (*term).type_0 as libc::c_uint {
                17 => {
                    current_block_13 = 17757133326439237465;
                    match current_block_13 {
                        7522209452724882128 => {
                            circ = xmlSchemaGetCircModelGrDefRef(
                                groupDef,
                                (*term).children,
                            );
                            if !circ.is_null() {
                                return circ;
                            }
                        }
                        _ => {
                            gdef = term as xmlSchemaModelGroupDefPtr;
                            if gdef == groupDef {
                                return particle;
                            }
                            if !((*gdef).flags & (1 as libc::c_int) << 0 as libc::c_int
                                != 0)
                            {
                                if !((*gdef).children).is_null() {
                                    (*gdef).flags |= (1 as libc::c_int) << 0 as libc::c_int;
                                    circ = xmlSchemaGetCircModelGrDefRef(
                                        groupDef,
                                        (*(*gdef).children).children,
                                    );
                                    (*gdef).flags ^= (1 as libc::c_int) << 0 as libc::c_int;
                                    if !circ.is_null() {
                                        return circ;
                                    }
                                }
                            }
                        }
                    }
                }
                6 | 7 | 8 => {
                    current_block_13 = 7522209452724882128;
                    match current_block_13 {
                        7522209452724882128 => {
                            circ = xmlSchemaGetCircModelGrDefRef(
                                groupDef,
                                (*term).children,
                            );
                            if !circ.is_null() {
                                return circ;
                            }
                        }
                        _ => {
                            gdef = term as xmlSchemaModelGroupDefPtr;
                            if gdef == groupDef {
                                return particle;
                            }
                            if !((*gdef).flags & (1 as libc::c_int) << 0 as libc::c_int
                                != 0)
                            {
                                if !((*gdef).children).is_null() {
                                    (*gdef).flags |= (1 as libc::c_int) << 0 as libc::c_int;
                                    circ = xmlSchemaGetCircModelGrDefRef(
                                        groupDef,
                                        (*(*gdef).children).children,
                                    );
                                    (*gdef).flags ^= (1 as libc::c_int) << 0 as libc::c_int;
                                    if !circ.is_null() {
                                        return circ;
                                    }
                                }
                            }
                        }
                    }
                }
                _ => {}
            }
        }
        particle = (*particle).next;
    }
    return 0 as xmlSchemaTreeItemPtr;
}
unsafe extern "C" fn xmlSchemaCheckGroupDefCircular(
    mut item: xmlSchemaModelGroupDefPtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) {
    if item.is_null()
        || (*item).type_0 as libc::c_uint
            != XML_SCHEMA_TYPE_GROUP as libc::c_int as libc::c_uint
        || ((*item).children).is_null()
    {
        return;
    }
    let mut circ: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
    circ = xmlSchemaGetCircModelGrDefRef(item, (*(*item).children).children);
    if !circ.is_null() {
        let mut str: *mut xmlChar = 0 as *mut xmlChar;
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_MG_PROPS_CORRECT_2,
            0 as xmlSchemaBasicItemPtr,
            xmlSchemaGetComponentNode(circ as xmlSchemaBasicItemPtr),
            b"Circular reference to the model group definition '%s' defined\0"
                as *const u8 as *const libc::c_char,
            xmlSchemaFormatQName(&mut str, (*item).targetNamespace, (*item).name),
        );
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
        let ref mut fresh400 = (*circ).children;
        *fresh400 = 0 as xmlSchemaTreeItemPtr;
    }
}
unsafe extern "C" fn xmlSchemaModelGroupToModelGroupDefFixup(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut mg: xmlSchemaModelGroupPtr,
) {
    let mut particle: xmlSchemaParticlePtr = (*mg).children as xmlSchemaParticlePtr;
    while !particle.is_null() {
        if ((*particle).children).is_null()
            || (*(*particle).children).type_0 as libc::c_uint
                != XML_SCHEMA_TYPE_GROUP as libc::c_int as libc::c_uint
        {
            particle = (*particle).next as xmlSchemaParticlePtr;
        } else if ((*((*particle).children as xmlSchemaModelGroupPtr)).children)
                .is_null()
            {
            let ref mut fresh401 = (*particle).children;
            *fresh401 = 0 as xmlSchemaTreeItemPtr;
            particle = (*particle).next as xmlSchemaParticlePtr;
        } else {
            let ref mut fresh402 = (*particle).children;
            *fresh402 = (*((*particle).children as xmlSchemaModelGroupPtr)).children;
            particle = (*particle).next as xmlSchemaParticlePtr;
        }
    }
}
unsafe extern "C" fn xmlSchemaCheckAttrGroupCircularRecur(
    mut ctxtGr: xmlSchemaAttributeGroupPtr,
    mut list: xmlSchemaItemListPtr,
) -> xmlSchemaQNameRefPtr {
    let mut gr: xmlSchemaAttributeGroupPtr = 0 as *mut xmlSchemaAttributeGroup;
    let mut ref_0: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    let mut circ: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (*list).nbItems {
        ref_0 = *((*list).items).offset(i as isize) as xmlSchemaQNameRefPtr;
        if (*ref_0).type_0 as libc::c_uint
            == XML_SCHEMA_EXTRA_QNAMEREF as libc::c_int as libc::c_uint
            && (*ref_0).itemType as libc::c_uint
                == XML_SCHEMA_TYPE_ATTRIBUTEGROUP as libc::c_int as libc::c_uint
            && !((*ref_0).item).is_null()
        {
            gr = (*ref_0).item as xmlSchemaAttributeGroupPtr;
            if gr == ctxtGr {
                return ref_0;
            }
            if !((*gr).flags & (1 as libc::c_int) << 2 as libc::c_int != 0) {
                if !((*gr).attrUses).is_null()
                    && (*gr).flags & (1 as libc::c_int) << 4 as libc::c_int != 0
                {
                    (*gr).flags |= (1 as libc::c_int) << 2 as libc::c_int;
                    circ = xmlSchemaCheckAttrGroupCircularRecur(
                        ctxtGr,
                        (*gr).attrUses as xmlSchemaItemListPtr,
                    );
                    (*gr).flags ^= (1 as libc::c_int) << 2 as libc::c_int;
                    if !circ.is_null() {
                        return circ;
                    }
                }
            }
        }
        i += 1;
    }
    return 0 as xmlSchemaQNameRefPtr;
}
unsafe extern "C" fn xmlSchemaCheckAttrGroupCircular(
    mut attrGr: xmlSchemaAttributeGroupPtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) -> libc::c_int {
    if ((*attrGr).attrUses).is_null() {
        return 0 as libc::c_int
    } else {
        if (*attrGr).flags & (1 as libc::c_int) << 4 as libc::c_int == 0 as libc::c_int {
            return 0 as libc::c_int
        } else {
            let mut circ: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
            circ = xmlSchemaCheckAttrGroupCircularRecur(
                attrGr,
                (*attrGr).attrUses as xmlSchemaItemListPtr,
            );
            if !circ.is_null() {
                let mut str: *mut xmlChar = 0 as *mut xmlChar;
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3,
                    0 as xmlSchemaBasicItemPtr,
                    xmlSchemaGetComponentNode(circ as xmlSchemaBasicItemPtr),
                    b"Circular reference to the attribute group '%s' defined\0"
                        as *const u8 as *const libc::c_char,
                    xmlSchemaGetComponentQName(&mut str, attrGr as *mut libc::c_void),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                let ref mut fresh403 = (*circ).item;
                *fresh403 = 0 as xmlSchemaBasicItemPtr;
                return (*ctxt).err;
            }
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaExpandAttributeGroupRefs(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut item: xmlSchemaBasicItemPtr,
    mut completeWild: *mut xmlSchemaWildcardPtr,
    mut list: xmlSchemaItemListPtr,
    mut prohibs: xmlSchemaItemListPtr,
) -> libc::c_int {
    let mut gr: xmlSchemaAttributeGroupPtr = 0 as *mut xmlSchemaAttributeGroup;
    let mut use_0: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
    let mut sublist: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut created: libc::c_int = if (*completeWild).is_null() {
        0 as libc::c_int
    } else {
        1 as libc::c_int
    };
    if !prohibs.is_null() {
        (*prohibs).nbItems = 0 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < (*list).nbItems {
        use_0 = *((*list).items).offset(i as isize) as xmlSchemaAttributeUsePtr;
        if (*use_0).type_0 as libc::c_uint
            == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB as libc::c_int as libc::c_uint
        {
            if prohibs.is_null() {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaExpandAttributeGroupRefs\0" as *const u8
                        as *const libc::c_char,
                    b"unexpected attr prohibition found\0" as *const u8
                        as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            if xmlSchemaItemListRemove(list, i) == -(1 as libc::c_int) {
                return -(1 as libc::c_int);
            }
            i -= 1;
            xmlSchemaItemListAddSize(
                prohibs,
                2 as libc::c_int,
                use_0 as *mut libc::c_void,
            );
        } else if (*use_0).type_0 as libc::c_uint
                == XML_SCHEMA_EXTRA_QNAMEREF as libc::c_int as libc::c_uint
                && (*(use_0 as xmlSchemaQNameRefPtr)).itemType as libc::c_uint
                    == XML_SCHEMA_TYPE_ATTRIBUTEGROUP as libc::c_int as libc::c_uint
            {
            if ((*(use_0 as xmlSchemaQNameRefPtr)).item).is_null() {
                return -(1 as libc::c_int);
            }
            gr = (*(use_0 as xmlSchemaQNameRefPtr)).item as xmlSchemaAttributeGroupPtr;
            if (*gr).flags & (1 as libc::c_int) << 0 as libc::c_int == 0 as libc::c_int {
                if xmlSchemaAttributeGroupExpandRefs(pctxt, gr) == -(1 as libc::c_int) {
                    return -(1 as libc::c_int);
                }
            }
            if !((*gr).attributeWildcard).is_null() {
                if (*completeWild).is_null() {
                    *completeWild = (*gr).attributeWildcard;
                } else {
                    if created == 0 {
                        let mut tmpWild: xmlSchemaWildcardPtr = 0
                            as *mut xmlSchemaWildcard;
                        tmpWild = xmlSchemaAddWildcard(
                            pctxt,
                            (*pctxt).schema,
                            XML_SCHEMA_TYPE_ANY_ATTRIBUTE,
                            xmlSchemaGetComponentNode(item),
                        );
                        if tmpWild.is_null() {
                            return -(1 as libc::c_int);
                        }
                        if xmlSchemaCloneWildcardNsConstraints(
                            pctxt,
                            tmpWild,
                            *completeWild,
                        ) == -(1 as libc::c_int)
                        {
                            return -(1 as libc::c_int);
                        }
                        (*tmpWild).processContents = (**completeWild).processContents;
                        *completeWild = tmpWild;
                        created = 1 as libc::c_int;
                    }
                    if xmlSchemaIntersectWildcards(
                        pctxt,
                        *completeWild,
                        (*gr).attributeWildcard,
                    ) == -(1 as libc::c_int)
                    {
                        return -(1 as libc::c_int);
                    }
                }
            }
            sublist = (*gr).attrUses as xmlSchemaItemListPtr;
            if sublist.is_null() || (*sublist).nbItems == 0 as libc::c_int {
                if xmlSchemaItemListRemove(list, i) == -(1 as libc::c_int) {
                    return -(1 as libc::c_int);
                }
                i -= 1;
            } else {
                let ref mut fresh404 = *((*list).items).offset(i as isize);
                *fresh404 = *((*sublist).items).offset(0 as libc::c_int as isize);
                if (*sublist).nbItems != 1 as libc::c_int {
                    j = 1 as libc::c_int;
                    while j < (*sublist).nbItems {
                        i += 1;
                        if xmlSchemaItemListInsert(
                            list,
                            *((*sublist).items).offset(j as isize),
                            i,
                        ) == -(1 as libc::c_int)
                        {
                            return -(1 as libc::c_int);
                        }
                        j += 1;
                    }
                }
            }
        }
        i += 1;
    }
    if !prohibs.is_null() && (*prohibs).nbItems != 0 as libc::c_int
        && (*list).nbItems != 0 as libc::c_int
    {
        let mut prohib: xmlSchemaAttributeUseProhibPtr = 0
            as *mut xmlSchemaAttributeUseProhib;
        i = (*prohibs).nbItems - 1 as libc::c_int;
        while i >= 0 as libc::c_int {
            prohib = *((*prohibs).items).offset(i as isize)
                as xmlSchemaAttributeUseProhibPtr;
            j = 0 as libc::c_int;
            while j < (*list).nbItems {
                use_0 = *((*list).items).offset(j as isize) as xmlSchemaAttributeUsePtr;
                if (*prohib).name == (*(*use_0).attrDecl).name
                    && (*prohib).targetNamespace == (*(*use_0).attrDecl).targetNamespace
                {
                    let mut str: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaCustomWarning(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
                        (*prohib).node,
                        0 as xmlSchemaTypePtr,
                        b"Skipping pointless attribute use prohibition '%s', since a corresponding attribute use exists already in the type definition\0"
                            as *const u8 as *const libc::c_char,
                        xmlSchemaFormatQName(
                            &mut str,
                            (*prohib).targetNamespace,
                            (*prohib).name,
                        ),
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                    if !str.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str as *mut libc::c_void);
                        str = 0 as *mut xmlChar;
                    }
                    if xmlSchemaItemListRemove(prohibs, i) == -(1 as libc::c_int) {
                        return -(1 as libc::c_int);
                    }
                    break;
                } else {
                    j += 1;
                }
            }
            i -= 1;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaAttributeGroupExpandRefs(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut attrGr: xmlSchemaAttributeGroupPtr,
) -> libc::c_int {
    if ((*attrGr).attrUses).is_null()
        || (*attrGr).flags & (1 as libc::c_int) << 0 as libc::c_int != 0
    {
        return 0 as libc::c_int;
    }
    (*attrGr).flags |= (1 as libc::c_int) << 0 as libc::c_int;
    if xmlSchemaExpandAttributeGroupRefs(
        pctxt,
        attrGr as xmlSchemaBasicItemPtr,
        &mut (*attrGr).attributeWildcard,
        (*attrGr).attrUses as xmlSchemaItemListPtr,
        0 as xmlSchemaItemListPtr,
    ) == -(1 as libc::c_int)
    {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaCheckAGPropsCorrect(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut attrGr: xmlSchemaAttributeGroupPtr,
) -> libc::c_int {
    if !((*attrGr).attrUses).is_null()
        && (*((*attrGr).attrUses as xmlSchemaItemListPtr)).nbItems > 1 as libc::c_int
    {
        let mut uses: xmlSchemaItemListPtr = (*attrGr).attrUses as xmlSchemaItemListPtr;
        let mut use_0: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
        let mut tmp: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
        let mut i: libc::c_int = 0;
        let mut j: libc::c_int = 0;
        let mut hasId: libc::c_int = 0 as libc::c_int;
        i = (*uses).nbItems - 1 as libc::c_int;
        while i >= 0 as libc::c_int {
            let mut current_block_27: u64;
            use_0 = *((*uses).items).offset(i as isize) as xmlSchemaAttributeUsePtr;
            if i > 0 as libc::c_int {
                j = i - 1 as libc::c_int;
                loop {
                    if !(j >= 0 as libc::c_int) {
                        current_block_27 = 12124785117276362961;
                        break;
                    }
                    tmp = *((*uses).items).offset(j as isize)
                        as xmlSchemaAttributeUsePtr;
                    if (*(*use_0).attrDecl).name == (*(*tmp).attrDecl).name
                        && (*(*use_0).attrDecl).targetNamespace
                            == (*(*tmp).attrDecl).targetNamespace
                    {
                        let mut str: *mut xmlChar = 0 as *mut xmlChar;
                        xmlSchemaCustomErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            XML_SCHEMAP_AG_PROPS_CORRECT,
                            (*attrGr).node,
                            attrGr as xmlSchemaBasicItemPtr,
                            b"Duplicate %s\0" as *const u8 as *const libc::c_char,
                            xmlSchemaGetComponentDesignation(
                                &mut str,
                                use_0 as *mut libc::c_void,
                            ),
                            0 as *const xmlChar,
                        );
                        if !str.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(str as *mut libc::c_void);
                            str = 0 as *mut xmlChar;
                        }
                        if xmlSchemaItemListRemove(uses, i) == -(1 as libc::c_int) {
                            return -(1 as libc::c_int);
                        }
                        current_block_27 = 7245201122033322888;
                        break;
                    } else {
                        j -= 1;
                    }
                }
            } else {
                current_block_27 = 12124785117276362961;
            }
            match current_block_27 {
                12124785117276362961 => {
                    if !((*(*use_0).attrDecl).subtypes).is_null() {
                        if xmlSchemaIsDerivedFromBuiltInType(
                            (*(*use_0).attrDecl).subtypes,
                            XML_SCHEMAS_ID as libc::c_int,
                        ) != 0
                        {
                            if hasId != 0 {
                                let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                                xmlSchemaCustomErr(
                                    pctxt as xmlSchemaAbstractCtxtPtr,
                                    XML_SCHEMAP_AG_PROPS_CORRECT,
                                    (*attrGr).node,
                                    attrGr as xmlSchemaBasicItemPtr,
                                    b"There must not exist more than one attribute declaration of type 'xs:ID' (or derived from 'xs:ID'). The %s violates this constraint\0"
                                        as *const u8 as *const libc::c_char,
                                    xmlSchemaGetComponentDesignation(
                                        &mut str_0,
                                        use_0 as *mut libc::c_void,
                                    ),
                                    0 as *const xmlChar,
                                );
                                if !str_0.is_null() {
                                    xmlFree
                                        .expect(
                                            "non-null function pointer",
                                        )(str_0 as *mut libc::c_void);
                                    str_0 = 0 as *mut xmlChar;
                                }
                                if xmlSchemaItemListRemove(uses, i) == -(1 as libc::c_int) {
                                    return -(1 as libc::c_int);
                                }
                            }
                            hasId = 1 as libc::c_int;
                        }
                    }
                }
                _ => {}
            }
            i -= 1;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaResolveAttrGroupReferences(
    mut ref_0: xmlSchemaQNameRefPtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) -> libc::c_int {
    let mut group: xmlSchemaAttributeGroupPtr = 0 as *mut xmlSchemaAttributeGroup;
    if !((*ref_0).item).is_null() {
        return 0 as libc::c_int;
    }
    group = xmlSchemaGetAttributeGroup(
        (*ctxt).schema,
        (*ref_0).name,
        (*ref_0).targetNamespace,
    );
    if group.is_null() {
        xmlSchemaPResCompAttrErr(
            ctxt,
            XML_SCHEMAP_SRC_RESOLVE,
            0 as xmlSchemaBasicItemPtr,
            (*ref_0).node,
            b"ref\0" as *const u8 as *const libc::c_char,
            (*ref_0).name,
            (*ref_0).targetNamespace,
            (*ref_0).itemType,
            0 as *const libc::c_char,
        );
        return (*ctxt).err;
    }
    let ref mut fresh405 = (*ref_0).item;
    *fresh405 = group as xmlSchemaBasicItemPtr;
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaCheckAttrPropsCorrect(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut attr: xmlSchemaAttributePtr,
) -> libc::c_int {
    if ((*attr).subtypes).is_null() {
        return 0 as libc::c_int;
    }
    if !((*attr).defValue).is_null() {
        let mut ret: libc::c_int = 0;
        if xmlSchemaIsDerivedFromBuiltInType(
            (*attr).subtypes,
            XML_SCHEMAS_ID as libc::c_int,
        ) != 0
        {
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_A_PROPS_CORRECT_3,
                0 as xmlNodePtr,
                attr as xmlSchemaBasicItemPtr,
                b"Value constraints are not allowed if the type definition is or is derived from xs:ID\0"
                    as *const u8 as *const libc::c_char,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return (*pctxt).err;
        }
        ret = xmlSchemaVCheckCVCSimpleType(
            pctxt as xmlSchemaAbstractCtxtPtr,
            (*attr).node,
            (*attr).subtypes,
            (*attr).defValue,
            &mut (*attr).defVal,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int,
        );
        if ret != 0 as libc::c_int {
            if ret < 0 as libc::c_int {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaCheckAttrPropsCorrect\0" as *const u8
                        as *const libc::c_char,
                    b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8
                        as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_A_PROPS_CORRECT_2,
                0 as xmlNodePtr,
                attr as xmlSchemaBasicItemPtr,
                b"The value of the value constraint is not valid\0" as *const u8
                    as *const libc::c_char,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return (*pctxt).err;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaCheckSubstGroupCircular(
    mut elemDecl: xmlSchemaElementPtr,
    mut ancestor: xmlSchemaElementPtr,
) -> xmlSchemaElementPtr {
    let mut ret: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
    if ((*ancestor).refDecl).is_null() {
        return 0 as xmlSchemaElementPtr;
    }
    if (*ancestor).refDecl == elemDecl {
        return ancestor;
    }
    if (*(*ancestor).refDecl).flags & (1 as libc::c_int) << 9 as libc::c_int != 0 {
        return 0 as xmlSchemaElementPtr;
    }
    (*(*ancestor).refDecl).flags |= (1 as libc::c_int) << 9 as libc::c_int;
    ret = xmlSchemaCheckSubstGroupCircular(elemDecl, (*ancestor).refDecl);
    (*(*ancestor).refDecl).flags ^= (1 as libc::c_int) << 9 as libc::c_int;
    return ret;
}
unsafe extern "C" fn xmlSchemaCheckElemPropsCorrect(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut elemDecl: xmlSchemaElementPtr,
) -> libc::c_int {
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut typeDef: xmlSchemaTypePtr = (*elemDecl).subtypes;
    if !((*elemDecl).refDecl).is_null() {
        let mut head: xmlSchemaElementPtr = (*elemDecl).refDecl;
        let mut circ: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
        xmlSchemaCheckElementDeclComponent(head, pctxt);
        if (*elemDecl).flags & (1 as libc::c_int) << 1 as libc::c_int == 0 as libc::c_int
        {
            xmlSchemaPCustomErr(
                pctxt,
                XML_SCHEMAP_E_PROPS_CORRECT_3,
                elemDecl as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"Only global element declarations can have a substitution group affiliation\0"
                    as *const u8 as *const libc::c_char,
                0 as *const xmlChar,
            );
            ret = XML_SCHEMAP_E_PROPS_CORRECT_3 as libc::c_int;
        }
        if head == elemDecl {
            circ = head;
        } else if !((*head).refDecl).is_null() {
            circ = xmlSchemaCheckSubstGroupCircular(head, head);
        } else {
            circ = 0 as xmlSchemaElementPtr;
        }
        if !circ.is_null() {
            let mut strA: *mut xmlChar = 0 as *mut xmlChar;
            let mut strB: *mut xmlChar = 0 as *mut xmlChar;
            xmlSchemaPCustomErrExt(
                pctxt,
                XML_SCHEMAP_E_PROPS_CORRECT_6,
                circ as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The element declaration '%s' defines a circular substitution group to element declaration '%s'\0"
                    as *const u8 as *const libc::c_char,
                xmlSchemaGetComponentQName(&mut strA, circ as *mut libc::c_void),
                xmlSchemaGetComponentQName(&mut strB, head as *mut libc::c_void),
                0 as *const xmlChar,
            );
            if !strA.is_null() {
                xmlFree.expect("non-null function pointer")(strA as *mut libc::c_void);
                strA = 0 as *mut xmlChar;
            }
            if !strB.is_null() {
                xmlFree.expect("non-null function pointer")(strB as *mut libc::c_void);
                strB = 0 as *mut xmlChar;
            }
            ret = XML_SCHEMAP_E_PROPS_CORRECT_6 as libc::c_int;
        }
        if typeDef != (*(*elemDecl).refDecl).subtypes {
            let mut set: libc::c_int = 0 as libc::c_int;
            if (*head).flags & (1 as libc::c_int) << 15 as libc::c_int != 0 {
                set |= (1 as libc::c_int) << 1 as libc::c_int;
            }
            if (*head).flags & (1 as libc::c_int) << 16 as libc::c_int != 0 {
                set |= (1 as libc::c_int) << 0 as libc::c_int;
            }
            if xmlSchemaCheckCOSDerivedOK(
                pctxt as xmlSchemaAbstractCtxtPtr,
                typeDef,
                (*head).subtypes,
                set,
            ) != 0 as libc::c_int
            {
                let mut strA_0: *mut xmlChar = 0 as *mut xmlChar;
                let mut strB_0: *mut xmlChar = 0 as *mut xmlChar;
                let mut strC: *mut xmlChar = 0 as *mut xmlChar;
                ret = XML_SCHEMAP_E_PROPS_CORRECT_4 as libc::c_int;
                xmlSchemaPCustomErrExt(
                    pctxt,
                    XML_SCHEMAP_E_PROPS_CORRECT_4,
                    elemDecl as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The type definition '%s' was either rejected by the substitution group affiliation '%s', or not validly derived from its type definition '%s'\0"
                        as *const u8 as *const libc::c_char,
                    xmlSchemaGetComponentQName(
                        &mut strA_0,
                        typeDef as *mut libc::c_void,
                    ),
                    xmlSchemaGetComponentQName(&mut strB_0, head as *mut libc::c_void),
                    xmlSchemaGetComponentQName(
                        &mut strC,
                        (*head).subtypes as *mut libc::c_void,
                    ),
                );
                if !strA_0.is_null() {
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(strA_0 as *mut libc::c_void);
                    strA_0 = 0 as *mut xmlChar;
                }
                if !strB_0.is_null() {
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(strB_0 as *mut libc::c_void);
                    strB_0 = 0 as *mut xmlChar;
                }
                if !strC.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(strC as *mut libc::c_void);
                    strC = 0 as *mut xmlChar;
                }
            }
        }
    }
    if !((*elemDecl).value).is_null()
        && (((*typeDef).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
            || (*typeDef).type_0 as libc::c_uint
                == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                && (*typeDef).builtInType != XML_SCHEMAS_ANYTYPE as libc::c_int)
            && xmlSchemaIsDerivedFromBuiltInType(typeDef, XML_SCHEMAS_ID as libc::c_int)
                != 0
            || ((*typeDef).type_0 as libc::c_uint
                == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
                || (*typeDef).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int)
                && ((*typeDef).contentType as libc::c_uint
                    == XML_SCHEMA_CONTENT_SIMPLE as libc::c_int as libc::c_uint
                    || (*typeDef).contentType as libc::c_uint
                        == XML_SCHEMA_CONTENT_BASIC as libc::c_int as libc::c_uint)
                && xmlSchemaIsDerivedFromBuiltInType(
                    (*typeDef).contentTypeDef,
                    XML_SCHEMAS_ID as libc::c_int,
                ) != 0)
    {
        ret = XML_SCHEMAP_E_PROPS_CORRECT_5 as libc::c_int;
        xmlSchemaPCustomErr(
            pctxt,
            XML_SCHEMAP_E_PROPS_CORRECT_5,
            elemDecl as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"The type definition (or type definition's content type) is or is derived from ID; value constraints are not allowed in conjunction with such a type definition\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
        );
    } else if !((*elemDecl).value).is_null() {
        let mut vcret: libc::c_int = 0;
        let mut node: xmlNodePtr = 0 as xmlNodePtr;
        if typeDef.is_null() {
            xmlSchemaPErr(
                pctxt,
                (*elemDecl).node,
                XML_SCHEMAP_INTERNAL as libc::c_int,
                b"Internal error: xmlSchemaCheckElemPropsCorrect, type is missing... skipping validation of the value constraint\0"
                    as *const u8 as *const libc::c_char,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return -(1 as libc::c_int);
        }
        if !((*elemDecl).node).is_null() {
            if (*elemDecl).flags & (1 as libc::c_int) << 3 as libc::c_int != 0 {
                node = xmlHasProp(
                    (*elemDecl).node as *const xmlNode,
                    b"fixed\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) as xmlNodePtr;
            } else {
                node = xmlHasProp(
                    (*elemDecl).node as *const xmlNode,
                    b"default\0" as *const u8 as *const libc::c_char as *mut xmlChar,
                ) as xmlNodePtr;
            }
        }
        vcret = xmlSchemaParseCheckCOSValidDefault(
            pctxt,
            node,
            typeDef,
            (*elemDecl).value,
            &mut (*elemDecl).defVal,
        );
        if vcret != 0 as libc::c_int {
            if vcret < 0 as libc::c_int {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaElemCheckValConstr\0" as *const u8 as *const libc::c_char,
                    b"failed to validate the value constraint of an element declaration\0"
                        as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            return vcret;
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaCheckElemSubstGroup(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut elemDecl: xmlSchemaElementPtr,
) {
    if ((*elemDecl).refDecl).is_null()
        || (*elemDecl).flags & (1 as libc::c_int) << 4 as libc::c_int != 0
    {
        return;
    }
    let mut head: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
    let mut headType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut set: libc::c_int = 0;
    let mut methSet: libc::c_int = 0;
    let mut current_block_28: u64;
    head = (*elemDecl).refDecl;
    while !head.is_null() {
        set = 0 as libc::c_int;
        methSet = 0 as libc::c_int;
        if !((*head).flags & (1 as libc::c_int) << 13 as libc::c_int != 0) {
            headType = (*head).subtypes;
            type_0 = (*elemDecl).subtypes;
            if headType == type_0 {
                current_block_28 = 12525254419223051704;
            } else {
                if (*head).flags & (1 as libc::c_int) << 12 as libc::c_int != 0 {
                    set |= (1 as libc::c_int) << 19 as libc::c_int;
                }
                if (*head).flags & (1 as libc::c_int) << 11 as libc::c_int != 0 {
                    set |= (1 as libc::c_int) << 18 as libc::c_int;
                }
                while !type_0.is_null() && type_0 != headType {
                    if (*type_0).flags & (1 as libc::c_int) << 1 as libc::c_int != 0
                        && methSet & (1 as libc::c_int) << 19 as libc::c_int
                            == 0 as libc::c_int
                    {
                        methSet |= (1 as libc::c_int) << 18 as libc::c_int;
                    }
                    if (*type_0).flags & (1 as libc::c_int) << 2 as libc::c_int != 0
                        && methSet & (1 as libc::c_int) << 19 as libc::c_int
                            == 0 as libc::c_int
                    {
                        methSet |= (1 as libc::c_int) << 19 as libc::c_int;
                    }
                    type_0 = (*type_0).baseType;
                }
                type_0 = (*(*elemDecl).subtypes).baseType;
                while !type_0.is_null() {
                    if !((*type_0).type_0 as libc::c_uint
                        == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
                        || (*type_0).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int)
                    {
                        break;
                    }
                    if (*type_0).flags & (1 as libc::c_int) << 18 as libc::c_int != 0
                        && set & (1 as libc::c_int) << 18 as libc::c_int
                            == 0 as libc::c_int
                    {
                        set |= (1 as libc::c_int) << 18 as libc::c_int;
                    }
                    if (*type_0).flags & (1 as libc::c_int) << 19 as libc::c_int != 0
                        && set & (1 as libc::c_int) << 19 as libc::c_int
                            == 0 as libc::c_int
                    {
                        set |= (1 as libc::c_int) << 19 as libc::c_int;
                    }
                    if type_0 == headType {
                        break;
                    }
                    type_0 = (*type_0).baseType;
                }
                if set != 0 as libc::c_int
                    && (set & (1 as libc::c_int) << 18 as libc::c_int != 0
                        && methSet & (1 as libc::c_int) << 18 as libc::c_int != 0
                        || set & (1 as libc::c_int) << 19 as libc::c_int != 0
                            && methSet & (1 as libc::c_int) << 19 as libc::c_int != 0)
                {
                    current_block_28 = 735147466149431745;
                } else {
                    current_block_28 = 12525254419223051704;
                }
            }
            match current_block_28 {
                735147466149431745 => {}
                _ => {
                    xmlSchemaAddElementSubstitutionMember(ctxt, head, elemDecl);
                    if (*head).flags & (1 as libc::c_int) << 17 as libc::c_int
                        == 0 as libc::c_int
                    {
                        (*head).flags |= (1 as libc::c_int) << 17 as libc::c_int;
                    }
                }
            }
        }
        head = (*head).refDecl;
    }
}
unsafe extern "C" fn xmlSchemaCheckElementDeclComponent(
    mut elemDecl: xmlSchemaElementPtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) {
    if elemDecl.is_null() {
        return;
    }
    if (*elemDecl).flags & (1 as libc::c_int) << 18 as libc::c_int != 0 {
        return;
    }
    (*elemDecl).flags |= (1 as libc::c_int) << 18 as libc::c_int;
    if xmlSchemaCheckElemPropsCorrect(ctxt, elemDecl) == 0 as libc::c_int {
        xmlSchemaCheckElemSubstGroup(ctxt, elemDecl);
    }
}
unsafe extern "C" fn xmlSchemaResolveModelGroupParticleReferences(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut mg: xmlSchemaModelGroupPtr,
) {
    let mut particle: xmlSchemaParticlePtr = (*mg).children as xmlSchemaParticlePtr;
    let mut ref_0: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    let mut refItem: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    while !particle.is_null() {
        if !(((*particle).children).is_null()
            || (*(*particle).children).type_0 as libc::c_uint
                != XML_SCHEMA_EXTRA_QNAMEREF as libc::c_int as libc::c_uint)
        {
            ref_0 = (*particle).children as xmlSchemaQNameRefPtr;
            let ref mut fresh406 = (*particle).children;
            *fresh406 = 0 as xmlSchemaTreeItemPtr;
            refItem = xmlSchemaGetNamedComponent(
                (*ctxt).schema,
                (*ref_0).itemType,
                (*ref_0).name,
                (*ref_0).targetNamespace,
            );
            if refItem.is_null() {
                xmlSchemaPResCompAttrErr(
                    ctxt,
                    XML_SCHEMAP_SRC_RESOLVE,
                    0 as xmlSchemaBasicItemPtr,
                    xmlSchemaGetComponentNode(particle as xmlSchemaBasicItemPtr),
                    b"ref\0" as *const u8 as *const libc::c_char,
                    (*ref_0).name,
                    (*ref_0).targetNamespace,
                    (*ref_0).itemType,
                    0 as *const libc::c_char,
                );
            } else if (*refItem).type_0 as libc::c_uint
                    == XML_SCHEMA_TYPE_GROUP as libc::c_int as libc::c_uint
                {
                if !((*(refItem as xmlSchemaModelGroupPtr)).children).is_null() {
                    if (*(*(refItem as xmlSchemaModelGroupPtr)).children).type_0
                        as libc::c_uint
                        == XML_SCHEMA_TYPE_ALL as libc::c_int as libc::c_uint
                    {
                        xmlSchemaCustomErr(
                            ctxt as xmlSchemaAbstractCtxtPtr,
                            XML_SCHEMAP_COS_ALL_LIMITED,
                            xmlSchemaGetComponentNode(particle as xmlSchemaBasicItemPtr),
                            0 as xmlSchemaBasicItemPtr,
                            b"A model group definition is referenced, but it contains an 'all' model group, which cannot be contained by model groups\0"
                                as *const u8 as *const libc::c_char,
                            0 as *const xmlChar,
                            0 as *const xmlChar,
                        );
                    } else {
                        let ref mut fresh407 = (*particle).children;
                        *fresh407 = refItem as xmlSchemaTreeItemPtr;
                    }
                }
            } else {
                let ref mut fresh408 = (*particle).children;
                *fresh408 = refItem as xmlSchemaTreeItemPtr;
            }
        }
        particle = (*particle).next as xmlSchemaParticlePtr;
    }
}
unsafe extern "C" fn xmlSchemaAreValuesEqual(
    mut x: xmlSchemaValPtr,
    mut y: xmlSchemaValPtr,
) -> libc::c_int {
    let mut tx: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ty: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ptx: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut pty: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ret: libc::c_int = 0;
    while !x.is_null() {
        tx = xmlSchemaGetBuiltInType(xmlSchemaGetValType(x));
        ty = xmlSchemaGetBuiltInType(xmlSchemaGetValType(y));
        ptx = xmlSchemaGetPrimitiveType(tx);
        pty = xmlSchemaGetPrimitiveType(ty);
        if ptx != pty {
            return 0 as libc::c_int;
        }
        if (*ptx).builtInType == XML_SCHEMAS_STRING as libc::c_int
            || (*ptx).type_0 as libc::c_uint
                == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                && (*ptx).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as libc::c_int
        {
            if xmlStrEqual(xmlSchemaValueGetAsString(x), xmlSchemaValueGetAsString(y))
                == 0
            {
                return 0 as libc::c_int;
            }
        } else {
            ret = xmlSchemaCompareValuesWhtsp(
                x,
                XML_SCHEMA_WHITESPACE_PRESERVE,
                y,
                XML_SCHEMA_WHITESPACE_PRESERVE,
            );
            if ret == -(2 as libc::c_int) {
                return -(1 as libc::c_int);
            }
            if ret != 0 as libc::c_int {
                return 0 as libc::c_int;
            }
        }
        x = xmlSchemaValueGetNext(x);
        if !x.is_null() {
            y = xmlSchemaValueGetNext(y);
            if y.is_null() {
                return 0 as libc::c_int;
            }
        } else if !(xmlSchemaValueGetNext(y)).is_null() {
            return 0 as libc::c_int
        } else {
            return 1 as libc::c_int
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaResolveAttrUseReferences(
    mut ause: xmlSchemaAttributeUsePtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) -> libc::c_int {
    if ctxt.is_null() || ause.is_null() {
        return -(1 as libc::c_int);
    }
    if ((*ause).attrDecl).is_null()
        || (*(*ause).attrDecl).type_0 as libc::c_uint
            != XML_SCHEMA_EXTRA_QNAMEREF as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int;
    }
    let mut ref_0: xmlSchemaQNameRefPtr = (*ause).attrDecl as xmlSchemaQNameRefPtr;
    let ref mut fresh409 = (*ause).attrDecl;
    *fresh409 = xmlSchemaGetAttributeDecl(
        (*ctxt).schema,
        (*ref_0).name,
        (*ref_0).targetNamespace,
    );
    if ((*ause).attrDecl).is_null() {
        xmlSchemaPResCompAttrErr(
            ctxt,
            XML_SCHEMAP_SRC_RESOLVE,
            ause as xmlSchemaBasicItemPtr,
            (*ause).node,
            b"ref\0" as *const u8 as *const libc::c_char,
            (*ref_0).name,
            (*ref_0).targetNamespace,
            XML_SCHEMA_TYPE_ATTRIBUTE,
            0 as *const libc::c_char,
        );
        return (*ctxt).err;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaCheckAttrUsePropsCorrect(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut use_0: xmlSchemaAttributeUsePtr,
) -> libc::c_int {
    if ctxt.is_null() || use_0.is_null() {
        return -(1 as libc::c_int);
    }
    if ((*use_0).defValue).is_null() || ((*use_0).attrDecl).is_null()
        || (*(*use_0).attrDecl).type_0 as libc::c_uint
            != XML_SCHEMA_TYPE_ATTRIBUTE as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int;
    }
    if !((*(*use_0).attrDecl).defValue).is_null()
        && (*(*use_0).attrDecl).flags & (1 as libc::c_int) << 9 as libc::c_int != 0
        && (*use_0).flags & (1 as libc::c_int) << 0 as libc::c_int == 0 as libc::c_int
    {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_AU_PROPS_CORRECT_2,
            use_0 as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"The attribute declaration has a 'fixed' value constraint , thus the attribute use must also have a 'fixed' value constraint\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
        );
        return (*ctxt).err;
    }
    if !((*use_0).defVal).is_null() && !((*(*use_0).attrDecl).subtypes).is_null() {
        let mut ret: libc::c_int = 0;
        if xmlSchemaIsDerivedFromBuiltInType(
            (*(*use_0).attrDecl).subtypes,
            XML_SCHEMAS_ID as libc::c_int,
        ) != 0
        {
            xmlSchemaCustomErr(
                ctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_AU_PROPS_CORRECT,
                0 as xmlNodePtr,
                use_0 as xmlSchemaBasicItemPtr,
                b"Value constraints are not allowed if the type definition is or is derived from xs:ID\0"
                    as *const u8 as *const libc::c_char,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return (*ctxt).err;
        }
        ret = xmlSchemaVCheckCVCSimpleType(
            ctxt as xmlSchemaAbstractCtxtPtr,
            (*use_0).node,
            (*(*use_0).attrDecl).subtypes,
            (*use_0).defValue,
            &mut (*use_0).defVal,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int,
        );
        if ret != 0 as libc::c_int {
            if ret < 0 as libc::c_int {
                xmlSchemaInternalErr(
                    ctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaCheckAttrUsePropsCorrect\0" as *const u8
                        as *const libc::c_char,
                    b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8
                        as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            xmlSchemaCustomErr(
                ctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_AU_PROPS_CORRECT,
                0 as xmlNodePtr,
                use_0 as xmlSchemaBasicItemPtr,
                b"The value of the value constraint is not valid\0" as *const u8
                    as *const libc::c_char,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return (*ctxt).err;
        }
    }
    if !((*(*use_0).attrDecl).defVal).is_null()
        && (*(*use_0).attrDecl).flags & (1 as libc::c_int) << 0 as libc::c_int
            == 0 as libc::c_int
    {
        if xmlSchemaAreValuesEqual((*use_0).defVal, (*(*use_0).attrDecl).defVal) == 0 {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_AU_PROPS_CORRECT_2,
                use_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The 'fixed' value constraint of the attribute use must match the attribute declaration's value constraint '%s'\0"
                    as *const u8 as *const libc::c_char,
                (*(*use_0).attrDecl).defValue,
            );
        }
        return (*ctxt).err;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaResolveAttrTypeReferences(
    mut item: xmlSchemaAttributePtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) -> libc::c_int {
    if (*item).flags & (1 as libc::c_int) << 8 as libc::c_int != 0 {
        return 0 as libc::c_int;
    }
    (*item).flags |= (1 as libc::c_int) << 8 as libc::c_int;
    if !((*item).subtypes).is_null() {
        return 0 as libc::c_int;
    }
    if !((*item).typeName).is_null() {
        let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        type_0 = xmlSchemaGetType((*ctxt).schema, (*item).typeName, (*item).typeNs);
        if type_0.is_null()
            || !((*type_0).type_0 as libc::c_uint
                == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
                || (*type_0).type_0 as libc::c_uint
                    == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                    && (*type_0).builtInType != XML_SCHEMAS_ANYTYPE as libc::c_int)
        {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                item as xmlSchemaBasicItemPtr,
                (*item).node,
                b"type\0" as *const u8 as *const libc::c_char,
                (*item).typeName,
                (*item).typeNs,
                XML_SCHEMA_TYPE_SIMPLE,
                0 as *const libc::c_char,
            );
            return (*ctxt).err;
        } else {
            let ref mut fresh410 = (*item).subtypes;
            *fresh410 = type_0;
        }
    } else {
        let ref mut fresh411 = (*item).subtypes;
        *fresh411 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaResolveIDCKeyReferences(
    mut idc: xmlSchemaIDCPtr,
    mut pctxt: xmlSchemaParserCtxtPtr,
) -> libc::c_int {
    if (*idc).type_0 as libc::c_uint
        != XML_SCHEMA_TYPE_IDC_KEYREF as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int;
    }
    if !((*(*idc).ref_0).name).is_null() {
        let ref mut fresh412 = (*(*idc).ref_0).item;
        *fresh412 = xmlSchemaGetIDC(
            (*pctxt).schema,
            (*(*idc).ref_0).name,
            (*(*idc).ref_0).targetNamespace,
        ) as xmlSchemaBasicItemPtr;
        if ((*(*idc).ref_0).item).is_null() {
            xmlSchemaPResCompAttrErr(
                pctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                idc as xmlSchemaBasicItemPtr,
                (*idc).node,
                b"refer\0" as *const u8 as *const libc::c_char,
                (*(*idc).ref_0).name,
                (*(*idc).ref_0).targetNamespace,
                XML_SCHEMA_TYPE_IDC_KEY,
                0 as *const libc::c_char,
            );
            return (*pctxt).err;
        } else {
            if (*(*(*idc).ref_0).item).type_0 as libc::c_uint
                == XML_SCHEMA_TYPE_IDC_KEYREF as libc::c_int as libc::c_uint
            {
                xmlSchemaCustomErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    XML_SCHEMAP_C_PROPS_CORRECT,
                    0 as xmlNodePtr,
                    idc as xmlSchemaBasicItemPtr,
                    b"The keyref references a keyref\0" as *const u8
                        as *const libc::c_char,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
                let ref mut fresh413 = (*(*idc).ref_0).item;
                *fresh413 = 0 as xmlSchemaBasicItemPtr;
                return (*pctxt).err;
            } else {
                if (*idc).nbFields
                    != (*((*(*idc).ref_0).item as xmlSchemaIDCPtr)).nbFields
                {
                    let mut str: *mut xmlChar = 0 as *mut xmlChar;
                    let mut refer: xmlSchemaIDCPtr = 0 as *mut xmlSchemaIDC;
                    refer = (*(*idc).ref_0).item as xmlSchemaIDCPtr;
                    xmlSchemaCustomErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_C_PROPS_CORRECT,
                        0 as xmlNodePtr,
                        idc as xmlSchemaBasicItemPtr,
                        b"The cardinality of the keyref differs from the cardinality of the referenced key/unique '%s'\0"
                            as *const u8 as *const libc::c_char,
                        xmlSchemaFormatQName(
                            &mut str,
                            (*refer).targetNamespace,
                            (*refer).name,
                        ),
                        0 as *const xmlChar,
                    );
                    if !str.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str as *mut libc::c_void);
                        str = 0 as *mut xmlChar;
                    }
                    return (*pctxt).err;
                }
            }
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaResolveAttrUseProhibReferences(
    mut prohib: xmlSchemaAttributeUseProhibPtr,
    mut pctxt: xmlSchemaParserCtxtPtr,
) -> libc::c_int {
    if (xmlSchemaGetAttributeDecl(
        (*pctxt).schema,
        (*prohib).name,
        (*prohib).targetNamespace,
    ))
        .is_null()
    {
        xmlSchemaPResCompAttrErr(
            pctxt,
            XML_SCHEMAP_SRC_RESOLVE,
            0 as xmlSchemaBasicItemPtr,
            (*prohib).node,
            b"ref\0" as *const u8 as *const libc::c_char,
            (*prohib).name,
            (*prohib).targetNamespace,
            XML_SCHEMA_TYPE_ATTRIBUTE,
            0 as *const libc::c_char,
        );
        return XML_SCHEMAP_SRC_RESOLVE as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaCheckSRCRedefineFirst(
    mut pctxt: xmlSchemaParserCtxtPtr,
) -> libc::c_int {
    let mut err: libc::c_int = 0 as libc::c_int;
    let mut redef: xmlSchemaRedefPtr = (*(*pctxt).constructor).redefs;
    let mut prev: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    let mut item: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    let mut wasRedefined: libc::c_int = 0;
    if redef.is_null() {
        return 0 as libc::c_int;
    }
    loop {
        item = (*redef).item;
        prev = xmlSchemaFindRedefCompInGraph(
            (*redef).targetBucket,
            (*item).type_0,
            (*redef).refName,
            (*redef).refTargetNs,
        );
        if prev.is_null() {
            let mut str: *mut xmlChar = 0 as *mut xmlChar;
            let mut node: xmlNodePtr = 0 as *mut xmlNode;
            if !((*redef).reference).is_null() {
                node = xmlSchemaGetComponentNode((*redef).reference);
            } else {
                node = xmlSchemaGetComponentNode(item);
            }
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_SRC_REDEFINE,
                node,
                0 as xmlSchemaBasicItemPtr,
                b"The %s '%s' to be redefined could not be found in the redefined schema\0"
                    as *const u8 as *const libc::c_char,
                xmlSchemaGetComponentTypeStr(item),
                xmlSchemaFormatQName(&mut str, (*redef).refTargetNs, (*redef).refName),
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
            err = (*pctxt).err;
            redef = (*redef).next;
        } else {
            wasRedefined = 0 as libc::c_int;
            match (*item).type_0 as libc::c_uint {
                5 | 4 => {
                    if (*(prev as xmlSchemaTypePtr)).flags
                        & (1 as libc::c_int) << 30 as libc::c_int != 0
                    {
                        wasRedefined = 1 as libc::c_int;
                    } else {
                        (*(prev as xmlSchemaTypePtr)).flags
                            |= (1 as libc::c_int) << 30 as libc::c_int;
                        let ref mut fresh414 = (*(item as xmlSchemaTypePtr)).baseType;
                        *fresh414 = prev as xmlSchemaTypePtr;
                    }
                }
                17 => {
                    if (*(prev as xmlSchemaModelGroupDefPtr)).flags
                        & (1 as libc::c_int) << 1 as libc::c_int != 0
                    {
                        wasRedefined = 1 as libc::c_int;
                    } else {
                        (*(prev as xmlSchemaModelGroupDefPtr)).flags
                            |= (1 as libc::c_int) << 1 as libc::c_int;
                        if !((*redef).reference).is_null() {
                            let ref mut fresh415 = (*((*redef).reference
                                as xmlSchemaParticlePtr))
                                .children;
                            *fresh415 = prev as xmlSchemaTreeItemPtr;
                        }
                        let ref mut fresh416 = (*redef).target;
                        *fresh416 = prev;
                    }
                }
                16 => {
                    if (*(prev as xmlSchemaAttributeGroupPtr)).flags
                        & (1 as libc::c_int) << 3 as libc::c_int != 0
                    {
                        wasRedefined = 1 as libc::c_int;
                    } else {
                        (*(prev as xmlSchemaAttributeGroupPtr)).flags
                            |= (1 as libc::c_int) << 3 as libc::c_int;
                        if !((*redef).reference).is_null() {
                            let ref mut fresh417 = (*((*redef).reference
                                as xmlSchemaQNameRefPtr))
                                .item;
                            *fresh417 = prev;
                            let ref mut fresh418 = (*redef).target;
                            *fresh418 = 0 as xmlSchemaBasicItemPtr;
                        } else {
                            let ref mut fresh419 = (*redef).target;
                            *fresh419 = prev;
                        }
                    }
                }
                _ => {
                    xmlSchemaInternalErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaResolveRedefReferences\0" as *const u8
                            as *const libc::c_char,
                        b"Unexpected redefined component type\0" as *const u8
                            as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
            }
            if wasRedefined != 0 {
                let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                let mut node_0: xmlNodePtr = 0 as *mut xmlNode;
                if !((*redef).reference).is_null() {
                    node_0 = xmlSchemaGetComponentNode((*redef).reference);
                } else {
                    node_0 = xmlSchemaGetComponentNode((*redef).item);
                }
                xmlSchemaCustomErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    XML_SCHEMAP_SRC_REDEFINE,
                    node_0,
                    0 as xmlSchemaBasicItemPtr,
                    b"The referenced %s was already redefined. Multiple redefinition of the same component is not supported\0"
                        as *const u8 as *const libc::c_char,
                    xmlSchemaGetComponentDesignation(
                        &mut str_0,
                        prev as *mut libc::c_void,
                    ),
                    0 as *const xmlChar,
                );
                if !str_0.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str_0 as *mut libc::c_void);
                    str_0 = 0 as *mut xmlChar;
                }
                err = (*pctxt).err;
                redef = (*redef).next;
            } else {
                redef = (*redef).next;
            }
        }
        if redef.is_null() {
            break;
        }
    }
    return err;
}
unsafe extern "C" fn xmlSchemaCheckSRCRedefineSecond(
    mut pctxt: xmlSchemaParserCtxtPtr,
) -> libc::c_int {
    let mut err: libc::c_int = 0 as libc::c_int;
    let mut redef: xmlSchemaRedefPtr = (*(*pctxt).constructor).redefs;
    let mut item: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    if redef.is_null() {
        return 0 as libc::c_int;
    }
    loop {
        if ((*redef).target).is_null() {
            redef = (*redef).next;
        } else {
            item = (*redef).item;
            match (*item).type_0 as libc::c_uint {
                4 | 5 => {
                    let ref mut fresh420 = (*((*redef).target as xmlSchemaTypePtr)).name;
                    *fresh420 = 0 as *const xmlChar;
                }
                16 => {
                    err = xmlSchemaCheckDerivationOKRestriction2to4(
                        pctxt,
                        1 as libc::c_int,
                        item,
                        (*redef).target,
                        (*(item as xmlSchemaAttributeGroupPtr)).attrUses
                            as xmlSchemaItemListPtr,
                        (*((*redef).target as xmlSchemaAttributeGroupPtr)).attrUses
                            as xmlSchemaItemListPtr,
                        (*(item as xmlSchemaAttributeGroupPtr)).attributeWildcard,
                        (*((*redef).target as xmlSchemaAttributeGroupPtr))
                            .attributeWildcard,
                    );
                    if err == -(1 as libc::c_int) {
                        return -(1 as libc::c_int);
                    }
                }
                17 | _ => {}
            }
            redef = (*redef).next;
        }
        if redef.is_null() {
            break;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaAddComponents(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut bucket: xmlSchemaBucketPtr,
) -> libc::c_int {
    let mut item: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    let mut err: libc::c_int = 0;
    let mut table: *mut xmlHashTablePtr = 0 as *mut xmlHashTablePtr;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut i: libc::c_int = 0;
    if bucket.is_null() {
        return -(1 as libc::c_int);
    }
    if (*bucket).flags & (1 as libc::c_int) << 1 as libc::c_int != 0 {
        return 0 as libc::c_int;
    }
    (*bucket).flags |= (1 as libc::c_int) << 1 as libc::c_int;
    let mut current_block_61: u64;
    i = 0 as libc::c_int;
    while i < (*(*bucket).globals).nbItems {
        item = *((*(*bucket).globals).items).offset(i as isize) as xmlSchemaBasicItemPtr;
        table = 0 as *mut xmlHashTablePtr;
        match (*item).type_0 as libc::c_uint {
            5 | 4 => {
                if (*(item as xmlSchemaTypePtr)).flags
                    & (1 as libc::c_int) << 30 as libc::c_int != 0
                {
                    current_block_61 = 6937071982253665452;
                } else {
                    name = (*(item as xmlSchemaTypePtr)).name;
                    if (*bucket).type_0 == 0 as libc::c_int
                        || (*bucket).type_0 == 1 as libc::c_int
                    {
                        table = &mut (*(*(bucket as xmlSchemaImportPtr)).schema)
                            .typeDecl;
                    } else {
                        table = &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport)
                            .schema)
                            .typeDecl;
                    }
                    current_block_61 = 2500484646272006982;
                }
            }
            14 => {
                name = (*(item as xmlSchemaElementPtr)).name;
                if (*bucket).type_0 == 0 as libc::c_int
                    || (*bucket).type_0 == 1 as libc::c_int
                {
                    table = &mut (*(*(bucket as xmlSchemaImportPtr)).schema).elemDecl;
                } else {
                    table = &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport)
                        .schema)
                        .elemDecl;
                }
                current_block_61 = 2500484646272006982;
            }
            15 => {
                name = (*(item as xmlSchemaAttributePtr)).name;
                if (*bucket).type_0 == 0 as libc::c_int
                    || (*bucket).type_0 == 1 as libc::c_int
                {
                    table = &mut (*(*(bucket as xmlSchemaImportPtr)).schema).attrDecl;
                } else {
                    table = &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport)
                        .schema)
                        .attrDecl;
                }
                current_block_61 = 2500484646272006982;
            }
            17 => {
                if (*(item as xmlSchemaModelGroupDefPtr)).flags
                    & (1 as libc::c_int) << 1 as libc::c_int != 0
                {
                    current_block_61 = 6937071982253665452;
                } else {
                    name = (*(item as xmlSchemaModelGroupDefPtr)).name;
                    if (*bucket).type_0 == 0 as libc::c_int
                        || (*bucket).type_0 == 1 as libc::c_int
                    {
                        table = &mut (*(*(bucket as xmlSchemaImportPtr)).schema)
                            .groupDecl;
                    } else {
                        table = &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport)
                            .schema)
                            .groupDecl;
                    }
                    current_block_61 = 2500484646272006982;
                }
            }
            16 => {
                if (*(item as xmlSchemaAttributeGroupPtr)).flags
                    & (1 as libc::c_int) << 3 as libc::c_int != 0
                {
                    current_block_61 = 6937071982253665452;
                } else {
                    name = (*(item as xmlSchemaAttributeGroupPtr)).name;
                    if (*bucket).type_0 == 0 as libc::c_int
                        || (*bucket).type_0 == 1 as libc::c_int
                    {
                        table = &mut (*(*(bucket as xmlSchemaImportPtr)).schema)
                            .attrgrpDecl;
                    } else {
                        table = &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport)
                            .schema)
                            .attrgrpDecl;
                    }
                    current_block_61 = 2500484646272006982;
                }
            }
            23 | 22 | 24 => {
                name = (*(item as xmlSchemaIDCPtr)).name;
                if (*bucket).type_0 == 0 as libc::c_int
                    || (*bucket).type_0 == 1 as libc::c_int
                {
                    table = &mut (*(*(bucket as xmlSchemaImportPtr)).schema).idcDef;
                } else {
                    table = &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport)
                        .schema)
                        .idcDef;
                }
                current_block_61 = 2500484646272006982;
            }
            18 => {
                name = (*(item as xmlSchemaNotationPtr)).name;
                if (*bucket).type_0 == 0 as libc::c_int
                    || (*bucket).type_0 == 1 as libc::c_int
                {
                    table = &mut (*(*(bucket as xmlSchemaImportPtr)).schema).notaDecl;
                } else {
                    table = &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport)
                        .schema)
                        .notaDecl;
                }
                current_block_61 = 2500484646272006982;
            }
            _ => {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaAddComponents\0" as *const u8 as *const libc::c_char,
                    b"Unexpected global component type\0" as *const u8
                        as *const libc::c_char,
                );
                current_block_61 = 6937071982253665452;
            }
        }
        match current_block_61 {
            2500484646272006982 => {
                if (*table).is_null() {
                    *table = xmlHashCreateDict(10 as libc::c_int, (*pctxt).dict);
                    if (*table).is_null() {
                        xmlSchemaInternalErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaAddComponents\0" as *const u8
                                as *const libc::c_char,
                            b"failed to create a component hash table\0" as *const u8
                                as *const libc::c_char,
                        );
                        return -(1 as libc::c_int);
                    }
                }
                err = xmlHashAddEntry(*table, name, item as *mut libc::c_void);
                if err != 0 as libc::c_int {
                    let mut str: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaCustomErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_REDEFINED_TYPE,
                        xmlSchemaGetComponentNode(item),
                        item,
                        b"A global %s '%s' does already exist\0" as *const u8
                            as *const libc::c_char,
                        xmlSchemaGetComponentTypeStr(item),
                        xmlSchemaGetComponentQName(&mut str, item as *mut libc::c_void),
                    );
                    if !str.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str as *mut libc::c_void);
                        str = 0 as *mut xmlChar;
                    }
                }
            }
            _ => {}
        }
        i += 1;
    }
    if !((*bucket).relations).is_null() {
        let mut rel: xmlSchemaSchemaRelationPtr = (*bucket).relations;
        loop {
            if !((*rel).bucket).is_null()
                && (*(*rel).bucket).flags & (1 as libc::c_int) << 1 as libc::c_int
                    == 0 as libc::c_int
            {
                if xmlSchemaAddComponents(pctxt, (*rel).bucket) == -(1 as libc::c_int) {
                    return -(1 as libc::c_int);
                }
            }
            rel = (*rel).next;
            if rel.is_null() {
                break;
            }
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaFixupComponents(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut rootBucket: xmlSchemaBucketPtr,
) -> libc::c_int {
    let mut current_block: u64;
    let mut con: xmlSchemaConstructionCtxtPtr = (*pctxt).constructor;
    let mut item: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
    let mut items: *mut xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItemPtr;
    let mut nbItems: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut oldbucket: xmlSchemaBucketPtr = (*con).bucket;
    let mut elemDecl: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
    if ((*con).pending).is_null() || (*(*con).pending).nbItems == 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    if ((*con).bucket).is_null() {
        let ref mut fresh421 = (*con).bucket;
        *fresh421 = rootBucket;
    }
    xmlSchemaCheckSRCRedefineFirst(pctxt);
    xmlSchemaAddComponents(pctxt, rootBucket);
    let ref mut fresh422 = (*pctxt).ctxtType;
    *fresh422 = 0 as xmlSchemaTypePtr;
    items = (*(*con).pending).items as *mut xmlSchemaTreeItemPtr;
    nbItems = (*(*con).pending).nbItems;
    i = 0 as libc::c_int;
    loop {
        if !(i < nbItems) {
            current_block = 1924505913685386279;
            break;
        }
        item = *items.offset(i as isize);
        match (*item).type_0 as libc::c_uint {
            14 => {
                xmlSchemaResolveElementReferences(item as xmlSchemaElementPtr, pctxt);
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                    current_block = 2133922729242721719;
                    break;
                }
            }
            5 | 4 => {
                xmlSchemaResolveTypeReferences(item as xmlSchemaTypePtr, pctxt);
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                    current_block = 2133922729242721719;
                    break;
                }
            }
            15 => {
                xmlSchemaResolveAttrTypeReferences(item as xmlSchemaAttributePtr, pctxt);
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                    current_block = 2133922729242721719;
                    break;
                }
            }
            26 => {
                xmlSchemaResolveAttrUseReferences(
                    item as xmlSchemaAttributeUsePtr,
                    pctxt,
                );
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                    current_block = 2133922729242721719;
                    break;
                }
            }
            2000 => {
                if (*(item as xmlSchemaQNameRefPtr)).itemType as libc::c_uint
                    == XML_SCHEMA_TYPE_ATTRIBUTEGROUP as libc::c_int as libc::c_uint
                {
                    xmlSchemaResolveAttrGroupReferences(
                        item as xmlSchemaQNameRefPtr,
                        pctxt,
                    );
                }
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                    current_block = 2133922729242721719;
                    break;
                }
            }
            6 | 7 | 8 => {
                xmlSchemaResolveModelGroupParticleReferences(
                    pctxt,
                    item as xmlSchemaModelGroupPtr,
                );
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                    current_block = 2133922729242721719;
                    break;
                }
            }
            23 | 22 | 24 => {
                xmlSchemaResolveIDCKeyReferences(item as xmlSchemaIDCPtr, pctxt);
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                    current_block = 2133922729242721719;
                    break;
                }
            }
            2001 => {
                xmlSchemaResolveAttrUseProhibReferences(
                    item as xmlSchemaAttributeUseProhibPtr,
                    pctxt,
                );
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                    current_block = 2133922729242721719;
                    break;
                }
            }
            _ => {}
        }
        i += 1;
    }
    match current_block {
        1924505913685386279 => {
            if (*pctxt).nberrors != 0 as libc::c_int {
                current_block = 3799963374263564300;
            } else {
                i = 0 as libc::c_int;
                loop {
                    if !(i < nbItems) {
                        current_block = 7330218953828964527;
                        break;
                    }
                    item = *items.offset(i as isize);
                    match (*item).type_0 as libc::c_uint {
                        5 | 4 => {
                            xmlSchemaCheckTypeDefCircular(
                                item as xmlSchemaTypePtr,
                                pctxt,
                            );
                            if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                                current_block = 2133922729242721719;
                                break;
                            }
                            if (*pctxt).nberrors != 0 as libc::c_int {
                                current_block = 3799963374263564300;
                                break;
                            }
                        }
                        17 => {
                            xmlSchemaCheckGroupDefCircular(
                                item as xmlSchemaModelGroupDefPtr,
                                pctxt,
                            );
                            if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                                current_block = 2133922729242721719;
                                break;
                            }
                            if (*pctxt).nberrors != 0 as libc::c_int {
                                current_block = 3799963374263564300;
                                break;
                            }
                        }
                        16 => {
                            xmlSchemaCheckAttrGroupCircular(
                                item as xmlSchemaAttributeGroupPtr,
                                pctxt,
                            );
                            if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                                current_block = 2133922729242721719;
                                break;
                            }
                            if (*pctxt).nberrors != 0 as libc::c_int {
                                current_block = 3799963374263564300;
                                break;
                            }
                        }
                        _ => {}
                    }
                    i += 1;
                }
                match current_block {
                    2133922729242721719 => {}
                    3799963374263564300 => {}
                    _ => {
                        if (*pctxt).nberrors != 0 as libc::c_int {
                            current_block = 3799963374263564300;
                        } else {
                            i = 0 as libc::c_int;
                            while i < nbItems {
                                item = *items.offset(i as isize);
                                match (*item).type_0 as libc::c_uint {
                                    6 | 7 => {
                                        xmlSchemaModelGroupToModelGroupDefFixup(
                                            pctxt,
                                            item as xmlSchemaModelGroupPtr,
                                        );
                                    }
                                    _ => {}
                                }
                                i += 1;
                            }
                            if (*pctxt).nberrors != 0 as libc::c_int {
                                current_block = 3799963374263564300;
                            } else {
                                i = 0 as libc::c_int;
                                loop {
                                    if !(i < nbItems) {
                                        current_block = 2798392256336243897;
                                        break;
                                    }
                                    item = *items.offset(i as isize);
                                    match (*item).type_0 as libc::c_uint {
                                        16 => {
                                            if (*(item as xmlSchemaAttributeGroupPtr)).flags
                                                & (1 as libc::c_int) << 0 as libc::c_int == 0
                                                && (*(item as xmlSchemaAttributeGroupPtr)).flags
                                                    & (1 as libc::c_int) << 4 as libc::c_int != 0
                                            {
                                                xmlSchemaAttributeGroupExpandRefs(
                                                    pctxt,
                                                    item as xmlSchemaAttributeGroupPtr,
                                                );
                                                if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                                                    current_block = 2133922729242721719;
                                                    break;
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                    i += 1;
                                }
                                match current_block {
                                    2133922729242721719 => {}
                                    _ => {
                                        if (*pctxt).nberrors != 0 as libc::c_int {
                                            current_block = 3799963374263564300;
                                        } else {
                                            i = 0 as libc::c_int;
                                            loop {
                                                if !(i < nbItems) {
                                                    current_block = 562309032768341766;
                                                    break;
                                                }
                                                item = *items.offset(i as isize);
                                                match (*item).type_0 as libc::c_uint {
                                                    4 => {
                                                        if (*(item as xmlSchemaTypePtr)).type_0 as libc::c_uint
                                                            != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                                                            && (*(item as xmlSchemaTypePtr)).flags
                                                                & (1 as libc::c_int) << 29 as libc::c_int
                                                                == 0 as libc::c_int
                                                        {
                                                            xmlSchemaFixupSimpleTypeStageOne(
                                                                pctxt,
                                                                item as xmlSchemaTypePtr,
                                                            );
                                                            if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                                                                current_block = 2133922729242721719;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    _ => {}
                                                }
                                                i += 1;
                                            }
                                            match current_block {
                                                2133922729242721719 => {}
                                                _ => {
                                                    if (*pctxt).nberrors != 0 as libc::c_int {
                                                        current_block = 3799963374263564300;
                                                    } else {
                                                        i = 0 as libc::c_int;
                                                        loop {
                                                            if !(i < nbItems) {
                                                                current_block = 14612007084265645573;
                                                                break;
                                                            }
                                                            item = *items.offset(i as isize);
                                                            match (*item).type_0 as libc::c_uint {
                                                                4 => {
                                                                    if !((*(item as xmlSchemaTypePtr)).memberTypes).is_null() {
                                                                        xmlSchemaCheckUnionTypeDefCircular(
                                                                            pctxt,
                                                                            item as xmlSchemaTypePtr,
                                                                        );
                                                                        if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                                                                            current_block = 2133922729242721719;
                                                                            break;
                                                                        }
                                                                    }
                                                                }
                                                                _ => {}
                                                            }
                                                            i += 1;
                                                        }
                                                        match current_block {
                                                            2133922729242721719 => {}
                                                            _ => {
                                                                if (*pctxt).nberrors != 0 as libc::c_int {
                                                                    current_block = 3799963374263564300;
                                                                } else {
                                                                    i = 0 as libc::c_int;
                                                                    loop {
                                                                        if !(i < nbItems) {
                                                                            current_block = 7079180960716815705;
                                                                            break;
                                                                        }
                                                                        item = *items.offset(i as isize);
                                                                        match (*item).type_0 as libc::c_uint {
                                                                            4 => {
                                                                                if (*(item as xmlSchemaTypePtr)).type_0 as libc::c_uint
                                                                                    != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                                                                                    && (*(item as xmlSchemaTypePtr)).flags
                                                                                        & (1 as libc::c_int) << 22 as libc::c_int
                                                                                        == 0 as libc::c_int
                                                                                {
                                                                                    xmlSchemaFixupSimpleTypeStageTwo(
                                                                                        pctxt,
                                                                                        item as xmlSchemaTypePtr,
                                                                                    );
                                                                                    if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                                                                                        current_block = 2133922729242721719;
                                                                                        break;
                                                                                    }
                                                                                }
                                                                            }
                                                                            _ => {}
                                                                        }
                                                                        i += 1;
                                                                    }
                                                                    match current_block {
                                                                        2133922729242721719 => {}
                                                                        _ => {
                                                                            if (*pctxt).nberrors != 0 as libc::c_int {
                                                                                current_block = 3799963374263564300;
                                                                            } else {
                                                                                i = 0 as libc::c_int;
                                                                                loop {
                                                                                    if !(i < nbItems) {
                                                                                        current_block = 5431927413890720344;
                                                                                        break;
                                                                                    }
                                                                                    item = *items.offset(i as isize);
                                                                                    match (*item).type_0 as libc::c_uint {
                                                                                        15 => {
                                                                                            xmlSchemaCheckAttrPropsCorrect(
                                                                                                pctxt,
                                                                                                item as xmlSchemaAttributePtr,
                                                                                            );
                                                                                            if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                                                                                                current_block = 2133922729242721719;
                                                                                                break;
                                                                                            }
                                                                                        }
                                                                                        _ => {}
                                                                                    }
                                                                                    i += 1;
                                                                                }
                                                                                match current_block {
                                                                                    2133922729242721719 => {}
                                                                                    _ => {
                                                                                        if (*pctxt).nberrors != 0 as libc::c_int {
                                                                                            current_block = 3799963374263564300;
                                                                                        } else {
                                                                                            i = 0 as libc::c_int;
                                                                                            loop {
                                                                                                if !(i < nbItems) {
                                                                                                    current_block = 6215370584428403858;
                                                                                                    break;
                                                                                                }
                                                                                                item = *items.offset(i as isize);
                                                                                                match (*item).type_0 as libc::c_uint {
                                                                                                    26 => {
                                                                                                        if !((*(item as xmlSchemaAttributeUsePtr)).defValue)
                                                                                                            .is_null()
                                                                                                        {
                                                                                                            xmlSchemaCheckAttrUsePropsCorrect(
                                                                                                                pctxt,
                                                                                                                item as xmlSchemaAttributeUsePtr,
                                                                                                            );
                                                                                                            if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                                                                                                                current_block = 2133922729242721719;
                                                                                                                break;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    _ => {}
                                                                                                }
                                                                                                i += 1;
                                                                                            }
                                                                                            match current_block {
                                                                                                2133922729242721719 => {}
                                                                                                _ => {
                                                                                                    if (*pctxt).nberrors != 0 as libc::c_int {
                                                                                                        current_block = 3799963374263564300;
                                                                                                    } else {
                                                                                                        i = 0 as libc::c_int;
                                                                                                        loop {
                                                                                                            if !(i < nbItems) {
                                                                                                                current_block = 6662862405959679103;
                                                                                                                break;
                                                                                                            }
                                                                                                            item = *items.offset(i as isize);
                                                                                                            match (*item).type_0 as libc::c_uint {
                                                                                                                16 => {
                                                                                                                    if !((*(item as xmlSchemaAttributeGroupPtr)).attrUses)
                                                                                                                        .is_null()
                                                                                                                        && (*((*(item as xmlSchemaAttributeGroupPtr)).attrUses
                                                                                                                            as xmlSchemaItemListPtr))
                                                                                                                            .nbItems > 1 as libc::c_int
                                                                                                                    {
                                                                                                                        xmlSchemaCheckAGPropsCorrect(
                                                                                                                            pctxt,
                                                                                                                            item as xmlSchemaAttributeGroupPtr,
                                                                                                                        );
                                                                                                                        if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                                                                                                                            current_block = 2133922729242721719;
                                                                                                                            break;
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                                _ => {}
                                                                                                            }
                                                                                                            i += 1;
                                                                                                        }
                                                                                                        match current_block {
                                                                                                            2133922729242721719 => {}
                                                                                                            _ => {
                                                                                                                if (*pctxt).nberrors != 0 as libc::c_int {
                                                                                                                    current_block = 3799963374263564300;
                                                                                                                } else {
                                                                                                                    if !((*(*pctxt).constructor).redefs).is_null() {
                                                                                                                        xmlSchemaCheckSRCRedefineSecond(pctxt);
                                                                                                                    }
                                                                                                                    if (*pctxt).nberrors != 0 as libc::c_int {
                                                                                                                        current_block = 3799963374263564300;
                                                                                                                    } else {
                                                                                                                        i = 0 as libc::c_int;
                                                                                                                        loop {
                                                                                                                            if !(i < nbItems) {
                                                                                                                                current_block = 13598848910332274892;
                                                                                                                                break;
                                                                                                                            }
                                                                                                                            item = *((*(*con).pending).items).offset(i as isize)
                                                                                                                                as xmlSchemaTreeItemPtr;
                                                                                                                            match (*item).type_0 as libc::c_uint {
                                                                                                                                5 => {
                                                                                                                                    if (*(item as xmlSchemaTypePtr)).type_0 as libc::c_uint
                                                                                                                                        != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                                                                                                                                        && (*(item as xmlSchemaTypePtr)).flags
                                                                                                                                            & (1 as libc::c_int) << 22 as libc::c_int
                                                                                                                                            == 0 as libc::c_int
                                                                                                                                    {
                                                                                                                                        xmlSchemaFixupComplexType(pctxt, item as xmlSchemaTypePtr);
                                                                                                                                        if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                                                                                                                                            current_block = 2133922729242721719;
                                                                                                                                            break;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                _ => {}
                                                                                                                            }
                                                                                                                            i += 1;
                                                                                                                        }
                                                                                                                        match current_block {
                                                                                                                            2133922729242721719 => {}
                                                                                                                            _ => {
                                                                                                                                if (*pctxt).nberrors != 0 as libc::c_int {
                                                                                                                                    current_block = 3799963374263564300;
                                                                                                                                } else {
                                                                                                                                    items = (*(*con).pending).items
                                                                                                                                        as *mut xmlSchemaTreeItemPtr;
                                                                                                                                    nbItems = (*(*con).pending).nbItems;
                                                                                                                                    i = 0 as libc::c_int;
                                                                                                                                    loop {
                                                                                                                                        if !(i < nbItems) {
                                                                                                                                            current_block = 2277602629737488951;
                                                                                                                                            break;
                                                                                                                                        }
                                                                                                                                        item = *items.offset(i as isize);
                                                                                                                                        match (*item).type_0 as libc::c_uint {
                                                                                                                                            14 => {
                                                                                                                                                elemDecl = item as xmlSchemaElementPtr;
                                                                                                                                                if (*elemDecl).flags
                                                                                                                                                    & (1 as libc::c_int) << 18 as libc::c_int
                                                                                                                                                    == 0 as libc::c_int
                                                                                                                                                {
                                                                                                                                                    xmlSchemaCheckElementDeclComponent(elemDecl, pctxt);
                                                                                                                                                    if (*pctxt).err == XML_SCHEMAP_INTERNAL as libc::c_int {
                                                                                                                                                        current_block = 2133922729242721719;
                                                                                                                                                        break;
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                            _ => {}
                                                                                                                                        }
                                                                                                                                        i += 1;
                                                                                                                                    }
                                                                                                                                    match current_block {
                                                                                                                                        2133922729242721719 => {}
                                                                                                                                        _ => {
                                                                                                                                            if (*pctxt).nberrors != 0 as libc::c_int {
                                                                                                                                                current_block = 3799963374263564300;
                                                                                                                                            } else {
                                                                                                                                                i = 0 as libc::c_int;
                                                                                                                                                while i < nbItems {
                                                                                                                                                    item = *items.offset(i as isize);
                                                                                                                                                    match (*item).type_0 as libc::c_uint {
                                                                                                                                                        5 => {
                                                                                                                                                            xmlSchemaBuildContentModel(item as xmlSchemaTypePtr, pctxt);
                                                                                                                                                        }
                                                                                                                                                        _ => {}
                                                                                                                                                    }
                                                                                                                                                    i += 1;
                                                                                                                                                }
                                                                                                                                                if (*pctxt).nberrors != 0 as libc::c_int {
                                                                                                                                                    current_block = 3799963374263564300;
                                                                                                                                                } else {
                                                                                                                                                    current_block = 17463883078150051418;
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            match current_block {
                17463883078150051418 => {}
                2133922729242721719 => {}
                _ => {
                    ret = (*pctxt).err;
                    current_block = 17463883078150051418;
                }
            }
        }
        _ => {}
    }
    match current_block {
        2133922729242721719 => {
            ret = -(1 as libc::c_int);
        }
        _ => {}
    }
    let ref mut fresh423 = (*con).bucket;
    *fresh423 = oldbucket;
    (*(*con).pending).nbItems = 0 as libc::c_int;
    if !((*con).substGroups).is_null() {
        xmlHashFree(
            (*con).substGroups,
            Some(
                xmlSchemaSubstGroupFreeEntry
                    as unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
            ),
        );
        let ref mut fresh424 = (*con).substGroups;
        *fresh424 = 0 as xmlHashTablePtr;
    }
    if !((*con).redefs).is_null() {
        xmlSchemaRedefListFree((*con).redefs);
        let ref mut fresh425 = (*con).redefs;
        *fresh425 = 0 as xmlSchemaRedefPtr;
    }
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaParse(
    mut ctxt: xmlSchemaParserCtxtPtr,
) -> xmlSchemaPtr {
    let mut current_block: u64;
    let mut mainSchema: xmlSchemaPtr = 0 as xmlSchemaPtr;
    let mut bucket: xmlSchemaBucketPtr = 0 as xmlSchemaBucketPtr;
    let mut res: libc::c_int = 0;
    xmlSchemaInitTypes();
    if ctxt.is_null() {
        return 0 as xmlSchemaPtr;
    }
    (*ctxt).nberrors = 0 as libc::c_int;
    (*ctxt).err = 0 as libc::c_int;
    (*ctxt).counter = 0 as libc::c_int;
    mainSchema = xmlSchemaNewSchema(ctxt);
    if !mainSchema.is_null() {
        if ((*ctxt).constructor).is_null() {
            let ref mut fresh426 = (*ctxt).constructor;
            *fresh426 = xmlSchemaConstructionCtxtCreate((*ctxt).dict);
            if ((*ctxt).constructor).is_null() {
                return 0 as xmlSchemaPtr;
            }
            (*ctxt).ownsConstructor = 1 as libc::c_int;
        }
        let ref mut fresh427 = (*(*ctxt).constructor).mainSchema;
        *fresh427 = mainSchema;
        res = xmlSchemaAddSchemaDoc(
            ctxt,
            0 as libc::c_int,
            (*ctxt).URL,
            (*ctxt).doc,
            (*ctxt).buffer,
            (*ctxt).size,
            0 as xmlNodePtr,
            0 as *const xmlChar,
            0 as *const xmlChar,
            &mut bucket,
        );
        if !(res == -(1 as libc::c_int)) {
            if res != 0 as libc::c_int {
                current_block = 7777198333657744202;
            } else if bucket.is_null() {
                if !((*ctxt).URL).is_null() {
                    xmlSchemaCustomErr(
                        ctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_FAILED_LOAD,
                        0 as xmlNodePtr,
                        0 as xmlSchemaBasicItemPtr,
                        b"Failed to locate the main schema resource at '%s'\0"
                            as *const u8 as *const libc::c_char,
                        (*ctxt).URL,
                        0 as *const xmlChar,
                    );
                } else {
                    xmlSchemaCustomErr(
                        ctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_FAILED_LOAD,
                        0 as xmlNodePtr,
                        0 as xmlSchemaBasicItemPtr,
                        b"Failed to locate the main schema resource\0" as *const u8
                            as *const libc::c_char,
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                }
                current_block = 7777198333657744202;
            } else if xmlSchemaParseNewDocWithContext(ctxt, mainSchema, bucket)
                    == -(1 as libc::c_int)
                {
                current_block = 4244197895050895038;
            } else if (*ctxt).nberrors != 0 as libc::c_int {
                current_block = 7777198333657744202;
            } else {
                let ref mut fresh428 = (*mainSchema).doc;
                *fresh428 = (*bucket).doc;
                (*mainSchema).preserve = (*ctxt).preserve;
                let ref mut fresh429 = (*ctxt).schema;
                *fresh429 = mainSchema;
                if xmlSchemaFixupComponents(ctxt, (*(*ctxt).constructor).mainBucket)
                    == -(1 as libc::c_int)
                {
                    current_block = 4244197895050895038;
                } else {
                    current_block = 7777198333657744202;
                }
            }
            match current_block {
                4244197895050895038 => {}
                _ => {
                    if (*ctxt).nberrors != 0 as libc::c_int {
                        if !mainSchema.is_null() {
                            xmlSchemaFree(mainSchema);
                            mainSchema = 0 as xmlSchemaPtr;
                        }
                        if !((*ctxt).constructor).is_null() {
                            xmlSchemaConstructionCtxtFree((*ctxt).constructor);
                            let ref mut fresh430 = (*ctxt).constructor;
                            *fresh430 = 0 as xmlSchemaConstructionCtxtPtr;
                            (*ctxt).ownsConstructor = 0 as libc::c_int;
                        }
                    }
                    let ref mut fresh431 = (*ctxt).schema;
                    *fresh431 = 0 as xmlSchemaPtr;
                    return mainSchema;
                }
            }
        }
    }
    if !mainSchema.is_null() {
        xmlSchemaFree(mainSchema);
        mainSchema = 0 as xmlSchemaPtr;
    }
    if !((*ctxt).constructor).is_null() {
        xmlSchemaConstructionCtxtFree((*ctxt).constructor);
        let ref mut fresh432 = (*ctxt).constructor;
        *fresh432 = 0 as xmlSchemaConstructionCtxtPtr;
        (*ctxt).ownsConstructor = 0 as libc::c_int;
    }
    xmlSchemaInternalErr(
        ctxt as xmlSchemaAbstractCtxtPtr,
        b"xmlSchemaParse\0" as *const u8 as *const libc::c_char,
        b"An internal error occurred\0" as *const u8 as *const libc::c_char,
    );
    let ref mut fresh433 = (*ctxt).schema;
    *fresh433 = 0 as xmlSchemaPtr;
    return 0 as xmlSchemaPtr;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSetParserErrors(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut err: xmlSchemaValidityErrorFunc,
    mut warn: xmlSchemaValidityWarningFunc,
    mut ctx: *mut libc::c_void,
) {
    if ctxt.is_null() {
        return;
    }
    let ref mut fresh434 = (*ctxt).error;
    *fresh434 = err;
    let ref mut fresh435 = (*ctxt).warning;
    *fresh435 = warn;
    let ref mut fresh436 = (*ctxt).errCtxt;
    *fresh436 = ctx;
    if !((*ctxt).vctxt).is_null() {
        xmlSchemaSetValidErrors((*ctxt).vctxt, err, warn, ctx);
    }
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSetParserStructuredErrors(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut serror: xmlStructuredErrorFunc,
    mut ctx: *mut libc::c_void,
) {
    if ctxt.is_null() {
        return;
    }
    let ref mut fresh437 = (*ctxt).serror;
    *fresh437 = serror;
    let ref mut fresh438 = (*ctxt).errCtxt;
    *fresh438 = ctx;
    if !((*ctxt).vctxt).is_null() {
        xmlSchemaSetValidStructuredErrors((*ctxt).vctxt, serror, ctx);
    }
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaGetParserErrors(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut err: *mut xmlSchemaValidityErrorFunc,
    mut warn: *mut xmlSchemaValidityWarningFunc,
    mut ctx: *mut *mut libc::c_void,
) -> libc::c_int {
    if ctxt.is_null() {
        return -(1 as libc::c_int);
    }
    if !err.is_null() {
        *err = (*ctxt).error;
    }
    if !warn.is_null() {
        *warn = (*ctxt).warning;
    }
    if !ctx.is_null() {
        *ctx = (*ctxt).errCtxt;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaFacetTypeToString(
    mut type_0: xmlSchemaTypeType,
) -> *const xmlChar {
    match type_0 as libc::c_uint {
        1006 => return b"pattern\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        1003 => {
            return b"maxExclusive\0" as *const u8 as *const libc::c_char as *mut xmlChar;
        }
        1002 => {
            return b"maxInclusive\0" as *const u8 as *const libc::c_char as *mut xmlChar;
        }
        1001 => {
            return b"minExclusive\0" as *const u8 as *const libc::c_char as *mut xmlChar;
        }
        1000 => {
            return b"minInclusive\0" as *const u8 as *const libc::c_char as *mut xmlChar;
        }
        1008 => {
            return b"whiteSpace\0" as *const u8 as *const libc::c_char as *mut xmlChar;
        }
        1007 => {
            return b"enumeration\0" as *const u8 as *const libc::c_char as *mut xmlChar;
        }
        1009 => return b"length\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        1010 => return b"maxLength\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        1011 => return b"minLength\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        1004 => {
            return b"totalDigits\0" as *const u8 as *const libc::c_char as *mut xmlChar;
        }
        1005 => {
            return b"fractionDigits\0" as *const u8 as *const libc::c_char
                as *mut xmlChar;
        }
        _ => {}
    }
    return b"Internal Error\0" as *const u8 as *const libc::c_char as *mut xmlChar;
}
unsafe extern "C" fn xmlSchemaGetWhiteSpaceFacetValue(
    mut type_0: xmlSchemaTypePtr,
) -> xmlSchemaWhitespaceValueType {
    if (*type_0).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
    {
        if (*type_0).builtInType == XML_SCHEMAS_STRING as libc::c_int
            || (*type_0).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as libc::c_int
        {
            return XML_SCHEMA_WHITESPACE_PRESERVE
        } else if (*type_0).builtInType == XML_SCHEMAS_NORMSTRING as libc::c_int {
            return XML_SCHEMA_WHITESPACE_REPLACE
        } else {
            return XML_SCHEMA_WHITESPACE_COLLAPSE
        }
    } else {
        if (*type_0).flags & (1 as libc::c_int) << 6 as libc::c_int != 0 {
            return XML_SCHEMA_WHITESPACE_COLLAPSE
        } else {
            if (*type_0).flags & (1 as libc::c_int) << 7 as libc::c_int != 0 {
                return XML_SCHEMA_WHITESPACE_UNKNOWN
            } else {
                if (*type_0).flags & (1 as libc::c_int) << 8 as libc::c_int != 0 {
                    if (*type_0).flags & (1 as libc::c_int) << 24 as libc::c_int != 0 {
                        return XML_SCHEMA_WHITESPACE_PRESERVE
                    } else if (*type_0).flags & (1 as libc::c_int) << 25 as libc::c_int
                            != 0
                        {
                        return XML_SCHEMA_WHITESPACE_REPLACE
                    } else {
                        return XML_SCHEMA_WHITESPACE_COLLAPSE
                    }
                }
            }
        }
    }
    return 4294967295 as xmlSchemaWhitespaceValueType;
}
unsafe extern "C" fn xmlSchemaAssembleByLocation(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut nsName: *const xmlChar,
    mut location: *const xmlChar,
) -> libc::c_int {
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut pctxt: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut bucket: xmlSchemaBucketPtr = 0 as xmlSchemaBucketPtr;
    if vctxt.is_null() || schema.is_null() {
        return -(1 as libc::c_int);
    }
    if ((*vctxt).pctxt).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaAssembleByLocation\0" as *const u8 as *const libc::c_char,
            b"no parser context available\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    pctxt = (*vctxt).pctxt;
    if ((*pctxt).constructor).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaAssembleByLocation\0" as *const u8 as *const libc::c_char,
            b"no constructor\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    location = xmlSchemaBuildAbsoluteURI((*pctxt).dict, location, node);
    ret = xmlSchemaAddSchemaDoc(
        pctxt,
        1 as libc::c_int,
        location,
        0 as xmlDocPtr,
        0 as *const libc::c_char,
        0 as libc::c_int,
        node,
        0 as *const xmlChar,
        nsName,
        &mut bucket,
    );
    if ret != 0 as libc::c_int {
        return ret;
    }
    if bucket.is_null() {
        xmlSchemaCustomWarning(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_MISC,
            node,
            0 as xmlSchemaTypePtr,
            b"The document at location '%s' could not be acquired\0" as *const u8
                as *const libc::c_char,
            location,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return ret;
    }
    if !bucket.is_null() && ((*(*pctxt).constructor).bucket).is_null() {
        let ref mut fresh439 = (*(*pctxt).constructor).bucket;
        *fresh439 = bucket;
    }
    if bucket.is_null()
        || !(!((*bucket).doc).is_null() && (*bucket).parsed == 0 as libc::c_int)
    {
        return 0 as libc::c_int;
    }
    (*pctxt).nberrors = 0 as libc::c_int;
    (*pctxt).err = 0 as libc::c_int;
    let ref mut fresh440 = (*pctxt).doc;
    *fresh440 = (*bucket).doc;
    ret = xmlSchemaParseNewDocWithContext(pctxt, schema, bucket);
    if ret == -(1 as libc::c_int) {
        let ref mut fresh441 = (*pctxt).doc;
        *fresh441 = 0 as xmlDocPtr;
        let ref mut fresh443 = (*pctxt).doc;
        *fresh443 = 0 as xmlDocPtr;
        return -(1 as libc::c_int);
    } else {
        if ret == 0 as libc::c_int && (*pctxt).nberrors != 0 as libc::c_int {
            ret = (*pctxt).err;
        }
        if (*pctxt).nberrors == 0 as libc::c_int {
            xmlSchemaFixupComponents(pctxt, bucket);
            ret = (*pctxt).err;
            if ret != 0 as libc::c_int && (*vctxt).err == 0 as libc::c_int {
                (*vctxt).err = ret;
            }
            (*vctxt).nberrors += (*pctxt).nberrors;
        } else {
            (*vctxt).nberrors += (*pctxt).nberrors;
        }
        let ref mut fresh442 = (*pctxt).doc;
        *fresh442 = 0 as xmlDocPtr;
        return ret;
    };
}
unsafe extern "C" fn xmlSchemaGetMetaAttrInfo(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut metaType: libc::c_int,
) -> xmlSchemaAttrInfoPtr {
    if (*vctxt).nbAttrInfos == 0 as libc::c_int {
        return 0 as xmlSchemaAttrInfoPtr;
    }
    let mut i: libc::c_int = 0;
    let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    i = 0 as libc::c_int;
    while i < (*vctxt).nbAttrInfos {
        iattr = *((*vctxt).attrInfos).offset(i as isize);
        if (*iattr).metaType == metaType {
            return iattr;
        }
        i += 1;
    }
    return 0 as xmlSchemaAttrInfoPtr;
}
unsafe extern "C" fn xmlSchemaAssembleByXSI(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> libc::c_int {
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    let mut end: *const xmlChar = 0 as *const xmlChar;
    let mut nsname: *const xmlChar = 0 as *const xmlChar;
    let mut location: *const xmlChar = 0 as *const xmlChar;
    let mut count: libc::c_int = 0 as libc::c_int;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    iattr = xmlSchemaGetMetaAttrInfo(vctxt, 3 as libc::c_int);
    if iattr.is_null() {
        iattr = xmlSchemaGetMetaAttrInfo(vctxt, 4 as libc::c_int);
    }
    if iattr.is_null() {
        return 0 as libc::c_int;
    }
    cur = (*iattr).value;
    loop {
        if (*iattr).metaType == 3 as libc::c_int {
            while *cur as libc::c_int == 0x20 as libc::c_int
                || 0x9 as libc::c_int <= *cur as libc::c_int
                    && *cur as libc::c_int <= 0xa as libc::c_int
                || *cur as libc::c_int == 0xd as libc::c_int
            {
                cur = cur.offset(1);
            }
            end = cur;
            while *end as libc::c_int != 0 as libc::c_int
                && !(*end as libc::c_int == 0x20 as libc::c_int
                    || 0x9 as libc::c_int <= *end as libc::c_int
                        && *end as libc::c_int <= 0xa as libc::c_int
                    || *end as libc::c_int == 0xd as libc::c_int)
            {
                end = end.offset(1);
            }
            if end == cur {
                break;
            }
            count += 1;
            nsname = xmlDictLookup(
                (*(*vctxt).schema).dict,
                cur,
                end.offset_from(cur) as libc::c_long as libc::c_int,
            );
            cur = end;
        }
        while *cur as libc::c_int == 0x20 as libc::c_int
            || 0x9 as libc::c_int <= *cur as libc::c_int
                && *cur as libc::c_int <= 0xa as libc::c_int
            || *cur as libc::c_int == 0xd as libc::c_int
        {
            cur = cur.offset(1);
        }
        end = cur;
        while *end as libc::c_int != 0 as libc::c_int
            && !(*end as libc::c_int == 0x20 as libc::c_int
                || 0x9 as libc::c_int <= *end as libc::c_int
                    && *end as libc::c_int <= 0xa as libc::c_int
                || *end as libc::c_int == 0xd as libc::c_int)
        {
            end = end.offset(1);
        }
        if end == cur {
            if (*iattr).metaType == 3 as libc::c_int {
                xmlSchemaCustomWarning(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    XML_SCHEMAV_MISC,
                    (*iattr).node,
                    0 as xmlSchemaTypePtr,
                    b"The value must consist of tuples: the target namespace name and the document's URI\0"
                        as *const u8 as *const libc::c_char,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
            }
            break;
        } else {
            count += 1;
            location = xmlDictLookup(
                (*(*vctxt).schema).dict,
                cur,
                end.offset_from(cur) as libc::c_long as libc::c_int,
            );
            cur = end;
            ret = xmlSchemaAssembleByLocation(
                vctxt,
                (*vctxt).schema,
                (*iattr).node,
                nsname,
                location,
            );
            if ret == -(1 as libc::c_int) {
                xmlSchemaInternalErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaAssembleByXSI\0" as *const u8 as *const libc::c_char,
                    b"assembling schemata\0" as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            if !(*cur as libc::c_int != 0 as libc::c_int) {
                break;
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaLookupNamespace(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut prefix: *const xmlChar,
) -> *const xmlChar {
    if !((*vctxt).sax).is_null() {
        let mut i: libc::c_int = 0;
        let mut j: libc::c_int = 0;
        let mut inode: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
        i = (*vctxt).depth;
        while i >= 0 as libc::c_int {
            if (**((*vctxt).elemInfos).offset(i as isize)).nbNsBindings
                != 0 as libc::c_int
            {
                inode = *((*vctxt).elemInfos).offset(i as isize);
                j = 0 as libc::c_int;
                while j < (*inode).nbNsBindings * 2 as libc::c_int {
                    if prefix.is_null()
                        && (*((*inode).nsBindings).offset(j as isize)).is_null()
                        || !prefix.is_null()
                            && xmlStrEqual(
                                prefix,
                                *((*inode).nsBindings).offset(j as isize),
                            ) != 0
                    {
                        return *((*inode).nsBindings)
                            .offset((j + 1 as libc::c_int) as isize);
                    }
                    j += 2 as libc::c_int;
                }
            }
            i -= 1;
        }
        return 0 as *const xmlChar;
    } else if !((*vctxt).reader).is_null() {
        let mut nsName: *mut xmlChar = 0 as *mut xmlChar;
        nsName = xmlTextReaderLookupNamespace((*vctxt).reader, prefix);
        if !nsName.is_null() {
            let mut ret: *const xmlChar = 0 as *const xmlChar;
            ret = xmlDictLookup((*vctxt).dict, nsName, -(1 as libc::c_int));
            xmlFree.expect("non-null function pointer")(nsName as *mut libc::c_void);
            return ret;
        } else {
            return 0 as *const xmlChar
        }
    } else {
        let mut ns: xmlNsPtr = 0 as *mut xmlNs;
        if ((*(*vctxt).inode).node).is_null()
            || ((*(*(*vctxt).inode).node).doc).is_null()
        {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaLookupNamespace\0" as *const u8 as *const libc::c_char,
                b"no node or node's doc available\0" as *const u8 as *const libc::c_char,
            );
            return 0 as *const xmlChar;
        }
        ns = xmlSearchNs((*(*(*vctxt).inode).node).doc, (*(*vctxt).inode).node, prefix);
        if !ns.is_null() {
            return (*ns).href;
        }
        return 0 as *const xmlChar;
    };
}
unsafe extern "C" fn xmlSchemaValidateNotation(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut value: *const xmlChar,
    mut val: *mut xmlSchemaValPtr,
    mut valNeeded: libc::c_int,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    if !vctxt.is_null() && ((*vctxt).schema).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaValidateNotation\0" as *const u8 as *const libc::c_char,
            b"a schema is needed on the validation context\0" as *const u8
                as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    ret = xmlValidateQName(value, 1 as libc::c_int);
    if ret != 0 as libc::c_int {
        return ret;
    }
    let mut localName: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    localName = xmlSplitQName2(value, &mut prefix);
    if !prefix.is_null() {
        let mut nsName: *const xmlChar = 0 as *const xmlChar;
        if !vctxt.is_null() {
            nsName = xmlSchemaLookupNamespace(vctxt, prefix);
        } else if !node.is_null() {
            let mut ns: xmlNsPtr = xmlSearchNs((*node).doc, node, prefix);
            if !ns.is_null() {
                nsName = (*ns).href;
            }
        } else {
            xmlFree.expect("non-null function pointer")(prefix as *mut libc::c_void);
            xmlFree.expect("non-null function pointer")(localName as *mut libc::c_void);
            return 1 as libc::c_int;
        }
        if nsName.is_null() {
            xmlFree.expect("non-null function pointer")(prefix as *mut libc::c_void);
            xmlFree.expect("non-null function pointer")(localName as *mut libc::c_void);
            return 1 as libc::c_int;
        }
        if !(xmlSchemaGetNotation(schema, localName, nsName)).is_null() {
            if valNeeded != 0 && !val.is_null() {
                *val = xmlSchemaNewNOTATIONValue(
                    xmlStrdup(localName),
                    xmlStrdup(nsName),
                );
                if (*val).is_null() {
                    ret = -(1 as libc::c_int);
                }
            }
        } else {
            ret = 1 as libc::c_int;
        }
        xmlFree.expect("non-null function pointer")(prefix as *mut libc::c_void);
        xmlFree.expect("non-null function pointer")(localName as *mut libc::c_void);
    } else if !(xmlSchemaGetNotation(schema, value, 0 as *const xmlChar)).is_null() {
        if valNeeded != 0 && !val.is_null() {
            *val = xmlSchemaNewNOTATIONValue(xmlStrdup(value), 0 as *const xmlChar);
            if (*val).is_null() {
                ret = -(1 as libc::c_int);
            }
        }
    } else {
        return 1 as libc::c_int
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaVAddNodeQName(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut lname: *const xmlChar,
    mut nsname: *const xmlChar,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    lname = xmlDictLookup((*vctxt).dict, lname, -(1 as libc::c_int));
    if lname.is_null() {
        return -(1 as libc::c_int);
    }
    if !nsname.is_null() {
        nsname = xmlDictLookup((*vctxt).dict, nsname, -(1 as libc::c_int));
        if nsname.is_null() {
            return -(1 as libc::c_int);
        }
    }
    i = 0 as libc::c_int;
    while i < (*(*vctxt).nodeQNames).nbItems {
        if *((*(*vctxt).nodeQNames).items).offset(i as isize)
            == lname as *mut libc::c_void
            && *((*(*vctxt).nodeQNames).items).offset((i + 1 as libc::c_int) as isize)
                == nsname as *mut libc::c_void
        {
            return i;
        }
        i += 2 as libc::c_int;
    }
    i = (*(*vctxt).nodeQNames).nbItems;
    xmlSchemaItemListAdd((*vctxt).nodeQNames, lname as *mut libc::c_void);
    xmlSchemaItemListAdd((*vctxt).nodeQNames, nsname as *mut libc::c_void);
    return i;
}
unsafe extern "C" fn xmlSchemaAugmentIDC(
    mut payload: *mut libc::c_void,
    mut data: *mut libc::c_void,
    mut name: *const xmlChar,
) {
    let mut idcDef: xmlSchemaIDCPtr = payload as xmlSchemaIDCPtr;
    let mut vctxt: xmlSchemaValidCtxtPtr = data as xmlSchemaValidCtxtPtr;
    let mut aidc: xmlSchemaIDCAugPtr = 0 as *mut xmlSchemaIDCAug;
    aidc = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaIDCAug>() as libc::c_ulong)
        as xmlSchemaIDCAugPtr;
    if aidc.is_null() {
        xmlSchemaVErrMemory(
            vctxt,
            b"xmlSchemaAugmentIDC: allocating an augmented IDC definition\0" as *const u8
                as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return;
    }
    (*aidc).keyrefDepth = -(1 as libc::c_int);
    let ref mut fresh444 = (*aidc).def;
    *fresh444 = idcDef;
    let ref mut fresh445 = (*aidc).next;
    *fresh445 = 0 as xmlSchemaIDCAugPtr;
    if ((*vctxt).aidcs).is_null() {
        let ref mut fresh446 = (*vctxt).aidcs;
        *fresh446 = aidc;
    } else {
        let ref mut fresh447 = (*aidc).next;
        *fresh447 = (*vctxt).aidcs;
        let ref mut fresh448 = (*vctxt).aidcs;
        *fresh448 = aidc;
    }
    if (*vctxt).hasKeyrefs == 0 as libc::c_int
        && (*idcDef).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_IDC_KEYREF as libc::c_int as libc::c_uint
    {
        (*vctxt).hasKeyrefs = 1 as libc::c_int;
    }
}
unsafe extern "C" fn xmlSchemaAugmentImportedIDC(
    mut payload: *mut libc::c_void,
    mut data: *mut libc::c_void,
    mut name: *const xmlChar,
) {
    let mut imported: xmlSchemaImportPtr = payload as xmlSchemaImportPtr;
    let mut vctxt: xmlSchemaValidCtxtPtr = data as xmlSchemaValidCtxtPtr;
    if !((*(*imported).schema).idcDef).is_null() {
        xmlHashScan(
            (*(*imported).schema).idcDef,
            Some(
                xmlSchemaAugmentIDC
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *mut libc::c_void,
                        *const xmlChar,
                    ) -> (),
            ),
            vctxt as *mut libc::c_void,
        );
    }
}
unsafe extern "C" fn xmlSchemaIDCNewBinding(
    mut idcDef: xmlSchemaIDCPtr,
) -> xmlSchemaPSVIIDCBindingPtr {
    let mut ret: xmlSchemaPSVIIDCBindingPtr = 0 as *mut xmlSchemaPSVIIDCBinding;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaPSVIIDCBinding>() as libc::c_ulong)
        as xmlSchemaPSVIIDCBindingPtr;
    if ret.is_null() {
        xmlSchemaVErrMemory(
            0 as xmlSchemaValidCtxtPtr,
            b"allocating a PSVI IDC binding item\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaPSVIIDCBindingPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaPSVIIDCBinding>() as libc::c_ulong,
    );
    let ref mut fresh449 = (*ret).definition;
    *fresh449 = idcDef;
    return ret;
}
unsafe extern "C" fn xmlSchemaIDCStoreNodeTableItem(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut item: xmlSchemaPSVIIDCNodePtr,
) -> libc::c_int {
    if ((*vctxt).idcNodes).is_null() {
        let ref mut fresh450 = (*vctxt).idcNodes;
        *fresh450 = xmlMalloc
            .expect(
                "non-null function pointer",
            )(
            (20 as libc::c_int as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>() as libc::c_ulong,
                ),
        ) as *mut xmlSchemaPSVIIDCNodePtr;
        if ((*vctxt).idcNodes).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"allocating the IDC node table item list\0" as *const u8
                    as *const libc::c_char,
                0 as xmlNodePtr,
            );
            return -(1 as libc::c_int);
        }
        (*vctxt).sizeIdcNodes = 20 as libc::c_int;
    } else if (*vctxt).sizeIdcNodes <= (*vctxt).nbIdcNodes {
        (*vctxt).sizeIdcNodes *= 2 as libc::c_int;
        let ref mut fresh451 = (*vctxt).idcNodes;
        *fresh451 = xmlRealloc
            .expect(
                "non-null function pointer",
            )(
            (*vctxt).idcNodes as *mut libc::c_void,
            ((*vctxt).sizeIdcNodes as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>() as libc::c_ulong,
                ),
        ) as *mut xmlSchemaPSVIIDCNodePtr;
        if ((*vctxt).idcNodes).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"re-allocating the IDC node table item list\0" as *const u8
                    as *const libc::c_char,
                0 as xmlNodePtr,
            );
            return -(1 as libc::c_int);
        }
    }
    let ref mut fresh452 = (*vctxt).nbIdcNodes;
    let fresh453 = *fresh452;
    *fresh452 = *fresh452 + 1;
    let ref mut fresh454 = *((*vctxt).idcNodes).offset(fresh453 as isize);
    *fresh454 = item;
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaIDCStoreKey(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut key: xmlSchemaPSVIIDCKeyPtr,
) -> libc::c_int {
    if ((*vctxt).idcKeys).is_null() {
        let ref mut fresh455 = (*vctxt).idcKeys;
        *fresh455 = xmlMalloc
            .expect(
                "non-null function pointer",
            )(
            (40 as libc::c_int as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaPSVIIDCKeyPtr>() as libc::c_ulong,
                ),
        ) as *mut xmlSchemaPSVIIDCKeyPtr;
        if ((*vctxt).idcKeys).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"allocating the IDC key storage list\0" as *const u8
                    as *const libc::c_char,
                0 as xmlNodePtr,
            );
            return -(1 as libc::c_int);
        }
        (*vctxt).sizeIdcKeys = 40 as libc::c_int;
    } else if (*vctxt).sizeIdcKeys <= (*vctxt).nbIdcKeys {
        (*vctxt).sizeIdcKeys *= 2 as libc::c_int;
        let ref mut fresh456 = (*vctxt).idcKeys;
        *fresh456 = xmlRealloc
            .expect(
                "non-null function pointer",
            )(
            (*vctxt).idcKeys as *mut libc::c_void,
            ((*vctxt).sizeIdcKeys as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaPSVIIDCKeyPtr>() as libc::c_ulong,
                ),
        ) as *mut xmlSchemaPSVIIDCKeyPtr;
        if ((*vctxt).idcKeys).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"re-allocating the IDC key storage list\0" as *const u8
                    as *const libc::c_char,
                0 as xmlNodePtr,
            );
            return -(1 as libc::c_int);
        }
    }
    let ref mut fresh457 = (*vctxt).nbIdcKeys;
    let fresh458 = *fresh457;
    *fresh457 = *fresh457 + 1;
    let ref mut fresh459 = *((*vctxt).idcKeys).offset(fresh458 as isize);
    *fresh459 = key;
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaIDCAppendNodeTableItem(
    mut bind: xmlSchemaPSVIIDCBindingPtr,
    mut ntItem: xmlSchemaPSVIIDCNodePtr,
) -> libc::c_int {
    if ((*bind).nodeTable).is_null() {
        (*bind).sizeNodes = 10 as libc::c_int;
        let ref mut fresh460 = (*bind).nodeTable;
        *fresh460 = xmlMalloc
            .expect(
                "non-null function pointer",
            )(
            (10 as libc::c_int as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>() as libc::c_ulong,
                ),
        ) as *mut xmlSchemaPSVIIDCNodePtr;
        if ((*bind).nodeTable).is_null() {
            xmlSchemaVErrMemory(
                0 as xmlSchemaValidCtxtPtr,
                b"allocating an array of IDC node-table items\0" as *const u8
                    as *const libc::c_char,
                0 as xmlNodePtr,
            );
            return -(1 as libc::c_int);
        }
    } else if (*bind).sizeNodes <= (*bind).nbNodes {
        (*bind).sizeNodes *= 2 as libc::c_int;
        let ref mut fresh461 = (*bind).nodeTable;
        *fresh461 = xmlRealloc
            .expect(
                "non-null function pointer",
            )(
            (*bind).nodeTable as *mut libc::c_void,
            ((*bind).sizeNodes as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>() as libc::c_ulong,
                ),
        ) as *mut xmlSchemaPSVIIDCNodePtr;
        if ((*bind).nodeTable).is_null() {
            xmlSchemaVErrMemory(
                0 as xmlSchemaValidCtxtPtr,
                b"re-allocating an array of IDC node-table items\0" as *const u8
                    as *const libc::c_char,
                0 as xmlNodePtr,
            );
            return -(1 as libc::c_int);
        }
    }
    let ref mut fresh462 = (*bind).nbNodes;
    let fresh463 = *fresh462;
    *fresh462 = *fresh462 + 1;
    let ref mut fresh464 = *((*bind).nodeTable).offset(fresh463 as isize);
    *fresh464 = ntItem;
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaIDCAcquireBinding(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut matcher: xmlSchemaIDCMatcherPtr,
) -> xmlSchemaPSVIIDCBindingPtr {
    let mut ielem: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
    ielem = *((*vctxt).elemInfos).offset((*matcher).depth as isize);
    if ((*ielem).idcTable).is_null() {
        let ref mut fresh465 = (*ielem).idcTable;
        *fresh465 = xmlSchemaIDCNewBinding((*(*matcher).aidc).def);
        if ((*ielem).idcTable).is_null() {
            return 0 as xmlSchemaPSVIIDCBindingPtr;
        }
        return (*ielem).idcTable;
    } else {
        let mut bind: xmlSchemaPSVIIDCBindingPtr = 0 as xmlSchemaPSVIIDCBindingPtr;
        bind = (*ielem).idcTable;
        loop {
            if (*bind).definition == (*(*matcher).aidc).def {
                return bind;
            }
            if ((*bind).next).is_null() {
                let ref mut fresh466 = (*bind).next;
                *fresh466 = xmlSchemaIDCNewBinding((*(*matcher).aidc).def);
                if ((*bind).next).is_null() {
                    return 0 as xmlSchemaPSVIIDCBindingPtr;
                }
                return (*bind).next;
            }
            bind = (*bind).next;
            if bind.is_null() {
                break;
            }
        }
    }
    return 0 as xmlSchemaPSVIIDCBindingPtr;
}
unsafe extern "C" fn xmlSchemaIDCAcquireTargetList(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut matcher: xmlSchemaIDCMatcherPtr,
) -> xmlSchemaItemListPtr {
    if ((*matcher).targets).is_null() {
        let ref mut fresh467 = (*matcher).targets;
        *fresh467 = xmlSchemaItemListCreate();
    }
    return (*matcher).targets;
}
unsafe extern "C" fn xmlSchemaIDCFreeKey(mut key: xmlSchemaPSVIIDCKeyPtr) {
    if !((*key).val).is_null() {
        xmlSchemaFreeValue((*key).val);
    }
    xmlFree.expect("non-null function pointer")(key as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaIDCFreeBinding(mut bind: xmlSchemaPSVIIDCBindingPtr) {
    if !((*bind).nodeTable).is_null() {
        xmlFree
            .expect("non-null function pointer")((*bind).nodeTable as *mut libc::c_void);
    }
    if !((*bind).dupls).is_null() {
        xmlSchemaItemListFree((*bind).dupls);
    }
    xmlFree.expect("non-null function pointer")(bind as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaIDCFreeIDCTable(mut bind: xmlSchemaPSVIIDCBindingPtr) {
    let mut prev: xmlSchemaPSVIIDCBindingPtr = 0 as *mut xmlSchemaPSVIIDCBinding;
    while !bind.is_null() {
        prev = bind;
        bind = (*bind).next;
        xmlSchemaIDCFreeBinding(prev);
    }
}
unsafe extern "C" fn xmlFreeIDCHashEntry(
    mut payload: *mut libc::c_void,
    mut name: *const xmlChar,
) {
    let mut e: xmlIDCHashEntryPtr = payload as xmlIDCHashEntryPtr;
    let mut n: xmlIDCHashEntryPtr = 0 as *mut xmlIDCHashEntry;
    while !e.is_null() {
        n = (*e).next;
        xmlFree.expect("non-null function pointer")(e as *mut libc::c_void);
        e = n;
    }
}
unsafe extern "C" fn xmlSchemaIDCFreeMatcherList(mut matcher: xmlSchemaIDCMatcherPtr) {
    let mut next: xmlSchemaIDCMatcherPtr = 0 as *mut xmlSchemaIDCMatcher;
    while !matcher.is_null() {
        next = (*matcher).next;
        if !((*matcher).keySeqs).is_null() {
            let mut i: libc::c_int = 0;
            i = 0 as libc::c_int;
            while i < (*matcher).sizeKeySeqs {
                if !(*((*matcher).keySeqs).offset(i as isize)).is_null() {
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(*((*matcher).keySeqs).offset(i as isize) as *mut libc::c_void);
                }
                i += 1;
            }
            xmlFree
                .expect(
                    "non-null function pointer",
                )((*matcher).keySeqs as *mut libc::c_void);
        }
        if !((*matcher).targets).is_null() {
            if (*matcher).idcType == XML_SCHEMA_TYPE_IDC_KEYREF as libc::c_int {
                let mut i_0: libc::c_int = 0;
                let mut idcNode: xmlSchemaPSVIIDCNodePtr = 0
                    as *mut xmlSchemaPSVIIDCNode;
                i_0 = 0 as libc::c_int;
                while i_0 < (*(*matcher).targets).nbItems {
                    idcNode = *((*(*matcher).targets).items).offset(i_0 as isize)
                        as xmlSchemaPSVIIDCNodePtr;
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )((*idcNode).keys as *mut libc::c_void);
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(idcNode as *mut libc::c_void);
                    i_0 += 1;
                }
            }
            xmlSchemaItemListFree((*matcher).targets);
        }
        if !((*matcher).htab).is_null() {
            xmlHashFree(
                (*matcher).htab,
                Some(
                    xmlFreeIDCHashEntry
                        as unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
                ),
            );
        }
        xmlFree.expect("non-null function pointer")(matcher as *mut libc::c_void);
        matcher = next;
    }
}
unsafe extern "C" fn xmlSchemaIDCReleaseMatcherList(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut matcher: xmlSchemaIDCMatcherPtr,
) {
    let mut next: xmlSchemaIDCMatcherPtr = 0 as *mut xmlSchemaIDCMatcher;
    while !matcher.is_null() {
        next = (*matcher).next;
        if !((*matcher).keySeqs).is_null() {
            let mut i: libc::c_int = 0;
            i = 0 as libc::c_int;
            while i < (*matcher).sizeKeySeqs {
                if !(*((*matcher).keySeqs).offset(i as isize)).is_null() {
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(*((*matcher).keySeqs).offset(i as isize) as *mut libc::c_void);
                    let ref mut fresh468 = *((*matcher).keySeqs).offset(i as isize);
                    *fresh468 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                }
                i += 1;
            }
        }
        if !((*matcher).targets).is_null() {
            if (*matcher).idcType == XML_SCHEMA_TYPE_IDC_KEYREF as libc::c_int {
                let mut i_0: libc::c_int = 0;
                let mut idcNode: xmlSchemaPSVIIDCNodePtr = 0
                    as *mut xmlSchemaPSVIIDCNode;
                i_0 = 0 as libc::c_int;
                while i_0 < (*(*matcher).targets).nbItems {
                    idcNode = *((*(*matcher).targets).items).offset(i_0 as isize)
                        as xmlSchemaPSVIIDCNodePtr;
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )((*idcNode).keys as *mut libc::c_void);
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(idcNode as *mut libc::c_void);
                    i_0 += 1;
                }
            }
            xmlSchemaItemListFree((*matcher).targets);
            let ref mut fresh469 = (*matcher).targets;
            *fresh469 = 0 as xmlSchemaItemListPtr;
        }
        if !((*matcher).htab).is_null() {
            xmlHashFree(
                (*matcher).htab,
                Some(
                    xmlFreeIDCHashEntry
                        as unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
                ),
            );
            let ref mut fresh470 = (*matcher).htab;
            *fresh470 = 0 as xmlHashTablePtr;
        }
        let ref mut fresh471 = (*matcher).next;
        *fresh471 = 0 as xmlSchemaIDCMatcherPtr;
        if !((*vctxt).idcMatcherCache).is_null() {
            let ref mut fresh472 = (*matcher).nextCached;
            *fresh472 = (*vctxt).idcMatcherCache;
        }
        let ref mut fresh473 = (*vctxt).idcMatcherCache;
        *fresh473 = matcher;
        matcher = next;
    }
}
unsafe extern "C" fn xmlSchemaIDCAddStateObject(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut matcher: xmlSchemaIDCMatcherPtr,
    mut sel: xmlSchemaIDCSelectPtr,
    mut type_0: libc::c_int,
) -> libc::c_int {
    let mut sto: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    if !((*vctxt).xpathStatePool).is_null() {
        sto = (*vctxt).xpathStatePool;
        let ref mut fresh474 = (*vctxt).xpathStatePool;
        *fresh474 = (*sto).next;
        let ref mut fresh475 = (*sto).next;
        *fresh475 = 0 as xmlSchemaIDCStateObjPtr;
    } else {
        sto = xmlMalloc
            .expect(
                "non-null function pointer",
            )(::std::mem::size_of::<xmlSchemaIDCStateObj>() as libc::c_ulong)
            as xmlSchemaIDCStateObjPtr;
        if sto.is_null() {
            xmlSchemaVErrMemory(
                0 as xmlSchemaValidCtxtPtr,
                b"allocating an IDC state object\0" as *const u8 as *const libc::c_char,
                0 as xmlNodePtr,
            );
            return -(1 as libc::c_int);
        }
        memset(
            sto as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<xmlSchemaIDCStateObj>() as libc::c_ulong,
        );
    }
    if !((*vctxt).xpathStates).is_null() {
        let ref mut fresh476 = (*sto).next;
        *fresh476 = (*vctxt).xpathStates;
    }
    let ref mut fresh477 = (*vctxt).xpathStates;
    *fresh477 = sto;
    if !((*sto).xpathCtxt).is_null() {
        xmlFreeStreamCtxt((*sto).xpathCtxt as xmlStreamCtxtPtr);
    }
    let ref mut fresh478 = (*sto).xpathCtxt;
    *fresh478 = xmlPatternGetStreamCtxt((*sel).xpathComp as xmlPatternPtr)
        as *mut libc::c_void;
    if ((*sto).xpathCtxt).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaIDCAddStateObject\0" as *const u8 as *const libc::c_char,
            b"failed to create an XPath validation context\0" as *const u8
                as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    (*sto).type_0 = type_0;
    (*sto).depth = (*vctxt).depth;
    let ref mut fresh479 = (*sto).matcher;
    *fresh479 = matcher;
    let ref mut fresh480 = (*sto).sel;
    *fresh480 = sel;
    (*sto).nbHistory = 0 as libc::c_int;
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaXPathEvaluate(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut nodeType: xmlElementType,
) -> libc::c_int {
    let mut sto: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    let mut head: xmlSchemaIDCStateObjPtr = 0 as xmlSchemaIDCStateObjPtr;
    let mut first: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    let mut res: libc::c_int = 0;
    let mut resolved: libc::c_int = 0 as libc::c_int;
    let mut depth: libc::c_int = (*vctxt).depth;
    if ((*vctxt).xpathStates).is_null() {
        return 0 as libc::c_int;
    }
    if nodeType as libc::c_uint == XML_ATTRIBUTE_NODE as libc::c_int as libc::c_uint {
        depth += 1;
    }
    first = (*vctxt).xpathStates;
    sto = first;
    while sto != head {
        if nodeType as libc::c_uint == XML_ELEMENT_NODE as libc::c_int as libc::c_uint {
            res = xmlStreamPush(
                (*sto).xpathCtxt as xmlStreamCtxtPtr,
                (*(*vctxt).inode).localName,
                (*(*vctxt).inode).nsName,
            );
        } else {
            res = xmlStreamPushAttr(
                (*sto).xpathCtxt as xmlStreamCtxtPtr,
                (*(*vctxt).inode).localName,
                (*(*vctxt).inode).nsName,
            );
        }
        if res == -(1 as libc::c_int) {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaXPathEvaluate\0" as *const u8 as *const libc::c_char,
                b"calling xmlStreamPush()\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        if !(res == 0 as libc::c_int) {
            if ((*sto).history).is_null() {
                let ref mut fresh481 = (*sto).history;
                *fresh481 = xmlMalloc
                    .expect(
                        "non-null function pointer",
                    )(
                    (5 as libc::c_int as libc::c_ulong)
                        .wrapping_mul(
                            ::std::mem::size_of::<libc::c_int>() as libc::c_ulong,
                        ),
                ) as *mut libc::c_int;
                if ((*sto).history).is_null() {
                    xmlSchemaVErrMemory(
                        0 as xmlSchemaValidCtxtPtr,
                        b"allocating the state object history\0" as *const u8
                            as *const libc::c_char,
                        0 as xmlNodePtr,
                    );
                    return -(1 as libc::c_int);
                }
                (*sto).sizeHistory = 5 as libc::c_int;
            } else if (*sto).sizeHistory <= (*sto).nbHistory {
                (*sto).sizeHistory *= 2 as libc::c_int;
                let ref mut fresh482 = (*sto).history;
                *fresh482 = xmlRealloc
                    .expect(
                        "non-null function pointer",
                    )(
                    (*sto).history as *mut libc::c_void,
                    ((*sto).sizeHistory as libc::c_ulong)
                        .wrapping_mul(
                            ::std::mem::size_of::<libc::c_int>() as libc::c_ulong,
                        ),
                ) as *mut libc::c_int;
                if ((*sto).history).is_null() {
                    xmlSchemaVErrMemory(
                        0 as xmlSchemaValidCtxtPtr,
                        b"re-allocating the state object history\0" as *const u8
                            as *const libc::c_char,
                        0 as xmlNodePtr,
                    );
                    return -(1 as libc::c_int);
                }
            }
            let ref mut fresh483 = (*sto).nbHistory;
            let fresh484 = *fresh483;
            *fresh483 = *fresh483 + 1;
            *((*sto).history).offset(fresh484 as isize) = depth;
            if (*sto).type_0 == 1 as libc::c_int {
                let mut sel: xmlSchemaIDCSelectPtr = 0 as *mut xmlSchemaIDCSelect;
                sel = (*(*(*(*sto).matcher).aidc).def).fields;
                while !sel.is_null() {
                    if xmlSchemaIDCAddStateObject(
                        vctxt,
                        (*sto).matcher,
                        sel,
                        2 as libc::c_int,
                    ) == -(1 as libc::c_int)
                    {
                        return -(1 as libc::c_int);
                    }
                    sel = (*sel).next;
                }
            } else if (*sto).type_0 == 2 as libc::c_int {
                if resolved == 0 as libc::c_int {
                    if (*(*vctxt).inode).flags & (1 as libc::c_int) << 4 as libc::c_int
                        == 0 as libc::c_int
                    {
                        (*(*vctxt).inode).flags
                            |= (1 as libc::c_int) << 4 as libc::c_int;
                    }
                }
                resolved += 1;
            }
        }
        if ((*sto).next).is_null() {
            head = first;
            sto = (*vctxt).xpathStates;
        } else {
            sto = (*sto).next;
        }
    }
    return resolved;
}
unsafe extern "C" fn xmlSchemaFormatIDCKeySequence_1(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut buf: *mut *mut xmlChar,
    mut seq: *mut xmlSchemaPSVIIDCKeyPtr,
    mut count: libc::c_int,
    mut for_hash: libc::c_int,
) -> *const xmlChar {
    let mut i: libc::c_int = 0;
    let mut res: libc::c_int = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    *buf = xmlStrdup(b"[\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    i = 0 as libc::c_int;
    while i < count {
        *buf = xmlStrcat(
            *buf,
            b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        );
        if for_hash == 0 {
            res = xmlSchemaGetCanonValueWhtspExt(
                (**seq.offset(i as isize)).val,
                xmlSchemaGetWhiteSpaceFacetValue((**seq.offset(i as isize)).type_0),
                &mut value,
            );
        } else {
            res = xmlSchemaGetCanonValueHash((**seq.offset(i as isize)).val, &mut value);
        }
        if res == 0 as libc::c_int {
            *buf = xmlStrcat(*buf, value);
        } else {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaFormatIDCKeySequence\0" as *const u8 as *const libc::c_char,
                b"failed to compute a canonical value\0" as *const u8
                    as *const libc::c_char,
            );
            *buf = xmlStrcat(
                *buf,
                b"???\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            );
        }
        if i < count - 1 as libc::c_int {
            *buf = xmlStrcat(
                *buf,
                b"', \0" as *const u8 as *const libc::c_char as *mut xmlChar,
            );
        } else {
            *buf = xmlStrcat(
                *buf,
                b"'\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            );
        }
        if !value.is_null() {
            xmlFree.expect("non-null function pointer")(value as *mut libc::c_void);
            value = 0 as *mut xmlChar;
        }
        i += 1;
    }
    *buf = xmlStrcat(*buf, b"]\0" as *const u8 as *const libc::c_char as *mut xmlChar);
    return *buf;
}
unsafe extern "C" fn xmlSchemaFormatIDCKeySequence(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut buf: *mut *mut xmlChar,
    mut seq: *mut xmlSchemaPSVIIDCKeyPtr,
    mut count: libc::c_int,
) -> *const xmlChar {
    return xmlSchemaFormatIDCKeySequence_1(vctxt, buf, seq, count, 0 as libc::c_int);
}
unsafe extern "C" fn xmlSchemaHashKeySequence(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut buf: *mut *mut xmlChar,
    mut seq: *mut xmlSchemaPSVIIDCKeyPtr,
    mut count: libc::c_int,
) -> *const xmlChar {
    return xmlSchemaFormatIDCKeySequence_1(vctxt, buf, seq, count, 1 as libc::c_int);
}
unsafe extern "C" fn xmlSchemaXPathPop(mut vctxt: xmlSchemaValidCtxtPtr) -> libc::c_int {
    let mut sto: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    let mut res: libc::c_int = 0;
    if ((*vctxt).xpathStates).is_null() {
        return 0 as libc::c_int;
    }
    sto = (*vctxt).xpathStates;
    loop {
        res = xmlStreamPop((*sto).xpathCtxt as xmlStreamCtxtPtr);
        if res == -(1 as libc::c_int) {
            return -(1 as libc::c_int);
        }
        sto = (*sto).next;
        if sto.is_null() {
            break;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaXPathProcessHistory(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut depth: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut sto: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    let mut nextsto: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    let mut res: libc::c_int = 0;
    let mut matchDepth: libc::c_int = 0;
    let mut key: xmlSchemaPSVIIDCKeyPtr = 0 as xmlSchemaPSVIIDCKeyPtr;
    let mut type_0: xmlSchemaTypePtr = (*(*vctxt).inode).typeDef;
    let mut simpleType: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
    if ((*vctxt).xpathStates).is_null() {
        return 0 as libc::c_int;
    }
    sto = (*vctxt).xpathStates;
    while !sto.is_null() {
        res = xmlStreamPop((*sto).xpathCtxt as xmlStreamCtxtPtr);
        if res == -(1 as libc::c_int) {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaXPathProcessHistory\0" as *const u8 as *const libc::c_char,
                b"calling xmlStreamPop()\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        if !((*sto).nbHistory == 0 as libc::c_int) {
            matchDepth = *((*sto).history)
                .offset(((*sto).nbHistory - 1 as libc::c_int) as isize);
            if matchDepth != depth {
                sto = (*sto).next;
                continue;
            } else {
                if (*sto).type_0 == 2 as libc::c_int {
                    if (*type_0).type_0 as libc::c_uint
                        == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
                        || (*type_0).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int
                    {
                        if (*type_0).contentType as libc::c_uint
                            == XML_SCHEMA_CONTENT_SIMPLE as libc::c_int as libc::c_uint
                            || (*type_0).contentType as libc::c_uint
                                == XML_SCHEMA_CONTENT_BASIC as libc::c_int as libc::c_uint
                        {
                            simpleType = (*type_0).contentTypeDef;
                            if simpleType.is_null() {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaXPathProcessHistory\0" as *const u8
                                        as *const libc::c_char,
                                    b"field resolves to a CT with simple content but the CT is missing the ST definition\0"
                                        as *const u8 as *const libc::c_char,
                                );
                                return -(1 as libc::c_int);
                            }
                        } else {
                            simpleType = 0 as xmlSchemaTypePtr;
                        }
                    } else {
                        simpleType = type_0;
                    }
                    if simpleType.is_null() {
                        let mut str: *mut xmlChar = 0 as *mut xmlChar;
                        xmlSchemaCustomErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            XML_SCHEMAV_CVC_IDC,
                            0 as xmlNodePtr,
                            (*(*(*sto).matcher).aidc).def as xmlSchemaBasicItemPtr,
                            b"The XPath '%s' of a field of %s does evaluate to a node of non-simple type\0"
                                as *const u8 as *const libc::c_char,
                            (*(*sto).sel).xpath,
                            xmlSchemaGetIDCDesignation(
                                &mut str,
                                (*(*(*sto).matcher).aidc).def,
                            ),
                        );
                        if !str.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(str as *mut libc::c_void);
                            str = 0 as *mut xmlChar;
                        }
                        let ref mut fresh485 = (*sto).nbHistory;
                        *fresh485 -= 1;
                        current_block = 10234920862480524530;
                    } else if key.is_null() && ((*(*vctxt).inode).val).is_null() {
                        xmlSchemaCustomErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            XML_SCHEMAV_CVC_IDC,
                            0 as xmlNodePtr,
                            (*(*(*sto).matcher).aidc).def as xmlSchemaBasicItemPtr,
                            b"Warning: No precomputed value available, the value was either invalid or something strange happened\0"
                                as *const u8 as *const libc::c_char,
                            0 as *const xmlChar,
                            0 as *const xmlChar,
                        );
                        let ref mut fresh486 = (*sto).nbHistory;
                        *fresh486 -= 1;
                        current_block = 10234920862480524530;
                    } else {
                        let mut matcher: xmlSchemaIDCMatcherPtr = (*sto).matcher;
                        let mut keySeq: *mut xmlSchemaPSVIIDCKeyPtr = 0
                            as *mut xmlSchemaPSVIIDCKeyPtr;
                        let mut pos: libc::c_int = 0;
                        let mut idx: libc::c_int = 0;
                        pos = (*sto).depth - (*matcher).depth;
                        idx = (*(*sto).sel).index;
                        if ((*matcher).keySeqs).is_null() {
                            if pos > 9 as libc::c_int {
                                (*matcher).sizeKeySeqs = pos * 2 as libc::c_int;
                            } else {
                                (*matcher).sizeKeySeqs = 10 as libc::c_int;
                            }
                            let ref mut fresh487 = (*matcher).keySeqs;
                            *fresh487 = xmlMalloc
                                .expect(
                                    "non-null function pointer",
                                )(
                                ((*matcher).sizeKeySeqs as libc::c_ulong)
                                    .wrapping_mul(
                                        ::std::mem::size_of::<*mut xmlSchemaPSVIIDCKeyPtr>()
                                            as libc::c_ulong,
                                    ),
                            ) as *mut *mut xmlSchemaPSVIIDCKeyPtr;
                            if ((*matcher).keySeqs).is_null() {
                                xmlSchemaVErrMemory(
                                    0 as xmlSchemaValidCtxtPtr,
                                    b"allocating an array of key-sequences\0" as *const u8
                                        as *const libc::c_char,
                                    0 as xmlNodePtr,
                                );
                                return -(1 as libc::c_int);
                            }
                            memset(
                                (*matcher).keySeqs as *mut libc::c_void,
                                0 as libc::c_int,
                                ((*matcher).sizeKeySeqs as libc::c_ulong)
                                    .wrapping_mul(
                                        ::std::mem::size_of::<*mut xmlSchemaPSVIIDCKeyPtr>()
                                            as libc::c_ulong,
                                    ),
                            );
                        } else if pos >= (*matcher).sizeKeySeqs {
                            let mut i: libc::c_int = (*matcher).sizeKeySeqs;
                            (*matcher).sizeKeySeqs *= 2 as libc::c_int;
                            let ref mut fresh488 = (*matcher).keySeqs;
                            *fresh488 = xmlRealloc
                                .expect(
                                    "non-null function pointer",
                                )(
                                (*matcher).keySeqs as *mut libc::c_void,
                                ((*matcher).sizeKeySeqs as libc::c_ulong)
                                    .wrapping_mul(
                                        ::std::mem::size_of::<*mut xmlSchemaPSVIIDCKeyPtr>()
                                            as libc::c_ulong,
                                    ),
                            ) as *mut *mut xmlSchemaPSVIIDCKeyPtr;
                            if ((*matcher).keySeqs).is_null() {
                                xmlSchemaVErrMemory(
                                    0 as xmlSchemaValidCtxtPtr,
                                    b"reallocating an array of key-sequences\0" as *const u8
                                        as *const libc::c_char,
                                    0 as xmlNodePtr,
                                );
                                return -(1 as libc::c_int);
                            }
                            while i < (*matcher).sizeKeySeqs {
                                let ref mut fresh489 = *((*matcher).keySeqs)
                                    .offset(i as isize);
                                *fresh489 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                i += 1;
                            }
                        }
                        keySeq = *((*matcher).keySeqs).offset(pos as isize);
                        if keySeq.is_null() {
                            keySeq = xmlMalloc
                                .expect(
                                    "non-null function pointer",
                                )(
                                ((*(*(*matcher).aidc).def).nbFields as libc::c_ulong)
                                    .wrapping_mul(
                                        ::std::mem::size_of::<xmlSchemaPSVIIDCKeyPtr>()
                                            as libc::c_ulong,
                                    ),
                            ) as *mut xmlSchemaPSVIIDCKeyPtr;
                            if keySeq.is_null() {
                                xmlSchemaVErrMemory(
                                    0 as xmlSchemaValidCtxtPtr,
                                    b"allocating an IDC key-sequence\0" as *const u8
                                        as *const libc::c_char,
                                    0 as xmlNodePtr,
                                );
                                return -(1 as libc::c_int);
                            }
                            memset(
                                keySeq as *mut libc::c_void,
                                0 as libc::c_int,
                                ((*(*(*matcher).aidc).def).nbFields as libc::c_ulong)
                                    .wrapping_mul(
                                        ::std::mem::size_of::<xmlSchemaPSVIIDCKeyPtr>()
                                            as libc::c_ulong,
                                    ),
                            );
                            let ref mut fresh491 = *((*matcher).keySeqs)
                                .offset(pos as isize);
                            *fresh491 = keySeq;
                            current_block = 2291247057274820162;
                        } else if !(*keySeq.offset(idx as isize)).is_null() {
                            let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                            xmlSchemaCustomErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAV_CVC_IDC,
                                0 as xmlNodePtr,
                                (*(*matcher).aidc).def as xmlSchemaBasicItemPtr,
                                b"The XPath '%s' of a field of %s evaluates to a node-set with more than one member\0"
                                    as *const u8 as *const libc::c_char,
                                (*(*sto).sel).xpath,
                                xmlSchemaGetIDCDesignation(
                                    &mut str_0,
                                    (*(*matcher).aidc).def,
                                ),
                            );
                            if !str_0.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(str_0 as *mut libc::c_void);
                                str_0 = 0 as *mut xmlChar;
                            }
                            let ref mut fresh490 = (*sto).nbHistory;
                            *fresh490 -= 1;
                            current_block = 10234920862480524530;
                        } else {
                            current_block = 2291247057274820162;
                        }
                        match current_block {
                            10234920862480524530 => {}
                            _ => {
                                if key.is_null() {
                                    key = xmlMalloc
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        ::std::mem::size_of::<xmlSchemaPSVIIDCKey>()
                                            as libc::c_ulong,
                                    ) as xmlSchemaPSVIIDCKeyPtr;
                                    if key.is_null() {
                                        xmlSchemaVErrMemory(
                                            0 as xmlSchemaValidCtxtPtr,
                                            b"allocating a IDC key\0" as *const u8
                                                as *const libc::c_char,
                                            0 as xmlNodePtr,
                                        );
                                        xmlFree
                                            .expect(
                                                "non-null function pointer",
                                            )(keySeq as *mut libc::c_void);
                                        let ref mut fresh492 = *((*matcher).keySeqs)
                                            .offset(pos as isize);
                                        *fresh492 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                        return -(1 as libc::c_int);
                                    }
                                    let ref mut fresh493 = (*key).type_0;
                                    *fresh493 = simpleType;
                                    let ref mut fresh494 = (*key).val;
                                    *fresh494 = (*(*vctxt).inode).val;
                                    let ref mut fresh495 = (*(*vctxt).inode).val;
                                    *fresh495 = 0 as xmlSchemaValPtr;
                                    if xmlSchemaIDCStoreKey(vctxt, key) == -(1 as libc::c_int) {
                                        xmlSchemaIDCFreeKey(key);
                                        return -(1 as libc::c_int);
                                    }
                                }
                                let ref mut fresh496 = *keySeq.offset(idx as isize);
                                *fresh496 = key;
                                current_block = 8288085890650723895;
                            }
                        }
                    }
                } else if (*sto).type_0 == 1 as libc::c_int {
                    let mut keySeq_0: *mut *mut xmlSchemaPSVIIDCKeyPtr = 0
                        as *mut *mut xmlSchemaPSVIIDCKeyPtr;
                    let mut ntItem: xmlSchemaPSVIIDCNodePtr = 0
                        as *mut xmlSchemaPSVIIDCNode;
                    let mut matcher_0: xmlSchemaIDCMatcherPtr = 0
                        as *mut xmlSchemaIDCMatcher;
                    let mut idc: xmlSchemaIDCPtr = 0 as *mut xmlSchemaIDC;
                    let mut targets: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
                    let mut pos_0: libc::c_int = 0;
                    let mut i_0: libc::c_int = 0;
                    let mut j: libc::c_int = 0;
                    let mut nbKeys: libc::c_int = 0;
                    matcher_0 = (*sto).matcher;
                    idc = (*(*matcher_0).aidc).def;
                    nbKeys = (*idc).nbFields;
                    pos_0 = depth - (*matcher_0).depth;
                    if ((*matcher_0).keySeqs).is_null()
                        || (*matcher_0).sizeKeySeqs <= pos_0
                    {
                        if (*idc).type_0 as libc::c_uint
                            == XML_SCHEMA_TYPE_IDC_KEY as libc::c_int as libc::c_uint
                        {
                            current_block = 13895810181616587163;
                        } else {
                            current_block = 17168440009377621674;
                        }
                    } else {
                        keySeq_0 = &mut *((*matcher_0).keySeqs).offset(pos_0 as isize)
                            as *mut *mut xmlSchemaPSVIIDCKeyPtr;
                        if (*keySeq_0).is_null() {
                            if (*idc).type_0 as libc::c_uint
                                == XML_SCHEMA_TYPE_IDC_KEY as libc::c_int as libc::c_uint
                            {
                                current_block = 13895810181616587163;
                            } else {
                                current_block = 17168440009377621674;
                            }
                        } else {
                            i_0 = 0 as libc::c_int;
                            loop {
                                if !(i_0 < nbKeys) {
                                    current_block = 14612007084265645573;
                                    break;
                                }
                                if (*(*keySeq_0).offset(i_0 as isize)).is_null() {
                                    if (*idc).type_0 as libc::c_uint
                                        == XML_SCHEMA_TYPE_IDC_KEY as libc::c_int as libc::c_uint
                                    {
                                        current_block = 13895810181616587163;
                                        break;
                                    } else {
                                        current_block = 17168440009377621674;
                                        break;
                                    }
                                } else {
                                    i_0 += 1;
                                }
                            }
                            match current_block {
                                13895810181616587163 => {}
                                17168440009377621674 => {}
                                _ => {
                                    targets = xmlSchemaIDCAcquireTargetList(vctxt, matcher_0);
                                    if (*idc).type_0 as libc::c_uint
                                        != XML_SCHEMA_TYPE_IDC_KEYREF as libc::c_int as libc::c_uint
                                        && (*targets).nbItems != 0 as libc::c_int
                                    {
                                        let mut ckey: xmlSchemaPSVIIDCKeyPtr = 0
                                            as *mut xmlSchemaPSVIIDCKey;
                                        let mut bkey: xmlSchemaPSVIIDCKeyPtr = 0
                                            as *mut xmlSchemaPSVIIDCKey;
                                        let mut bkeySeq: *mut xmlSchemaPSVIIDCKeyPtr = 0
                                            as *mut xmlSchemaPSVIIDCKeyPtr;
                                        let mut e: xmlIDCHashEntryPtr = 0 as *mut xmlIDCHashEntry;
                                        res = 0 as libc::c_int;
                                        if ((*matcher_0).htab).is_null() {
                                            e = 0 as xmlIDCHashEntryPtr;
                                        } else {
                                            let mut value: *mut xmlChar = 0 as *mut xmlChar;
                                            xmlSchemaHashKeySequence(
                                                vctxt,
                                                &mut value,
                                                *keySeq_0,
                                                nbKeys,
                                            );
                                            e = xmlHashLookup((*matcher_0).htab, value)
                                                as xmlIDCHashEntryPtr;
                                            if !value.is_null() {
                                                xmlFree
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(value as *mut libc::c_void);
                                                value = 0 as *mut xmlChar;
                                            }
                                        }
                                        while !e.is_null() {
                                            bkeySeq = (*(*((*targets).items).offset((*e).index as isize)
                                                as xmlSchemaPSVIIDCNodePtr))
                                                .keys;
                                            j = 0 as libc::c_int;
                                            while j < nbKeys {
                                                ckey = *(*keySeq_0).offset(j as isize);
                                                bkey = *bkeySeq.offset(j as isize);
                                                res = xmlSchemaAreValuesEqual((*ckey).val, (*bkey).val);
                                                if res == -(1 as libc::c_int) {
                                                    return -(1 as libc::c_int)
                                                } else {
                                                    if res == 0 as libc::c_int {
                                                        break;
                                                    }
                                                    j += 1;
                                                }
                                            }
                                            if res == 1 as libc::c_int {
                                                break;
                                            }
                                            e = (*e).next;
                                        }
                                        if !e.is_null() {
                                            let mut str_1: *mut xmlChar = 0 as *mut xmlChar;
                                            let mut strB: *mut xmlChar = 0 as *mut xmlChar;
                                            xmlSchemaCustomErr(
                                                vctxt as xmlSchemaAbstractCtxtPtr,
                                                XML_SCHEMAV_CVC_IDC,
                                                0 as xmlNodePtr,
                                                idc as xmlSchemaBasicItemPtr,
                                                b"Duplicate key-sequence %s in %s\0" as *const u8
                                                    as *const libc::c_char,
                                                xmlSchemaFormatIDCKeySequence(
                                                    vctxt,
                                                    &mut str_1,
                                                    *keySeq_0,
                                                    nbKeys,
                                                ),
                                                xmlSchemaGetIDCDesignation(&mut strB, idc),
                                            );
                                            if !str_1.is_null() {
                                                xmlFree
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(str_1 as *mut libc::c_void);
                                                str_1 = 0 as *mut xmlChar;
                                            }
                                            if !strB.is_null() {
                                                xmlFree
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(strB as *mut libc::c_void);
                                                strB = 0 as *mut xmlChar;
                                            }
                                            current_block = 17168440009377621674;
                                        } else {
                                            current_block = 2704538829018177290;
                                        }
                                    } else {
                                        current_block = 2704538829018177290;
                                    }
                                    match current_block {
                                        17168440009377621674 => {}
                                        _ => {
                                            ntItem = xmlMalloc
                                                .expect(
                                                    "non-null function pointer",
                                                )(
                                                ::std::mem::size_of::<xmlSchemaPSVIIDCNode>()
                                                    as libc::c_ulong,
                                            ) as xmlSchemaPSVIIDCNodePtr;
                                            if ntItem.is_null() {
                                                xmlSchemaVErrMemory(
                                                    0 as xmlSchemaValidCtxtPtr,
                                                    b"allocating an IDC node-table item\0" as *const u8
                                                        as *const libc::c_char,
                                                    0 as xmlNodePtr,
                                                );
                                                xmlFree
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(*keySeq_0 as *mut libc::c_void);
                                                *keySeq_0 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                                return -(1 as libc::c_int);
                                            }
                                            memset(
                                                ntItem as *mut libc::c_void,
                                                0 as libc::c_int,
                                                ::std::mem::size_of::<xmlSchemaPSVIIDCNode>()
                                                    as libc::c_ulong,
                                            );
                                            if (*idc).type_0 as libc::c_uint
                                                != XML_SCHEMA_TYPE_IDC_KEYREF as libc::c_int as libc::c_uint
                                            {
                                                if xmlSchemaIDCStoreNodeTableItem(vctxt, ntItem)
                                                    == -(1 as libc::c_int)
                                                {
                                                    xmlFree
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(ntItem as *mut libc::c_void);
                                                    xmlFree
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(*keySeq_0 as *mut libc::c_void);
                                                    *keySeq_0 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                                    return -(1 as libc::c_int);
                                                }
                                                (*ntItem).nodeQNameID = -(1 as libc::c_int);
                                            } else {
                                                (*ntItem)
                                                    .nodeQNameID = xmlSchemaVAddNodeQName(
                                                    vctxt,
                                                    (*(*vctxt).inode).localName,
                                                    (*(*vctxt).inode).nsName,
                                                );
                                                if (*ntItem).nodeQNameID == -(1 as libc::c_int) {
                                                    xmlFree
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(ntItem as *mut libc::c_void);
                                                    xmlFree
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(*keySeq_0 as *mut libc::c_void);
                                                    *keySeq_0 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                                    return -(1 as libc::c_int);
                                                }
                                            }
                                            let ref mut fresh497 = (*ntItem).node;
                                            *fresh497 = (*vctxt).node;
                                            (*ntItem).nodeLine = (*(*vctxt).inode).nodeLine;
                                            let ref mut fresh498 = (*ntItem).keys;
                                            *fresh498 = *keySeq_0;
                                            *keySeq_0 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                            if xmlSchemaItemListAdd(
                                                targets,
                                                ntItem as *mut libc::c_void,
                                            ) == -(1 as libc::c_int)
                                            {
                                                if (*idc).type_0 as libc::c_uint
                                                    == XML_SCHEMA_TYPE_IDC_KEYREF as libc::c_int as libc::c_uint
                                                {
                                                    xmlFree
                                                        .expect(
                                                            "non-null function pointer",
                                                        )((*ntItem).keys as *mut libc::c_void);
                                                    xmlFree
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(ntItem as *mut libc::c_void);
                                                }
                                                return -(1 as libc::c_int);
                                            }
                                            if (*idc).type_0 as libc::c_uint
                                                != XML_SCHEMA_TYPE_IDC_KEYREF as libc::c_int as libc::c_uint
                                            {
                                                let mut value_0: *mut xmlChar = 0 as *mut xmlChar;
                                                let mut r: xmlIDCHashEntryPtr = 0 as *mut xmlIDCHashEntry;
                                                let mut e_0: xmlIDCHashEntryPtr = 0 as *mut xmlIDCHashEntry;
                                                if ((*matcher_0).htab).is_null() {
                                                    let ref mut fresh499 = (*matcher_0).htab;
                                                    *fresh499 = xmlHashCreate(4 as libc::c_int);
                                                }
                                                xmlSchemaHashKeySequence(
                                                    vctxt,
                                                    &mut value_0,
                                                    (*ntItem).keys,
                                                    nbKeys,
                                                );
                                                e_0 = xmlMalloc
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(::std::mem::size_of::<xmlIDCHashEntry>() as libc::c_ulong)
                                                    as xmlIDCHashEntryPtr;
                                                (*e_0).index = (*targets).nbItems - 1 as libc::c_int;
                                                r = xmlHashLookup((*matcher_0).htab, value_0)
                                                    as xmlIDCHashEntryPtr;
                                                if !r.is_null() {
                                                    let ref mut fresh500 = (*e_0).next;
                                                    *fresh500 = (*r).next;
                                                    let ref mut fresh501 = (*r).next;
                                                    *fresh501 = e_0;
                                                } else {
                                                    let ref mut fresh502 = (*e_0).next;
                                                    *fresh502 = 0 as xmlIDCHashEntryPtr;
                                                    xmlHashAddEntry(
                                                        (*matcher_0).htab,
                                                        value_0,
                                                        e_0 as *mut libc::c_void,
                                                    );
                                                }
                                                if !value_0.is_null() {
                                                    xmlFree
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(value_0 as *mut libc::c_void);
                                                    value_0 = 0 as *mut xmlChar;
                                                }
                                            }
                                            current_block = 17168440009377621674;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    match current_block {
                        13895810181616587163 => {
                            let mut str_2: *mut xmlChar = 0 as *mut xmlChar;
                            xmlSchemaCustomErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAV_CVC_IDC,
                                0 as xmlNodePtr,
                                idc as xmlSchemaBasicItemPtr,
                                b"Not all fields of %s evaluate to a node\0" as *const u8
                                    as *const libc::c_char,
                                xmlSchemaGetIDCDesignation(&mut str_2, idc),
                                0 as *const xmlChar,
                            );
                            if !str_2.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(str_2 as *mut libc::c_void);
                                str_2 = 0 as *mut xmlChar;
                            }
                        }
                        _ => {}
                    }
                    if !keySeq_0.is_null() && !(*keySeq_0).is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(*keySeq_0 as *mut libc::c_void);
                        *keySeq_0 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                    }
                    current_block = 8288085890650723895;
                } else {
                    current_block = 8288085890650723895;
                }
                match current_block {
                    10234920862480524530 => {}
                    _ => {
                        let ref mut fresh503 = (*sto).nbHistory;
                        *fresh503 -= 1;
                    }
                }
            }
        }
        if (*sto).nbHistory == 0 as libc::c_int && (*sto).depth == depth {
            if (*vctxt).xpathStates != sto {
                xmlSchemaInternalErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaXPathProcessHistory\0" as *const u8
                        as *const libc::c_char,
                    b"The state object to be removed is not the first in the list\0"
                        as *const u8 as *const libc::c_char,
                );
            }
            nextsto = (*sto).next;
            let ref mut fresh504 = (*vctxt).xpathStates;
            *fresh504 = (*sto).next;
            let ref mut fresh505 = (*sto).next;
            *fresh505 = (*vctxt).xpathStatePool;
            let ref mut fresh506 = (*vctxt).xpathStatePool;
            *fresh506 = sto;
            sto = nextsto;
        } else {
            sto = (*sto).next;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaIDCRegisterMatchers(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut elemDecl: xmlSchemaElementPtr,
) -> libc::c_int {
    let mut matcher: xmlSchemaIDCMatcherPtr = 0 as *mut xmlSchemaIDCMatcher;
    let mut last: xmlSchemaIDCMatcherPtr = 0 as xmlSchemaIDCMatcherPtr;
    let mut idc: xmlSchemaIDCPtr = 0 as *mut xmlSchemaIDC;
    let mut refIdc: xmlSchemaIDCPtr = 0 as *mut xmlSchemaIDC;
    let mut aidc: xmlSchemaIDCAugPtr = 0 as *mut xmlSchemaIDCAug;
    idc = (*elemDecl).idcs as xmlSchemaIDCPtr;
    if idc.is_null() {
        return 0 as libc::c_int;
    }
    if !((*(*vctxt).inode).idcMatchers).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaIDCRegisterMatchers\0" as *const u8 as *const libc::c_char,
            b"The chain of IDC matchers is expected to be empty\0" as *const u8
                as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    loop {
        if (*idc).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_IDC_KEYREF as libc::c_int as libc::c_uint
        {
            refIdc = (*(*idc).ref_0).item as xmlSchemaIDCPtr;
            if !refIdc.is_null() {
                (*(*vctxt).inode).hasKeyrefs = 1 as libc::c_int;
                aidc = (*vctxt).aidcs;
                while !aidc.is_null() {
                    if (*aidc).def == refIdc {
                        break;
                    }
                    aidc = (*aidc).next;
                }
                if aidc.is_null() {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaIDCRegisterMatchers\0" as *const u8
                            as *const libc::c_char,
                        b"Could not find an augmented IDC item for an IDC definition\0"
                            as *const u8 as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
                if (*aidc).keyrefDepth == -(1 as libc::c_int)
                    || (*vctxt).depth < (*aidc).keyrefDepth
                {
                    (*aidc).keyrefDepth = (*vctxt).depth;
                }
            }
        }
        aidc = (*vctxt).aidcs;
        while !aidc.is_null() {
            if (*aidc).def == idc {
                break;
            }
            aidc = (*aidc).next;
        }
        if aidc.is_null() {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaIDCRegisterMatchers\0" as *const u8 as *const libc::c_char,
                b"Could not find an augmented IDC item for an IDC definition\0"
                    as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        if !((*vctxt).idcMatcherCache).is_null() {
            matcher = (*vctxt).idcMatcherCache;
            let ref mut fresh507 = (*vctxt).idcMatcherCache;
            *fresh507 = (*matcher).nextCached;
            let ref mut fresh508 = (*matcher).nextCached;
            *fresh508 = 0 as xmlSchemaIDCMatcherPtr;
        } else {
            matcher = xmlMalloc
                .expect(
                    "non-null function pointer",
                )(::std::mem::size_of::<xmlSchemaIDCMatcher>() as libc::c_ulong)
                as xmlSchemaIDCMatcherPtr;
            if matcher.is_null() {
                xmlSchemaVErrMemory(
                    vctxt,
                    b"allocating an IDC matcher\0" as *const u8 as *const libc::c_char,
                    0 as xmlNodePtr,
                );
                return -(1 as libc::c_int);
            }
            memset(
                matcher as *mut libc::c_void,
                0 as libc::c_int,
                ::std::mem::size_of::<xmlSchemaIDCMatcher>() as libc::c_ulong,
            );
        }
        if last.is_null() {
            let ref mut fresh509 = (*(*vctxt).inode).idcMatchers;
            *fresh509 = matcher;
        } else {
            let ref mut fresh510 = (*last).next;
            *fresh510 = matcher;
        }
        last = matcher;
        (*matcher).type_0 = 0 as libc::c_int;
        (*matcher).depth = (*vctxt).depth;
        let ref mut fresh511 = (*matcher).aidc;
        *fresh511 = aidc;
        (*matcher).idcType = (*(*aidc).def).type_0 as libc::c_int;
        if xmlSchemaIDCAddStateObject(vctxt, matcher, (*idc).selector, 1 as libc::c_int)
            == -(1 as libc::c_int)
        {
            return -(1 as libc::c_int);
        }
        idc = (*idc).next;
        if idc.is_null() {
            break;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaIDCFillNodeTables(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut ielem: xmlSchemaNodeInfoPtr,
) -> libc::c_int {
    let mut current_block: u64;
    let mut bind: xmlSchemaPSVIIDCBindingPtr = 0 as *mut xmlSchemaPSVIIDCBinding;
    let mut res: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut nbTargets: libc::c_int = 0;
    let mut nbFields: libc::c_int = 0;
    let mut nbDupls: libc::c_int = 0;
    let mut nbNodeTable: libc::c_int = 0;
    let mut keys: *mut xmlSchemaPSVIIDCKeyPtr = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
    let mut ntkeys: *mut xmlSchemaPSVIIDCKeyPtr = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
    let mut targets: *mut xmlSchemaPSVIIDCNodePtr = 0 as *mut xmlSchemaPSVIIDCNodePtr;
    let mut dupls: *mut xmlSchemaPSVIIDCNodePtr = 0 as *mut xmlSchemaPSVIIDCNodePtr;
    let mut matcher: xmlSchemaIDCMatcherPtr = (*ielem).idcMatchers;
    's_17: loop {
        if matcher.is_null() {
            current_block = 14541395414537699361;
            break;
        }
        if (*(*(*matcher).aidc).def).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_IDC_KEYREF as libc::c_int as libc::c_uint
            || (((*matcher).targets).is_null()
                || (*(*matcher).targets).nbItems == 0 as libc::c_int)
        {
            matcher = (*matcher).next;
        } else if (*vctxt).createIDCNodeTables == 0
                && ((*(*matcher).aidc).keyrefDepth == -(1 as libc::c_int)
                    || (*(*matcher).aidc).keyrefDepth > (*vctxt).depth)
            {
            matcher = (*matcher).next;
        } else {
            bind = xmlSchemaIDCAcquireBinding(vctxt, matcher);
            if bind.is_null() {
                current_block = 17119793500333090447;
                break;
            }
            if !(((*bind).dupls).is_null()
                || (*(*bind).dupls).nbItems == 0 as libc::c_int)
            {
                dupls = (*(*bind).dupls).items as *mut xmlSchemaPSVIIDCNodePtr;
                nbDupls = (*(*bind).dupls).nbItems;
            } else {
                dupls = 0 as *mut xmlSchemaPSVIIDCNodePtr;
                nbDupls = 0 as libc::c_int;
            }
            if !((*bind).nodeTable).is_null() {
                nbNodeTable = (*bind).nbNodes;
            } else {
                nbNodeTable = 0 as libc::c_int;
            }
            if nbNodeTable == 0 as libc::c_int && nbDupls == 0 as libc::c_int {
                let ref mut fresh512 = (*bind).nodeTable;
                *fresh512 = (*(*matcher).targets).items as *mut xmlSchemaPSVIIDCNodePtr;
                (*bind).sizeNodes = (*(*matcher).targets).sizeItems;
                (*bind).nbNodes = (*(*matcher).targets).nbItems;
                let ref mut fresh513 = (*(*matcher).targets).items;
                *fresh513 = 0 as *mut *mut libc::c_void;
                (*(*matcher).targets).sizeItems = 0 as libc::c_int;
                (*(*matcher).targets).nbItems = 0 as libc::c_int;
                if !((*matcher).htab).is_null() {
                    xmlHashFree(
                        (*matcher).htab,
                        Some(
                            xmlFreeIDCHashEntry
                                as unsafe extern "C" fn(
                                    *mut libc::c_void,
                                    *const xmlChar,
                                ) -> (),
                        ),
                    );
                    let ref mut fresh514 = (*matcher).htab;
                    *fresh514 = 0 as xmlHashTablePtr;
                }
            } else {
                nbTargets = (*(*matcher).targets).nbItems;
                targets = (*(*matcher).targets).items as *mut xmlSchemaPSVIIDCNodePtr;
                nbFields = (*(*(*matcher).aidc).def).nbFields;
                i = 0 as libc::c_int;
                loop {
                    keys = (**targets.offset(i as isize)).keys;
                    if nbDupls != 0 {
                        j = 0 as libc::c_int;
                        loop {
                            if nbFields == 1 as libc::c_int {
                                res = xmlSchemaAreValuesEqual(
                                    (**keys.offset(0 as libc::c_int as isize)).val,
                                    (**((**dupls.offset(j as isize)).keys)
                                        .offset(0 as libc::c_int as isize))
                                        .val,
                                );
                                if res == -(1 as libc::c_int) {
                                    current_block = 17119793500333090447;
                                    break 's_17;
                                }
                                if res == 1 as libc::c_int {
                                    current_block = 7654530974828906095;
                                    break;
                                }
                            } else {
                                res = 0 as libc::c_int;
                                ntkeys = (**dupls.offset(j as isize)).keys;
                                k = 0 as libc::c_int;
                                while k < nbFields {
                                    res = xmlSchemaAreValuesEqual(
                                        (**keys.offset(k as isize)).val,
                                        (**ntkeys.offset(k as isize)).val,
                                    );
                                    if res == -(1 as libc::c_int) {
                                        current_block = 17119793500333090447;
                                        break 's_17;
                                    }
                                    if res == 0 as libc::c_int {
                                        break;
                                    }
                                    k += 1;
                                }
                                if res == 1 as libc::c_int {
                                    current_block = 7654530974828906095;
                                    break;
                                }
                            }
                            j += 1;
                            if !(j < nbDupls) {
                                current_block = 9241535491006583629;
                                break;
                            }
                        }
                    } else {
                        current_block = 9241535491006583629;
                    }
                    match current_block {
                        9241535491006583629 => {
                            if nbNodeTable != 0 {
                                j = 0 as libc::c_int;
                                loop {
                                    if nbFields == 1 as libc::c_int {
                                        res = xmlSchemaAreValuesEqual(
                                            (**keys.offset(0 as libc::c_int as isize)).val,
                                            (**((**((*bind).nodeTable).offset(j as isize)).keys)
                                                .offset(0 as libc::c_int as isize))
                                                .val,
                                        );
                                        if res == -(1 as libc::c_int) {
                                            current_block = 17119793500333090447;
                                            break 's_17;
                                        }
                                        if res == 0 as libc::c_int {
                                            current_block = 6985438050701255290;
                                        } else {
                                            current_block = 2168227384378665163;
                                        }
                                    } else {
                                        res = 0 as libc::c_int;
                                        ntkeys = (**((*bind).nodeTable).offset(j as isize)).keys;
                                        k = 0 as libc::c_int;
                                        loop {
                                            if !(k < nbFields) {
                                                current_block = 2168227384378665163;
                                                break;
                                            }
                                            res = xmlSchemaAreValuesEqual(
                                                (**keys.offset(k as isize)).val,
                                                (**ntkeys.offset(k as isize)).val,
                                            );
                                            if res == -(1 as libc::c_int) {
                                                current_block = 17119793500333090447;
                                                break 's_17;
                                            }
                                            if res == 0 as libc::c_int {
                                                current_block = 6985438050701255290;
                                                break;
                                            }
                                            k += 1;
                                        }
                                    }
                                    match current_block {
                                        6985438050701255290 => {
                                            j += 1;
                                            if !(j < nbNodeTable) {
                                                current_block = 15855550149339537395;
                                                break;
                                            }
                                        }
                                        _ => {
                                            if ((*bind).dupls).is_null() {
                                                let ref mut fresh515 = (*bind).dupls;
                                                *fresh515 = xmlSchemaItemListCreate();
                                                if ((*bind).dupls).is_null() {
                                                    current_block = 17119793500333090447;
                                                    break 's_17;
                                                }
                                            }
                                            if xmlSchemaItemListAdd(
                                                (*bind).dupls,
                                                *((*bind).nodeTable).offset(j as isize) as *mut libc::c_void,
                                            ) == -(1 as libc::c_int)
                                            {
                                                current_block = 17119793500333090447;
                                                break 's_17;
                                            }
                                            let ref mut fresh516 = *((*bind).nodeTable)
                                                .offset(j as isize);
                                            *fresh516 = *((*bind).nodeTable)
                                                .offset(((*bind).nbNodes - 1 as libc::c_int) as isize);
                                            let ref mut fresh517 = (*bind).nbNodes;
                                            *fresh517 -= 1;
                                            current_block = 7654530974828906095;
                                            break;
                                        }
                                    }
                                }
                            } else {
                                current_block = 15855550149339537395;
                            }
                            match current_block {
                                7654530974828906095 => {}
                                _ => {
                                    if xmlSchemaIDCAppendNodeTableItem(
                                        bind,
                                        *targets.offset(i as isize),
                                    ) == -(1 as libc::c_int)
                                    {
                                        current_block = 17119793500333090447;
                                        break 's_17;
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                    i += 1;
                    if !(i < nbTargets) {
                        break;
                    }
                }
            }
            matcher = (*matcher).next;
        }
    }
    match current_block {
        17119793500333090447 => return -(1 as libc::c_int),
        _ => return 0 as libc::c_int,
    };
}
unsafe extern "C" fn xmlSchemaBubbleIDCNodeTables(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> libc::c_int {
    let mut current_block: u64;
    let mut bind: xmlSchemaPSVIIDCBindingPtr = 0 as *mut xmlSchemaPSVIIDCBinding;
    let mut parTable: *mut xmlSchemaPSVIIDCBindingPtr = 0
        as *mut xmlSchemaPSVIIDCBindingPtr;
    let mut parBind: xmlSchemaPSVIIDCBindingPtr = 0 as xmlSchemaPSVIIDCBindingPtr;
    let mut node: xmlSchemaPSVIIDCNodePtr = 0 as *mut xmlSchemaPSVIIDCNode;
    let mut parNode: xmlSchemaPSVIIDCNodePtr = 0 as xmlSchemaPSVIIDCNodePtr;
    let mut dupls: *mut xmlSchemaPSVIIDCNodePtr = 0 as *mut xmlSchemaPSVIIDCNodePtr;
    let mut parNodes: *mut xmlSchemaPSVIIDCNodePtr = 0 as *mut xmlSchemaPSVIIDCNodePtr;
    let mut aidc: xmlSchemaIDCAugPtr = 0 as *mut xmlSchemaIDCAug;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut nbFields: libc::c_int = 0;
    let mut oldNum: libc::c_int = 0;
    let mut oldDupls: libc::c_int = 0;
    bind = (*(*vctxt).inode).idcTable;
    if bind.is_null() {
        return 0 as libc::c_int;
    }
    parTable = &mut (**((*vctxt).elemInfos)
        .offset(((*vctxt).depth - 1 as libc::c_int) as isize))
        .idcTable;
    's_37: loop {
        if bind.is_null() {
            current_block = 7157669805658135323;
            break;
        }
        if !((*bind).nbNodes == 0 as libc::c_int
            && (((*bind).dupls).is_null()
                || (*(*bind).dupls).nbItems == 0 as libc::c_int))
        {
            if (*vctxt).createIDCNodeTables == 0 {
                aidc = (*vctxt).aidcs;
                loop {
                    if (*aidc).def == (*bind).definition {
                        if (*aidc).keyrefDepth == -(1 as libc::c_int)
                            || (*aidc).keyrefDepth >= (*vctxt).depth
                        {
                            current_block = 1182060686398305565;
                            break;
                        } else {
                            current_block = 17833034027772472439;
                            break;
                        }
                    } else {
                        aidc = (*aidc).next;
                        if aidc.is_null() {
                            current_block = 17833034027772472439;
                            break;
                        }
                    }
                }
            } else {
                current_block = 17833034027772472439;
            }
            match current_block {
                1182060686398305565 => {}
                _ => {
                    if !parTable.is_null() {
                        parBind = *parTable;
                    }
                    while !parBind.is_null() {
                        if (*parBind).definition == (*bind).definition {
                            break;
                        }
                        parBind = (*parBind).next;
                    }
                    if !parBind.is_null() {
                        oldNum = (*parBind).nbNodes;
                        if !(((*parBind).dupls).is_null()
                            || (*(*parBind).dupls).nbItems == 0 as libc::c_int)
                        {
                            oldDupls = (*(*parBind).dupls).nbItems;
                            dupls = (*(*parBind).dupls).items
                                as *mut xmlSchemaPSVIIDCNodePtr;
                        } else {
                            dupls = 0 as *mut xmlSchemaPSVIIDCNodePtr;
                            oldDupls = 0 as libc::c_int;
                        }
                        parNodes = (*parBind).nodeTable;
                        nbFields = (*(*bind).definition).nbFields;
                        i = 0 as libc::c_int;
                        while i < (*bind).nbNodes {
                            node = *((*bind).nodeTable).offset(i as isize);
                            if !node.is_null() {
                                if oldDupls != 0 {
                                    j = 0 as libc::c_int;
                                    while j < oldDupls {
                                        if nbFields == 1 as libc::c_int {
                                            ret = xmlSchemaAreValuesEqual(
                                                (**((*node).keys).offset(0 as libc::c_int as isize)).val,
                                                (**((**dupls.offset(j as isize)).keys)
                                                    .offset(0 as libc::c_int as isize))
                                                    .val,
                                            );
                                            if ret == -(1 as libc::c_int) {
                                                current_block = 8730031095742260322;
                                                break 's_37;
                                            }
                                            if ret == 0 as libc::c_int {
                                                j += 1;
                                                continue;
                                            }
                                        } else {
                                            parNode = *dupls.offset(j as isize);
                                            k = 0 as libc::c_int;
                                            while k < nbFields {
                                                ret = xmlSchemaAreValuesEqual(
                                                    (**((*node).keys).offset(k as isize)).val,
                                                    (**((*parNode).keys).offset(k as isize)).val,
                                                );
                                                if ret == -(1 as libc::c_int) {
                                                    current_block = 8730031095742260322;
                                                    break 's_37;
                                                }
                                                if ret == 0 as libc::c_int {
                                                    break;
                                                }
                                                k += 1;
                                            }
                                        }
                                        if ret == 1 as libc::c_int {
                                            break;
                                        }
                                        j += 1;
                                    }
                                    if j != oldDupls {
                                        current_block = 14434620278749266018;
                                    } else {
                                        current_block = 6721012065216013753;
                                    }
                                } else {
                                    current_block = 6721012065216013753;
                                }
                                match current_block {
                                    14434620278749266018 => {}
                                    _ => {
                                        if oldNum != 0 {
                                            j = 0 as libc::c_int;
                                            while j < oldNum {
                                                parNode = *parNodes.offset(j as isize);
                                                if nbFields == 1 as libc::c_int {
                                                    ret = xmlSchemaAreValuesEqual(
                                                        (**((*node).keys).offset(0 as libc::c_int as isize)).val,
                                                        (**((*parNode).keys).offset(0 as libc::c_int as isize)).val,
                                                    );
                                                    if ret == -(1 as libc::c_int) {
                                                        current_block = 8730031095742260322;
                                                        break 's_37;
                                                    }
                                                    if ret == 0 as libc::c_int {
                                                        j += 1;
                                                        continue;
                                                    }
                                                } else {
                                                    k = 0 as libc::c_int;
                                                    while k < nbFields {
                                                        ret = xmlSchemaAreValuesEqual(
                                                            (**((*node).keys).offset(k as isize)).val,
                                                            (**((*parNode).keys).offset(k as isize)).val,
                                                        );
                                                        if ret == -(1 as libc::c_int) {
                                                            current_block = 8730031095742260322;
                                                            break 's_37;
                                                        }
                                                        if ret == 0 as libc::c_int {
                                                            break;
                                                        }
                                                        k += 1;
                                                    }
                                                }
                                                if ret == 1 as libc::c_int {
                                                    break;
                                                }
                                                j += 1;
                                            }
                                            if j != oldNum {
                                                oldNum -= 1;
                                                let ref mut fresh518 = (*parBind).nbNodes;
                                                *fresh518 -= 1;
                                                let ref mut fresh519 = *parNodes.offset(j as isize);
                                                *fresh519 = *parNodes.offset(oldNum as isize);
                                                if (*parBind).nbNodes != oldNum {
                                                    let ref mut fresh520 = *parNodes.offset(oldNum as isize);
                                                    *fresh520 = *parNodes.offset((*parBind).nbNodes as isize);
                                                }
                                                if ((*parBind).dupls).is_null() {
                                                    let ref mut fresh521 = (*parBind).dupls;
                                                    *fresh521 = xmlSchemaItemListCreate();
                                                    if ((*parBind).dupls).is_null() {
                                                        current_block = 8730031095742260322;
                                                        break 's_37;
                                                    }
                                                }
                                                xmlSchemaItemListAdd(
                                                    (*parBind).dupls,
                                                    parNode as *mut libc::c_void,
                                                );
                                            } else {
                                                if ((*parBind).nodeTable).is_null() {
                                                    let ref mut fresh522 = (*parBind).nodeTable;
                                                    *fresh522 = xmlMalloc
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(
                                                        (10 as libc::c_int as libc::c_ulong)
                                                            .wrapping_mul(
                                                                ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>()
                                                                    as libc::c_ulong,
                                                            ),
                                                    ) as *mut xmlSchemaPSVIIDCNodePtr;
                                                    if ((*parBind).nodeTable).is_null() {
                                                        xmlSchemaVErrMemory(
                                                            0 as xmlSchemaValidCtxtPtr,
                                                            b"allocating IDC list of node-table items\0" as *const u8
                                                                as *const libc::c_char,
                                                            0 as xmlNodePtr,
                                                        );
                                                        current_block = 8730031095742260322;
                                                        break 's_37;
                                                    } else {
                                                        (*parBind).sizeNodes = 1 as libc::c_int;
                                                    }
                                                } else if (*parBind).nbNodes >= (*parBind).sizeNodes {
                                                    (*parBind).sizeNodes *= 2 as libc::c_int;
                                                    let ref mut fresh523 = (*parBind).nodeTable;
                                                    *fresh523 = xmlRealloc
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(
                                                        (*parBind).nodeTable as *mut libc::c_void,
                                                        ((*parBind).sizeNodes as libc::c_ulong)
                                                            .wrapping_mul(
                                                                ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>()
                                                                    as libc::c_ulong,
                                                            ),
                                                    ) as *mut xmlSchemaPSVIIDCNodePtr;
                                                    if ((*parBind).nodeTable).is_null() {
                                                        xmlSchemaVErrMemory(
                                                            0 as xmlSchemaValidCtxtPtr,
                                                            b"re-allocating IDC list of node-table items\0" as *const u8
                                                                as *const libc::c_char,
                                                            0 as xmlNodePtr,
                                                        );
                                                        current_block = 8730031095742260322;
                                                        break 's_37;
                                                    }
                                                }
                                                parNodes = (*parBind).nodeTable;
                                                let ref mut fresh524 = (*parBind).nbNodes;
                                                let fresh525 = *fresh524;
                                                *fresh524 = *fresh524 + 1;
                                                let ref mut fresh526 = *parNodes.offset(fresh525 as isize);
                                                *fresh526 = node;
                                            }
                                        }
                                    }
                                }
                            }
                            i += 1;
                        }
                    } else {
                        parBind = xmlSchemaIDCNewBinding((*bind).definition);
                        if parBind.is_null() {
                            current_block = 8730031095742260322;
                            break;
                        }
                        if (*bind).nbNodes != 0 as libc::c_int {
                            if (*vctxt).psviExposeIDCNodeTables == 0 {
                                let ref mut fresh527 = (*parBind).nodeTable;
                                *fresh527 = (*bind).nodeTable;
                                let ref mut fresh528 = (*bind).nodeTable;
                                *fresh528 = 0 as *mut xmlSchemaPSVIIDCNodePtr;
                                (*parBind).sizeNodes = (*bind).sizeNodes;
                                (*bind).sizeNodes = 0 as libc::c_int;
                                (*parBind).nbNodes = (*bind).nbNodes;
                                (*bind).nbNodes = 0 as libc::c_int;
                            } else {
                                let ref mut fresh529 = (*parBind).nodeTable;
                                *fresh529 = xmlMalloc
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*bind).nbNodes as libc::c_ulong)
                                        .wrapping_mul(
                                            ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>()
                                                as libc::c_ulong,
                                        ),
                                ) as *mut xmlSchemaPSVIIDCNodePtr;
                                if ((*parBind).nodeTable).is_null() {
                                    xmlSchemaVErrMemory(
                                        0 as xmlSchemaValidCtxtPtr,
                                        b"allocating an array of IDC node-table items\0"
                                            as *const u8 as *const libc::c_char,
                                        0 as xmlNodePtr,
                                    );
                                    xmlSchemaIDCFreeBinding(parBind);
                                    current_block = 8730031095742260322;
                                    break;
                                } else {
                                    (*parBind).sizeNodes = (*bind).nbNodes;
                                    (*parBind).nbNodes = (*bind).nbNodes;
                                    memcpy(
                                        (*parBind).nodeTable as *mut libc::c_void,
                                        (*bind).nodeTable as *const libc::c_void,
                                        ((*bind).nbNodes as libc::c_ulong)
                                            .wrapping_mul(
                                                ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>()
                                                    as libc::c_ulong,
                                            ),
                                    );
                                }
                            }
                        }
                        if !((*bind).dupls).is_null() {
                            if !((*parBind).dupls).is_null() {
                                xmlSchemaItemListFree((*parBind).dupls);
                            }
                            let ref mut fresh530 = (*parBind).dupls;
                            *fresh530 = (*bind).dupls;
                            let ref mut fresh531 = (*bind).dupls;
                            *fresh531 = 0 as xmlSchemaItemListPtr;
                        }
                        if !parTable.is_null() {
                            if (*parTable).is_null() {
                                *parTable = parBind;
                            } else {
                                let ref mut fresh532 = (*parBind).next;
                                *fresh532 = *parTable;
                                *parTable = parBind;
                            }
                        }
                    }
                }
            }
        }
        bind = (*bind).next;
    }
    match current_block {
        8730031095742260322 => return -(1 as libc::c_int),
        _ => return 0 as libc::c_int,
    };
}
unsafe extern "C" fn xmlSchemaCheckCVCIDCKeyRef(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> libc::c_int {
    let mut matcher: xmlSchemaIDCMatcherPtr = 0 as *mut xmlSchemaIDCMatcher;
    let mut bind: xmlSchemaPSVIIDCBindingPtr = 0 as *mut xmlSchemaPSVIIDCBinding;
    matcher = (*(*vctxt).inode).idcMatchers;
    while !matcher.is_null() {
        if (*matcher).idcType == XML_SCHEMA_TYPE_IDC_KEYREF as libc::c_int
            && !((*matcher).targets).is_null() && (*(*matcher).targets).nbItems != 0
        {
            let mut i: libc::c_int = 0;
            let mut j: libc::c_int = 0;
            let mut k: libc::c_int = 0;
            let mut res: libc::c_int = 0;
            let mut nbFields: libc::c_int = 0;
            let mut hasDupls: libc::c_int = 0;
            let mut refKeys: *mut xmlSchemaPSVIIDCKeyPtr = 0
                as *mut xmlSchemaPSVIIDCKeyPtr;
            let mut keys: *mut xmlSchemaPSVIIDCKeyPtr = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
            let mut refNode: xmlSchemaPSVIIDCNodePtr = 0 as xmlSchemaPSVIIDCNodePtr;
            let mut table: xmlHashTablePtr = 0 as xmlHashTablePtr;
            nbFields = (*(*(*matcher).aidc).def).nbFields;
            bind = (*(*vctxt).inode).idcTable;
            while !bind.is_null() {
                if (*(*(*(*matcher).aidc).def).ref_0).item as xmlSchemaIDCPtr
                    == (*bind).definition
                {
                    break;
                }
                bind = (*bind).next;
            }
            hasDupls = if !bind.is_null() && !((*bind).dupls).is_null()
                && (*(*bind).dupls).nbItems != 0
            {
                1 as libc::c_int
            } else {
                0 as libc::c_int
            };
            if !bind.is_null() {
                table = xmlHashCreate((*bind).nbNodes * 2 as libc::c_int);
                j = 0 as libc::c_int;
                while j < (*bind).nbNodes {
                    let mut value: *mut xmlChar = 0 as *mut xmlChar;
                    let mut r: xmlIDCHashEntryPtr = 0 as *mut xmlIDCHashEntry;
                    let mut e: xmlIDCHashEntryPtr = 0 as *mut xmlIDCHashEntry;
                    keys = (**((*bind).nodeTable).offset(j as isize)).keys;
                    xmlSchemaHashKeySequence(vctxt, &mut value, keys, nbFields);
                    e = xmlMalloc
                        .expect(
                            "non-null function pointer",
                        )(::std::mem::size_of::<xmlIDCHashEntry>() as libc::c_ulong)
                        as xmlIDCHashEntryPtr;
                    (*e).index = j;
                    r = xmlHashLookup(table, value) as xmlIDCHashEntryPtr;
                    if !r.is_null() {
                        let ref mut fresh533 = (*e).next;
                        *fresh533 = (*r).next;
                        let ref mut fresh534 = (*r).next;
                        *fresh534 = e;
                    } else {
                        let ref mut fresh535 = (*e).next;
                        *fresh535 = 0 as xmlIDCHashEntryPtr;
                        xmlHashAddEntry(table, value, e as *mut libc::c_void);
                    }
                    if !value.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(value as *mut libc::c_void);
                        value = 0 as *mut xmlChar;
                    }
                    j += 1;
                }
            }
            i = 0 as libc::c_int;
            while i < (*(*matcher).targets).nbItems {
                res = 0 as libc::c_int;
                refNode = *((*(*matcher).targets).items).offset(i as isize)
                    as xmlSchemaPSVIIDCNodePtr;
                if !bind.is_null() {
                    let mut value_0: *mut xmlChar = 0 as *mut xmlChar;
                    let mut e_0: xmlIDCHashEntryPtr = 0 as *mut xmlIDCHashEntry;
                    refKeys = (*refNode).keys;
                    xmlSchemaHashKeySequence(vctxt, &mut value_0, refKeys, nbFields);
                    e_0 = xmlHashLookup(table, value_0) as xmlIDCHashEntryPtr;
                    if !value_0.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(value_0 as *mut libc::c_void);
                        value_0 = 0 as *mut xmlChar;
                    }
                    res = 0 as libc::c_int;
                    while !e_0.is_null() {
                        keys = (**((*bind).nodeTable).offset((*e_0).index as isize))
                            .keys;
                        k = 0 as libc::c_int;
                        while k < nbFields {
                            res = xmlSchemaAreValuesEqual(
                                (**keys.offset(k as isize)).val,
                                (**refKeys.offset(k as isize)).val,
                            );
                            if res == 0 as libc::c_int {
                                break;
                            }
                            if res == -(1 as libc::c_int) {
                                return -(1 as libc::c_int);
                            }
                            k += 1;
                        }
                        if res == 1 as libc::c_int {
                            break;
                        }
                        e_0 = (*e_0).next;
                    }
                    if res == 0 as libc::c_int && hasDupls != 0 {
                        j = 0 as libc::c_int;
                        while j < (*(*bind).dupls).nbItems {
                            keys = (*(*((*(*bind).dupls).items).offset(j as isize)
                                as xmlSchemaPSVIIDCNodePtr))
                                .keys;
                            k = 0 as libc::c_int;
                            while k < nbFields {
                                res = xmlSchemaAreValuesEqual(
                                    (**keys.offset(k as isize)).val,
                                    (**refKeys.offset(k as isize)).val,
                                );
                                if res == 0 as libc::c_int {
                                    break;
                                }
                                if res == -(1 as libc::c_int) {
                                    return -(1 as libc::c_int);
                                }
                                k += 1;
                            }
                            if res == 1 as libc::c_int {
                                let mut str: *mut xmlChar = 0 as *mut xmlChar;
                                let mut strB: *mut xmlChar = 0 as *mut xmlChar;
                                xmlSchemaKeyrefErr(
                                    vctxt,
                                    XML_SCHEMAV_CVC_IDC,
                                    refNode,
                                    (*(*matcher).aidc).def as xmlSchemaTypePtr,
                                    b"More than one match found for key-sequence %s of keyref '%s'\0"
                                        as *const u8 as *const libc::c_char,
                                    xmlSchemaFormatIDCKeySequence(
                                        vctxt,
                                        &mut str,
                                        (*refNode).keys,
                                        nbFields,
                                    ),
                                    xmlSchemaGetComponentQName(
                                        &mut strB,
                                        (*(*matcher).aidc).def as *mut libc::c_void,
                                    ),
                                );
                                if !str.is_null() {
                                    xmlFree
                                        .expect(
                                            "non-null function pointer",
                                        )(str as *mut libc::c_void);
                                    str = 0 as *mut xmlChar;
                                }
                                if !strB.is_null() {
                                    xmlFree
                                        .expect(
                                            "non-null function pointer",
                                        )(strB as *mut libc::c_void);
                                    strB = 0 as *mut xmlChar;
                                }
                                break;
                            } else {
                                j += 1;
                            }
                        }
                    }
                }
                if res == 0 as libc::c_int {
                    let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                    let mut strB_0: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaKeyrefErr(
                        vctxt,
                        XML_SCHEMAV_CVC_IDC,
                        refNode,
                        (*(*matcher).aidc).def as xmlSchemaTypePtr,
                        b"No match found for key-sequence %s of keyref '%s'\0"
                            as *const u8 as *const libc::c_char,
                        xmlSchemaFormatIDCKeySequence(
                            vctxt,
                            &mut str_0,
                            (*refNode).keys,
                            nbFields,
                        ),
                        xmlSchemaGetComponentQName(
                            &mut strB_0,
                            (*(*matcher).aidc).def as *mut libc::c_void,
                        ),
                    );
                    if !str_0.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str_0 as *mut libc::c_void);
                        str_0 = 0 as *mut xmlChar;
                    }
                    if !strB_0.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(strB_0 as *mut libc::c_void);
                        strB_0 = 0 as *mut xmlChar;
                    }
                }
                i += 1;
            }
            if !table.is_null() {
                xmlHashFree(
                    table,
                    Some(
                        xmlFreeIDCHashEntry
                            as unsafe extern "C" fn(
                                *mut libc::c_void,
                                *const xmlChar,
                            ) -> (),
                    ),
                );
            }
        }
        matcher = (*matcher).next;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaGetFreshAttrInfo(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> xmlSchemaAttrInfoPtr {
    let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    if ((*vctxt).attrInfos).is_null() {
        let ref mut fresh536 = (*vctxt).attrInfos;
        *fresh536 = xmlMalloc
            .expect(
                "non-null function pointer",
            )(::std::mem::size_of::<xmlSchemaAttrInfoPtr>() as libc::c_ulong)
            as *mut xmlSchemaAttrInfoPtr;
        (*vctxt).sizeAttrInfos = 1 as libc::c_int;
        if ((*vctxt).attrInfos).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"allocating attribute info list\0" as *const u8 as *const libc::c_char,
                0 as xmlNodePtr,
            );
            return 0 as xmlSchemaAttrInfoPtr;
        }
    } else if (*vctxt).sizeAttrInfos <= (*vctxt).nbAttrInfos {
        let ref mut fresh537 = (*vctxt).sizeAttrInfos;
        *fresh537 += 1;
        let ref mut fresh538 = (*vctxt).attrInfos;
        *fresh538 = xmlRealloc
            .expect(
                "non-null function pointer",
            )(
            (*vctxt).attrInfos as *mut libc::c_void,
            ((*vctxt).sizeAttrInfos as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaAttrInfoPtr>() as libc::c_ulong,
                ),
        ) as *mut xmlSchemaAttrInfoPtr;
        if ((*vctxt).attrInfos).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"re-allocating attribute info list\0" as *const u8
                    as *const libc::c_char,
                0 as xmlNodePtr,
            );
            return 0 as xmlSchemaAttrInfoPtr;
        }
    } else {
        let ref mut fresh539 = (*vctxt).nbAttrInfos;
        let fresh540 = *fresh539;
        *fresh539 = *fresh539 + 1;
        iattr = *((*vctxt).attrInfos).offset(fresh540 as isize);
        if !((*iattr).localName).is_null() {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaGetFreshAttrInfo\0" as *const u8 as *const libc::c_char,
                b"attr info not cleared\0" as *const u8 as *const libc::c_char,
            );
            return 0 as xmlSchemaAttrInfoPtr;
        }
        (*iattr).nodeType = XML_ATTRIBUTE_NODE as libc::c_int;
        return iattr;
    }
    iattr = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaAttrInfo>() as libc::c_ulong)
        as xmlSchemaAttrInfoPtr;
    if iattr.is_null() {
        xmlSchemaVErrMemory(
            vctxt,
            b"creating new attribute info\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaAttrInfoPtr;
    }
    memset(
        iattr as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaAttrInfo>() as libc::c_ulong,
    );
    (*iattr).nodeType = XML_ATTRIBUTE_NODE as libc::c_int;
    let ref mut fresh541 = (*vctxt).nbAttrInfos;
    let fresh542 = *fresh541;
    *fresh541 = *fresh541 + 1;
    let ref mut fresh543 = *((*vctxt).attrInfos).offset(fresh542 as isize);
    *fresh543 = iattr;
    return iattr;
}
unsafe extern "C" fn xmlSchemaValidatorPushAttribute(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut attrNode: xmlNodePtr,
    mut nodeLine: libc::c_int,
    mut localName: *const xmlChar,
    mut nsName: *const xmlChar,
    mut ownedNames: libc::c_int,
    mut value: *mut xmlChar,
    mut ownedValue: libc::c_int,
) -> libc::c_int {
    let mut attr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    attr = xmlSchemaGetFreshAttrInfo(vctxt);
    if attr.is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaPushAttribute\0" as *const u8 as *const libc::c_char,
            b"calling xmlSchemaGetFreshAttrInfo()\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    let ref mut fresh544 = (*attr).node;
    *fresh544 = attrNode;
    (*attr).nodeLine = nodeLine;
    (*attr).state = 1 as libc::c_int;
    let ref mut fresh545 = (*attr).localName;
    *fresh545 = localName;
    let ref mut fresh546 = (*attr).nsName;
    *fresh546 = nsName;
    if ownedNames != 0 {
        (*attr).flags |= (1 as libc::c_int) << 0 as libc::c_int;
    }
    if !nsName.is_null() {
        if xmlStrEqual(
            localName,
            b"nil\0" as *const u8 as *const libc::c_char as *mut xmlChar,
        ) != 0
        {
            if xmlStrEqual((*attr).nsName, xmlSchemaInstanceNs) != 0 {
                (*attr).metaType = 2 as libc::c_int;
            }
        } else if xmlStrEqual(
                localName,
                b"type\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) != 0
            {
            if xmlStrEqual((*attr).nsName, xmlSchemaInstanceNs) != 0 {
                (*attr).metaType = 1 as libc::c_int;
            }
        } else if xmlStrEqual(
                localName,
                b"schemaLocation\0" as *const u8 as *const libc::c_char as *mut xmlChar,
            ) != 0
            {
            if xmlStrEqual((*attr).nsName, xmlSchemaInstanceNs) != 0 {
                (*attr).metaType = 3 as libc::c_int;
            }
        } else if xmlStrEqual(
                localName,
                b"noNamespaceSchemaLocation\0" as *const u8 as *const libc::c_char
                    as *mut xmlChar,
            ) != 0
            {
            if xmlStrEqual((*attr).nsName, xmlSchemaInstanceNs) != 0 {
                (*attr).metaType = 4 as libc::c_int;
            }
        } else if xmlStrEqual((*attr).nsName, xmlNamespaceNs) != 0 {
            (*attr).metaType = 5 as libc::c_int;
        }
    }
    let ref mut fresh547 = (*attr).value;
    *fresh547 = value;
    if ownedValue != 0 {
        (*attr).flags |= (1 as libc::c_int) << 1 as libc::c_int;
    }
    if (*attr).metaType != 0 as libc::c_int {
        (*attr).state = 17 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaClearElemInfo(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut ielem: xmlSchemaNodeInfoPtr,
) {
    (*ielem).hasKeyrefs = 0 as libc::c_int;
    (*ielem).appliedXPath = 0 as libc::c_int;
    if (*ielem).flags & (1 as libc::c_int) << 0 as libc::c_int != 0 {
        if !((*ielem).localName).is_null() {
            xmlFree
                .expect(
                    "non-null function pointer",
                )((*ielem).localName as *mut xmlChar as *mut libc::c_void);
            let ref mut fresh548 = (*ielem).localName;
            *fresh548 = 0 as *const xmlChar;
        }
        if !((*ielem).nsName).is_null() {
            xmlFree
                .expect(
                    "non-null function pointer",
                )((*ielem).nsName as *mut xmlChar as *mut libc::c_void);
            let ref mut fresh549 = (*ielem).nsName;
            *fresh549 = 0 as *const xmlChar;
        }
    } else {
        let ref mut fresh550 = (*ielem).localName;
        *fresh550 = 0 as *const xmlChar;
        let ref mut fresh551 = (*ielem).nsName;
        *fresh551 = 0 as *const xmlChar;
    }
    if (*ielem).flags & (1 as libc::c_int) << 1 as libc::c_int != 0 {
        if !((*ielem).value).is_null() {
            xmlFree
                .expect(
                    "non-null function pointer",
                )((*ielem).value as *mut xmlChar as *mut libc::c_void);
            let ref mut fresh552 = (*ielem).value;
            *fresh552 = 0 as *const xmlChar;
        }
    } else {
        let ref mut fresh553 = (*ielem).value;
        *fresh553 = 0 as *const xmlChar;
    }
    if !((*ielem).val).is_null() {
        xmlSchemaFreeValue((*ielem).val);
        let ref mut fresh554 = (*ielem).val;
        *fresh554 = 0 as xmlSchemaValPtr;
    }
    if !((*ielem).idcMatchers).is_null() {
        xmlSchemaIDCReleaseMatcherList(vctxt, (*ielem).idcMatchers);
        let ref mut fresh555 = (*ielem).idcMatchers;
        *fresh555 = 0 as xmlSchemaIDCMatcherPtr;
    }
    if !((*ielem).idcTable).is_null() {
        xmlSchemaIDCFreeIDCTable((*ielem).idcTable);
        let ref mut fresh556 = (*ielem).idcTable;
        *fresh556 = 0 as xmlSchemaPSVIIDCBindingPtr;
    }
    if !((*ielem).regexCtxt).is_null() {
        xmlRegFreeExecCtxt((*ielem).regexCtxt);
        let ref mut fresh557 = (*ielem).regexCtxt;
        *fresh557 = 0 as xmlRegExecCtxtPtr;
    }
    if !((*ielem).nsBindings).is_null() {
        xmlFree
            .expect(
                "non-null function pointer",
            )((*ielem).nsBindings as *mut *mut xmlChar as *mut libc::c_void);
        let ref mut fresh558 = (*ielem).nsBindings;
        *fresh558 = 0 as *mut *const xmlChar;
        (*ielem).nbNsBindings = 0 as libc::c_int;
        (*ielem).sizeNsBindings = 0 as libc::c_int;
    }
}
unsafe extern "C" fn xmlSchemaGetFreshElemInfo(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> xmlSchemaNodeInfoPtr {
    let mut info: xmlSchemaNodeInfoPtr = 0 as xmlSchemaNodeInfoPtr;
    if (*vctxt).depth > (*vctxt).sizeElemInfos {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaGetFreshElemInfo\0" as *const u8 as *const libc::c_char,
            b"inconsistent depth encountered\0" as *const u8 as *const libc::c_char,
        );
        return 0 as xmlSchemaNodeInfoPtr;
    }
    if ((*vctxt).elemInfos).is_null() {
        let ref mut fresh559 = (*vctxt).elemInfos;
        *fresh559 = xmlMalloc
            .expect(
                "non-null function pointer",
            )(
            (10 as libc::c_int as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaNodeInfoPtr>() as libc::c_ulong,
                ),
        ) as *mut xmlSchemaNodeInfoPtr;
        if ((*vctxt).elemInfos).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"allocating the element info array\0" as *const u8
                    as *const libc::c_char,
                0 as xmlNodePtr,
            );
            return 0 as xmlSchemaNodeInfoPtr;
        }
        memset(
            (*vctxt).elemInfos as *mut libc::c_void,
            0 as libc::c_int,
            (10 as libc::c_int as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaNodeInfoPtr>() as libc::c_ulong,
                ),
        );
        (*vctxt).sizeElemInfos = 10 as libc::c_int;
    } else if (*vctxt).sizeElemInfos <= (*vctxt).depth {
        let mut i: libc::c_int = (*vctxt).sizeElemInfos;
        (*vctxt).sizeElemInfos *= 2 as libc::c_int;
        let ref mut fresh560 = (*vctxt).elemInfos;
        *fresh560 = xmlRealloc
            .expect(
                "non-null function pointer",
            )(
            (*vctxt).elemInfos as *mut libc::c_void,
            ((*vctxt).sizeElemInfos as libc::c_ulong)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaNodeInfoPtr>() as libc::c_ulong,
                ),
        ) as *mut xmlSchemaNodeInfoPtr;
        if ((*vctxt).elemInfos).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"re-allocating the element info array\0" as *const u8
                    as *const libc::c_char,
                0 as xmlNodePtr,
            );
            return 0 as xmlSchemaNodeInfoPtr;
        }
        while i < (*vctxt).sizeElemInfos {
            let ref mut fresh561 = *((*vctxt).elemInfos).offset(i as isize);
            *fresh561 = 0 as xmlSchemaNodeInfoPtr;
            i += 1;
        }
    } else {
        info = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
    }
    if info.is_null() {
        info = xmlMalloc
            .expect(
                "non-null function pointer",
            )(::std::mem::size_of::<xmlSchemaNodeInfo>() as libc::c_ulong)
            as xmlSchemaNodeInfoPtr;
        if info.is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"allocating an element info\0" as *const u8 as *const libc::c_char,
                0 as xmlNodePtr,
            );
            return 0 as xmlSchemaNodeInfoPtr;
        }
        let ref mut fresh562 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
        *fresh562 = info;
    } else if !((*info).localName).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaGetFreshElemInfo\0" as *const u8 as *const libc::c_char,
            b"elem info has not been cleared\0" as *const u8 as *const libc::c_char,
        );
        return 0 as xmlSchemaNodeInfoPtr;
    }
    memset(
        info as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaNodeInfo>() as libc::c_ulong,
    );
    (*info).nodeType = XML_ELEMENT_NODE as libc::c_int;
    (*info).depth = (*vctxt).depth;
    return info;
}
unsafe extern "C" fn xmlSchemaValidateFacets(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut node: xmlNodePtr,
    mut type_0: xmlSchemaTypePtr,
    mut valType: xmlSchemaValType,
    mut value: *const xmlChar,
    mut val: xmlSchemaValPtr,
    mut length: libc::c_ulong,
    mut fireErrors: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut ret: libc::c_int = 0;
    let mut error: libc::c_int = 0 as libc::c_int;
    let mut found: libc::c_int = 0;
    let mut tmpType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut facetLink: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut len: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    let mut ws: xmlSchemaWhitespaceValueType = XML_SCHEMA_WHITESPACE_UNKNOWN;
    if (*type_0).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int;
    }
    if !((*type_0).facetSet).is_null() {
        if (*type_0).flags & (1 as libc::c_int) << 8 as libc::c_int == 0 {
            if (*type_0).flags & (1 as libc::c_int) << 6 as libc::c_int != 0 {
                current_block = 13331728595066369563;
            } else {
                current_block = 1410358537824353994;
            }
        } else {
            tmpType = xmlSchemaGetPrimitiveType(type_0);
            if (*tmpType).builtInType == XML_SCHEMAS_STRING as libc::c_int
                || (*tmpType).type_0 as libc::c_uint
                    == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                    && (*tmpType).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as libc::c_int
            {
                ws = xmlSchemaGetWhiteSpaceFacetValue(type_0);
            } else {
                ws = XML_SCHEMA_WHITESPACE_COLLAPSE;
            }
            if !val.is_null() {
                valType = xmlSchemaGetValType(val);
            }
            ret = 0 as libc::c_int;
            let mut current_block_25: u64;
            facetLink = (*type_0).facetSet;
            while !facetLink.is_null() {
                match (*(*facetLink).facet).type_0 as libc::c_uint {
                    1008 | 1006 | 1007 => {
                        current_block_25 = 15652330335145281839;
                    }
                    1009 | 1011 | 1010 => {
                        ret = xmlSchemaValidateLengthFacetWhtsp(
                            (*facetLink).facet,
                            valType,
                            value,
                            val,
                            &mut len,
                            ws,
                        );
                        current_block_25 = 2719512138335094285;
                    }
                    _ => {
                        ret = xmlSchemaValidateFacetWhtsp(
                            (*facetLink).facet,
                            ws,
                            valType,
                            value,
                            val,
                            ws,
                        );
                        current_block_25 = 2719512138335094285;
                    }
                }
                match current_block_25 {
                    2719512138335094285 => {
                        if ret < 0 as libc::c_int {
                            xmlSchemaInternalErr(
                                actxt,
                                b"xmlSchemaValidateFacets\0" as *const u8
                                    as *const libc::c_char,
                                b"validating against a atomic type facet\0" as *const u8
                                    as *const libc::c_char,
                            );
                            return -(1 as libc::c_int);
                        } else {
                            if ret > 0 as libc::c_int {
                                if fireErrors != 0 {
                                    xmlSchemaFacetErr(
                                        actxt,
                                        ret as xmlParserErrors,
                                        node,
                                        value,
                                        len,
                                        type_0,
                                        (*facetLink).facet,
                                        0 as *const libc::c_char,
                                        0 as *const xmlChar,
                                        0 as *const xmlChar,
                                    );
                                } else {
                                    return ret
                                }
                                if error == 0 as libc::c_int {
                                    error = ret;
                                }
                            }
                        }
                        ret = 0 as libc::c_int;
                    }
                    _ => {}
                }
                facetLink = (*facetLink).next;
            }
            current_block = 13331728595066369563;
        }
        match current_block {
            1410358537824353994 => {}
            _ => {
                if !((*type_0).flags & (1 as libc::c_int) << 6 as libc::c_int == 0) {
                    ret = 0 as libc::c_int;
                    facetLink = (*type_0).facetSet;
                    while !facetLink.is_null() {
                        match (*(*facetLink).facet).type_0 as libc::c_uint {
                            1009 | 1011 | 1010 => {
                                ret = xmlSchemaValidateListSimpleTypeFacet(
                                    (*facetLink).facet,
                                    value,
                                    length,
                                    0 as *mut libc::c_ulong,
                                );
                                if ret < 0 as libc::c_int {
                                    xmlSchemaInternalErr(
                                        actxt,
                                        b"xmlSchemaValidateFacets\0" as *const u8
                                            as *const libc::c_char,
                                        b"validating against a list type facet\0" as *const u8
                                            as *const libc::c_char,
                                    );
                                    return -(1 as libc::c_int);
                                } else {
                                    if ret > 0 as libc::c_int {
                                        if fireErrors != 0 {
                                            xmlSchemaFacetErr(
                                                actxt,
                                                ret as xmlParserErrors,
                                                node,
                                                value,
                                                length,
                                                type_0,
                                                (*facetLink).facet,
                                                0 as *const libc::c_char,
                                                0 as *const xmlChar,
                                                0 as *const xmlChar,
                                            );
                                        } else {
                                            return ret
                                        }
                                        if error == 0 as libc::c_int {
                                            error = ret;
                                        }
                                    }
                                }
                                ret = 0 as libc::c_int;
                            }
                            _ => {}
                        }
                        facetLink = (*facetLink).next;
                    }
                }
            }
        }
    }
    found = 0 as libc::c_int;
    ret = 0 as libc::c_int;
    tmpType = type_0;
    loop {
        facet = (*tmpType).facets;
        while !facet.is_null() {
            if !((*facet).type_0 as libc::c_uint
                != XML_SCHEMA_FACET_ENUMERATION as libc::c_int as libc::c_uint)
            {
                found = 1 as libc::c_int;
                ret = xmlSchemaAreValuesEqual((*facet).val, val);
                if ret == 1 as libc::c_int {
                    break;
                }
                if ret < 0 as libc::c_int {
                    xmlSchemaInternalErr(
                        actxt,
                        b"xmlSchemaValidateFacets\0" as *const u8 as *const libc::c_char,
                        b"validating against an enumeration facet\0" as *const u8
                            as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
            }
            facet = (*facet).next;
        }
        if ret != 0 as libc::c_int {
            break;
        }
        if found != 0 {
            break;
        }
        tmpType = (*tmpType).baseType;
        if !(!tmpType.is_null()
            && (*tmpType).type_0 as libc::c_uint
                != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint)
        {
            break;
        }
    }
    if found != 0 && ret == 0 as libc::c_int {
        ret = XML_SCHEMAV_CVC_ENUMERATION_VALID as libc::c_int;
        if fireErrors != 0 {
            xmlSchemaFacetErr(
                actxt,
                ret as xmlParserErrors,
                node,
                value,
                0 as libc::c_int as libc::c_ulong,
                type_0,
                0 as xmlSchemaFacetPtr,
                0 as *const libc::c_char,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
        } else {
            return ret
        }
        if error == 0 as libc::c_int {
            error = ret;
        }
    }
    tmpType = type_0;
    facet = 0 as xmlSchemaFacetPtr;
    loop {
        found = 0 as libc::c_int;
        facetLink = (*tmpType).facetSet;
        while !facetLink.is_null() {
            if !((*(*facetLink).facet).type_0 as libc::c_uint
                != XML_SCHEMA_FACET_PATTERN as libc::c_int as libc::c_uint)
            {
                found = 1 as libc::c_int;
                ret = xmlRegexpExec((*(*facetLink).facet).regexp, value);
                if ret == 1 as libc::c_int {
                    break;
                }
                if ret < 0 as libc::c_int {
                    xmlSchemaInternalErr(
                        actxt,
                        b"xmlSchemaValidateFacets\0" as *const u8 as *const libc::c_char,
                        b"validating against a pattern facet\0" as *const u8
                            as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                } else {
                    facet = (*facetLink).facet;
                }
            }
            facetLink = (*facetLink).next;
        }
        if found != 0 && ret != 1 as libc::c_int {
            ret = XML_SCHEMAV_CVC_PATTERN_VALID as libc::c_int;
            if fireErrors != 0 {
                xmlSchemaFacetErr(
                    actxt,
                    ret as xmlParserErrors,
                    node,
                    value,
                    0 as libc::c_int as libc::c_ulong,
                    type_0,
                    facet,
                    0 as *const libc::c_char,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
            } else {
                return ret
            }
            if error == 0 as libc::c_int {
                error = ret;
            }
            break;
        } else {
            tmpType = (*tmpType).baseType;
            if !(!tmpType.is_null()
                && (*tmpType).type_0 as libc::c_uint
                    != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint)
            {
                break;
            }
        }
    }
    return error;
}
unsafe extern "C" fn xmlSchemaNormalizeValue(
    mut type_0: xmlSchemaTypePtr,
    mut value: *const xmlChar,
) -> *mut xmlChar {
    match xmlSchemaGetWhiteSpaceFacetValue(type_0) as libc::c_uint {
        3 => return xmlSchemaCollapseString(value),
        2 => return xmlSchemaWhiteSpaceReplace(value),
        _ => return 0 as *mut xmlChar,
    };
}
unsafe extern "C" fn xmlSchemaValidateQName(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut value: *const xmlChar,
    mut val: *mut xmlSchemaValPtr,
    mut valNeeded: libc::c_int,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    let mut stripped: *mut xmlChar = 0 as *mut xmlChar;
    let mut nsName: *const xmlChar = 0 as *const xmlChar;
    let mut local: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    ret = xmlValidateQName(value, 1 as libc::c_int);
    if ret != 0 as libc::c_int {
        if ret == -(1 as libc::c_int) {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaValidateQName\0" as *const u8 as *const libc::c_char,
                b"calling xmlValidateQName()\0" as *const u8 as *const libc::c_char,
            );
            return -(1 as libc::c_int);
        }
        return XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as libc::c_int;
    }
    stripped = xmlSchemaCollapseString(value);
    local = xmlSplitQName2(
        if !stripped.is_null() { stripped as *const xmlChar } else { value },
        &mut prefix,
    );
    xmlFree.expect("non-null function pointer")(stripped as *mut libc::c_void);
    if local.is_null() {
        local = xmlStrdup(value);
    }
    nsName = xmlSchemaLookupNamespace(vctxt, prefix);
    if !prefix.is_null() {
        xmlFree.expect("non-null function pointer")(prefix as *mut libc::c_void);
        if nsName.is_null() {
            ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as libc::c_int;
            xmlSchemaCustomErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                ret as xmlParserErrors,
                0 as xmlNodePtr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME) as xmlSchemaBasicItemPtr,
                b"The QName value '%s' has no corresponding namespace declaration in scope\0"
                    as *const u8 as *const libc::c_char,
                value,
                0 as *const xmlChar,
            );
            if !local.is_null() {
                xmlFree.expect("non-null function pointer")(local as *mut libc::c_void);
            }
            return ret;
        }
    }
    if valNeeded != 0 && !val.is_null() {
        if !nsName.is_null() {
            *val = xmlSchemaNewQNameValue(xmlStrdup(nsName), local);
        } else {
            *val = xmlSchemaNewQNameValue(0 as *const xmlChar, local);
        }
    } else {
        xmlFree.expect("non-null function pointer")(local as *mut libc::c_void);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaVCheckCVCSimpleType(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut node: xmlNodePtr,
    mut type_0: xmlSchemaTypePtr,
    mut value: *const xmlChar,
    mut retVal: *mut xmlSchemaValPtr,
    mut fireErrors: libc::c_int,
    mut normalize: libc::c_int,
    mut isNormalized: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut valNeeded: libc::c_int = if !retVal.is_null() {
        1 as libc::c_int
    } else {
        0 as libc::c_int
    };
    let mut val: xmlSchemaValPtr = 0 as xmlSchemaValPtr;
    let mut normValue: *mut xmlChar = 0 as *mut xmlChar;
    if !retVal.is_null() && !(*retVal).is_null() {
        xmlSchemaFreeValue(*retVal);
        *retVal = 0 as xmlSchemaValPtr;
    }
    if valNeeded == 0 && (*type_0).flags & (1 as libc::c_int) << 21 as libc::c_int != 0 {
        valNeeded = 1 as libc::c_int;
    }
    if value.is_null() {
        value = b"\0" as *const u8 as *const libc::c_char as *mut xmlChar;
    }
    if (*type_0).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
        && (*type_0).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as libc::c_int
        || (*type_0).flags & (1 as libc::c_int) << 8 as libc::c_int != 0
    {
        let mut biType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        if isNormalized == 0
            && (normalize != 0
                || (*type_0).flags & (1 as libc::c_int) << 28 as libc::c_int != 0)
        {
            normValue = xmlSchemaNormalizeValue(type_0, value);
            if !normValue.is_null() {
                value = normValue;
            }
            isNormalized = 1 as libc::c_int;
        }
        if (*type_0).type_0 as libc::c_uint
            != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
        {
            biType = (*type_0).baseType;
            while !biType.is_null()
                && (*biType).type_0 as libc::c_uint
                    != XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
            {
                biType = (*biType).baseType;
            }
            if biType.is_null() {
                xmlSchemaInternalErr(
                    actxt,
                    b"xmlSchemaVCheckCVCSimpleType\0" as *const u8
                        as *const libc::c_char,
                    b"could not get the built-in type\0" as *const u8
                        as *const libc::c_char,
                );
                current_block = 10711413107550680511;
            } else {
                current_block = 9828876828309294594;
            }
        } else {
            biType = type_0;
            current_block = 9828876828309294594;
        }
        match current_block {
            10711413107550680511 => {}
            _ => {
                if (*actxt).type_0 == 2 as libc::c_int {
                    match (*biType).builtInType {
                        28 => {
                            ret = xmlSchemaValidateNotation(
                                actxt as xmlSchemaValidCtxtPtr,
                                (*(actxt as xmlSchemaValidCtxtPtr)).schema,
                                0 as xmlNodePtr,
                                value,
                                &mut val,
                                valNeeded,
                            );
                        }
                        21 => {
                            ret = xmlSchemaValidateQName(
                                actxt as xmlSchemaValidCtxtPtr,
                                value,
                                &mut val,
                                valNeeded,
                            );
                        }
                        _ => {
                            if valNeeded != 0 {
                                ret = xmlSchemaValPredefTypeNodeNoNorm(
                                    biType,
                                    value,
                                    &mut val,
                                    node,
                                );
                            } else {
                                ret = xmlSchemaValPredefTypeNodeNoNorm(
                                    biType,
                                    value,
                                    0 as *mut xmlSchemaValPtr,
                                    node,
                                );
                            }
                        }
                    }
                    current_block = 16799951812150840583;
                } else if (*actxt).type_0 == 1 as libc::c_int {
                    match (*biType).builtInType {
                        28 => {
                            ret = xmlSchemaValidateNotation(
                                0 as xmlSchemaValidCtxtPtr,
                                (*(actxt as xmlSchemaParserCtxtPtr)).schema,
                                node,
                                value,
                                &mut val,
                                valNeeded,
                            );
                        }
                        _ => {
                            if valNeeded != 0 {
                                ret = xmlSchemaValPredefTypeNodeNoNorm(
                                    biType,
                                    value,
                                    &mut val,
                                    node,
                                );
                            } else {
                                ret = xmlSchemaValPredefTypeNodeNoNorm(
                                    biType,
                                    value,
                                    0 as *mut xmlSchemaValPtr,
                                    node,
                                );
                            }
                        }
                    }
                    current_block = 16799951812150840583;
                } else {
                    (*__xmlGenericError())
                        .expect(
                            "non-null function pointer",
                        )(
                        *__xmlGenericErrorContext(),
                        b"Unimplemented block at %s:%d\n\0" as *const u8
                            as *const libc::c_char,
                        b"xmlschemas.c\0" as *const u8 as *const libc::c_char,
                        24827 as libc::c_int,
                    );
                    current_block = 10711413107550680511;
                }
                match current_block {
                    10711413107550680511 => {}
                    _ => {
                        if ret != 0 as libc::c_int {
                            if ret < 0 as libc::c_int {
                                xmlSchemaInternalErr(
                                    actxt,
                                    b"xmlSchemaVCheckCVCSimpleType\0" as *const u8
                                        as *const libc::c_char,
                                    b"validating against a built-in type\0" as *const u8
                                        as *const libc::c_char,
                                );
                                current_block = 10711413107550680511;
                            } else {
                                if (*type_0).flags & (1 as libc::c_int) << 6 as libc::c_int
                                    != 0
                                {
                                    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as libc::c_int;
                                } else {
                                    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as libc::c_int;
                                }
                                current_block = 13826291924415791078;
                            }
                        } else {
                            current_block = 13826291924415791078;
                        }
                        match current_block {
                            10711413107550680511 => {}
                            _ => {
                                if ret == 0 as libc::c_int
                                    && (*type_0).flags & (1 as libc::c_int) << 27 as libc::c_int
                                        != 0
                                {
                                    ret = xmlSchemaValidateFacets(
                                        actxt,
                                        node,
                                        type_0,
                                        (*biType).builtInType as xmlSchemaValType,
                                        value,
                                        val,
                                        0 as libc::c_int as libc::c_ulong,
                                        fireErrors,
                                    );
                                    if ret != 0 as libc::c_int {
                                        if ret < 0 as libc::c_int {
                                            xmlSchemaInternalErr(
                                                actxt,
                                                b"xmlSchemaVCheckCVCSimpleType\0" as *const u8
                                                    as *const libc::c_char,
                                                b"validating facets of atomic simple type\0" as *const u8
                                                    as *const libc::c_char,
                                            );
                                            current_block = 10711413107550680511;
                                        } else {
                                            if (*type_0).flags & (1 as libc::c_int) << 6 as libc::c_int
                                                != 0
                                            {
                                                ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as libc::c_int;
                                            } else {
                                                ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as libc::c_int;
                                            }
                                            current_block = 8953117030348968745;
                                        }
                                    } else {
                                        current_block = 8953117030348968745;
                                    }
                                } else {
                                    if fireErrors != 0 && ret > 0 as libc::c_int {
                                        xmlSchemaSimpleTypeErr(
                                            actxt,
                                            ret as xmlParserErrors,
                                            node,
                                            value,
                                            type_0,
                                            1 as libc::c_int,
                                        );
                                    }
                                    current_block = 8953117030348968745;
                                }
                            }
                        }
                    }
                }
            }
        }
    } else if (*type_0).flags & (1 as libc::c_int) << 6 as libc::c_int != 0 {
        let mut itemType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        let mut cur: *const xmlChar = 0 as *const xmlChar;
        let mut end: *const xmlChar = 0 as *const xmlChar;
        let mut tmpValue: *mut xmlChar = 0 as *mut xmlChar;
        let mut len: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
        let mut prevVal: xmlSchemaValPtr = 0 as xmlSchemaValPtr;
        let mut curVal: xmlSchemaValPtr = 0 as xmlSchemaValPtr;
        if isNormalized == 0
            && (normalize != 0
                || (*type_0).flags & (1 as libc::c_int) << 28 as libc::c_int != 0)
        {
            normValue = xmlSchemaNormalizeValue(type_0, value);
            if !normValue.is_null() {
                value = normValue;
            }
            isNormalized = 1 as libc::c_int;
        }
        itemType = (*type_0).subtypes;
        cur = value;
        loop {
            while *cur as libc::c_int == 0x20 as libc::c_int
                || 0x9 as libc::c_int <= *cur as libc::c_int
                    && *cur as libc::c_int <= 0xa as libc::c_int
                || *cur as libc::c_int == 0xd as libc::c_int
            {
                cur = cur.offset(1);
            }
            end = cur;
            while *end as libc::c_int != 0 as libc::c_int
                && !(*end as libc::c_int == 0x20 as libc::c_int
                    || 0x9 as libc::c_int <= *end as libc::c_int
                        && *end as libc::c_int <= 0xa as libc::c_int
                    || *end as libc::c_int == 0xd as libc::c_int)
            {
                end = end.offset(1);
            }
            if end == cur {
                current_block = 4804377075063615140;
                break;
            }
            tmpValue = xmlStrndup(
                cur,
                end.offset_from(cur) as libc::c_long as libc::c_int,
            );
            len = len.wrapping_add(1);
            if valNeeded != 0 {
                ret = xmlSchemaVCheckCVCSimpleType(
                    actxt,
                    node,
                    itemType,
                    tmpValue,
                    &mut curVal,
                    fireErrors,
                    0 as libc::c_int,
                    1 as libc::c_int,
                );
            } else {
                ret = xmlSchemaVCheckCVCSimpleType(
                    actxt,
                    node,
                    itemType,
                    tmpValue,
                    0 as *mut xmlSchemaValPtr,
                    fireErrors,
                    0 as libc::c_int,
                    1 as libc::c_int,
                );
            }
            if !tmpValue.is_null() {
                xmlFree
                    .expect("non-null function pointer")(tmpValue as *mut libc::c_void);
                tmpValue = 0 as *mut xmlChar;
            }
            if !curVal.is_null() {
                if val.is_null() {
                    val = curVal;
                } else {
                    xmlSchemaValueAppend(prevVal, curVal);
                }
                prevVal = curVal;
                curVal = 0 as xmlSchemaValPtr;
            }
            if ret != 0 as libc::c_int {
                if ret < 0 as libc::c_int {
                    xmlSchemaInternalErr(
                        actxt,
                        b"xmlSchemaVCheckCVCSimpleType\0" as *const u8
                            as *const libc::c_char,
                        b"validating an item of list simple type\0" as *const u8
                            as *const libc::c_char,
                    );
                    current_block = 10711413107550680511;
                    break;
                } else {
                    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as libc::c_int;
                    current_block = 4804377075063615140;
                    break;
                }
            } else {
                cur = end;
                if !(*cur as libc::c_int != 0 as libc::c_int) {
                    current_block = 4804377075063615140;
                    break;
                }
            }
        }
        match current_block {
            10711413107550680511 => {}
            _ => {
                if !tmpValue.is_null() {
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(tmpValue as *mut libc::c_void);
                    tmpValue = 0 as *mut xmlChar;
                }
                if ret == 0 as libc::c_int
                    && (*type_0).flags & (1 as libc::c_int) << 27 as libc::c_int != 0
                {
                    ret = xmlSchemaValidateFacets(
                        actxt,
                        node,
                        type_0,
                        XML_SCHEMAS_UNKNOWN,
                        value,
                        val,
                        len,
                        fireErrors,
                    );
                    if ret != 0 as libc::c_int {
                        if ret < 0 as libc::c_int {
                            xmlSchemaInternalErr(
                                actxt,
                                b"xmlSchemaVCheckCVCSimpleType\0" as *const u8
                                    as *const libc::c_char,
                                b"validating facets of list simple type\0" as *const u8
                                    as *const libc::c_char,
                            );
                            current_block = 10711413107550680511;
                        } else {
                            ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as libc::c_int;
                            current_block = 8533724845731836612;
                        }
                    } else {
                        current_block = 8533724845731836612;
                    }
                } else {
                    current_block = 8533724845731836612;
                }
                match current_block {
                    10711413107550680511 => {}
                    _ => {
                        if fireErrors != 0 && ret > 0 as libc::c_int {
                            normalize = 1 as libc::c_int;
                            if isNormalized == 0
                                && (normalize != 0
                                    || (*type_0).flags & (1 as libc::c_int) << 28 as libc::c_int
                                        != 0)
                            {
                                normValue = xmlSchemaNormalizeValue(type_0, value);
                                if !normValue.is_null() {
                                    value = normValue;
                                }
                                isNormalized = 1 as libc::c_int;
                            }
                            xmlSchemaSimpleTypeErr(
                                actxt,
                                ret as xmlParserErrors,
                                node,
                                value,
                                type_0,
                                1 as libc::c_int,
                            );
                        }
                        current_block = 8953117030348968745;
                    }
                }
            }
        }
    } else if (*type_0).flags & (1 as libc::c_int) << 7 as libc::c_int != 0 {
        let mut memberLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
        memberLink = xmlSchemaGetUnionSimpleTypeMemberTypes(type_0);
        if memberLink.is_null() {
            xmlSchemaInternalErr(
                actxt,
                b"xmlSchemaVCheckCVCSimpleType\0" as *const u8 as *const libc::c_char,
                b"union simple type has no member types\0" as *const u8
                    as *const libc::c_char,
            );
            current_block = 10711413107550680511;
        } else {
            while !memberLink.is_null() {
                if valNeeded != 0 {
                    ret = xmlSchemaVCheckCVCSimpleType(
                        actxt,
                        node,
                        (*memberLink).type_0,
                        value,
                        &mut val,
                        0 as libc::c_int,
                        1 as libc::c_int,
                        0 as libc::c_int,
                    );
                } else {
                    ret = xmlSchemaVCheckCVCSimpleType(
                        actxt,
                        node,
                        (*memberLink).type_0,
                        value,
                        0 as *mut xmlSchemaValPtr,
                        0 as libc::c_int,
                        1 as libc::c_int,
                        0 as libc::c_int,
                    );
                }
                if ret <= 0 as libc::c_int {
                    break;
                }
                memberLink = (*memberLink).next;
            }
            if ret != 0 as libc::c_int {
                if ret < 0 as libc::c_int {
                    xmlSchemaInternalErr(
                        actxt,
                        b"xmlSchemaVCheckCVCSimpleType\0" as *const u8
                            as *const libc::c_char,
                        b"validating members of union simple type\0" as *const u8
                            as *const libc::c_char,
                    );
                    current_block = 10711413107550680511;
                } else {
                    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3 as libc::c_int;
                    current_block = 4871270227279186910;
                }
            } else {
                current_block = 4871270227279186910;
            }
            match current_block {
                10711413107550680511 => {}
                _ => {
                    if ret == 0 as libc::c_int
                        && (*type_0).flags & (1 as libc::c_int) << 27 as libc::c_int != 0
                    {
                        if isNormalized == 0
                            && (normalize != 0
                                || (*type_0).flags & (1 as libc::c_int) << 28 as libc::c_int
                                    != 0)
                        {
                            normValue = xmlSchemaNormalizeValue(
                                (*memberLink).type_0,
                                value,
                            );
                            if !normValue.is_null() {
                                value = normValue;
                            }
                            isNormalized = 1 as libc::c_int;
                        }
                        ret = xmlSchemaValidateFacets(
                            actxt,
                            node,
                            type_0,
                            XML_SCHEMAS_UNKNOWN,
                            value,
                            val,
                            0 as libc::c_int as libc::c_ulong,
                            fireErrors,
                        );
                        if ret != 0 as libc::c_int {
                            if ret < 0 as libc::c_int {
                                xmlSchemaInternalErr(
                                    actxt,
                                    b"xmlSchemaVCheckCVCSimpleType\0" as *const u8
                                        as *const libc::c_char,
                                    b"validating facets of union simple type\0" as *const u8
                                        as *const libc::c_char,
                                );
                                current_block = 10711413107550680511;
                            } else {
                                ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3 as libc::c_int;
                                current_block = 7198204517578597543;
                            }
                        } else {
                            current_block = 7198204517578597543;
                        }
                    } else {
                        current_block = 7198204517578597543;
                    }
                    match current_block {
                        10711413107550680511 => {}
                        _ => {
                            if fireErrors != 0 && ret > 0 as libc::c_int {
                                xmlSchemaSimpleTypeErr(
                                    actxt,
                                    ret as xmlParserErrors,
                                    node,
                                    value,
                                    type_0,
                                    1 as libc::c_int,
                                );
                            }
                            current_block = 8953117030348968745;
                        }
                    }
                }
            }
        }
    } else {
        current_block = 8953117030348968745;
    }
    match current_block {
        10711413107550680511 => {
            if !normValue.is_null() {
                xmlFree
                    .expect("non-null function pointer")(normValue as *mut libc::c_void);
            }
            if !val.is_null() {
                xmlSchemaFreeValue(val);
            }
            return -(1 as libc::c_int);
        }
        _ => {
            if !normValue.is_null() {
                xmlFree
                    .expect("non-null function pointer")(normValue as *mut libc::c_void);
            }
            if ret == 0 as libc::c_int {
                if !retVal.is_null() {
                    *retVal = val;
                } else if !val.is_null() {
                    xmlSchemaFreeValue(val);
                }
            } else if !val.is_null() {
                xmlSchemaFreeValue(val);
            }
            return ret;
        }
    };
}
unsafe extern "C" fn xmlSchemaVExpandQName(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut value: *const xmlChar,
    mut nsName: *mut *const xmlChar,
    mut localName: *mut *const xmlChar,
) -> libc::c_int {
    let mut ret: libc::c_int = 0 as libc::c_int;
    if nsName.is_null() || localName.is_null() {
        return -(1 as libc::c_int);
    }
    *nsName = 0 as *const xmlChar;
    *localName = 0 as *const xmlChar;
    ret = xmlValidateQName(value, 1 as libc::c_int);
    if ret == -(1 as libc::c_int) {
        return -(1 as libc::c_int);
    }
    if ret > 0 as libc::c_int {
        xmlSchemaSimpleTypeErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1,
            0 as xmlNodePtr,
            value,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),
            1 as libc::c_int,
        );
        return 1 as libc::c_int;
    }
    let mut local: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    local = xmlSplitQName2(value, &mut prefix);
    if local.is_null() {
        *localName = xmlDictLookup((*vctxt).dict, value, -(1 as libc::c_int));
    } else {
        *localName = xmlDictLookup((*vctxt).dict, local, -(1 as libc::c_int));
        xmlFree.expect("non-null function pointer")(local as *mut libc::c_void);
    }
    *nsName = xmlSchemaLookupNamespace(vctxt, prefix);
    if !prefix.is_null() {
        xmlFree.expect("non-null function pointer")(prefix as *mut libc::c_void);
        if (*nsName).is_null() {
            xmlSchemaCustomErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1,
                0 as xmlNodePtr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME) as xmlSchemaBasicItemPtr,
                b"The QName value '%s' has no corresponding namespace declaration in scope\0"
                    as *const u8 as *const libc::c_char,
                value,
                0 as *const xmlChar,
            );
            return 2 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaProcessXSIType(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut iattr: xmlSchemaAttrInfoPtr,
    mut localType: *mut xmlSchemaTypePtr,
    mut elemDecl: xmlSchemaElementPtr,
) -> libc::c_int {
    let mut ret: libc::c_int = 0 as libc::c_int;
    if localType.is_null() {
        return -(1 as libc::c_int);
    }
    *localType = 0 as xmlSchemaTypePtr;
    if iattr.is_null() {
        return 0 as libc::c_int
    } else {
        let mut nsName: *const xmlChar = 0 as *const xmlChar;
        let mut local: *const xmlChar = 0 as *const xmlChar;
        let ref mut fresh563 = (*vctxt).inode;
        *fresh563 = iattr as xmlSchemaNodeInfoPtr;
        ret = xmlSchemaVExpandQName(vctxt, (*iattr).value, &mut nsName, &mut local);
        if ret != 0 as libc::c_int {
            if ret < 0 as libc::c_int {
                xmlSchemaInternalErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaValidateElementByDeclaration\0" as *const u8
                        as *const libc::c_char,
                    b"calling xmlSchemaQNameExpand() to validate the attribute 'xsi:type'\0"
                        as *const u8 as *const libc::c_char,
                );
                let ref mut fresh565 = (*vctxt).inode;
                *fresh565 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
                return -(1 as libc::c_int);
            }
        } else {
            *localType = xmlSchemaGetType((*vctxt).schema, local, nsName);
            if (*localType).is_null() {
                let mut str: *mut xmlChar = 0 as *mut xmlChar;
                xmlSchemaCustomErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    XML_SCHEMAV_CVC_ELT_4_2,
                    0 as xmlNodePtr,
                    xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME) as xmlSchemaBasicItemPtr,
                    b"The QName value '%s' of the xsi:type attribute does not resolve to a type definition\0"
                        as *const u8 as *const libc::c_char,
                    xmlSchemaFormatQName(&mut str, nsName, local),
                    0 as *const xmlChar,
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                ret = (*vctxt).err;
            } else if !elemDecl.is_null() {
                let mut set: libc::c_int = 0 as libc::c_int;
                if (*elemDecl).flags & (1 as libc::c_int) << 11 as libc::c_int != 0
                    || (*(*elemDecl).subtypes).flags
                        & (1 as libc::c_int) << 18 as libc::c_int != 0
                {
                    set |= (1 as libc::c_int) << 1 as libc::c_int;
                }
                if (*elemDecl).flags & (1 as libc::c_int) << 12 as libc::c_int != 0
                    || (*(*elemDecl).subtypes).flags
                        & (1 as libc::c_int) << 19 as libc::c_int != 0
                {
                    set |= (1 as libc::c_int) << 0 as libc::c_int;
                }
                if xmlSchemaCheckCOSDerivedOK(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    *localType,
                    (*elemDecl).subtypes,
                    set,
                ) != 0 as libc::c_int
                {
                    let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaCustomErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAV_CVC_ELT_4_3,
                        0 as xmlNodePtr,
                        0 as xmlSchemaBasicItemPtr,
                        b"The type definition '%s', specified by xsi:type, is blocked or not validly derived from the type definition of the element declaration\0"
                            as *const u8 as *const libc::c_char,
                        xmlSchemaFormatQName(
                            &mut str_0,
                            (**localType).targetNamespace,
                            (**localType).name,
                        ),
                        0 as *const xmlChar,
                    );
                    if !str_0.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str_0 as *mut libc::c_void);
                        str_0 = 0 as *mut xmlChar;
                    }
                    ret = (*vctxt).err;
                    *localType = 0 as xmlSchemaTypePtr;
                }
            }
        }
        let ref mut fresh564 = (*vctxt).inode;
        *fresh564 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
        return ret;
    };
}
unsafe extern "C" fn xmlSchemaValidateElemDecl(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> libc::c_int {
    let mut elemDecl: xmlSchemaElementPtr = (*(*vctxt).inode).decl;
    let mut actualType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    if elemDecl.is_null() {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_ELT_1,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"No matching declaration available\0" as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*vctxt).err;
    }
    actualType = (*elemDecl).subtypes;
    if (*elemDecl).flags & (1 as libc::c_int) << 4 as libc::c_int != 0 {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_ELT_2,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"The element declaration is abstract\0" as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*vctxt).err;
    }
    if actualType.is_null() {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_TYPE_1,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"The type definition is absent\0" as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return XML_SCHEMAV_CVC_TYPE_1 as libc::c_int;
    }
    if (*vctxt).nbAttrInfos != 0 as libc::c_int {
        let mut ret: libc::c_int = 0;
        let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
        iattr = xmlSchemaGetMetaAttrInfo(vctxt, 2 as libc::c_int);
        if !iattr.is_null() {
            let ref mut fresh566 = (*vctxt).inode;
            *fresh566 = iattr as xmlSchemaNodeInfoPtr;
            ret = xmlSchemaVCheckCVCSimpleType(
                vctxt as xmlSchemaAbstractCtxtPtr,
                0 as xmlNodePtr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
                (*iattr).value,
                &mut (*iattr).val,
                1 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
            );
            let ref mut fresh567 = (*vctxt).inode;
            *fresh567 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
            if ret < 0 as libc::c_int {
                xmlSchemaInternalErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaValidateElemDecl\0" as *const u8 as *const libc::c_char,
                    b"calling xmlSchemaVCheckCVCSimpleType() to validate the attribute 'xsi:nil'\0"
                        as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            if ret == 0 as libc::c_int {
                if (*elemDecl).flags & (1 as libc::c_int) << 0 as libc::c_int
                    == 0 as libc::c_int
                {
                    xmlSchemaCustomErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAV_CVC_ELT_3_1,
                        0 as xmlNodePtr,
                        0 as xmlSchemaBasicItemPtr,
                        b"The element is not 'nillable'\0" as *const u8
                            as *const libc::c_char,
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                } else if xmlSchemaValueGetAsBoolean((*iattr).val) != 0 {
                    if (*elemDecl).flags & (1 as libc::c_int) << 3 as libc::c_int != 0
                        && !((*elemDecl).value).is_null()
                    {
                        xmlSchemaCustomErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            XML_SCHEMAV_CVC_ELT_3_2_2,
                            0 as xmlNodePtr,
                            0 as xmlSchemaBasicItemPtr,
                            b"The element cannot be 'nilled' because there is a fixed value constraint defined for it\0"
                                as *const u8 as *const libc::c_char,
                            0 as *const xmlChar,
                            0 as *const xmlChar,
                        );
                    } else {
                        (*(*vctxt).inode).flags
                            |= (1 as libc::c_int) << 2 as libc::c_int;
                    }
                }
            }
        }
        iattr = xmlSchemaGetMetaAttrInfo(vctxt, 1 as libc::c_int);
        if !iattr.is_null() {
            let mut localType: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
            ret = xmlSchemaProcessXSIType(vctxt, iattr, &mut localType, elemDecl);
            if ret != 0 as libc::c_int {
                if ret == -(1 as libc::c_int) {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaValidateElemDecl\0" as *const u8
                            as *const libc::c_char,
                        b"calling xmlSchemaProcessXSIType() to process the attribute 'xsi:type'\0"
                            as *const u8 as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
            }
            if !localType.is_null() {
                (*(*vctxt).inode).flags |= (1 as libc::c_int) << 3 as libc::c_int;
                actualType = localType;
            }
        }
    }
    if !((*elemDecl).idcs).is_null()
        && xmlSchemaIDCRegisterMatchers(vctxt, elemDecl) == -(1 as libc::c_int)
    {
        return -(1 as libc::c_int);
    }
    if actualType.is_null() {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_TYPE_1,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"The type definition is absent\0" as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return XML_SCHEMAV_CVC_TYPE_1 as libc::c_int;
    }
    let ref mut fresh568 = (*(*vctxt).inode).typeDef;
    *fresh568 = actualType;
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaVAttributesSimple(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> libc::c_int {
    let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_int = 0;
    if (*vctxt).nbAttrInfos == 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < (*vctxt).nbAttrInfos {
        iattr = *((*vctxt).attrInfos).offset(i as isize);
        if (*iattr).metaType == 0 {
            let ref mut fresh569 = (*vctxt).inode;
            *fresh569 = iattr as xmlSchemaNodeInfoPtr;
            xmlSchemaIllegalAttrErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAV_CVC_TYPE_3_1_1,
                iattr,
                0 as xmlNodePtr,
            );
            ret = XML_SCHEMAV_CVC_TYPE_3_1_1 as libc::c_int;
        }
        i += 1;
    }
    let ref mut fresh570 = (*vctxt).inode;
    *fresh570 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
    return ret;
}
unsafe extern "C" fn xmlSchemaClearAttrInfos(mut vctxt: xmlSchemaValidCtxtPtr) {
    let mut i: libc::c_int = 0;
    let mut attr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    if (*vctxt).nbAttrInfos == 0 as libc::c_int {
        return;
    }
    i = 0 as libc::c_int;
    while i < (*vctxt).nbAttrInfos {
        attr = *((*vctxt).attrInfos).offset(i as isize);
        if (*attr).flags & (1 as libc::c_int) << 0 as libc::c_int != 0 {
            if !((*attr).localName).is_null() {
                xmlFree
                    .expect(
                        "non-null function pointer",
                    )((*attr).localName as *mut xmlChar as *mut libc::c_void);
            }
            if !((*attr).nsName).is_null() {
                xmlFree
                    .expect(
                        "non-null function pointer",
                    )((*attr).nsName as *mut xmlChar as *mut libc::c_void);
            }
        }
        if (*attr).flags & (1 as libc::c_int) << 1 as libc::c_int != 0 {
            if !((*attr).value).is_null() {
                xmlFree
                    .expect(
                        "non-null function pointer",
                    )((*attr).value as *mut xmlChar as *mut libc::c_void);
            }
        }
        if !((*attr).val).is_null() {
            xmlSchemaFreeValue((*attr).val);
            let ref mut fresh571 = (*attr).val;
            *fresh571 = 0 as xmlSchemaValPtr;
        }
        memset(
            attr as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<xmlSchemaAttrInfo>() as libc::c_ulong,
        );
        i += 1;
    }
    (*vctxt).nbAttrInfos = 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaVAttributesComplex(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> libc::c_int {
    let mut current_block: u64;
    let mut type_0: xmlSchemaTypePtr = (*(*vctxt).inode).typeDef;
    let mut attrUseList: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    let mut attrUse: xmlSchemaAttributeUsePtr = 0 as xmlSchemaAttributeUsePtr;
    let mut attrDecl: xmlSchemaAttributePtr = 0 as xmlSchemaAttributePtr;
    let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    let mut tmpiattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut found: libc::c_int = 0;
    let mut nbAttrs: libc::c_int = 0;
    let mut nbUses: libc::c_int = 0;
    let mut xpathRes: libc::c_int = 0 as libc::c_int;
    let mut res: libc::c_int = 0;
    let mut wildIDs: libc::c_int = 0 as libc::c_int;
    let mut fixed: libc::c_int = 0;
    let mut defAttrOwnerElem: xmlNodePtr = 0 as xmlNodePtr;
    attrUseList = (*type_0).attrUses as xmlSchemaItemListPtr;
    nbAttrs = (*vctxt).nbAttrInfos;
    if !attrUseList.is_null() {
        nbUses = (*attrUseList).nbItems;
    } else {
        nbUses = 0 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < nbUses {
        found = 0 as libc::c_int;
        attrUse = *((*attrUseList).items).offset(i as isize) as xmlSchemaAttributeUsePtr;
        attrDecl = (*attrUse).attrDecl;
        j = 0 as libc::c_int;
        while j < nbAttrs {
            iattr = *((*vctxt).attrInfos).offset(j as isize);
            if !((*iattr).metaType != 0) {
                if !(*((*iattr).localName).offset(0 as libc::c_int as isize)
                    as libc::c_int
                    != *((*attrDecl).name).offset(0 as libc::c_int as isize)
                        as libc::c_int)
                {
                    if !(xmlStrEqual((*iattr).localName, (*attrDecl).name) == 0) {
                        if !(xmlStrEqual((*iattr).nsName, (*attrDecl).targetNamespace)
                            == 0)
                        {
                            found = 1 as libc::c_int;
                            (*iattr).state = 2 as libc::c_int;
                            let ref mut fresh572 = (*iattr).use_0;
                            *fresh572 = attrUse;
                            let ref mut fresh573 = (*iattr).decl;
                            *fresh573 = attrDecl;
                            let ref mut fresh574 = (*iattr).typeDef;
                            *fresh574 = (*attrDecl).subtypes;
                            break;
                        }
                    }
                }
            }
            j += 1;
        }
        if !(found != 0) {
            if (*attrUse).occurs == 1 as libc::c_int {
                tmpiattr = xmlSchemaGetFreshAttrInfo(vctxt);
                if tmpiattr.is_null() {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaVAttributesComplex\0" as *const u8
                            as *const libc::c_char,
                        b"calling xmlSchemaGetFreshAttrInfo()\0" as *const u8
                            as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
                (*tmpiattr).state = 4 as libc::c_int;
                let ref mut fresh575 = (*tmpiattr).use_0;
                *fresh575 = attrUse;
                let ref mut fresh576 = (*tmpiattr).decl;
                *fresh576 = attrDecl;
            } else if (*attrUse).occurs == 2 as libc::c_int
                    && (!((*attrUse).defValue).is_null()
                        || !((*attrDecl).defValue).is_null())
                {
                tmpiattr = xmlSchemaGetFreshAttrInfo(vctxt);
                if tmpiattr.is_null() {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaVAttributesComplex\0" as *const u8
                            as *const libc::c_char,
                        b"calling xmlSchemaGetFreshAttrInfo()\0" as *const u8
                            as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
                (*tmpiattr).state = 8 as libc::c_int;
                let ref mut fresh577 = (*tmpiattr).use_0;
                *fresh577 = attrUse;
                let ref mut fresh578 = (*tmpiattr).decl;
                *fresh578 = attrDecl;
                let ref mut fresh579 = (*tmpiattr).typeDef;
                *fresh579 = (*attrDecl).subtypes;
                let ref mut fresh580 = (*tmpiattr).localName;
                *fresh580 = (*attrDecl).name;
                let ref mut fresh581 = (*tmpiattr).nsName;
                *fresh581 = (*attrDecl).targetNamespace;
            }
        }
        i += 1;
    }
    if (*vctxt).nbAttrInfos == 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    if !((*type_0).attributeWildcard).is_null() {
        i = 0 as libc::c_int;
        while i < nbAttrs {
            iattr = *((*vctxt).attrInfos).offset(i as isize);
            if !((*iattr).state != 1 as libc::c_int) {
                if xmlSchemaCheckCVCWildcardNamespace(
                    (*type_0).attributeWildcard,
                    (*iattr).nsName,
                ) == 0 as libc::c_int
                {
                    if (*(*type_0).attributeWildcard).processContents == 1 as libc::c_int
                    {
                        (*iattr).state = 13 as libc::c_int;
                    } else {
                        let ref mut fresh582 = (*iattr).decl;
                        *fresh582 = xmlSchemaGetAttributeDecl(
                            (*vctxt).schema,
                            (*iattr).localName,
                            (*iattr).nsName,
                        );
                        if !((*iattr).decl).is_null() {
                            (*iattr).state = 2 as libc::c_int;
                            let ref mut fresh583 = (*iattr).typeDef;
                            *fresh583 = (*(*iattr).decl).subtypes;
                            if xmlSchemaIsDerivedFromBuiltInType(
                                (*iattr).typeDef,
                                XML_SCHEMAS_ID as libc::c_int,
                            ) != 0
                            {
                                if wildIDs != 0 as libc::c_int {
                                    (*iattr).state = 15 as libc::c_int;
                                    (*__xmlGenericError())
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        *__xmlGenericErrorContext(),
                                        b"Unimplemented block at %s:%d\n\0" as *const u8
                                            as *const libc::c_char,
                                        b"xmlschemas.c\0" as *const u8 as *const libc::c_char,
                                        25640 as libc::c_int,
                                    );
                                } else {
                                    wildIDs += 1;
                                    if !attrUseList.is_null() {
                                        j = 0 as libc::c_int;
                                        while j < (*attrUseList).nbItems {
                                            if xmlSchemaIsDerivedFromBuiltInType(
                                                (*(*(*((*attrUseList).items).offset(j as isize)
                                                    as xmlSchemaAttributeUsePtr))
                                                    .attrDecl)
                                                    .subtypes,
                                                XML_SCHEMAS_ID as libc::c_int,
                                            ) != 0
                                            {
                                                (*iattr).state = 16 as libc::c_int;
                                                (*__xmlGenericError())
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(
                                                    *__xmlGenericErrorContext(),
                                                    b"Unimplemented block at %s:%d\n\0" as *const u8
                                                        as *const libc::c_char,
                                                    b"xmlschemas.c\0" as *const u8 as *const libc::c_char,
                                                    25658 as libc::c_int,
                                                );
                                                break;
                                            } else {
                                                j += 1;
                                            }
                                        }
                                    }
                                }
                            }
                        } else if (*(*type_0).attributeWildcard).processContents
                                == 2 as libc::c_int
                            {
                            (*iattr).state = 14 as libc::c_int;
                        } else {
                            (*iattr).state = 10 as libc::c_int;
                        }
                    }
                }
            }
            i += 1;
        }
    }
    if (*vctxt).nbAttrInfos == 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    if (*vctxt).options & XML_SCHEMA_VAL_VC_I_CREATE as libc::c_int != 0 {
        let mut ielem: xmlSchemaNodeInfoPtr = *((*vctxt).elemInfos)
            .offset((*vctxt).depth as isize);
        if !ielem.is_null() && !((*ielem).node).is_null()
            && !((*(*ielem).node).doc).is_null()
        {
            defAttrOwnerElem = (*ielem).node;
        }
    }
    i = 0 as libc::c_int;
    's_457: loop {
        if !(i < (*vctxt).nbAttrInfos) {
            current_block = 12463749970033092792;
            break;
        }
        iattr = *((*vctxt).attrInfos).offset(i as isize);
        if !((*iattr).state != 2 as libc::c_int && (*iattr).state != 8 as libc::c_int) {
            if ((*iattr).typeDef).is_null() {
                (*iattr).state = 6 as libc::c_int;
            } else {
                let ref mut fresh584 = (*vctxt).inode;
                *fresh584 = iattr as xmlSchemaNodeInfoPtr;
                fixed = 0 as libc::c_int;
                xpathRes = 0 as libc::c_int;
                if !((*vctxt).xpathStates).is_null() {
                    xpathRes = xmlSchemaXPathEvaluate(vctxt, XML_ATTRIBUTE_NODE);
                    if xpathRes == -(1 as libc::c_int) {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaVAttributesComplex\0" as *const u8
                                as *const libc::c_char,
                            b"calling xmlSchemaXPathEvaluate()\0" as *const u8
                                as *const libc::c_char,
                        );
                        current_block = 16059426333721732591;
                        break;
                    }
                }
                if (*iattr).state == 8 as libc::c_int {
                    if xpathRes != 0 || !defAttrOwnerElem.is_null() {
                        if !((*(*iattr).use_0).defValue).is_null() {
                            let ref mut fresh585 = (*iattr).value;
                            *fresh585 = (*(*iattr).use_0).defValue as *mut xmlChar;
                            let ref mut fresh586 = (*iattr).val;
                            *fresh586 = (*(*iattr).use_0).defVal;
                        } else {
                            let ref mut fresh587 = (*iattr).value;
                            *fresh587 = (*(*iattr).decl).defValue as *mut xmlChar;
                            let ref mut fresh588 = (*iattr).val;
                            *fresh588 = (*(*iattr).decl).defVal;
                        }
                        if ((*iattr).val).is_null() {
                            xmlSchemaInternalErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                b"xmlSchemaVAttributesComplex\0" as *const u8
                                    as *const libc::c_char,
                                b"default/fixed value on an attribute use was not precomputed\0"
                                    as *const u8 as *const libc::c_char,
                            );
                            current_block = 16059426333721732591;
                            break;
                        } else {
                            let ref mut fresh589 = (*iattr).val;
                            *fresh589 = xmlSchemaCopyValue((*iattr).val);
                            if ((*iattr).val).is_null() {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaVAttributesComplex\0" as *const u8
                                        as *const libc::c_char,
                                    b"calling xmlSchemaCopyValue()\0" as *const u8
                                        as *const libc::c_char,
                                );
                                current_block = 16059426333721732591;
                                break;
                            }
                        }
                    }
                    if !defAttrOwnerElem.is_null() {
                        let mut normValue: *mut xmlChar = 0 as *mut xmlChar;
                        let mut value: *const xmlChar = 0 as *const xmlChar;
                        value = (*iattr).value;
                        normValue = xmlSchemaNormalizeValue(
                            (*iattr).typeDef,
                            (*iattr).value,
                        );
                        if !normValue.is_null() {
                            value = normValue;
                        }
                        if ((*iattr).nsName).is_null() {
                            if (xmlNewProp(defAttrOwnerElem, (*iattr).localName, value))
                                .is_null()
                            {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaVAttributesComplex\0" as *const u8
                                        as *const libc::c_char,
                                    b"calling xmlNewProp()\0" as *const u8
                                        as *const libc::c_char,
                                );
                                if !normValue.is_null() {
                                    xmlFree
                                        .expect(
                                            "non-null function pointer",
                                        )(normValue as *mut libc::c_void);
                                }
                                current_block = 16059426333721732591;
                                break;
                            }
                        } else {
                            let mut ns: xmlNsPtr = 0 as *mut xmlNs;
                            ns = xmlSearchNsByHref(
                                (*defAttrOwnerElem).doc,
                                defAttrOwnerElem,
                                (*iattr).nsName,
                            );
                            if ns.is_null() {
                                let mut prefix: [xmlChar; 12] = [0; 12];
                                let mut counter: libc::c_int = 0 as libc::c_int;
                                loop {
                                    let fresh590 = counter;
                                    counter = counter + 1;
                                    snprintf(
                                        prefix.as_mut_ptr() as *mut libc::c_char,
                                        12 as libc::c_int as libc::c_ulong,
                                        b"p%d\0" as *const u8 as *const libc::c_char,
                                        fresh590,
                                    );
                                    ns = xmlSearchNs(
                                        (*defAttrOwnerElem).doc,
                                        defAttrOwnerElem,
                                        prefix.as_mut_ptr(),
                                    );
                                    if counter > 1000 as libc::c_int {
                                        xmlSchemaInternalErr(
                                            vctxt as xmlSchemaAbstractCtxtPtr,
                                            b"xmlSchemaVAttributesComplex\0" as *const u8
                                                as *const libc::c_char,
                                            b"could not compute a ns prefix for a default/fixed attribute\0"
                                                as *const u8 as *const libc::c_char,
                                        );
                                        if !normValue.is_null() {
                                            xmlFree
                                                .expect(
                                                    "non-null function pointer",
                                                )(normValue as *mut libc::c_void);
                                        }
                                        current_block = 16059426333721732591;
                                        break 's_457;
                                    } else if ns.is_null() {
                                        break;
                                    }
                                }
                                ns = xmlNewNs(
                                    (*vctxt).validationRoot,
                                    (*iattr).nsName,
                                    prefix.as_mut_ptr(),
                                );
                            }
                            xmlNewNsProp(
                                defAttrOwnerElem,
                                ns,
                                (*iattr).localName,
                                value,
                            );
                        }
                        if !normValue.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(normValue as *mut libc::c_void);
                        }
                    }
                } else {
                    if !((*vctxt).value).is_null() {
                        xmlSchemaFreeValue((*vctxt).value);
                        let ref mut fresh591 = (*vctxt).value;
                        *fresh591 = 0 as xmlSchemaValPtr;
                    }
                    if (*(*iattr).decl).flags & (1 as libc::c_int) << 9 as libc::c_int
                        != 0
                        || !((*iattr).use_0).is_null()
                            && (*(*iattr).use_0).flags
                                & (1 as libc::c_int) << 9 as libc::c_int != 0
                    {
                        fixed = 1 as libc::c_int;
                    } else {
                        fixed = 0 as libc::c_int;
                    }
                    if xpathRes != 0 || fixed != 0 {
                        (*iattr).flags |= (1 as libc::c_int) << 4 as libc::c_int;
                        res = xmlSchemaVCheckCVCSimpleType(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            (*iattr).node,
                            (*iattr).typeDef,
                            (*iattr).value,
                            &mut (*iattr).val,
                            1 as libc::c_int,
                            1 as libc::c_int,
                            0 as libc::c_int,
                        );
                    } else {
                        res = xmlSchemaVCheckCVCSimpleType(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            (*iattr).node,
                            (*iattr).typeDef,
                            (*iattr).value,
                            0 as *mut xmlSchemaValPtr,
                            1 as libc::c_int,
                            0 as libc::c_int,
                            0 as libc::c_int,
                        );
                    }
                    if res != 0 as libc::c_int {
                        if res == -(1 as libc::c_int) {
                            xmlSchemaInternalErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                b"xmlSchemaVAttributesComplex\0" as *const u8
                                    as *const libc::c_char,
                                b"calling xmlSchemaStreamValidateSimpleTypeValue()\0"
                                    as *const u8 as *const libc::c_char,
                            );
                            current_block = 16059426333721732591;
                            break;
                        } else {
                            (*iattr).state = 5 as libc::c_int;
                        }
                    } else if fixed != 0 {
                        if ((*iattr).val).is_null() {
                            (*__xmlGenericError())
                                .expect(
                                    "non-null function pointer",
                                )(
                                *__xmlGenericErrorContext(),
                                b"Unimplemented block at %s:%d\n\0" as *const u8
                                    as *const libc::c_char,
                                b"xmlschemas.c\0" as *const u8 as *const libc::c_char,
                                25912 as libc::c_int,
                            );
                        } else if !((*iattr).use_0).is_null()
                                && !((*(*iattr).use_0).defValue).is_null()
                            {
                            if ((*(*iattr).use_0).defVal).is_null() {
                                (*__xmlGenericError())
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    *__xmlGenericErrorContext(),
                                    b"Unimplemented block at %s:%d\n\0" as *const u8
                                        as *const libc::c_char,
                                    b"xmlschemas.c\0" as *const u8 as *const libc::c_char,
                                    25919 as libc::c_int,
                                );
                            } else {
                                let ref mut fresh592 = (*iattr).vcValue;
                                *fresh592 = (*(*iattr).use_0).defValue;
                                if xmlSchemaAreValuesEqual(
                                    (*iattr).val,
                                    (*(*iattr).use_0).defVal,
                                ) == 0
                                {
                                    (*iattr).state = 7 as libc::c_int;
                                }
                            }
                        } else if ((*(*iattr).decl).defVal).is_null() {
                            (*__xmlGenericError())
                                .expect(
                                    "non-null function pointer",
                                )(
                                *__xmlGenericErrorContext(),
                                b"Unimplemented block at %s:%d\n\0" as *const u8
                                    as *const libc::c_char,
                                b"xmlschemas.c\0" as *const u8 as *const libc::c_char,
                                25934 as libc::c_int,
                            );
                        } else {
                            let ref mut fresh593 = (*iattr).vcValue;
                            *fresh593 = (*(*iattr).decl).defValue;
                            if xmlSchemaAreValuesEqual(
                                (*iattr).val,
                                (*(*iattr).decl).defVal,
                            ) == 0
                            {
                                (*iattr).state = 7 as libc::c_int;
                            }
                        }
                    }
                }
                if xpathRes != 0 {
                    if xmlSchemaXPathProcessHistory(
                        vctxt,
                        (*vctxt).depth + 1 as libc::c_int,
                    ) == -(1 as libc::c_int)
                    {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaVAttributesComplex\0" as *const u8
                                as *const libc::c_char,
                            b"calling xmlSchemaXPathEvaluate()\0" as *const u8
                                as *const libc::c_char,
                        );
                        current_block = 16059426333721732591;
                        break;
                    }
                } else if !((*vctxt).xpathStates).is_null() {
                    xmlSchemaXPathPop(vctxt);
                }
            }
        }
        i += 1;
    }
    match current_block {
        16059426333721732591 => {
            let ref mut fresh597 = (*vctxt).inode;
            *fresh597 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
            return -(1 as libc::c_int);
        }
        _ => {
            i = 0 as libc::c_int;
            while i < (*vctxt).nbAttrInfos {
                iattr = *((*vctxt).attrInfos).offset(i as isize);
                if !((*iattr).state == 17 as libc::c_int
                    || (*iattr).state == 2 as libc::c_int
                    || (*iattr).state == 13 as libc::c_int
                    || (*iattr).state == 14 as libc::c_int)
                {
                    let ref mut fresh594 = (*vctxt).inode;
                    *fresh594 = iattr as xmlSchemaNodeInfoPtr;
                    match (*iattr).state {
                        4 => {
                            let mut str: *mut xmlChar = 0 as *mut xmlChar;
                            let ref mut fresh595 = (*vctxt).inode;
                            *fresh595 = *((*vctxt).elemInfos)
                                .offset((*vctxt).depth as isize);
                            xmlSchemaCustomErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAV_CVC_COMPLEX_TYPE_4,
                                0 as xmlNodePtr,
                                0 as xmlSchemaBasicItemPtr,
                                b"The attribute '%s' is required but missing\0" as *const u8
                                    as *const libc::c_char,
                                xmlSchemaFormatQName(
                                    &mut str,
                                    (*(*iattr).decl).targetNamespace,
                                    (*(*iattr).decl).name,
                                ),
                                0 as *const xmlChar,
                            );
                            if !str.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(str as *mut libc::c_void);
                                str = 0 as *mut xmlChar;
                            }
                        }
                        6 => {
                            xmlSchemaCustomErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAV_CVC_ATTRIBUTE_2,
                                0 as xmlNodePtr,
                                0 as xmlSchemaBasicItemPtr,
                                b"The type definition is absent\0" as *const u8
                                    as *const libc::c_char,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        }
                        7 => {
                            xmlSchemaCustomErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAV_CVC_AU,
                                0 as xmlNodePtr,
                                0 as xmlSchemaBasicItemPtr,
                                b"The value '%s' does not match the fixed value constraint '%s'\0"
                                    as *const u8 as *const libc::c_char,
                                (*iattr).value,
                                (*iattr).vcValue,
                            );
                        }
                        10 => {
                            xmlSchemaCustomErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAV_CVC_WILDCARD,
                                0 as xmlNodePtr,
                                0 as xmlSchemaBasicItemPtr,
                                b"No matching global attribute declaration available, but demanded by the strict wildcard\0"
                                    as *const u8 as *const libc::c_char,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        }
                        1 => {
                            if !((*iattr).metaType != 0) {
                                if ((*type_0).attributeWildcard).is_null() {
                                    xmlSchemaIllegalAttrErr(
                                        vctxt as xmlSchemaAbstractCtxtPtr,
                                        XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1,
                                        iattr,
                                        0 as xmlNodePtr,
                                    );
                                } else {
                                    xmlSchemaIllegalAttrErr(
                                        vctxt as xmlSchemaAbstractCtxtPtr,
                                        XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2,
                                        iattr,
                                        0 as xmlNodePtr,
                                    );
                                }
                            }
                        }
                        _ => {}
                    }
                }
                i += 1;
            }
            let ref mut fresh596 = (*vctxt).inode;
            *fresh596 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
            return 0 as libc::c_int;
        }
    };
}
unsafe extern "C" fn xmlSchemaValidateElemWildcard(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut skip: *mut libc::c_int,
) -> libc::c_int {
    let mut wild: xmlSchemaWildcardPtr = (*(*vctxt).inode).decl as xmlSchemaWildcardPtr;
    if skip.is_null() || wild.is_null()
        || (*wild).type_0 as libc::c_uint
            != XML_SCHEMA_TYPE_ANY as libc::c_int as libc::c_uint
    {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaValidateElemWildcard\0" as *const u8 as *const libc::c_char,
            b"bad arguments\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    *skip = 0 as libc::c_int;
    if (*wild).processContents == 1 as libc::c_int {
        *skip = 1 as libc::c_int;
        return 0 as libc::c_int;
    }
    let mut decl: xmlSchemaElementPtr = 0 as xmlSchemaElementPtr;
    decl = xmlSchemaGetElem(
        (*vctxt).schema,
        (*(*vctxt).inode).localName,
        (*(*vctxt).inode).nsName,
    );
    if !decl.is_null() {
        let ref mut fresh598 = (*(*vctxt).inode).decl;
        *fresh598 = decl;
        return 0 as libc::c_int;
    }
    if (*wild).processContents == 3 as libc::c_int {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_ELT_1,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"No matching global element declaration available, but demanded by the strict wildcard\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*vctxt).err;
    }
    if (*vctxt).nbAttrInfos != 0 as libc::c_int {
        let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
        iattr = xmlSchemaGetMetaAttrInfo(vctxt, 1 as libc::c_int);
        if !iattr.is_null() {
            if xmlSchemaProcessXSIType(
                vctxt,
                iattr,
                &mut (*(*vctxt).inode).typeDef,
                0 as xmlSchemaElementPtr,
            ) == -(1 as libc::c_int)
            {
                xmlSchemaInternalErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaValidateElemWildcard\0" as *const u8
                        as *const libc::c_char,
                    b"calling xmlSchemaProcessXSIType() to process the attribute 'xsi:nil'\0"
                        as *const u8 as *const libc::c_char,
                );
                return -(1 as libc::c_int);
            }
            return 0 as libc::c_int;
        }
    }
    let ref mut fresh599 = (*(*vctxt).inode).typeDef;
    *fresh599 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaCheckCOSValidDefault(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut value: *const xmlChar,
    mut val: *mut xmlSchemaValPtr,
) -> libc::c_int {
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut inode: xmlSchemaNodeInfoPtr = (*vctxt).inode;
    if (*(*inode).typeDef).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
        || (*(*inode).typeDef).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int
    {
        if !((*(*inode).typeDef).contentType as libc::c_uint
            == XML_SCHEMA_CONTENT_SIMPLE as libc::c_int as libc::c_uint
            || (*(*inode).typeDef).contentType as libc::c_uint
                == XML_SCHEMA_CONTENT_BASIC as libc::c_int as libc::c_uint)
            && (!((*(*inode).typeDef).contentType as libc::c_uint
                == XML_SCHEMA_CONTENT_MIXED as libc::c_int as libc::c_uint)
                || xmlSchemaIsParticleEmptiable(
                    (*(*inode).typeDef).subtypes as xmlSchemaParticlePtr,
                ) == 0)
        {
            ret = XML_SCHEMAP_COS_VALID_DEFAULT_2_1 as libc::c_int;
            xmlSchemaCustomErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                ret as xmlParserErrors,
                0 as xmlNodePtr,
                0 as xmlSchemaBasicItemPtr,
                b"For a string to be a valid default, the type definition must be a simple type or a complex type with simple content or mixed content and a particle emptiable\0"
                    as *const u8 as *const libc::c_char,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return ret;
        }
    }
    if (*(*inode).typeDef).type_0 as libc::c_uint
        == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
        || (*(*inode).typeDef).type_0 as libc::c_uint
            == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
            && (*(*inode).typeDef).builtInType != XML_SCHEMAS_ANYTYPE as libc::c_int
    {
        ret = xmlSchemaVCheckCVCSimpleType(
            vctxt as xmlSchemaAbstractCtxtPtr,
            0 as xmlNodePtr,
            (*inode).typeDef,
            value,
            val,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int,
        );
    } else if (*(*inode).typeDef).contentType as libc::c_uint
            == XML_SCHEMA_CONTENT_SIMPLE as libc::c_int as libc::c_uint
            || (*(*inode).typeDef).contentType as libc::c_uint
                == XML_SCHEMA_CONTENT_BASIC as libc::c_int as libc::c_uint
        {
        ret = xmlSchemaVCheckCVCSimpleType(
            vctxt as xmlSchemaAbstractCtxtPtr,
            0 as xmlNodePtr,
            (*(*inode).typeDef).contentTypeDef,
            value,
            val,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int,
        );
    }
    if ret < 0 as libc::c_int {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaCheckCOSValidDefault\0" as *const u8 as *const libc::c_char,
            b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8
                as *const libc::c_char,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaVContentModelCallback(
    mut exec: xmlRegExecCtxtPtr,
    mut name: *const xmlChar,
    mut transdata: *mut libc::c_void,
    mut inputdata: *mut libc::c_void,
) {
    let mut item: xmlSchemaElementPtr = transdata as xmlSchemaElementPtr;
    let mut inode: xmlSchemaNodeInfoPtr = inputdata as xmlSchemaNodeInfoPtr;
    let ref mut fresh600 = (*inode).decl;
    *fresh600 = item;
}
unsafe extern "C" fn xmlSchemaValidatorPushElem(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> libc::c_int {
    let ref mut fresh601 = (*vctxt).inode;
    *fresh601 = xmlSchemaGetFreshElemInfo(vctxt);
    if ((*vctxt).inode).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaValidatorPushElem\0" as *const u8 as *const libc::c_char,
            b"calling xmlSchemaGetFreshElemInfo()\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    (*vctxt).nbAttrInfos = 0 as libc::c_int;
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaVCheckINodeDataType(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut inode: xmlSchemaNodeInfoPtr,
    mut type_0: xmlSchemaTypePtr,
    mut value: *const xmlChar,
) -> libc::c_int {
    if (*inode).flags & (1 as libc::c_int) << 4 as libc::c_int != 0 {
        return xmlSchemaVCheckCVCSimpleType(
            vctxt as xmlSchemaAbstractCtxtPtr,
            0 as xmlNodePtr,
            type_0,
            value,
            &mut (*inode).val,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as libc::c_int,
        )
    } else {
        return xmlSchemaVCheckCVCSimpleType(
            vctxt as xmlSchemaAbstractCtxtPtr,
            0 as xmlNodePtr,
            type_0,
            value,
            0 as *mut xmlSchemaValPtr,
            1 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
        )
    };
}
unsafe extern "C" fn xmlSchemaValidatorPopElem(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> libc::c_int {
    let mut current_block: u64;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut inode: xmlSchemaNodeInfoPtr = (*vctxt).inode;
    if (*vctxt).nbAttrInfos != 0 as libc::c_int {
        xmlSchemaClearAttrInfos(vctxt);
    }
    if (*inode).flags & (1 as libc::c_int) << 9 as libc::c_int != 0 {
        (*vctxt).skipDepth = (*vctxt).depth - 1 as libc::c_int;
        current_block = 13159517723375190530;
    } else if ((*inode).typeDef).is_null()
            || (*inode).flags & (1 as libc::c_int) << 10 as libc::c_int != 0
        {
        current_block = 13159517723375190530;
    } else {
        if (*(*inode).typeDef).contentType as libc::c_uint
            == XML_SCHEMA_CONTENT_MIXED as libc::c_int as libc::c_uint
            || (*(*inode).typeDef).contentType as libc::c_uint
                == XML_SCHEMA_CONTENT_ELEMENTS as libc::c_int as libc::c_uint
        {
            if (*(*inode).typeDef).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int {
                current_block = 8993999215443021867;
            } else if (*inode).flags & (1 as libc::c_int) << 8 as libc::c_int
                    == 0 as libc::c_int
                {
                let mut values: [*mut xmlChar; 10] = [0 as *mut xmlChar; 10];
                let mut terminal: libc::c_int = 0;
                let mut nbval: libc::c_int = 10 as libc::c_int;
                let mut nbneg: libc::c_int = 0;
                if ((*inode).regexCtxt).is_null() {
                    let ref mut fresh602 = (*inode).regexCtxt;
                    *fresh602 = xmlRegNewExecCtxt(
                        (*(*inode).typeDef).contModel,
                        Some(
                            xmlSchemaVContentModelCallback
                                as unsafe extern "C" fn(
                                    xmlRegExecCtxtPtr,
                                    *const xmlChar,
                                    *mut libc::c_void,
                                    *mut libc::c_void,
                                ) -> (),
                        ),
                        vctxt as *mut libc::c_void,
                    );
                    if ((*inode).regexCtxt).is_null() {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaValidatorPopElem\0" as *const u8
                                as *const libc::c_char,
                            b"failed to create a regex context\0" as *const u8
                                as *const libc::c_char,
                        );
                        current_block = 3454747893076357924;
                    } else {
                        current_block = 15976848397966268834;
                    }
                } else {
                    current_block = 15976848397966268834;
                }
                match current_block {
                    3454747893076357924 => {}
                    _ => {
                        if (*inode).flags & (1 as libc::c_int) << 2 as libc::c_int != 0 {
                            ret = 0 as libc::c_int;
                        } else {
                            xmlRegExecNextValues(
                                (*inode).regexCtxt,
                                &mut nbval,
                                &mut nbneg,
                                &mut *values.as_mut_ptr().offset(0 as libc::c_int as isize),
                                &mut terminal,
                            );
                            ret = xmlRegExecPushString(
                                (*inode).regexCtxt,
                                0 as *const xmlChar,
                                0 as *mut libc::c_void,
                            );
                            if ret < 0 as libc::c_int
                                || ret == 0 as libc::c_int
                                    && (*inode).flags & (1 as libc::c_int) << 2 as libc::c_int
                                        == 0
                            {
                                ret = 1 as libc::c_int;
                                (*inode).flags |= (1 as libc::c_int) << 8 as libc::c_int;
                                xmlSchemaComplexTypeErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    XML_SCHEMAV_ELEMENT_CONTENT,
                                    0 as xmlNodePtr,
                                    0 as xmlSchemaTypePtr,
                                    b"Missing child element(s)\0" as *const u8
                                        as *const libc::c_char,
                                    nbval,
                                    nbneg,
                                    values.as_mut_ptr(),
                                );
                            } else {
                                ret = 0 as libc::c_int;
                            }
                        }
                        current_block = 10035050265139717661;
                    }
                }
            } else {
                current_block = 10035050265139717661;
            }
        } else {
            current_block = 10035050265139717661;
        }
        match current_block {
            3454747893076357924 => {}
            _ => {
                match current_block {
                    10035050265139717661 => {
                        if (*(*inode).typeDef).contentType as libc::c_uint
                            == XML_SCHEMA_CONTENT_ELEMENTS as libc::c_int as libc::c_uint
                        {
                            current_block = 13159517723375190530;
                        } else {
                            current_block = 8993999215443021867;
                        }
                    }
                    _ => {}
                }
                match current_block {
                    13159517723375190530 => {}
                    _ => {
                        if !((*vctxt).value).is_null() {
                            xmlSchemaFreeValue((*vctxt).value);
                            let ref mut fresh603 = (*vctxt).value;
                            *fresh603 = 0 as xmlSchemaValPtr;
                        }
                        if ((*inode).decl).is_null() {
                            if (*(*inode).typeDef).type_0 as libc::c_uint
                                == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
                                || (*(*inode).typeDef).type_0 as libc::c_uint
                                    == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                                    && (*(*inode).typeDef).builtInType
                                        != XML_SCHEMAS_ANYTYPE as libc::c_int
                            {
                                ret = xmlSchemaVCheckINodeDataType(
                                    vctxt,
                                    inode,
                                    (*inode).typeDef,
                                    (*inode).value,
                                );
                            } else if (*(*inode).typeDef).contentType as libc::c_uint
                                    == XML_SCHEMA_CONTENT_SIMPLE as libc::c_int as libc::c_uint
                                    || (*(*inode).typeDef).contentType as libc::c_uint
                                        == XML_SCHEMA_CONTENT_BASIC as libc::c_int as libc::c_uint
                                {
                                ret = xmlSchemaVCheckINodeDataType(
                                    vctxt,
                                    inode,
                                    (*(*inode).typeDef).contentTypeDef,
                                    (*inode).value,
                                );
                            }
                            if ret < 0 as libc::c_int {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaValidatorPopElem\0" as *const u8
                                        as *const libc::c_char,
                                    b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8
                                        as *const libc::c_char,
                                );
                                current_block = 3454747893076357924;
                            } else {
                                current_block = 13159517723375190530;
                            }
                        } else if !((*(*inode).decl).value).is_null()
                                && (*inode).flags & (1 as libc::c_int) << 5 as libc::c_int
                                    != 0
                                && (*inode).flags & (1 as libc::c_int) << 2 as libc::c_int
                                    == 0
                            {
                            if (*inode).flags & (1 as libc::c_int) << 3 as libc::c_int
                                != 0
                            {
                                ret = xmlSchemaCheckCOSValidDefault(
                                    vctxt,
                                    (*(*inode).decl).value,
                                    &mut (*inode).val,
                                );
                                if ret != 0 as libc::c_int {
                                    if ret < 0 as libc::c_int {
                                        xmlSchemaInternalErr(
                                            vctxt as xmlSchemaAbstractCtxtPtr,
                                            b"xmlSchemaValidatorPopElem\0" as *const u8
                                                as *const libc::c_char,
                                            b"calling xmlSchemaCheckCOSValidDefault()\0" as *const u8
                                                as *const libc::c_char,
                                        );
                                        current_block = 3454747893076357924;
                                    } else {
                                        current_block = 13159517723375190530;
                                    }
                                } else {
                                    current_block = 15766311179120147566;
                                }
                            } else {
                                if (*(*inode).typeDef).type_0 as libc::c_uint
                                    == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
                                    || (*(*inode).typeDef).type_0 as libc::c_uint
                                        == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                                        && (*(*inode).typeDef).builtInType
                                            != XML_SCHEMAS_ANYTYPE as libc::c_int
                                {
                                    ret = xmlSchemaVCheckINodeDataType(
                                        vctxt,
                                        inode,
                                        (*inode).typeDef,
                                        (*(*inode).decl).value,
                                    );
                                } else if (*(*inode).typeDef).contentType as libc::c_uint
                                        == XML_SCHEMA_CONTENT_SIMPLE as libc::c_int as libc::c_uint
                                        || (*(*inode).typeDef).contentType as libc::c_uint
                                            == XML_SCHEMA_CONTENT_BASIC as libc::c_int as libc::c_uint
                                    {
                                    ret = xmlSchemaVCheckINodeDataType(
                                        vctxt,
                                        inode,
                                        (*(*inode).typeDef).contentTypeDef,
                                        (*(*inode).decl).value,
                                    );
                                }
                                if ret != 0 as libc::c_int {
                                    if ret < 0 as libc::c_int {
                                        xmlSchemaInternalErr(
                                            vctxt as xmlSchemaAbstractCtxtPtr,
                                            b"xmlSchemaValidatorPopElem\0" as *const u8
                                                as *const libc::c_char,
                                            b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8
                                                as *const libc::c_char,
                                        );
                                        current_block = 3454747893076357924;
                                    } else {
                                        current_block = 13159517723375190530;
                                    }
                                } else {
                                    current_block = 15766311179120147566;
                                }
                            }
                            match current_block {
                                13159517723375190530 => {}
                                3454747893076357924 => {}
                                _ => {
                                    if (*vctxt).options
                                        & XML_SCHEMA_VAL_VC_I_CREATE as libc::c_int != 0
                                        && !((*inode).node).is_null()
                                    {
                                        let mut textChild: xmlNodePtr = 0 as *mut xmlNode;
                                        let mut normValue: *mut xmlChar = 0 as *mut xmlChar;
                                        normValue = xmlSchemaNormalizeValue(
                                            (*inode).typeDef,
                                            (*(*inode).decl).value,
                                        );
                                        if !normValue.is_null() {
                                            textChild = xmlNewDocText((*(*inode).node).doc, normValue);
                                            xmlFree
                                                .expect(
                                                    "non-null function pointer",
                                                )(normValue as *mut libc::c_void);
                                        } else {
                                            textChild = xmlNewDocText(
                                                (*(*inode).node).doc,
                                                (*(*inode).decl).value,
                                            );
                                        }
                                        if textChild.is_null() {
                                            xmlSchemaInternalErr(
                                                vctxt as xmlSchemaAbstractCtxtPtr,
                                                b"xmlSchemaValidatorPopElem\0" as *const u8
                                                    as *const libc::c_char,
                                                b"calling xmlNewDocText()\0" as *const u8
                                                    as *const libc::c_char,
                                            );
                                            current_block = 3454747893076357924;
                                        } else {
                                            xmlAddChild((*inode).node, textChild);
                                            current_block = 13159517723375190530;
                                        }
                                    } else {
                                        current_block = 13159517723375190530;
                                    }
                                }
                            }
                        } else if (*inode).flags & (1 as libc::c_int) << 2 as libc::c_int
                                == 0
                            {
                            if (*(*inode).typeDef).type_0 as libc::c_uint
                                == XML_SCHEMA_TYPE_SIMPLE as libc::c_int as libc::c_uint
                                || (*(*inode).typeDef).type_0 as libc::c_uint
                                    == XML_SCHEMA_TYPE_BASIC as libc::c_int as libc::c_uint
                                    && (*(*inode).typeDef).builtInType
                                        != XML_SCHEMAS_ANYTYPE as libc::c_int
                            {
                                ret = xmlSchemaVCheckINodeDataType(
                                    vctxt,
                                    inode,
                                    (*inode).typeDef,
                                    (*inode).value,
                                );
                            } else if (*(*inode).typeDef).contentType as libc::c_uint
                                    == XML_SCHEMA_CONTENT_SIMPLE as libc::c_int as libc::c_uint
                                    || (*(*inode).typeDef).contentType as libc::c_uint
                                        == XML_SCHEMA_CONTENT_BASIC as libc::c_int as libc::c_uint
                                {
                                ret = xmlSchemaVCheckINodeDataType(
                                    vctxt,
                                    inode,
                                    (*(*inode).typeDef).contentTypeDef,
                                    (*inode).value,
                                );
                            }
                            if ret != 0 as libc::c_int {
                                if ret < 0 as libc::c_int {
                                    xmlSchemaInternalErr(
                                        vctxt as xmlSchemaAbstractCtxtPtr,
                                        b"xmlSchemaValidatorPopElem\0" as *const u8
                                            as *const libc::c_char,
                                        b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8
                                            as *const libc::c_char,
                                    );
                                    current_block = 3454747893076357924;
                                } else {
                                    current_block = 13159517723375190530;
                                }
                            } else if !((*(*inode).decl).value).is_null()
                                    && (*(*inode).decl).flags
                                        & (1 as libc::c_int) << 3 as libc::c_int != 0
                                {
                                if (*inode).flags & (1 as libc::c_int) << 7 as libc::c_int
                                    != 0
                                {
                                    ret = XML_SCHEMAV_CVC_ELT_5_2_2_1 as libc::c_int;
                                    xmlSchemaCustomErr(
                                        vctxt as xmlSchemaAbstractCtxtPtr,
                                        ret as xmlParserErrors,
                                        0 as xmlNodePtr,
                                        0 as xmlSchemaBasicItemPtr,
                                        b"The content must not contain element nodes since there is a fixed value constraint\0"
                                            as *const u8 as *const libc::c_char,
                                        0 as *const xmlChar,
                                        0 as *const xmlChar,
                                    );
                                } else if (*(*inode).typeDef).contentType as libc::c_uint
                                        == XML_SCHEMA_CONTENT_MIXED as libc::c_int as libc::c_uint
                                    {
                                    if xmlStrEqual((*inode).value, (*(*inode).decl).value) == 0
                                    {
                                        ret = XML_SCHEMAV_CVC_ELT_5_2_2_2_1 as libc::c_int;
                                        xmlSchemaCustomErr(
                                            vctxt as xmlSchemaAbstractCtxtPtr,
                                            ret as xmlParserErrors,
                                            0 as xmlNodePtr,
                                            0 as xmlSchemaBasicItemPtr,
                                            b"The initial value '%s' does not match the fixed value constraint '%s'\0"
                                                as *const u8 as *const libc::c_char,
                                            (*inode).value,
                                            (*(*inode).decl).value,
                                        );
                                    }
                                } else if (*(*inode).typeDef).contentType as libc::c_uint
                                        == XML_SCHEMA_CONTENT_SIMPLE as libc::c_int as libc::c_uint
                                        || (*(*inode).typeDef).contentType as libc::c_uint
                                            == XML_SCHEMA_CONTENT_BASIC as libc::c_int as libc::c_uint
                                    {
                                    if xmlStrEqual((*inode).value, (*(*inode).decl).value) == 0
                                    {
                                        ret = XML_SCHEMAV_CVC_ELT_5_2_2_2_2 as libc::c_int;
                                        xmlSchemaCustomErr(
                                            vctxt as xmlSchemaAbstractCtxtPtr,
                                            ret as xmlParserErrors,
                                            0 as xmlNodePtr,
                                            0 as xmlSchemaBasicItemPtr,
                                            b"The actual value '%s' does not match the fixed value constraint '%s'\0"
                                                as *const u8 as *const libc::c_char,
                                            (*inode).value,
                                            (*(*inode).decl).value,
                                        );
                                    }
                                }
                                current_block = 13159517723375190530;
                            } else {
                                current_block = 13159517723375190530;
                            }
                        } else {
                            current_block = 13159517723375190530;
                        }
                    }
                }
            }
        }
    }
    match current_block {
        13159517723375190530 => {
            if (*vctxt).depth < 0 as libc::c_int {
                return 0 as libc::c_int;
            }
            if (*vctxt).depth == (*vctxt).skipDepth {
                (*vctxt).skipDepth = -(1 as libc::c_int);
            }
            if !((*inode).appliedXPath != 0
                && xmlSchemaXPathProcessHistory(vctxt, (*vctxt).depth)
                    == -(1 as libc::c_int))
            {
                if !((*inode).idcMatchers).is_null()
                    && ((*vctxt).hasKeyrefs != 0 || (*vctxt).createIDCNodeTables != 0)
                {
                    if xmlSchemaIDCFillNodeTables(vctxt, inode) == -(1 as libc::c_int) {
                        current_block = 3454747893076357924;
                    } else {
                        current_block = 6665878751423064961;
                    }
                } else {
                    current_block = 6665878751423064961;
                }
                match current_block {
                    3454747893076357924 => {}
                    _ => {
                        if (*(*vctxt).inode).hasKeyrefs != 0 {
                            if xmlSchemaCheckCVCIDCKeyRef(vctxt) == -(1 as libc::c_int) {
                                current_block = 3454747893076357924;
                            } else {
                                current_block = 8225018548522317130;
                            }
                        } else {
                            current_block = 8225018548522317130;
                        }
                        match current_block {
                            3454747893076357924 => {}
                            _ => {
                                if !((*inode).idcTable).is_null() {
                                    if (*vctxt).depth > 0 as libc::c_int
                                        && ((*vctxt).hasKeyrefs != 0
                                            || (*vctxt).createIDCNodeTables != 0)
                                    {
                                        if xmlSchemaBubbleIDCNodeTables(vctxt)
                                            == -(1 as libc::c_int)
                                        {
                                            current_block = 3454747893076357924;
                                        } else {
                                            current_block = 5636883459695696059;
                                        }
                                    } else {
                                        current_block = 5636883459695696059;
                                    }
                                } else {
                                    current_block = 5636883459695696059;
                                }
                                match current_block {
                                    3454747893076357924 => {}
                                    _ => {
                                        xmlSchemaClearElemInfo(vctxt, inode);
                                        if (*vctxt).depth == 0 as libc::c_int {
                                            let ref mut fresh604 = (*vctxt).depth;
                                            *fresh604 -= 1;
                                            let ref mut fresh605 = (*vctxt).inode;
                                            *fresh605 = 0 as xmlSchemaNodeInfoPtr;
                                            return 0 as libc::c_int;
                                        }
                                        if !((*vctxt).aidcs).is_null() {
                                            let mut aidc: xmlSchemaIDCAugPtr = (*vctxt).aidcs;
                                            loop {
                                                if (*aidc).keyrefDepth == (*vctxt).depth {
                                                    (*aidc).keyrefDepth = -(1 as libc::c_int);
                                                }
                                                aidc = (*aidc).next;
                                                if aidc.is_null() {
                                                    break;
                                                }
                                            }
                                        }
                                        let ref mut fresh606 = (*vctxt).depth;
                                        *fresh606 -= 1;
                                        let ref mut fresh607 = (*vctxt).inode;
                                        *fresh607 = *((*vctxt).elemInfos)
                                            .offset((*vctxt).depth as isize);
                                        return ret;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    (*vctxt).err = -(1 as libc::c_int);
    return -(1 as libc::c_int);
}
unsafe extern "C" fn xmlSchemaValidateChildElem(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> libc::c_int {
    let mut current_block: u64;
    let mut pielem: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
    let mut ptype: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ret: libc::c_int = 0 as libc::c_int;
    if (*vctxt).depth <= 0 as libc::c_int {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaValidateChildElem\0" as *const u8 as *const libc::c_char,
            b"not intended for the validation root\0" as *const u8 as *const libc::c_char,
        );
        return -(1 as libc::c_int);
    }
    pielem = *((*vctxt).elemInfos).offset(((*vctxt).depth - 1 as libc::c_int) as isize);
    if (*pielem).flags & (1 as libc::c_int) << 5 as libc::c_int != 0 {
        (*pielem).flags ^= (1 as libc::c_int) << 5 as libc::c_int;
    }
    if (*pielem).flags & (1 as libc::c_int) << 2 as libc::c_int != 0 {
        let ref mut fresh608 = (*vctxt).inode;
        *fresh608 = *((*vctxt).elemInfos)
            .offset(((*vctxt).depth - 1 as libc::c_int) as isize);
        ret = XML_SCHEMAV_CVC_ELT_3_2_1 as libc::c_int;
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            ret as xmlParserErrors,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"Neither character nor element content is allowed, because the element was 'nilled'\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        let ref mut fresh609 = (*vctxt).inode;
        *fresh609 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
    } else {
        ptype = (*pielem).typeDef;
        if (*ptype).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int {
            let ref mut fresh610 = (*(*vctxt).inode).decl;
            *fresh610 = xmlSchemaGetElem(
                (*vctxt).schema,
                (*(*vctxt).inode).localName,
                (*(*vctxt).inode).nsName,
            );
            if ((*(*vctxt).inode).decl).is_null() {
                let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
                iattr = xmlSchemaGetMetaAttrInfo(vctxt, 1 as libc::c_int);
                if !iattr.is_null() {
                    ret = xmlSchemaProcessXSIType(
                        vctxt,
                        iattr,
                        &mut (*(*vctxt).inode).typeDef,
                        0 as xmlSchemaElementPtr,
                    );
                    if ret != 0 as libc::c_int {
                        if ret == -(1 as libc::c_int) {
                            xmlSchemaInternalErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                b"xmlSchemaValidateChildElem\0" as *const u8
                                    as *const libc::c_char,
                                b"calling xmlSchemaProcessXSIType() to process the attribute 'xsi:nil'\0"
                                    as *const u8 as *const libc::c_char,
                            );
                            return -(1 as libc::c_int);
                        }
                        return ret;
                    }
                } else {
                    let ref mut fresh611 = (*(*vctxt).inode).typeDef;
                    *fresh611 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
                }
            }
            return 0 as libc::c_int;
        }
        match (*ptype).contentType as libc::c_uint {
            1 => {
                let ref mut fresh612 = (*vctxt).inode;
                *fresh612 = *((*vctxt).elemInfos)
                    .offset(((*vctxt).depth - 1 as libc::c_int) as isize);
                ret = XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1 as libc::c_int;
                xmlSchemaCustomErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    ret as xmlParserErrors,
                    0 as xmlNodePtr,
                    0 as xmlSchemaBasicItemPtr,
                    b"Element content is not allowed, because the content type is empty\0"
                        as *const u8 as *const libc::c_char,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
                let ref mut fresh613 = (*vctxt).inode;
                *fresh613 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
                current_block = 16160522325362342750;
            }
            3 | 2 => {
                let mut regexCtxt: xmlRegExecCtxtPtr = 0 as *mut xmlRegExecCtxt;
                let mut values: [*mut xmlChar; 10] = [0 as *mut xmlChar; 10];
                let mut terminal: libc::c_int = 0;
                let mut nbval: libc::c_int = 10 as libc::c_int;
                let mut nbneg: libc::c_int = 0;
                if ((*ptype).contModel).is_null() {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaValidateChildElem\0" as *const u8
                            as *const libc::c_char,
                        b"type has elem content but no content model\0" as *const u8
                            as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
                if (*pielem).flags & (1 as libc::c_int) << 8 as libc::c_int != 0 {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaValidateChildElem\0" as *const u8
                            as *const libc::c_char,
                        b"validating elem, but elem content is already invalid\0"
                            as *const u8 as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
                regexCtxt = (*pielem).regexCtxt;
                if regexCtxt.is_null() {
                    regexCtxt = xmlRegNewExecCtxt(
                        (*ptype).contModel,
                        Some(
                            xmlSchemaVContentModelCallback
                                as unsafe extern "C" fn(
                                    xmlRegExecCtxtPtr,
                                    *const xmlChar,
                                    *mut libc::c_void,
                                    *mut libc::c_void,
                                ) -> (),
                        ),
                        vctxt as *mut libc::c_void,
                    );
                    if regexCtxt.is_null() {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaValidateChildElem\0" as *const u8
                                as *const libc::c_char,
                            b"failed to create a regex context\0" as *const u8
                                as *const libc::c_char,
                        );
                        return -(1 as libc::c_int);
                    }
                    let ref mut fresh614 = (*pielem).regexCtxt;
                    *fresh614 = regexCtxt;
                }
                ret = xmlRegExecPushString2(
                    regexCtxt,
                    (*(*vctxt).inode).localName,
                    (*(*vctxt).inode).nsName,
                    (*vctxt).inode as *mut libc::c_void,
                );
                if (*vctxt).err == XML_SCHEMAV_INTERNAL as libc::c_int {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaValidateChildElem\0" as *const u8
                            as *const libc::c_char,
                        b"calling xmlRegExecPushString2()\0" as *const u8
                            as *const libc::c_char,
                    );
                    return -(1 as libc::c_int);
                }
                if ret < 0 as libc::c_int {
                    xmlRegExecErrInfo(
                        regexCtxt,
                        0 as *mut *const xmlChar,
                        &mut nbval,
                        &mut nbneg,
                        &mut *values.as_mut_ptr().offset(0 as libc::c_int as isize),
                        &mut terminal,
                    );
                    xmlSchemaComplexTypeErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAV_ELEMENT_CONTENT,
                        0 as xmlNodePtr,
                        0 as xmlSchemaTypePtr,
                        b"This element is not expected\0" as *const u8
                            as *const libc::c_char,
                        nbval,
                        nbneg,
                        values.as_mut_ptr(),
                    );
                    ret = (*vctxt).err;
                    current_block = 16160522325362342750;
                } else {
                    ret = 0 as libc::c_int;
                    current_block = 3879520548144599102;
                }
            }
            4 | 6 => {
                let ref mut fresh615 = (*vctxt).inode;
                *fresh615 = *((*vctxt).elemInfos)
                    .offset(((*vctxt).depth - 1 as libc::c_int) as isize);
                if (*ptype).type_0 as libc::c_uint
                    == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
                    || (*ptype).builtInType == XML_SCHEMAS_ANYTYPE as libc::c_int
                {
                    ret = XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2 as libc::c_int;
                    xmlSchemaCustomErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        ret as xmlParserErrors,
                        0 as xmlNodePtr,
                        0 as xmlSchemaBasicItemPtr,
                        b"Element content is not allowed, because the content type is a simple type definition\0"
                            as *const u8 as *const libc::c_char,
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                } else {
                    ret = XML_SCHEMAV_CVC_TYPE_3_1_2 as libc::c_int;
                    xmlSchemaCustomErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        ret as xmlParserErrors,
                        0 as xmlNodePtr,
                        0 as xmlSchemaBasicItemPtr,
                        b"Element content is not allowed, because the type definition is simple\0"
                            as *const u8 as *const libc::c_char,
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                }
                let ref mut fresh616 = (*vctxt).inode;
                *fresh616 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
                ret = (*vctxt).err;
                current_block = 16160522325362342750;
            }
            _ => {
                current_block = 3879520548144599102;
            }
        }
        match current_block {
            16160522325362342750 => {}
            _ => return ret,
        }
    }
    (*vctxt).skipDepth = (*vctxt).depth;
    (*(*vctxt).inode).flags |= (1 as libc::c_int) << 9 as libc::c_int;
    (*pielem).flags |= (1 as libc::c_int) << 8 as libc::c_int;
    return ret;
}
unsafe extern "C" fn xmlSchemaVPushText(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut nodeType: libc::c_int,
    mut value: *const xmlChar,
    mut len: libc::c_int,
    mut mode: libc::c_int,
    mut consumed: *mut libc::c_int,
) -> libc::c_int {
    if !consumed.is_null() {
        *consumed = 0 as libc::c_int;
    }
    if (*(*vctxt).inode).flags & (1 as libc::c_int) << 2 as libc::c_int != 0 {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_ELT_3_2_1,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"Neither character nor element content is allowed because the element is 'nilled'\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*vctxt).err;
    }
    if (*(*(*vctxt).inode).typeDef).contentType as libc::c_uint
        == XML_SCHEMA_CONTENT_EMPTY as libc::c_int as libc::c_uint
    {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"Character content is not allowed, because the content type is empty\0"
                as *const u8 as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*vctxt).err;
    }
    if (*(*(*vctxt).inode).typeDef).contentType as libc::c_uint
        == XML_SCHEMA_CONTENT_ELEMENTS as libc::c_int as libc::c_uint
    {
        if nodeType != XML_TEXT_NODE as libc::c_int
            || xmlSchemaIsBlank(value as *mut xmlChar, len) == 0
        {
            xmlSchemaCustomErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3,
                0 as xmlNodePtr,
                0 as xmlSchemaBasicItemPtr,
                b"Character content other than whitespace is not allowed because the content type is 'element-only'\0"
                    as *const u8 as *const libc::c_char,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return (*vctxt).err;
        }
        return 0 as libc::c_int;
    }
    if value.is_null()
        || *value.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
    {
        return 0 as libc::c_int;
    }
    if (*(*(*vctxt).inode).typeDef).contentType as libc::c_uint
        == XML_SCHEMA_CONTENT_MIXED as libc::c_int as libc::c_uint
        && (((*(*vctxt).inode).decl).is_null()
            || ((*(*(*vctxt).inode).decl).value).is_null())
    {
        return 0 as libc::c_int;
    }
    if ((*(*vctxt).inode).value).is_null() {
        match mode {
            1 => {
                let ref mut fresh617 = (*(*vctxt).inode).value;
                *fresh617 = value;
            }
            2 => {
                let ref mut fresh618 = (*(*vctxt).inode).value;
                *fresh618 = value;
                if !consumed.is_null() {
                    *consumed = 1 as libc::c_int;
                }
                (*(*vctxt).inode).flags |= (1 as libc::c_int) << 1 as libc::c_int;
            }
            3 => {
                if len != -(1 as libc::c_int) {
                    let ref mut fresh619 = (*(*vctxt).inode).value;
                    *fresh619 = xmlStrndup(value, len);
                } else {
                    let ref mut fresh620 = (*(*vctxt).inode).value;
                    *fresh620 = xmlStrdup(value);
                }
                (*(*vctxt).inode).flags |= (1 as libc::c_int) << 1 as libc::c_int;
            }
            _ => {}
        }
    } else {
        if len < 0 as libc::c_int {
            len = xmlStrlen(value);
        }
        if (*(*vctxt).inode).flags & (1 as libc::c_int) << 1 as libc::c_int != 0 {
            let ref mut fresh621 = (*(*vctxt).inode).value;
            *fresh621 = xmlStrncat((*(*vctxt).inode).value as *mut xmlChar, value, len);
        } else {
            let ref mut fresh622 = (*(*vctxt).inode).value;
            *fresh622 = xmlStrncatNew((*(*vctxt).inode).value, value, len);
            (*(*vctxt).inode).flags |= (1 as libc::c_int) << 1 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaValidateElem(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> libc::c_int {
    let mut current_block: u64;
    let mut ret: libc::c_int = 0 as libc::c_int;
    if (*vctxt).skipDepth != -(1 as libc::c_int) && (*vctxt).depth >= (*vctxt).skipDepth
    {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaValidateElem\0" as *const u8 as *const libc::c_char,
            b"in skip-state\0" as *const u8 as *const libc::c_char,
        );
    } else {
        if (*vctxt).xsiAssemble != 0 {
            ret = xmlSchemaAssembleByXSI(vctxt);
            if ret != 0 as libc::c_int {
                if ret == -(1 as libc::c_int) {
                    current_block = 17069188355963176026;
                } else {
                    (*vctxt).skipDepth = 0 as libc::c_int;
                    return ret;
                }
            } else {
                xmlHashScan(
                    (*(*vctxt).schema).schemasImports,
                    Some(
                        xmlSchemaAugmentImportedIDC
                            as unsafe extern "C" fn(
                                *mut libc::c_void,
                                *mut libc::c_void,
                                *const xmlChar,
                            ) -> (),
                    ),
                    vctxt as *mut libc::c_void,
                );
                current_block = 13536709405535804910;
            }
        } else {
            current_block = 13536709405535804910;
        }
        match current_block {
            17069188355963176026 => {}
            _ => {
                if (*vctxt).depth > 0 as libc::c_int {
                    ret = xmlSchemaValidateChildElem(vctxt);
                    if ret != 0 as libc::c_int {
                        if ret < 0 as libc::c_int {
                            xmlSchemaInternalErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                b"xmlSchemaValidateElem\0" as *const u8
                                    as *const libc::c_char,
                                b"calling xmlSchemaStreamValidateChildElement()\0"
                                    as *const u8 as *const libc::c_char,
                            );
                            current_block = 17069188355963176026;
                        } else {
                            current_block = 6848767425915334727;
                        }
                    } else if (*vctxt).depth == (*vctxt).skipDepth {
                        current_block = 6848767425915334727;
                    } else if ((*(*vctxt).inode).decl).is_null()
                            && ((*(*vctxt).inode).typeDef).is_null()
                        {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaValidateElem\0" as *const u8
                                as *const libc::c_char,
                            b"the child element was valid but neither the declaration nor the type was set\0"
                                as *const u8 as *const libc::c_char,
                        );
                        current_block = 17069188355963176026;
                    } else {
                        current_block = 16924917904204750491;
                    }
                } else {
                    let ref mut fresh623 = (*(*vctxt).inode).decl;
                    *fresh623 = xmlSchemaGetElem(
                        (*vctxt).schema,
                        (*(*vctxt).inode).localName,
                        (*(*vctxt).inode).nsName,
                    );
                    if ((*(*vctxt).inode).decl).is_null() {
                        ret = XML_SCHEMAV_CVC_ELT_1 as libc::c_int;
                        xmlSchemaCustomErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            ret as xmlParserErrors,
                            0 as xmlNodePtr,
                            0 as xmlSchemaBasicItemPtr,
                            b"No matching global declaration available for the validation root\0"
                                as *const u8 as *const libc::c_char,
                            0 as *const xmlChar,
                            0 as *const xmlChar,
                        );
                        current_block = 6848767425915334727;
                    } else {
                        current_block = 16924917904204750491;
                    }
                }
                match current_block {
                    17069188355963176026 => {}
                    _ => {
                        match current_block {
                            16924917904204750491 => {
                                if ((*(*vctxt).inode).decl).is_null() {
                                    current_block = 10371967630163830273;
                                } else {
                                    if (*(*(*vctxt).inode).decl).type_0 as libc::c_uint
                                        == XML_SCHEMA_TYPE_ANY as libc::c_int as libc::c_uint
                                    {
                                        let mut skip: libc::c_int = 0;
                                        ret = xmlSchemaValidateElemWildcard(vctxt, &mut skip);
                                        if ret != 0 as libc::c_int {
                                            if ret < 0 as libc::c_int {
                                                xmlSchemaInternalErr(
                                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                                    b"xmlSchemaValidateElem\0" as *const u8
                                                        as *const libc::c_char,
                                                    b"calling xmlSchemaValidateElemWildcard()\0" as *const u8
                                                        as *const libc::c_char,
                                                );
                                                current_block = 17069188355963176026;
                                            } else {
                                                current_block = 6848767425915334727;
                                            }
                                        } else if skip != 0 {
                                            (*vctxt).skipDepth = (*vctxt).depth;
                                            current_block = 6848767425915334727;
                                        } else if (*(*(*vctxt).inode).decl).type_0 as libc::c_uint
                                                != XML_SCHEMA_TYPE_ELEMENT as libc::c_int as libc::c_uint
                                            {
                                            let ref mut fresh624 = (*(*vctxt).inode).decl;
                                            *fresh624 = 0 as xmlSchemaElementPtr;
                                            current_block = 10371967630163830273;
                                        } else {
                                            current_block = 790185930182612747;
                                        }
                                    } else {
                                        current_block = 790185930182612747;
                                    }
                                    match current_block {
                                        6848767425915334727 => {}
                                        17069188355963176026 => {}
                                        10371967630163830273 => {}
                                        _ => {
                                            ret = xmlSchemaValidateElemDecl(vctxt);
                                            if ret != 0 as libc::c_int {
                                                if ret < 0 as libc::c_int {
                                                    xmlSchemaInternalErr(
                                                        vctxt as xmlSchemaAbstractCtxtPtr,
                                                        b"xmlSchemaValidateElem\0" as *const u8
                                                            as *const libc::c_char,
                                                        b"calling xmlSchemaValidateElemDecl()\0" as *const u8
                                                            as *const libc::c_char,
                                                    );
                                                    current_block = 17069188355963176026;
                                                } else {
                                                    current_block = 6848767425915334727;
                                                }
                                            } else {
                                                current_block = 10371967630163830273;
                                            }
                                        }
                                    }
                                }
                                match current_block {
                                    6848767425915334727 => {}
                                    17069188355963176026 => {}
                                    _ => {
                                        if ((*(*vctxt).inode).typeDef).is_null() {
                                            (*(*vctxt).inode).flags
                                                |= (1 as libc::c_int) << 10 as libc::c_int;
                                            ret = XML_SCHEMAV_CVC_TYPE_1 as libc::c_int;
                                            xmlSchemaCustomErr(
                                                vctxt as xmlSchemaAbstractCtxtPtr,
                                                ret as xmlParserErrors,
                                                0 as xmlNodePtr,
                                                0 as xmlSchemaBasicItemPtr,
                                                b"The type definition is absent\0" as *const u8
                                                    as *const libc::c_char,
                                                0 as *const xmlChar,
                                                0 as *const xmlChar,
                                            );
                                            current_block = 6848767425915334727;
                                        } else if (*(*(*vctxt).inode).typeDef).flags
                                                & (1 as libc::c_int) << 20 as libc::c_int != 0
                                            {
                                            (*(*vctxt).inode).flags
                                                |= (1 as libc::c_int) << 10 as libc::c_int;
                                            ret = XML_SCHEMAV_CVC_TYPE_2 as libc::c_int;
                                            xmlSchemaCustomErr(
                                                vctxt as xmlSchemaAbstractCtxtPtr,
                                                ret as xmlParserErrors,
                                                0 as xmlNodePtr,
                                                0 as xmlSchemaBasicItemPtr,
                                                b"The type definition is abstract\0" as *const u8
                                                    as *const libc::c_char,
                                                0 as *const xmlChar,
                                                0 as *const xmlChar,
                                            );
                                            current_block = 6848767425915334727;
                                        } else {
                                            if !((*vctxt).xpathStates).is_null() {
                                                ret = xmlSchemaXPathEvaluate(vctxt, XML_ELEMENT_NODE);
                                                (*(*vctxt).inode).appliedXPath = 1 as libc::c_int;
                                                if ret == -(1 as libc::c_int) {
                                                    xmlSchemaInternalErr(
                                                        vctxt as xmlSchemaAbstractCtxtPtr,
                                                        b"xmlSchemaValidateElem\0" as *const u8
                                                            as *const libc::c_char,
                                                        b"calling xmlSchemaXPathEvaluate()\0" as *const u8
                                                            as *const libc::c_char,
                                                    );
                                                    current_block = 17069188355963176026;
                                                } else {
                                                    current_block = 1874315696050160458;
                                                }
                                            } else {
                                                current_block = 1874315696050160458;
                                            }
                                            match current_block {
                                                17069188355963176026 => {}
                                                _ => {
                                                    if (*(*(*vctxt).inode).typeDef).type_0 as libc::c_uint
                                                        == XML_SCHEMA_TYPE_COMPLEX as libc::c_int as libc::c_uint
                                                        || (*(*(*vctxt).inode).typeDef).builtInType
                                                            == XML_SCHEMAS_ANYTYPE as libc::c_int
                                                    {
                                                        if (*vctxt).nbAttrInfos != 0 as libc::c_int
                                                            || !((*(*(*vctxt).inode).typeDef).attrUses).is_null()
                                                        {
                                                            ret = xmlSchemaVAttributesComplex(vctxt);
                                                        }
                                                    } else if (*vctxt).nbAttrInfos != 0 as libc::c_int {
                                                        ret = xmlSchemaVAttributesSimple(vctxt);
                                                    }
                                                    if (*vctxt).nbAttrInfos != 0 as libc::c_int {
                                                        xmlSchemaClearAttrInfos(vctxt);
                                                    }
                                                    if ret == -(1 as libc::c_int) {
                                                        xmlSchemaInternalErr(
                                                            vctxt as xmlSchemaAbstractCtxtPtr,
                                                            b"xmlSchemaValidateElem\0" as *const u8
                                                                as *const libc::c_char,
                                                            b"calling attributes validation\0" as *const u8
                                                                as *const libc::c_char,
                                                        );
                                                        current_block = 17069188355963176026;
                                                    } else {
                                                        ret = 0 as libc::c_int;
                                                        current_block = 6848767425915334727;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                        match current_block {
                            17069188355963176026 => {}
                            _ => {
                                if ret != 0 as libc::c_int {
                                    (*vctxt).skipDepth = (*vctxt).depth;
                                }
                                return ret;
                            }
                        }
                    }
                }
            }
        }
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn xmlSchemaSAXHandleText(
    mut ctx: *mut libc::c_void,
    mut ch: *const xmlChar,
    mut len: libc::c_int,
) {
    let mut vctxt: xmlSchemaValidCtxtPtr = ctx as xmlSchemaValidCtxtPtr;
    if (*vctxt).depth < 0 as libc::c_int {
        return;
    }
    if (*vctxt).skipDepth != -(1 as libc::c_int) && (*vctxt).depth >= (*vctxt).skipDepth
    {
        return;
    }
    if (*(*vctxt).inode).flags & (1 as libc::c_int) << 5 as libc::c_int != 0 {
        (*(*vctxt).inode).flags ^= (1 as libc::c_int) << 5 as libc::c_int;
    }
    if xmlSchemaVPushText(
        vctxt,
        XML_TEXT_NODE as libc::c_int,
        ch,
        len,
        3 as libc::c_int,
        0 as *mut libc::c_int,
    ) == -(1 as libc::c_int)
    {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaSAXHandleCDataSection\0" as *const u8 as *const libc::c_char,
            b"calling xmlSchemaVPushText()\0" as *const u8 as *const libc::c_char,
        );
        (*vctxt).err = -(1 as libc::c_int);
        xmlStopParser((*vctxt).parserCtxt);
    }
}
unsafe extern "C" fn xmlSchemaSAXHandleCDataSection(
    mut ctx: *mut libc::c_void,
    mut ch: *const xmlChar,
    mut len: libc::c_int,
) {
    let mut vctxt: xmlSchemaValidCtxtPtr = ctx as xmlSchemaValidCtxtPtr;
    if (*vctxt).depth < 0 as libc::c_int {
        return;
    }
    if (*vctxt).skipDepth != -(1 as libc::c_int) && (*vctxt).depth >= (*vctxt).skipDepth
    {
        return;
    }
    if (*(*vctxt).inode).flags & (1 as libc::c_int) << 5 as libc::c_int != 0 {
        (*(*vctxt).inode).flags ^= (1 as libc::c_int) << 5 as libc::c_int;
    }
    if xmlSchemaVPushText(
        vctxt,
        XML_CDATA_SECTION_NODE as libc::c_int,
        ch,
        len,
        3 as libc::c_int,
        0 as *mut libc::c_int,
    ) == -(1 as libc::c_int)
    {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaSAXHandleCDataSection\0" as *const u8 as *const libc::c_char,
            b"calling xmlSchemaVPushText()\0" as *const u8 as *const libc::c_char,
        );
        (*vctxt).err = -(1 as libc::c_int);
        xmlStopParser((*vctxt).parserCtxt);
    }
}
unsafe extern "C" fn xmlSchemaSAXHandleReference(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
) {
    let mut vctxt: xmlSchemaValidCtxtPtr = ctx as xmlSchemaValidCtxtPtr;
    if (*vctxt).depth < 0 as libc::c_int {
        return;
    }
    if (*vctxt).skipDepth != -(1 as libc::c_int) && (*vctxt).depth >= (*vctxt).skipDepth
    {
        return;
    }
    (*__xmlGenericError())
        .expect(
            "non-null function pointer",
        )(
        *__xmlGenericErrorContext(),
        b"Unimplemented block at %s:%d\n\0" as *const u8 as *const libc::c_char,
        b"xmlschemas.c\0" as *const u8 as *const libc::c_char,
        27517 as libc::c_int,
    );
}
unsafe extern "C" fn xmlSchemaSAXHandleStartElementNs(
    mut ctx: *mut libc::c_void,
    mut localname: *const xmlChar,
    mut prefix: *const xmlChar,
    mut URI: *const xmlChar,
    mut nb_namespaces: libc::c_int,
    mut namespaces: *mut *const xmlChar,
    mut nb_attributes: libc::c_int,
    mut nb_defaulted: libc::c_int,
    mut attributes: *mut *const xmlChar,
) {
    let mut current_block: u64;
    let mut vctxt: xmlSchemaValidCtxtPtr = ctx as xmlSchemaValidCtxtPtr;
    let mut ret: libc::c_int = 0;
    let mut ielem: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let ref mut fresh625 = (*vctxt).depth;
    *fresh625 += 1;
    if (*vctxt).skipDepth != -(1 as libc::c_int) && (*vctxt).depth >= (*vctxt).skipDepth
    {
        return;
    }
    if xmlSchemaValidatorPushElem(vctxt) == -(1 as libc::c_int) {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaSAXHandleStartElementNs\0" as *const u8 as *const libc::c_char,
            b"calling xmlSchemaValidatorPushElem()\0" as *const u8 as *const libc::c_char,
        );
    } else {
        ielem = (*vctxt).inode;
        (*ielem)
            .nodeLine = xmlSAX2GetLineNumber((*vctxt).parserCtxt as *mut libc::c_void);
        let ref mut fresh626 = (*ielem).localName;
        *fresh626 = localname;
        let ref mut fresh627 = (*ielem).nsName;
        *fresh627 = URI;
        (*ielem).flags |= (1 as libc::c_int) << 5 as libc::c_int;
        if nb_namespaces != 0 as libc::c_int {
            i = 0 as libc::c_int;
            j = 0 as libc::c_int;
            loop {
                if !(i < nb_namespaces) {
                    current_block = 14434620278749266018;
                    break;
                }
                if ((*ielem).nsBindings).is_null() {
                    let ref mut fresh628 = (*ielem).nsBindings;
                    *fresh628 = xmlMalloc
                        .expect(
                            "non-null function pointer",
                        )(
                        (10 as libc::c_int as libc::c_ulong)
                            .wrapping_mul(
                                ::std::mem::size_of::<*const xmlChar>() as libc::c_ulong,
                            ),
                    ) as *mut *const xmlChar;
                    if ((*ielem).nsBindings).is_null() {
                        xmlSchemaVErrMemory(
                            vctxt,
                            b"allocating namespace bindings for SAX validation\0"
                                as *const u8 as *const libc::c_char,
                            0 as xmlNodePtr,
                        );
                        current_block = 757928548486660075;
                        break;
                    } else {
                        (*ielem).nbNsBindings = 0 as libc::c_int;
                        (*ielem).sizeNsBindings = 5 as libc::c_int;
                    }
                } else if (*ielem).sizeNsBindings <= (*ielem).nbNsBindings {
                    (*ielem).sizeNsBindings *= 2 as libc::c_int;
                    let ref mut fresh629 = (*ielem).nsBindings;
                    *fresh629 = xmlRealloc
                        .expect(
                            "non-null function pointer",
                        )(
                        (*ielem).nsBindings as *mut libc::c_void,
                        (((*ielem).sizeNsBindings * 2 as libc::c_int) as libc::c_ulong)
                            .wrapping_mul(
                                ::std::mem::size_of::<*const xmlChar>() as libc::c_ulong,
                            ),
                    ) as *mut *const xmlChar;
                    if ((*ielem).nsBindings).is_null() {
                        xmlSchemaVErrMemory(
                            vctxt,
                            b"re-allocating namespace bindings for SAX validation\0"
                                as *const u8 as *const libc::c_char,
                            0 as xmlNodePtr,
                        );
                        current_block = 757928548486660075;
                        break;
                    }
                }
                let ref mut fresh630 = *((*ielem).nsBindings)
                    .offset(((*ielem).nbNsBindings * 2 as libc::c_int) as isize);
                *fresh630 = *namespaces.offset(j as isize);
                if *(*namespaces.offset((j + 1 as libc::c_int) as isize))
                    .offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
                {
                    let ref mut fresh631 = *((*ielem).nsBindings)
                        .offset(
                            ((*ielem).nbNsBindings * 2 as libc::c_int + 1 as libc::c_int)
                                as isize,
                        );
                    *fresh631 = 0 as *const xmlChar;
                } else {
                    let ref mut fresh632 = *((*ielem).nsBindings)
                        .offset(
                            ((*ielem).nbNsBindings * 2 as libc::c_int + 1 as libc::c_int)
                                as isize,
                        );
                    *fresh632 = *namespaces.offset((j + 1 as libc::c_int) as isize);
                }
                let ref mut fresh633 = (*ielem).nbNsBindings;
                *fresh633 += 1;
                i += 1;
                j += 2 as libc::c_int;
            }
        } else {
            current_block = 14434620278749266018;
        }
        match current_block {
            757928548486660075 => {}
            _ => {
                if nb_attributes != 0 as libc::c_int {
                    let mut valueLen: libc::c_int = 0;
                    let mut k: libc::c_int = 0;
                    let mut l: libc::c_int = 0;
                    let mut value: *mut xmlChar = 0 as *mut xmlChar;
                    j = 0 as libc::c_int;
                    i = 0 as libc::c_int;
                    loop {
                        if !(i < nb_attributes) {
                            current_block = 9241535491006583629;
                            break;
                        }
                        valueLen = (*attributes.offset((j + 4 as libc::c_int) as isize))
                            .offset_from(
                                *attributes.offset((j + 3 as libc::c_int) as isize),
                            ) as libc::c_long as libc::c_int;
                        value = xmlMallocAtomic
                            .expect(
                                "non-null function pointer",
                            )((valueLen + 1 as libc::c_int) as size_t) as *mut xmlChar;
                        if value.is_null() {
                            xmlSchemaVErrMemory(
                                vctxt,
                                b"allocating string for decoded attribute\0" as *const u8
                                    as *const libc::c_char,
                                0 as xmlNodePtr,
                            );
                            current_block = 757928548486660075;
                            break;
                        } else {
                            k = 0 as libc::c_int;
                            l = 0 as libc::c_int;
                            while k < valueLen {
                                if k < valueLen - 4 as libc::c_int
                                    && *(*attributes.offset((j + 3 as libc::c_int) as isize))
                                        .offset((k + 0 as libc::c_int) as isize) as libc::c_int
                                        == '&' as i32
                                    && *(*attributes.offset((j + 3 as libc::c_int) as isize))
                                        .offset((k + 1 as libc::c_int) as isize) as libc::c_int
                                        == '#' as i32
                                    && *(*attributes.offset((j + 3 as libc::c_int) as isize))
                                        .offset((k + 2 as libc::c_int) as isize) as libc::c_int
                                        == '3' as i32
                                    && *(*attributes.offset((j + 3 as libc::c_int) as isize))
                                        .offset((k + 3 as libc::c_int) as isize) as libc::c_int
                                        == '8' as i32
                                    && *(*attributes.offset((j + 3 as libc::c_int) as isize))
                                        .offset((k + 4 as libc::c_int) as isize) as libc::c_int
                                        == ';' as i32
                                {
                                    *value.offset(l as isize) = '&' as i32 as xmlChar;
                                    k += 5 as libc::c_int;
                                } else {
                                    *value
                                        .offset(
                                            l as isize,
                                        ) = *(*attributes.offset((j + 3 as libc::c_int) as isize))
                                        .offset(k as isize);
                                    k += 1;
                                }
                                l += 1;
                            }
                            *value.offset(l as isize) = '\u{0}' as i32 as xmlChar;
                            ret = xmlSchemaValidatorPushAttribute(
                                vctxt,
                                0 as xmlNodePtr,
                                (*ielem).nodeLine,
                                *attributes.offset(j as isize),
                                *attributes.offset((j + 2 as libc::c_int) as isize),
                                0 as libc::c_int,
                                value,
                                1 as libc::c_int,
                            );
                            if ret == -(1 as libc::c_int) {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaSAXHandleStartElementNs\0" as *const u8
                                        as *const libc::c_char,
                                    b"calling xmlSchemaValidatorPushAttribute()\0" as *const u8
                                        as *const libc::c_char,
                                );
                                current_block = 757928548486660075;
                                break;
                            } else {
                                i += 1;
                                j += 5 as libc::c_int;
                            }
                        }
                    }
                } else {
                    current_block = 9241535491006583629;
                }
                match current_block {
                    757928548486660075 => {}
                    _ => {
                        ret = xmlSchemaValidateElem(vctxt);
                        if ret != 0 as libc::c_int {
                            if ret == -(1 as libc::c_int) {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaSAXHandleStartElementNs\0" as *const u8
                                        as *const libc::c_char,
                                    b"calling xmlSchemaValidateElem()\0" as *const u8
                                        as *const libc::c_char,
                                );
                                current_block = 757928548486660075;
                            } else {
                                current_block = 2482997575520911882;
                            }
                        } else {
                            current_block = 2482997575520911882;
                        }
                        match current_block {
                            757928548486660075 => {}
                            _ => return,
                        }
                    }
                }
            }
        }
    }
    (*vctxt).err = -(1 as libc::c_int);
    xmlStopParser((*vctxt).parserCtxt);
}
unsafe extern "C" fn xmlSchemaSAXHandleEndElementNs(
    mut ctx: *mut libc::c_void,
    mut localname: *const xmlChar,
    mut prefix: *const xmlChar,
    mut URI: *const xmlChar,
) {
    let mut vctxt: xmlSchemaValidCtxtPtr = ctx as xmlSchemaValidCtxtPtr;
    let mut res: libc::c_int = 0;
    if (*vctxt).skipDepth != -(1 as libc::c_int) {
        if (*vctxt).depth > (*vctxt).skipDepth {
            let ref mut fresh634 = (*vctxt).depth;
            *fresh634 -= 1;
            return;
        } else {
            (*vctxt).skipDepth = -(1 as libc::c_int);
        }
    }
    if xmlStrEqual((*(*vctxt).inode).localName, localname) == 0
        || xmlStrEqual((*(*vctxt).inode).nsName, URI) == 0
    {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaSAXHandleEndElementNs\0" as *const u8 as *const libc::c_char,
            b"elem pop mismatch\0" as *const u8 as *const libc::c_char,
        );
    }
    res = xmlSchemaValidatorPopElem(vctxt);
    if res != 0 as libc::c_int {
        if res < 0 as libc::c_int {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaSAXHandleEndElementNs\0" as *const u8 as *const libc::c_char,
                b"calling xmlSchemaValidatorPopElem()\0" as *const u8
                    as *const libc::c_char,
            );
            (*vctxt).err = -(1 as libc::c_int);
            xmlStopParser((*vctxt).parserCtxt);
            return;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaNewValidCtxt(
    mut schema: xmlSchemaPtr,
) -> xmlSchemaValidCtxtPtr {
    let mut ret: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaValidCtxt>() as libc::c_ulong)
        as xmlSchemaValidCtxtPtr;
    if ret.is_null() {
        xmlSchemaVErrMemory(
            0 as xmlSchemaValidCtxtPtr,
            b"allocating validation context\0" as *const u8 as *const libc::c_char,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaValidCtxtPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaValidCtxt>() as libc::c_ulong,
    );
    (*ret).type_0 = 2 as libc::c_int;
    let ref mut fresh635 = (*ret).dict;
    *fresh635 = xmlDictCreate();
    let ref mut fresh636 = (*ret).nodeQNames;
    *fresh636 = xmlSchemaItemListCreate();
    let ref mut fresh637 = (*ret).schema;
    *fresh637 = schema;
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateSetFilename(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut filename: *const libc::c_char,
) {
    if vctxt.is_null() {
        return;
    }
    if !((*vctxt).filename).is_null() {
        xmlFree
            .expect("non-null function pointer")((*vctxt).filename as *mut libc::c_void);
    }
    if !filename.is_null() {
        let ref mut fresh638 = (*vctxt).filename;
        *fresh638 = xmlStrdup(filename as *const xmlChar) as *mut libc::c_char;
    } else {
        let ref mut fresh639 = (*vctxt).filename;
        *fresh639 = 0 as *mut libc::c_char;
    };
}
unsafe extern "C" fn xmlSchemaClearValidCtxt(mut vctxt: xmlSchemaValidCtxtPtr) {
    if vctxt.is_null() {
        return;
    }
    (*vctxt).flags = 0 as libc::c_int;
    let ref mut fresh640 = (*vctxt).validationRoot;
    *fresh640 = 0 as xmlNodePtr;
    let ref mut fresh641 = (*vctxt).doc;
    *fresh641 = 0 as xmlDocPtr;
    let ref mut fresh642 = (*vctxt).reader;
    *fresh642 = 0 as xmlTextReaderPtr;
    (*vctxt).hasKeyrefs = 0 as libc::c_int;
    if !((*vctxt).value).is_null() {
        xmlSchemaFreeValue((*vctxt).value);
        let ref mut fresh643 = (*vctxt).value;
        *fresh643 = 0 as xmlSchemaValPtr;
    }
    if !((*vctxt).aidcs).is_null() {
        let mut cur: xmlSchemaIDCAugPtr = (*vctxt).aidcs;
        let mut next: xmlSchemaIDCAugPtr = 0 as *mut xmlSchemaIDCAug;
        loop {
            next = (*cur).next;
            xmlFree.expect("non-null function pointer")(cur as *mut libc::c_void);
            cur = next;
            if cur.is_null() {
                break;
            }
        }
        let ref mut fresh644 = (*vctxt).aidcs;
        *fresh644 = 0 as xmlSchemaIDCAugPtr;
    }
    if !((*vctxt).idcNodes).is_null() {
        let mut i: libc::c_int = 0;
        let mut item: xmlSchemaPSVIIDCNodePtr = 0 as *mut xmlSchemaPSVIIDCNode;
        i = 0 as libc::c_int;
        while i < (*vctxt).nbIdcNodes {
            item = *((*vctxt).idcNodes).offset(i as isize);
            xmlFree
                .expect("non-null function pointer")((*item).keys as *mut libc::c_void);
            xmlFree.expect("non-null function pointer")(item as *mut libc::c_void);
            i += 1;
        }
        xmlFree
            .expect("non-null function pointer")((*vctxt).idcNodes as *mut libc::c_void);
        let ref mut fresh645 = (*vctxt).idcNodes;
        *fresh645 = 0 as *mut xmlSchemaPSVIIDCNodePtr;
        (*vctxt).nbIdcNodes = 0 as libc::c_int;
        (*vctxt).sizeIdcNodes = 0 as libc::c_int;
    }
    if !((*vctxt).idcKeys).is_null() {
        let mut i_0: libc::c_int = 0;
        i_0 = 0 as libc::c_int;
        while i_0 < (*vctxt).nbIdcKeys {
            xmlSchemaIDCFreeKey(*((*vctxt).idcKeys).offset(i_0 as isize));
            i_0 += 1;
        }
        xmlFree
            .expect("non-null function pointer")((*vctxt).idcKeys as *mut libc::c_void);
        let ref mut fresh646 = (*vctxt).idcKeys;
        *fresh646 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
        (*vctxt).nbIdcKeys = 0 as libc::c_int;
        (*vctxt).sizeIdcKeys = 0 as libc::c_int;
    }
    if !((*vctxt).xpathStates).is_null() {
        xmlSchemaFreeIDCStateObjList((*vctxt).xpathStates);
        let ref mut fresh647 = (*vctxt).xpathStates;
        *fresh647 = 0 as xmlSchemaIDCStateObjPtr;
    }
    if (*vctxt).nbAttrInfos != 0 as libc::c_int {
        xmlSchemaClearAttrInfos(vctxt);
    }
    if !((*vctxt).elemInfos).is_null() {
        let mut i_1: libc::c_int = 0;
        let mut ei: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
        i_1 = 0 as libc::c_int;
        while i_1 < (*vctxt).sizeElemInfos {
            ei = *((*vctxt).elemInfos).offset(i_1 as isize);
            if ei.is_null() {
                break;
            }
            xmlSchemaClearElemInfo(vctxt, ei);
            i_1 += 1;
        }
    }
    xmlSchemaItemListClear((*vctxt).nodeQNames);
    xmlDictFree((*vctxt).dict);
    let ref mut fresh648 = (*vctxt).dict;
    *fresh648 = xmlDictCreate();
    if !((*vctxt).filename).is_null() {
        xmlFree
            .expect("non-null function pointer")((*vctxt).filename as *mut libc::c_void);
        let ref mut fresh649 = (*vctxt).filename;
        *fresh649 = 0 as *mut libc::c_char;
    }
    if !((*vctxt).idcMatcherCache).is_null() {
        let mut matcher: xmlSchemaIDCMatcherPtr = (*vctxt).idcMatcherCache;
        let mut tmp: xmlSchemaIDCMatcherPtr = 0 as *mut xmlSchemaIDCMatcher;
        while !matcher.is_null() {
            tmp = matcher;
            matcher = (*matcher).nextCached;
            xmlSchemaIDCFreeMatcherList(tmp);
        }
        let ref mut fresh650 = (*vctxt).idcMatcherCache;
        *fresh650 = 0 as xmlSchemaIDCMatcherPtr;
    }
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFreeValidCtxt(mut ctxt: xmlSchemaValidCtxtPtr) {
    if ctxt.is_null() {
        return;
    }
    if !((*ctxt).value).is_null() {
        xmlSchemaFreeValue((*ctxt).value);
    }
    if !((*ctxt).pctxt).is_null() {
        xmlSchemaFreeParserCtxt((*ctxt).pctxt);
    }
    if !((*ctxt).idcNodes).is_null() {
        let mut i: libc::c_int = 0;
        let mut item: xmlSchemaPSVIIDCNodePtr = 0 as *mut xmlSchemaPSVIIDCNode;
        i = 0 as libc::c_int;
        while i < (*ctxt).nbIdcNodes {
            item = *((*ctxt).idcNodes).offset(i as isize);
            xmlFree
                .expect("non-null function pointer")((*item).keys as *mut libc::c_void);
            xmlFree.expect("non-null function pointer")(item as *mut libc::c_void);
            i += 1;
        }
        xmlFree
            .expect("non-null function pointer")((*ctxt).idcNodes as *mut libc::c_void);
    }
    if !((*ctxt).idcKeys).is_null() {
        let mut i_0: libc::c_int = 0;
        i_0 = 0 as libc::c_int;
        while i_0 < (*ctxt).nbIdcKeys {
            xmlSchemaIDCFreeKey(*((*ctxt).idcKeys).offset(i_0 as isize));
            i_0 += 1;
        }
        xmlFree
            .expect("non-null function pointer")((*ctxt).idcKeys as *mut libc::c_void);
    }
    if !((*ctxt).xpathStates).is_null() {
        xmlSchemaFreeIDCStateObjList((*ctxt).xpathStates);
        let ref mut fresh651 = (*ctxt).xpathStates;
        *fresh651 = 0 as xmlSchemaIDCStateObjPtr;
    }
    if !((*ctxt).xpathStatePool).is_null() {
        xmlSchemaFreeIDCStateObjList((*ctxt).xpathStatePool);
        let ref mut fresh652 = (*ctxt).xpathStatePool;
        *fresh652 = 0 as xmlSchemaIDCStateObjPtr;
    }
    if !((*ctxt).aidcs).is_null() {
        let mut cur: xmlSchemaIDCAugPtr = (*ctxt).aidcs;
        let mut next: xmlSchemaIDCAugPtr = 0 as *mut xmlSchemaIDCAug;
        loop {
            next = (*cur).next;
            xmlFree.expect("non-null function pointer")(cur as *mut libc::c_void);
            cur = next;
            if cur.is_null() {
                break;
            }
        }
    }
    if !((*ctxt).attrInfos).is_null() {
        let mut i_1: libc::c_int = 0;
        let mut attr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
        if (*ctxt).nbAttrInfos != 0 as libc::c_int {
            xmlSchemaClearAttrInfos(ctxt);
        }
        i_1 = 0 as libc::c_int;
        while i_1 < (*ctxt).sizeAttrInfos {
            attr = *((*ctxt).attrInfos).offset(i_1 as isize);
            xmlFree.expect("non-null function pointer")(attr as *mut libc::c_void);
            i_1 += 1;
        }
        xmlFree
            .expect("non-null function pointer")((*ctxt).attrInfos as *mut libc::c_void);
    }
    if !((*ctxt).elemInfos).is_null() {
        let mut i_2: libc::c_int = 0;
        let mut ei: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
        i_2 = 0 as libc::c_int;
        while i_2 < (*ctxt).sizeElemInfos {
            ei = *((*ctxt).elemInfos).offset(i_2 as isize);
            if ei.is_null() {
                break;
            }
            xmlSchemaClearElemInfo(ctxt, ei);
            xmlFree.expect("non-null function pointer")(ei as *mut libc::c_void);
            i_2 += 1;
        }
        xmlFree
            .expect("non-null function pointer")((*ctxt).elemInfos as *mut libc::c_void);
    }
    if !((*ctxt).nodeQNames).is_null() {
        xmlSchemaItemListFree((*ctxt).nodeQNames);
    }
    if !((*ctxt).dict).is_null() {
        xmlDictFree((*ctxt).dict);
    }
    if !((*ctxt).filename).is_null() {
        xmlFree
            .expect("non-null function pointer")((*ctxt).filename as *mut libc::c_void);
    }
    xmlFree.expect("non-null function pointer")(ctxt as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaIsValid(
    mut ctxt: xmlSchemaValidCtxtPtr,
) -> libc::c_int {
    if ctxt.is_null() {
        return -(1 as libc::c_int);
    }
    return ((*ctxt).err == 0 as libc::c_int) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSetValidErrors(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut err: xmlSchemaValidityErrorFunc,
    mut warn: xmlSchemaValidityWarningFunc,
    mut ctx: *mut libc::c_void,
) {
    if ctxt.is_null() {
        return;
    }
    let ref mut fresh653 = (*ctxt).error;
    *fresh653 = err;
    let ref mut fresh654 = (*ctxt).warning;
    *fresh654 = warn;
    let ref mut fresh655 = (*ctxt).errCtxt;
    *fresh655 = ctx;
    if !((*ctxt).pctxt).is_null() {
        xmlSchemaSetParserErrors((*ctxt).pctxt, err, warn, ctx);
    }
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSetValidStructuredErrors(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut serror: xmlStructuredErrorFunc,
    mut ctx: *mut libc::c_void,
) {
    if ctxt.is_null() {
        return;
    }
    let ref mut fresh656 = (*ctxt).serror;
    *fresh656 = serror;
    let ref mut fresh657 = (*ctxt).error;
    *fresh657 = None;
    let ref mut fresh658 = (*ctxt).warning;
    *fresh658 = None;
    let ref mut fresh659 = (*ctxt).errCtxt;
    *fresh659 = ctx;
    if !((*ctxt).pctxt).is_null() {
        xmlSchemaSetParserStructuredErrors((*ctxt).pctxt, serror, ctx);
    }
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaGetValidErrors(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut err: *mut xmlSchemaValidityErrorFunc,
    mut warn: *mut xmlSchemaValidityWarningFunc,
    mut ctx: *mut *mut libc::c_void,
) -> libc::c_int {
    if ctxt.is_null() {
        return -(1 as libc::c_int);
    }
    if !err.is_null() {
        *err = (*ctxt).error;
    }
    if !warn.is_null() {
        *warn = (*ctxt).warning;
    }
    if !ctx.is_null() {
        *ctx = (*ctxt).errCtxt;
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSetValidOptions(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut options: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    if ctxt.is_null() {
        return -(1 as libc::c_int);
    }
    i = 1 as libc::c_int;
    while i
        < ::std::mem::size_of::<libc::c_int>() as libc::c_ulong as libc::c_int
            * 8 as libc::c_int
    {
        if options & (1 as libc::c_int) << i != 0 {
            return -(1 as libc::c_int);
        }
        i += 1;
    }
    (*ctxt).options = options;
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidCtxtGetOptions(
    mut ctxt: xmlSchemaValidCtxtPtr,
) -> libc::c_int {
    if ctxt.is_null() { return -(1 as libc::c_int) } else { return (*ctxt).options };
}
unsafe extern "C" fn xmlSchemaVDocWalk(mut vctxt: xmlSchemaValidCtxtPtr) -> libc::c_int {
    let mut current_block: u64;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut ielem: xmlSchemaNodeInfoPtr = 0 as xmlSchemaNodeInfoPtr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut valRoot: xmlNodePtr = 0 as *mut xmlNode;
    let mut nsName: *const xmlChar = 0 as *const xmlChar;
    if !((*vctxt).validationRoot).is_null() {
        valRoot = (*vctxt).validationRoot;
    } else {
        valRoot = xmlDocGetRootElement((*vctxt).doc as *const xmlDoc);
    }
    if valRoot.is_null() {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_ERR_INTERNAL_ERROR,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"The document has no document element\0" as *const u8
                as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return 1 as libc::c_int;
    }
    (*vctxt).depth = -(1 as libc::c_int);
    let ref mut fresh660 = (*vctxt).validationRoot;
    *fresh660 = valRoot;
    node = valRoot;
    's_62: loop {
        if node.is_null() {
            current_block = 17798826982086638848;
            break;
        }
        if (*vctxt).skipDepth != -(1 as libc::c_int)
            && (*vctxt).depth >= (*vctxt).skipDepth
        {
            current_block = 14755719952959066985;
        } else {
            if (*node).type_0 as libc::c_uint
                == XML_ELEMENT_NODE as libc::c_int as libc::c_uint
            {
                let ref mut fresh661 = (*vctxt).depth;
                *fresh661 += 1;
                if xmlSchemaValidatorPushElem(vctxt) == -(1 as libc::c_int) {
                    current_block = 1349865872602754158;
                    break;
                }
                ielem = (*vctxt).inode;
                let ref mut fresh662 = (*ielem).node;
                *fresh662 = node;
                (*ielem).nodeLine = (*node).line as libc::c_int;
                let ref mut fresh663 = (*ielem).localName;
                *fresh663 = (*node).name;
                if !((*node).ns).is_null() {
                    let ref mut fresh664 = (*ielem).nsName;
                    *fresh664 = (*(*node).ns).href;
                }
                (*ielem).flags |= (1 as libc::c_int) << 5 as libc::c_int;
                (*vctxt).nbAttrInfos = 0 as libc::c_int;
                if !((*node).properties).is_null() {
                    attr = (*node).properties;
                    loop {
                        if !((*attr).ns).is_null() {
                            nsName = (*(*attr).ns).href;
                        } else {
                            nsName = 0 as *const xmlChar;
                        }
                        ret = xmlSchemaValidatorPushAttribute(
                            vctxt,
                            attr as xmlNodePtr,
                            (*ielem).nodeLine,
                            (*attr).name,
                            nsName,
                            0 as libc::c_int,
                            xmlNodeListGetString(
                                (*attr).doc,
                                (*attr).children,
                                1 as libc::c_int,
                            ),
                            1 as libc::c_int,
                        );
                        if ret == -(1 as libc::c_int) {
                            xmlSchemaInternalErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                b"xmlSchemaDocWalk\0" as *const u8 as *const libc::c_char,
                                b"calling xmlSchemaValidatorPushAttribute()\0" as *const u8
                                    as *const libc::c_char,
                            );
                            current_block = 1349865872602754158;
                            break 's_62;
                        } else {
                            attr = (*attr).next;
                            if attr.is_null() {
                                break;
                            }
                        }
                    }
                }
                ret = xmlSchemaValidateElem(vctxt);
                if ret != 0 as libc::c_int {
                    if ret == -(1 as libc::c_int) {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaDocWalk\0" as *const u8 as *const libc::c_char,
                            b"calling xmlSchemaValidateElem()\0" as *const u8
                                as *const libc::c_char,
                        );
                        current_block = 1349865872602754158;
                        break;
                    }
                    current_block = 15505510009722066756;
                } else if (*vctxt).skipDepth != -(1 as libc::c_int)
                        && (*vctxt).depth >= (*vctxt).skipDepth
                    {
                    current_block = 15505510009722066756;
                } else {
                    current_block = 17233182392562552756;
                }
            } else if (*node).type_0 as libc::c_uint
                    == XML_TEXT_NODE as libc::c_int as libc::c_uint
                    || (*node).type_0 as libc::c_uint
                        == XML_CDATA_SECTION_NODE as libc::c_int as libc::c_uint
                {
                if !ielem.is_null()
                    && (*ielem).flags & (1 as libc::c_int) << 5 as libc::c_int != 0
                {
                    (*ielem).flags ^= (1 as libc::c_int) << 5 as libc::c_int;
                }
                ret = xmlSchemaVPushText(
                    vctxt,
                    (*node).type_0 as libc::c_int,
                    (*node).content,
                    -(1 as libc::c_int),
                    1 as libc::c_int,
                    0 as *mut libc::c_int,
                );
                if ret < 0 as libc::c_int {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaVDocWalk\0" as *const u8 as *const libc::c_char,
                        b"calling xmlSchemaVPushText()\0" as *const u8
                            as *const libc::c_char,
                    );
                    current_block = 1349865872602754158;
                    break;
                } else {
                    current_block = 17233182392562552756;
                }
            } else if (*node).type_0 as libc::c_uint
                    == XML_ENTITY_NODE as libc::c_int as libc::c_uint
                    || (*node).type_0 as libc::c_uint
                        == XML_ENTITY_REF_NODE as libc::c_int as libc::c_uint
                {
                xmlSchemaInternalErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaVDocWalk\0" as *const u8 as *const libc::c_char,
                    b"there is at least one entity reference in the node-tree currently being validated. Processing of entities with this XML Schema processor is not supported (yet). Please substitute entities before validation.\0"
                        as *const u8 as *const libc::c_char,
                );
                current_block = 1349865872602754158;
                break;
            } else {
                current_block = 15505510009722066756;
            }
            match current_block {
                15505510009722066756 => {}
                _ => {
                    if !((*node).children).is_null() {
                        node = (*node).children;
                        continue;
                    } else {
                        current_block = 15505510009722066756;
                    }
                }
            }
        }
        loop {
            match current_block {
                14755719952959066985 => {
                    if !((*node).next).is_null() {
                        node = (*node).next;
                        break;
                    } else {
                        node = (*node).parent;
                        current_block = 15505510009722066756;
                    }
                }
                _ => {
                    if !((*node).type_0 as libc::c_uint
                        == XML_ELEMENT_NODE as libc::c_int as libc::c_uint)
                    {
                        current_block = 14755719952959066985;
                        continue;
                    }
                    if node != (*(*vctxt).inode).node {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaVDocWalk\0" as *const u8 as *const libc::c_char,
                            b"element position mismatch\0" as *const u8
                                as *const libc::c_char,
                        );
                        current_block = 1349865872602754158;
                        break 's_62;
                    } else {
                        ret = xmlSchemaValidatorPopElem(vctxt);
                        if ret != 0 as libc::c_int {
                            if ret < 0 as libc::c_int {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaVDocWalk\0" as *const u8 as *const libc::c_char,
                                    b"calling xmlSchemaValidatorPopElem()\0" as *const u8
                                        as *const libc::c_char,
                                );
                                current_block = 1349865872602754158;
                                break 's_62;
                            }
                        }
                        if node == valRoot {
                            current_block = 17798826982086638848;
                            break 's_62;
                        } else {
                            current_block = 14755719952959066985;
                        }
                    }
                }
            }
        }
    }
    match current_block {
        1349865872602754158 => return -(1 as libc::c_int),
        _ => return ret,
    };
}
unsafe extern "C" fn xmlSchemaPreRun(mut vctxt: xmlSchemaValidCtxtPtr) -> libc::c_int {
    (*vctxt).err = 0 as libc::c_int;
    (*vctxt).nberrors = 0 as libc::c_int;
    (*vctxt).depth = -(1 as libc::c_int);
    (*vctxt).skipDepth = -(1 as libc::c_int);
    (*vctxt).hasKeyrefs = 0 as libc::c_int;
    (*vctxt).createIDCNodeTables = 0 as libc::c_int;
    if ((*vctxt).schema).is_null() {
        let mut pctxt: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
        (*vctxt).xsiAssemble = 1 as libc::c_int;
        if ((*vctxt).pctxt).is_null()
            && xmlSchemaCreatePCtxtOnVCtxt(vctxt) == -(1 as libc::c_int)
        {
            return -(1 as libc::c_int);
        }
        pctxt = (*vctxt).pctxt;
        (*pctxt).xsiAssemble = 1 as libc::c_int;
        let ref mut fresh665 = (*vctxt).schema;
        *fresh665 = xmlSchemaNewSchema(pctxt);
        if ((*vctxt).schema).is_null() {
            return -(1 as libc::c_int);
        }
        let ref mut fresh666 = (*pctxt).constructor;
        *fresh666 = xmlSchemaConstructionCtxtCreate((*pctxt).dict);
        if ((*pctxt).constructor).is_null() {
            return -(1 as libc::c_int);
        }
        let ref mut fresh667 = (*(*pctxt).constructor).mainSchema;
        *fresh667 = (*vctxt).schema;
        (*pctxt).ownsConstructor = 1 as libc::c_int;
    }
    xmlHashScan(
        (*(*vctxt).schema).schemasImports,
        Some(
            xmlSchemaAugmentImportedIDC
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *mut libc::c_void,
                    *const xmlChar,
                ) -> (),
        ),
        vctxt as *mut libc::c_void,
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn xmlSchemaPostRun(mut vctxt: xmlSchemaValidCtxtPtr) {
    if (*vctxt).xsiAssemble != 0 {
        if !((*vctxt).schema).is_null() {
            xmlSchemaFree((*vctxt).schema);
            let ref mut fresh668 = (*vctxt).schema;
            *fresh668 = 0 as xmlSchemaPtr;
        }
    }
    xmlSchemaClearValidCtxt(vctxt);
}
unsafe extern "C" fn xmlSchemaVStart(mut vctxt: xmlSchemaValidCtxtPtr) -> libc::c_int {
    let mut ret: libc::c_int = 0 as libc::c_int;
    if xmlSchemaPreRun(vctxt) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    if !((*vctxt).doc).is_null() {
        ret = xmlSchemaVDocWalk(vctxt);
    } else if ((*vctxt).reader).is_null() {
        if !((*vctxt).sax).is_null() && !((*vctxt).parserCtxt).is_null() {
            ret = xmlParseDocument((*vctxt).parserCtxt);
        } else {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaVStart\0" as *const u8 as *const libc::c_char,
                b"no instance to validate\0" as *const u8 as *const libc::c_char,
            );
            ret = -(1 as libc::c_int);
        }
    }
    xmlSchemaPostRun(vctxt);
    if ret == 0 as libc::c_int {
        ret = (*vctxt).err;
    }
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateOneElement(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut elem: xmlNodePtr,
) -> libc::c_int {
    if ctxt.is_null() || elem.is_null()
        || (*elem).type_0 as libc::c_uint
            != XML_ELEMENT_NODE as libc::c_int as libc::c_uint
    {
        return -(1 as libc::c_int);
    }
    if ((*ctxt).schema).is_null() {
        return -(1 as libc::c_int);
    }
    let ref mut fresh669 = (*ctxt).doc;
    *fresh669 = (*elem).doc;
    let ref mut fresh670 = (*ctxt).node;
    *fresh670 = elem;
    let ref mut fresh671 = (*ctxt).validationRoot;
    *fresh671 = elem;
    return xmlSchemaVStart(ctxt);
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateDoc(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut doc: xmlDocPtr,
) -> libc::c_int {
    if ctxt.is_null() || doc.is_null() {
        return -(1 as libc::c_int);
    }
    let ref mut fresh672 = (*ctxt).doc;
    *fresh672 = doc;
    let ref mut fresh673 = (*ctxt).node;
    *fresh673 = xmlDocGetRootElement(doc as *const xmlDoc);
    if ((*ctxt).node).is_null() {
        xmlSchemaCustomErr(
            ctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING,
            doc as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"The document has no document element\0" as *const u8
                as *const libc::c_char,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*ctxt).err;
    }
    let ref mut fresh674 = (*ctxt).validationRoot;
    *fresh674 = (*ctxt).node;
    return xmlSchemaVStart(ctxt);
}
unsafe extern "C" fn internalSubsetSplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
    mut ExternalID: *const xmlChar,
    mut SystemID: *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).internalSubset).is_some()
    {
        ((*(*ctxt).user_sax).internalSubset)
            .expect(
                "non-null function pointer",
            )((*ctxt).user_data, name, ExternalID, SystemID);
    }
}
unsafe extern "C" fn isStandaloneSplit(mut ctx: *mut libc::c_void) -> libc::c_int {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).isStandalone).is_some()
    {
        return ((*(*ctxt).user_sax).isStandalone)
            .expect("non-null function pointer")((*ctxt).user_data);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn hasInternalSubsetSplit(mut ctx: *mut libc::c_void) -> libc::c_int {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).hasInternalSubset).is_some()
    {
        return ((*(*ctxt).user_sax).hasInternalSubset)
            .expect("non-null function pointer")((*ctxt).user_data);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn hasExternalSubsetSplit(mut ctx: *mut libc::c_void) -> libc::c_int {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).hasExternalSubset).is_some()
    {
        return ((*(*ctxt).user_sax).hasExternalSubset)
            .expect("non-null function pointer")((*ctxt).user_data);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn externalSubsetSplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
    mut ExternalID: *const xmlChar,
    mut SystemID: *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).externalSubset).is_some()
    {
        ((*(*ctxt).user_sax).externalSubset)
            .expect(
                "non-null function pointer",
            )((*ctxt).user_data, name, ExternalID, SystemID);
    }
}
unsafe extern "C" fn resolveEntitySplit(
    mut ctx: *mut libc::c_void,
    mut publicId: *const xmlChar,
    mut systemId: *const xmlChar,
) -> xmlParserInputPtr {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).resolveEntity).is_some()
    {
        return ((*(*ctxt).user_sax).resolveEntity)
            .expect("non-null function pointer")((*ctxt).user_data, publicId, systemId);
    }
    return 0 as xmlParserInputPtr;
}
unsafe extern "C" fn getEntitySplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
) -> xmlEntityPtr {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).getEntity).is_some()
    {
        return ((*(*ctxt).user_sax).getEntity)
            .expect("non-null function pointer")((*ctxt).user_data, name);
    }
    return 0 as xmlEntityPtr;
}
unsafe extern "C" fn getParameterEntitySplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
) -> xmlEntityPtr {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).getParameterEntity).is_some()
    {
        return ((*(*ctxt).user_sax).getParameterEntity)
            .expect("non-null function pointer")((*ctxt).user_data, name);
    }
    return 0 as xmlEntityPtr;
}
unsafe extern "C" fn entityDeclSplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
    mut type_0: libc::c_int,
    mut publicId: *const xmlChar,
    mut systemId: *const xmlChar,
    mut content: *mut xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).entityDecl).is_some()
    {
        ((*(*ctxt).user_sax).entityDecl)
            .expect(
                "non-null function pointer",
            )((*ctxt).user_data, name, type_0, publicId, systemId, content);
    }
}
unsafe extern "C" fn attributeDeclSplit(
    mut ctx: *mut libc::c_void,
    mut elem: *const xmlChar,
    mut name: *const xmlChar,
    mut type_0: libc::c_int,
    mut def: libc::c_int,
    mut defaultValue: *const xmlChar,
    mut tree: xmlEnumerationPtr,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).attributeDecl).is_some()
    {
        ((*(*ctxt).user_sax).attributeDecl)
            .expect(
                "non-null function pointer",
            )((*ctxt).user_data, elem, name, type_0, def, defaultValue, tree);
    } else {
        xmlFreeEnumeration(tree);
    };
}
unsafe extern "C" fn elementDeclSplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
    mut type_0: libc::c_int,
    mut content: xmlElementContentPtr,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).elementDecl).is_some()
    {
        ((*(*ctxt).user_sax).elementDecl)
            .expect(
                "non-null function pointer",
            )((*ctxt).user_data, name, type_0, content);
    }
}
unsafe extern "C" fn notationDeclSplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
    mut publicId: *const xmlChar,
    mut systemId: *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).notationDecl).is_some()
    {
        ((*(*ctxt).user_sax).notationDecl)
            .expect(
                "non-null function pointer",
            )((*ctxt).user_data, name, publicId, systemId);
    }
}
unsafe extern "C" fn unparsedEntityDeclSplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
    mut publicId: *const xmlChar,
    mut systemId: *const xmlChar,
    mut notationName: *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).unparsedEntityDecl).is_some()
    {
        ((*(*ctxt).user_sax).unparsedEntityDecl)
            .expect(
                "non-null function pointer",
            )((*ctxt).user_data, name, publicId, systemId, notationName);
    }
}
unsafe extern "C" fn setDocumentLocatorSplit(
    mut ctx: *mut libc::c_void,
    mut loc: xmlSAXLocatorPtr,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).setDocumentLocator).is_some()
    {
        ((*(*ctxt).user_sax).setDocumentLocator)
            .expect("non-null function pointer")((*ctxt).user_data, loc);
    }
}
unsafe extern "C" fn startDocumentSplit(mut ctx: *mut libc::c_void) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).startDocument).is_some()
    {
        ((*(*ctxt).user_sax).startDocument)
            .expect("non-null function pointer")((*ctxt).user_data);
    }
}
unsafe extern "C" fn endDocumentSplit(mut ctx: *mut libc::c_void) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).endDocument).is_some()
    {
        ((*(*ctxt).user_sax).endDocument)
            .expect("non-null function pointer")((*ctxt).user_data);
    }
}
unsafe extern "C" fn processingInstructionSplit(
    mut ctx: *mut libc::c_void,
    mut target: *const xmlChar,
    mut data: *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).processingInstruction).is_some()
    {
        ((*(*ctxt).user_sax).processingInstruction)
            .expect("non-null function pointer")((*ctxt).user_data, target, data);
    }
}
unsafe extern "C" fn commentSplit(
    mut ctx: *mut libc::c_void,
    mut value: *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).comment).is_some()
    {
        ((*(*ctxt).user_sax).comment)
            .expect("non-null function pointer")((*ctxt).user_data, value);
    }
}
unsafe extern "C" fn warningSplit(
    mut ctx: *mut libc::c_void,
    mut msg: *const libc::c_char,
    mut args: ...
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).warning).is_some()
    {
        (*__xmlGenericError())
            .expect(
                "non-null function pointer",
            )(
            *__xmlGenericErrorContext(),
            b"Unimplemented block at %s:%d\n\0" as *const u8 as *const libc::c_char,
            b"xmlschemas.c\0" as *const u8 as *const libc::c_char,
            28699 as libc::c_int,
        );
    }
}
unsafe extern "C" fn errorSplit(
    mut ctx: *mut libc::c_void,
    mut msg: *const libc::c_char,
    mut args: ...
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).error).is_some()
    {
        (*__xmlGenericError())
            .expect(
                "non-null function pointer",
            )(
            *__xmlGenericErrorContext(),
            b"Unimplemented block at %s:%d\n\0" as *const u8 as *const libc::c_char,
            b"xmlschemas.c\0" as *const u8 as *const libc::c_char,
            28707 as libc::c_int,
        );
    }
}
unsafe extern "C" fn fatalErrorSplit(
    mut ctx: *mut libc::c_void,
    mut msg: *const libc::c_char,
    mut args: ...
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).fatalError).is_some()
    {
        (*__xmlGenericError())
            .expect(
                "non-null function pointer",
            )(
            *__xmlGenericErrorContext(),
            b"Unimplemented block at %s:%d\n\0" as *const u8 as *const libc::c_char,
            b"xmlschemas.c\0" as *const u8 as *const libc::c_char,
            28715 as libc::c_int,
        );
    }
}
unsafe extern "C" fn charactersSplit(
    mut ctx: *mut libc::c_void,
    mut ch: *const xmlChar,
    mut len: libc::c_int,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !((*ctxt).user_sax).is_null() && ((*(*ctxt).user_sax).characters).is_some() {
        ((*(*ctxt).user_sax).characters)
            .expect("non-null function pointer")((*ctxt).user_data, ch, len);
    }
    if !((*ctxt).ctxt).is_null() {
        xmlSchemaSAXHandleText((*ctxt).ctxt as *mut libc::c_void, ch, len);
    }
}
unsafe extern "C" fn ignorableWhitespaceSplit(
    mut ctx: *mut libc::c_void,
    mut ch: *const xmlChar,
    mut len: libc::c_int,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).ignorableWhitespace).is_some()
    {
        ((*(*ctxt).user_sax).ignorableWhitespace)
            .expect("non-null function pointer")((*ctxt).user_data, ch, len);
    }
    if !((*ctxt).ctxt).is_null() {
        xmlSchemaSAXHandleText((*ctxt).ctxt as *mut libc::c_void, ch, len);
    }
}
unsafe extern "C" fn cdataBlockSplit(
    mut ctx: *mut libc::c_void,
    mut value: *const xmlChar,
    mut len: libc::c_int,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !((*ctxt).user_sax).is_null() && ((*(*ctxt).user_sax).cdataBlock).is_some() {
        ((*(*ctxt).user_sax).cdataBlock)
            .expect("non-null function pointer")((*ctxt).user_data, value, len);
    }
    if !((*ctxt).ctxt).is_null() {
        xmlSchemaSAXHandleCDataSection((*ctxt).ctxt as *mut libc::c_void, value, len);
    }
}
unsafe extern "C" fn referenceSplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).reference).is_some()
    {
        ((*(*ctxt).user_sax).reference)
            .expect("non-null function pointer")((*ctxt).user_data, name);
    }
    if !((*ctxt).ctxt).is_null() {
        xmlSchemaSAXHandleReference((*ctxt).user_data, name);
    }
}
unsafe extern "C" fn startElementNsSplit(
    mut ctx: *mut libc::c_void,
    mut localname: *const xmlChar,
    mut prefix: *const xmlChar,
    mut URI: *const xmlChar,
    mut nb_namespaces: libc::c_int,
    mut namespaces: *mut *const xmlChar,
    mut nb_attributes: libc::c_int,
    mut nb_defaulted: libc::c_int,
    mut attributes: *mut *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !((*ctxt).user_sax).is_null() && ((*(*ctxt).user_sax).startElementNs).is_some() {
        ((*(*ctxt).user_sax).startElementNs)
            .expect(
                "non-null function pointer",
            )(
            (*ctxt).user_data,
            localname,
            prefix,
            URI,
            nb_namespaces,
            namespaces,
            nb_attributes,
            nb_defaulted,
            attributes,
        );
    }
    if !((*ctxt).ctxt).is_null() {
        xmlSchemaSAXHandleStartElementNs(
            (*ctxt).ctxt as *mut libc::c_void,
            localname,
            prefix,
            URI,
            nb_namespaces,
            namespaces,
            nb_attributes,
            nb_defaulted,
            attributes,
        );
    }
}
unsafe extern "C" fn endElementNsSplit(
    mut ctx: *mut libc::c_void,
    mut localname: *const xmlChar,
    mut prefix: *const xmlChar,
    mut URI: *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !((*ctxt).user_sax).is_null() && ((*(*ctxt).user_sax).endElementNs).is_some() {
        ((*(*ctxt).user_sax).endElementNs)
            .expect(
                "non-null function pointer",
            )((*ctxt).user_data, localname, prefix, URI);
    }
    if !((*ctxt).ctxt).is_null() {
        xmlSchemaSAXHandleEndElementNs(
            (*ctxt).ctxt as *mut libc::c_void,
            localname,
            prefix,
            URI,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSAXPlug(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut sax: *mut xmlSAXHandlerPtr,
    mut user_data: *mut *mut libc::c_void,
) -> xmlSchemaSAXPlugPtr {
    let mut ret: xmlSchemaSAXPlugPtr = 0 as *mut xmlSchemaSAXPlugStruct;
    let mut old_sax: xmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    if ctxt.is_null() || sax.is_null() || user_data.is_null() {
        return 0 as xmlSchemaSAXPlugPtr;
    }
    old_sax = *sax;
    if !old_sax.is_null() && (*old_sax).initialized != 0xdeedbeaf as libc::c_uint {
        return 0 as xmlSchemaSAXPlugPtr;
    }
    if !old_sax.is_null() && ((*old_sax).startElementNs).is_none()
        && ((*old_sax).endElementNs).is_none()
        && (((*old_sax).startElement).is_some() || ((*old_sax).endElement).is_some())
    {
        return 0 as xmlSchemaSAXPlugPtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaSAXPlugStruct>() as libc::c_ulong)
        as xmlSchemaSAXPlugPtr;
    if ret.is_null() {
        return 0 as xmlSchemaSAXPlugPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<xmlSchemaSAXPlugStruct>() as libc::c_ulong,
    );
    (*ret).magic = 0xdc43ba21 as libc::c_uint;
    (*ret).schemas_sax.initialized = 0xdeedbeaf as libc::c_uint;
    let ref mut fresh675 = (*ret).ctxt;
    *fresh675 = ctxt;
    let ref mut fresh676 = (*ret).user_sax_ptr;
    *fresh676 = sax;
    let ref mut fresh677 = (*ret).user_sax;
    *fresh677 = old_sax;
    if old_sax.is_null() {
        let ref mut fresh678 = (*ret).schemas_sax.startElementNs;
        *fresh678 = Some(
            xmlSchemaSAXHandleStartElementNs
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    *const xmlChar,
                    *const xmlChar,
                    libc::c_int,
                    *mut *const xmlChar,
                    libc::c_int,
                    libc::c_int,
                    *mut *const xmlChar,
                ) -> (),
        );
        let ref mut fresh679 = (*ret).schemas_sax.endElementNs;
        *fresh679 = Some(
            xmlSchemaSAXHandleEndElementNs
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    *const xmlChar,
                    *const xmlChar,
                ) -> (),
        );
        let ref mut fresh680 = (*ret).schemas_sax.ignorableWhitespace;
        *fresh680 = Some(
            xmlSchemaSAXHandleText
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    libc::c_int,
                ) -> (),
        );
        let ref mut fresh681 = (*ret).schemas_sax.characters;
        *fresh681 = Some(
            xmlSchemaSAXHandleText
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    libc::c_int,
                ) -> (),
        );
        let ref mut fresh682 = (*ret).schemas_sax.cdataBlock;
        *fresh682 = Some(
            xmlSchemaSAXHandleCDataSection
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    libc::c_int,
                ) -> (),
        );
        let ref mut fresh683 = (*ret).schemas_sax.reference;
        *fresh683 = Some(
            xmlSchemaSAXHandleReference
                as unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
        );
        let ref mut fresh684 = (*ret).user_data;
        *fresh684 = ctxt as *mut libc::c_void;
        *user_data = ctxt as *mut libc::c_void;
    } else {
        if ((*old_sax).internalSubset).is_some() {
            let ref mut fresh685 = (*ret).schemas_sax.internalSubset;
            *fresh685 = Some(
                internalSubsetSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        *const xmlChar,
                        *const xmlChar,
                    ) -> (),
            );
        }
        if ((*old_sax).isStandalone).is_some() {
            let ref mut fresh686 = (*ret).schemas_sax.isStandalone;
            *fresh686 = Some(
                isStandaloneSplit
                    as unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
            );
        }
        if ((*old_sax).hasInternalSubset).is_some() {
            let ref mut fresh687 = (*ret).schemas_sax.hasInternalSubset;
            *fresh687 = Some(
                hasInternalSubsetSplit
                    as unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
            );
        }
        if ((*old_sax).hasExternalSubset).is_some() {
            let ref mut fresh688 = (*ret).schemas_sax.hasExternalSubset;
            *fresh688 = Some(
                hasExternalSubsetSplit
                    as unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
            );
        }
        if ((*old_sax).resolveEntity).is_some() {
            let ref mut fresh689 = (*ret).schemas_sax.resolveEntity;
            *fresh689 = Some(
                resolveEntitySplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        *const xmlChar,
                    ) -> xmlParserInputPtr,
            );
        }
        if ((*old_sax).getEntity).is_some() {
            let ref mut fresh690 = (*ret).schemas_sax.getEntity;
            *fresh690 = Some(
                getEntitySplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                    ) -> xmlEntityPtr,
            );
        }
        if ((*old_sax).entityDecl).is_some() {
            let ref mut fresh691 = (*ret).schemas_sax.entityDecl;
            *fresh691 = Some(
                entityDeclSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        libc::c_int,
                        *const xmlChar,
                        *const xmlChar,
                        *mut xmlChar,
                    ) -> (),
            );
        }
        if ((*old_sax).notationDecl).is_some() {
            let ref mut fresh692 = (*ret).schemas_sax.notationDecl;
            *fresh692 = Some(
                notationDeclSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        *const xmlChar,
                        *const xmlChar,
                    ) -> (),
            );
        }
        if ((*old_sax).attributeDecl).is_some() {
            let ref mut fresh693 = (*ret).schemas_sax.attributeDecl;
            *fresh693 = Some(
                attributeDeclSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        *const xmlChar,
                        libc::c_int,
                        libc::c_int,
                        *const xmlChar,
                        xmlEnumerationPtr,
                    ) -> (),
            );
        }
        if ((*old_sax).elementDecl).is_some() {
            let ref mut fresh694 = (*ret).schemas_sax.elementDecl;
            *fresh694 = Some(
                elementDeclSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        libc::c_int,
                        xmlElementContentPtr,
                    ) -> (),
            );
        }
        if ((*old_sax).unparsedEntityDecl).is_some() {
            let ref mut fresh695 = (*ret).schemas_sax.unparsedEntityDecl;
            *fresh695 = Some(
                unparsedEntityDeclSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        *const xmlChar,
                        *const xmlChar,
                        *const xmlChar,
                    ) -> (),
            );
        }
        if ((*old_sax).setDocumentLocator).is_some() {
            let ref mut fresh696 = (*ret).schemas_sax.setDocumentLocator;
            *fresh696 = Some(
                setDocumentLocatorSplit
                    as unsafe extern "C" fn(*mut libc::c_void, xmlSAXLocatorPtr) -> (),
            );
        }
        if ((*old_sax).startDocument).is_some() {
            let ref mut fresh697 = (*ret).schemas_sax.startDocument;
            *fresh697 = Some(
                startDocumentSplit as unsafe extern "C" fn(*mut libc::c_void) -> (),
            );
        }
        if ((*old_sax).endDocument).is_some() {
            let ref mut fresh698 = (*ret).schemas_sax.endDocument;
            *fresh698 = Some(
                endDocumentSplit as unsafe extern "C" fn(*mut libc::c_void) -> (),
            );
        }
        if ((*old_sax).processingInstruction).is_some() {
            let ref mut fresh699 = (*ret).schemas_sax.processingInstruction;
            *fresh699 = Some(
                processingInstructionSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        *const xmlChar,
                    ) -> (),
            );
        }
        if ((*old_sax).comment).is_some() {
            let ref mut fresh700 = (*ret).schemas_sax.comment;
            *fresh700 = Some(
                commentSplit
                    as unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
            );
        }
        if ((*old_sax).warning).is_some() {
            let ref mut fresh701 = (*ret).schemas_sax.warning;
            *fresh701 = Some(
                warningSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const libc::c_char,
                        ...
                    ) -> (),
            );
        }
        if ((*old_sax).error).is_some() {
            let ref mut fresh702 = (*ret).schemas_sax.error;
            *fresh702 = Some(
                errorSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const libc::c_char,
                        ...
                    ) -> (),
            );
        }
        if ((*old_sax).fatalError).is_some() {
            let ref mut fresh703 = (*ret).schemas_sax.fatalError;
            *fresh703 = Some(
                fatalErrorSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const libc::c_char,
                        ...
                    ) -> (),
            );
        }
        if ((*old_sax).getParameterEntity).is_some() {
            let ref mut fresh704 = (*ret).schemas_sax.getParameterEntity;
            *fresh704 = Some(
                getParameterEntitySplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                    ) -> xmlEntityPtr,
            );
        }
        if ((*old_sax).externalSubset).is_some() {
            let ref mut fresh705 = (*ret).schemas_sax.externalSubset;
            *fresh705 = Some(
                externalSubsetSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        *const xmlChar,
                        *const xmlChar,
                    ) -> (),
            );
        }
        let ref mut fresh706 = (*ret).schemas_sax.characters;
        *fresh706 = Some(
            charactersSplit
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    libc::c_int,
                ) -> (),
        );
        if ((*old_sax).ignorableWhitespace).is_some()
            && (*old_sax).ignorableWhitespace != (*old_sax).characters
        {
            let ref mut fresh707 = (*ret).schemas_sax.ignorableWhitespace;
            *fresh707 = Some(
                ignorableWhitespaceSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        libc::c_int,
                    ) -> (),
            );
        } else {
            let ref mut fresh708 = (*ret).schemas_sax.ignorableWhitespace;
            *fresh708 = Some(
                charactersSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        libc::c_int,
                    ) -> (),
            );
        }
        let ref mut fresh709 = (*ret).schemas_sax.cdataBlock;
        *fresh709 = Some(
            cdataBlockSplit
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    libc::c_int,
                ) -> (),
        );
        let ref mut fresh710 = (*ret).schemas_sax.reference;
        *fresh710 = Some(
            referenceSplit
                as unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
        );
        let ref mut fresh711 = (*ret).schemas_sax.startElementNs;
        *fresh711 = Some(
            startElementNsSplit
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    *const xmlChar,
                    *const xmlChar,
                    libc::c_int,
                    *mut *const xmlChar,
                    libc::c_int,
                    libc::c_int,
                    *mut *const xmlChar,
                ) -> (),
        );
        let ref mut fresh712 = (*ret).schemas_sax.endElementNs;
        *fresh712 = Some(
            endElementNsSplit
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    *const xmlChar,
                    *const xmlChar,
                ) -> (),
        );
        let ref mut fresh713 = (*ret).user_data_ptr;
        *fresh713 = user_data;
        let ref mut fresh714 = (*ret).user_data;
        *fresh714 = *user_data;
        *user_data = ret as *mut libc::c_void;
    }
    *sax = &mut (*ret).schemas_sax;
    let ref mut fresh715 = (*ctxt).sax;
    *fresh715 = *sax;
    (*ctxt).flags |= 1 as libc::c_int;
    xmlSchemaPreRun(ctxt);
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSAXUnplug(
    mut plug: xmlSchemaSAXPlugPtr,
) -> libc::c_int {
    let mut sax: *mut xmlSAXHandlerPtr = 0 as *mut xmlSAXHandlerPtr;
    let mut user_data: *mut *mut libc::c_void = 0 as *mut *mut libc::c_void;
    if plug.is_null() || (*plug).magic != 0xdc43ba21 as libc::c_uint {
        return -(1 as libc::c_int);
    }
    (*plug).magic = 0 as libc::c_int as libc::c_uint;
    xmlSchemaPostRun((*plug).ctxt);
    sax = (*plug).user_sax_ptr;
    *sax = (*plug).user_sax;
    if !((*plug).user_sax).is_null() {
        user_data = (*plug).user_data_ptr;
        *user_data = (*plug).user_data;
    }
    xmlFree.expect("non-null function pointer")(plug as *mut libc::c_void);
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateSetLocator(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut f: xmlSchemaValidityLocatorFunc,
    mut ctxt: *mut libc::c_void,
) {
    if vctxt.is_null() {
        return;
    }
    let ref mut fresh716 = (*vctxt).locFunc;
    *fresh716 = f;
    let ref mut fresh717 = (*vctxt).locCtxt;
    *fresh717 = ctxt;
}
unsafe extern "C" fn xmlSchemaValidateStreamLocator(
    mut ctx: *mut libc::c_void,
    mut file: *mut *const libc::c_char,
    mut line: *mut libc::c_ulong,
) -> libc::c_int {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    if ctx.is_null() || file.is_null() && line.is_null() {
        return -(1 as libc::c_int);
    }
    if !file.is_null() {
        *file = 0 as *const libc::c_char;
    }
    if !line.is_null() {
        *line = 0 as libc::c_int as libc::c_ulong;
    }
    ctxt = ctx as xmlParserCtxtPtr;
    if !((*ctxt).input).is_null() {
        if !file.is_null() {
            *file = (*(*ctxt).input).filename;
        }
        if !line.is_null() {
            *line = (*(*ctxt).input).line as libc::c_ulong;
        }
        return 0 as libc::c_int;
    }
    return -(1 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateStream(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut input: xmlParserInputBufferPtr,
    mut enc: xmlCharEncoding,
    mut sax: xmlSAXHandlerPtr,
    mut user_data: *mut libc::c_void,
) -> libc::c_int {
    let mut plug: xmlSchemaSAXPlugPtr = 0 as xmlSchemaSAXPlugPtr;
    let mut old_sax: xmlSAXHandlerPtr = 0 as xmlSAXHandlerPtr;
    let mut pctxt: xmlParserCtxtPtr = 0 as xmlParserCtxtPtr;
    let mut inputStream: xmlParserInputPtr = 0 as xmlParserInputPtr;
    let mut ret: libc::c_int = 0;
    if ctxt.is_null() || input.is_null() {
        return -(1 as libc::c_int);
    }
    pctxt = xmlNewParserCtxt();
    if pctxt.is_null() {
        return -(1 as libc::c_int);
    }
    old_sax = (*pctxt).sax;
    let ref mut fresh718 = (*pctxt).sax;
    *fresh718 = sax;
    let ref mut fresh719 = (*pctxt).userData;
    *fresh719 = user_data;
    (*pctxt).linenumbers = 1 as libc::c_int;
    xmlSchemaValidateSetLocator(
        ctxt,
        Some(
            xmlSchemaValidateStreamLocator
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *mut *const libc::c_char,
                    *mut libc::c_ulong,
                ) -> libc::c_int,
        ),
        pctxt as *mut libc::c_void,
    );
    inputStream = xmlNewIOInputStream(pctxt, input, enc);
    if inputStream.is_null() {
        ret = -(1 as libc::c_int);
    } else {
        inputPush(pctxt, inputStream);
        let ref mut fresh720 = (*ctxt).parserCtxt;
        *fresh720 = pctxt;
        let ref mut fresh721 = (*ctxt).input;
        *fresh721 = input;
        plug = xmlSchemaSAXPlug(ctxt, &mut (*pctxt).sax, &mut (*pctxt).userData);
        if plug.is_null() {
            ret = -(1 as libc::c_int);
        } else {
            let ref mut fresh722 = (*ctxt).input;
            *fresh722 = input;
            (*ctxt).enc = enc;
            let ref mut fresh723 = (*ctxt).sax;
            *fresh723 = (*pctxt).sax;
            (*ctxt).flags |= 1 as libc::c_int;
            ret = xmlSchemaVStart(ctxt);
            if ret == 0 as libc::c_int && (*(*ctxt).parserCtxt).wellFormed == 0 {
                ret = (*(*ctxt).parserCtxt).errNo;
                if ret == 0 as libc::c_int {
                    ret = 1 as libc::c_int;
                }
            }
        }
    }
    let ref mut fresh724 = (*ctxt).parserCtxt;
    *fresh724 = 0 as xmlParserCtxtPtr;
    let ref mut fresh725 = (*ctxt).sax;
    *fresh725 = 0 as xmlSAXHandlerPtr;
    let ref mut fresh726 = (*ctxt).input;
    *fresh726 = 0 as xmlParserInputBufferPtr;
    if !plug.is_null() {
        xmlSchemaSAXUnplug(plug);
    }
    if !pctxt.is_null() {
        let ref mut fresh727 = (*pctxt).sax;
        *fresh727 = old_sax;
        xmlFreeParserCtxt(pctxt);
    }
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateFile(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut filename: *const libc::c_char,
    mut options: libc::c_int,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    if ctxt.is_null() || filename.is_null() {
        return -(1 as libc::c_int);
    }
    input = xmlParserInputBufferCreateFilename(filename, XML_CHAR_ENCODING_NONE);
    if input.is_null() {
        return -(1 as libc::c_int);
    }
    ret = xmlSchemaValidateStream(
        ctxt,
        input,
        XML_CHAR_ENCODING_NONE,
        0 as xmlSAXHandlerPtr,
        0 as *mut libc::c_void,
    );
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidCtxtGetParserCtxt(
    mut ctxt: xmlSchemaValidCtxtPtr,
) -> xmlParserCtxtPtr {
    if ctxt.is_null() {
        return 0 as xmlParserCtxtPtr;
    }
    return (*ctxt).parserCtxt;
}

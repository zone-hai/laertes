use ::libc;
extern "C" {
<<<<<<< HEAD
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type PyMemberDef;
    pub type _xmlBuf;
    pub type _xmlDict;
    pub type _xmlHashTable;
    pub type _xmlStartTag;
    pub type _xmlAutomataState;
    pub type _xmlAutomata;
    pub type _xmlValidState;
    pub type _xmlRegexp;
    pub type _xmlSchemaParserCtxt;
    pub type _xmlSchemaValidCtxt;
    pub type _xmlCatalog;
    pub type _xmlXPathCompExpr;
    pub type _xmlRelaxNG;
    pub type _xmlRelaxNGParserCtxt;
    pub type _xmlRelaxNGValidCtxt;
    pub type _xmlTextReader;
    static mut stdout: *mut FILE;
    fn PyType_IsSubtype(_: *mut PyTypeObject, _: *mut PyTypeObject) -> i32;
    static mut _Py_NoneStruct: PyObject;
    static mut PyFile_Type: PyTypeObject;
    fn PyFile_AsFile(_: *mut PyObject) -> *mut FILE;
    fn _PyArg_ParseTuple_SizeT(
        _: *mut PyObject,
        _: *const i8,
        _: ...
    ) -> i32;
    fn xmlCheckVersion(version: i32);
    fn xmlStrdup(cur: *const xmlChar) -> *mut xmlChar;
    fn xmlStrndup(cur: *const xmlChar, len: i32) -> *mut xmlChar;
    fn xmlCharStrndup(cur: *const i8, len: i32) -> *mut xmlChar;
    fn xmlCharStrdup(cur: *const i8) -> *mut xmlChar;
    fn xmlStrsub(
        str: *const xmlChar,
        start: i32,
        len: i32,
    ) -> *mut xmlChar;
    fn xmlStrchr(str: *const xmlChar, val: xmlChar) -> *const xmlChar;
    fn xmlStrstr(str: *const xmlChar, val: *const xmlChar) -> *const xmlChar;
    fn xmlStrcasestr(str: *const xmlChar, val: *const xmlChar) -> *const xmlChar;
    fn xmlStrcmp(str1: *const xmlChar, str2: *const xmlChar) -> i32;
    fn xmlStrncmp(
        str1: *const xmlChar,
        str2: *const xmlChar,
        len: i32,
    ) -> i32;
    fn xmlStrcasecmp(str1: *const xmlChar, str2: *const xmlChar) -> i32;
    fn xmlStrncasecmp(
        str1: *const xmlChar,
        str2: *const xmlChar,
        len: i32,
    ) -> i32;
    fn xmlStrEqual(str1: *const xmlChar, str2: *const xmlChar) -> i32;
    fn xmlStrQEqual(
        pref: *const xmlChar,
        name: *const xmlChar,
        str: *const xmlChar,
    ) -> i32;
    fn xmlStrlen(str: *const xmlChar) -> i32;
    fn xmlStrcat(cur: *mut xmlChar, add: *const xmlChar) -> *mut xmlChar;
    fn xmlStrncat(
        cur: *mut xmlChar,
        add: *const xmlChar,
        len: i32,
    ) -> *mut xmlChar;
    fn xmlStrncatNew(
        str1: *const xmlChar,
        str2: *const xmlChar,
        len: i32,
    ) -> *mut xmlChar;
    fn xmlCheckUTF8(utf: *const u8) -> i32;
    fn xmlUTF8Strsize(utf: *const xmlChar, len: i32) -> i32;
    fn xmlUTF8Strndup(utf: *const xmlChar, len: i32) -> *mut xmlChar;
    fn xmlUTF8Strpos(utf: *const xmlChar, pos: i32) -> *const xmlChar;
    fn xmlUTF8Strloc(utf: *const xmlChar, utfchar: *const xmlChar) -> i32;
    fn xmlUTF8Strsub(
        utf: *const xmlChar,
        start: i32,
        len: i32,
    ) -> *mut xmlChar;
    fn xmlValidateDocument(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> i32;
    fn xmlInitializeDict() -> i32;
    fn xmlDictCleanup();
    fn xmlRegexpCompile(regexp: *const xmlChar) -> xmlRegexpPtr;
    fn xmlRegFreeRegexp(regexp: xmlRegexpPtr);
    fn xmlRegexpExec(comp: xmlRegexpPtr, value: *const xmlChar) -> i32;
    fn xmlRegexpPrint(output: *mut FILE, regexp: xmlRegexpPtr);
    fn xmlRegexpIsDeterminist(comp: xmlRegexpPtr) -> i32;
    fn xmlValidateNCName(value: *const xmlChar, space: i32) -> i32;
    fn xmlValidateQName(value: *const xmlChar, space: i32) -> i32;
    fn xmlValidateName(value: *const xmlChar, space: i32) -> i32;
    fn xmlValidateNMToken(value: *const xmlChar, space: i32) -> i32;
    fn xmlBuildQName(
        ncname: *const xmlChar,
        prefix: *const xmlChar,
        memory: *mut xmlChar,
        len: i32,
    ) -> *mut xmlChar;
    fn xmlCreateIntSubset(
        doc: xmlDocPtr,
        name: *const xmlChar,
        ExternalID: *const xmlChar,
        SystemID: *const xmlChar,
    ) -> xmlDtdPtr;
    fn xmlNewDtd(
        doc: xmlDocPtr,
        name: *const xmlChar,
        ExternalID: *const xmlChar,
        SystemID: *const xmlChar,
    ) -> xmlDtdPtr;
    fn xmlGetIntSubset(doc: *const xmlDoc) -> xmlDtdPtr;
    fn xmlFreeDtd(cur: xmlDtdPtr);
    fn xmlNewGlobalNs(
        doc: xmlDocPtr,
        href: *const xmlChar,
        prefix: *const xmlChar,
    ) -> xmlNsPtr;
    fn xmlNewNs(
        node: xmlNodePtr,
        href: *const xmlChar,
        prefix: *const xmlChar,
    ) -> xmlNsPtr;
    fn xmlFreeNs(cur: xmlNsPtr);
    fn xmlFreeNsList(cur: xmlNsPtr);
    fn xmlNewDoc(version: *const xmlChar) -> xmlDocPtr;
    fn xmlFreeDoc(cur: xmlDocPtr);
    fn xmlNewDocProp(
        doc: xmlDocPtr,
        name: *const xmlChar,
        value: *const xmlChar,
    ) -> xmlAttrPtr;
    fn xmlNewProp(
        node: xmlNodePtr,
        name: *const xmlChar,
        value: *const xmlChar,
    ) -> xmlAttrPtr;
    fn xmlNewNsProp(
        node: xmlNodePtr,
        ns: xmlNsPtr,
        name: *const xmlChar,
        value: *const xmlChar,
    ) -> xmlAttrPtr;
    fn xmlNewNsPropEatName(
        node: xmlNodePtr,
        ns: xmlNsPtr,
        name: *mut xmlChar,
        value: *const xmlChar,
    ) -> xmlAttrPtr;
    fn xmlFreePropList(cur: xmlAttrPtr);
    fn xmlFreeProp(cur: xmlAttrPtr);
    fn xmlCopyProp(target: xmlNodePtr, cur: xmlAttrPtr) -> xmlAttrPtr;
    fn xmlCopyPropList(target: xmlNodePtr, cur: xmlAttrPtr) -> xmlAttrPtr;
    fn xmlCopyDtd(dtd: xmlDtdPtr) -> xmlDtdPtr;
    fn xmlCopyDoc(doc: xmlDocPtr, recursive: i32) -> xmlDocPtr;
    fn xmlNewDocNode(
        doc: xmlDocPtr,
        ns: xmlNsPtr,
        name: *const xmlChar,
        content: *const xmlChar,
    ) -> xmlNodePtr;
    fn xmlNewDocNodeEatName(
        doc: xmlDocPtr,
        ns: xmlNsPtr,
        name: *mut xmlChar,
        content: *const xmlChar,
    ) -> xmlNodePtr;
    fn xmlNewNodeEatName(ns: xmlNsPtr, name: *mut xmlChar) -> xmlNodePtr;
    fn xmlNewChild(
        parent: xmlNodePtr,
        ns: xmlNsPtr,
        name: *const xmlChar,
        content: *const xmlChar,
    ) -> xmlNodePtr;
    fn xmlNewDocText(doc: *const xmlDoc, content: *const xmlChar) -> xmlNodePtr;
    fn xmlNewText(content: *const xmlChar) -> xmlNodePtr;
    fn xmlNewDocPI(
        doc: xmlDocPtr,
        name: *const xmlChar,
        content: *const xmlChar,
    ) -> xmlNodePtr;
    fn xmlNewPI(name: *const xmlChar, content: *const xmlChar) -> xmlNodePtr;
    fn xmlNewDocTextLen(
        doc: xmlDocPtr,
        content: *const xmlChar,
        len: i32,
    ) -> xmlNodePtr;
    fn xmlNewTextLen(content: *const xmlChar, len: i32) -> xmlNodePtr;
    fn xmlNewDocComment(doc: xmlDocPtr, content: *const xmlChar) -> xmlNodePtr;
    fn xmlNewComment(content: *const xmlChar) -> xmlNodePtr;
    fn xmlNewCDataBlock(
        doc: xmlDocPtr,
        content: *const xmlChar,
        len: i32,
    ) -> xmlNodePtr;
    fn xmlNewCharRef(doc: xmlDocPtr, name: *const xmlChar) -> xmlNodePtr;
    fn xmlNewReference(doc: *const xmlDoc, name: *const xmlChar) -> xmlNodePtr;
    fn xmlCopyNode(node: xmlNodePtr, recursive: i32) -> xmlNodePtr;
    fn xmlDocCopyNode(
        node: xmlNodePtr,
        doc: xmlDocPtr,
        recursive: i32,
    ) -> xmlNodePtr;
    fn xmlDocCopyNodeList(doc: xmlDocPtr, node: xmlNodePtr) -> xmlNodePtr;
    fn xmlCopyNodeList(node: xmlNodePtr) -> xmlNodePtr;
    fn xmlNewTextChild(
        parent: xmlNodePtr,
        ns: xmlNsPtr,
        name: *const xmlChar,
        content: *const xmlChar,
    ) -> xmlNodePtr;
    fn xmlNewDocRawNode(
        doc: xmlDocPtr,
        ns: xmlNsPtr,
        name: *const xmlChar,
        content: *const xmlChar,
    ) -> xmlNodePtr;
    fn xmlNewDocFragment(doc: xmlDocPtr) -> xmlNodePtr;
    fn xmlGetLineNo(node: *const xmlNode) -> i64;
    fn xmlGetNodePath(node: *const xmlNode) -> *mut xmlChar;
    fn xmlDocGetRootElement(doc: *const xmlDoc) -> xmlNodePtr;
    fn xmlGetLastChild(parent: *const xmlNode) -> xmlNodePtr;
    fn xmlNodeIsText(node: *const xmlNode) -> i32;
    fn xmlIsBlankNode(node: *const xmlNode) -> i32;
    fn xmlDocSetRootElement(doc: xmlDocPtr, root: xmlNodePtr) -> xmlNodePtr;
    fn xmlNodeSetName(cur: xmlNodePtr, name: *const xmlChar);
    fn xmlAddChild(parent: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
    fn xmlAddChildList(parent: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
    fn xmlReplaceNode(old: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
    fn xmlAddPrevSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
    fn xmlAddSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
    fn xmlAddNextSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
    fn xmlUnlinkNode(cur: xmlNodePtr);
    fn xmlTextMerge(first: xmlNodePtr, second: xmlNodePtr) -> xmlNodePtr;
    fn xmlTextConcat(
        node: xmlNodePtr,
        content: *const xmlChar,
        len: i32,
    ) -> i32;
    fn xmlFreeNodeList(cur: xmlNodePtr);
    fn xmlFreeNode(cur: xmlNodePtr);
    fn xmlSetTreeDoc(tree: xmlNodePtr, doc: xmlDocPtr);
    fn xmlSetListDoc(list: xmlNodePtr, doc: xmlDocPtr);
    fn xmlSearchNs(
        doc: xmlDocPtr,
        node: xmlNodePtr,
        nameSpace: *const xmlChar,
    ) -> xmlNsPtr;
    fn xmlSearchNsByHref(
        doc: xmlDocPtr,
        node: xmlNodePtr,
        href: *const xmlChar,
    ) -> xmlNsPtr;
    fn xmlSetNs(node: xmlNodePtr, ns: xmlNsPtr);
    fn xmlCopyNamespace(cur: xmlNsPtr) -> xmlNsPtr;
    fn xmlCopyNamespaceList(cur: xmlNsPtr) -> xmlNsPtr;
    fn xmlSetProp(
        node: xmlNodePtr,
        name: *const xmlChar,
        value: *const xmlChar,
    ) -> xmlAttrPtr;
    fn xmlSetNsProp(
        node: xmlNodePtr,
        ns: xmlNsPtr,
        name: *const xmlChar,
        value: *const xmlChar,
    ) -> xmlAttrPtr;
    fn xmlGetNoNsProp(node: *const xmlNode, name: *const xmlChar) -> *mut xmlChar;
    fn xmlGetProp(node: *const xmlNode, name: *const xmlChar) -> *mut xmlChar;
    fn xmlHasProp(node: *const xmlNode, name: *const xmlChar) -> xmlAttrPtr;
    fn xmlHasNsProp(
        node: *const xmlNode,
        name: *const xmlChar,
        nameSpace: *const xmlChar,
    ) -> xmlAttrPtr;
    fn xmlGetNsProp(
        node: *const xmlNode,
        name: *const xmlChar,
        nameSpace: *const xmlChar,
    ) -> *mut xmlChar;
    fn xmlStringGetNodeList(doc: *const xmlDoc, value: *const xmlChar) -> xmlNodePtr;
    fn xmlStringLenGetNodeList(
        doc: *const xmlDoc,
        value: *const xmlChar,
        len: i32,
    ) -> xmlNodePtr;
    fn xmlNodeListGetString(
        doc: xmlDocPtr,
        list: *const xmlNode,
        inLine: i32,
    ) -> *mut xmlChar;
    fn xmlNodeListGetRawString(
        doc: *const xmlDoc,
        list: *const xmlNode,
        inLine: i32,
    ) -> *mut xmlChar;
    fn xmlNodeSetContent(cur: xmlNodePtr, content: *const xmlChar);
    fn xmlNodeSetContentLen(cur: xmlNodePtr, content: *const xmlChar, len: i32);
    fn xmlNodeAddContent(cur: xmlNodePtr, content: *const xmlChar);
    fn xmlNodeAddContentLen(cur: xmlNodePtr, content: *const xmlChar, len: i32);
    fn xmlNodeGetContent(cur: *const xmlNode) -> *mut xmlChar;
    fn xmlNodeGetLang(cur: *const xmlNode) -> *mut xmlChar;
    fn xmlNodeGetSpacePreserve(cur: *const xmlNode) -> i32;
    fn xmlNodeSetLang(cur: xmlNodePtr, lang: *const xmlChar);
    fn xmlNodeSetSpacePreserve(cur: xmlNodePtr, val: i32);
    fn xmlNodeGetBase(doc: *const xmlDoc, cur: *const xmlNode) -> *mut xmlChar;
    fn xmlNodeSetBase(cur: xmlNodePtr, uri: *const xmlChar);
    fn xmlRemoveProp(cur: xmlAttrPtr) -> i32;
    fn xmlUnsetNsProp(
        node: xmlNodePtr,
        ns: xmlNsPtr,
        name: *const xmlChar,
    ) -> i32;
    fn xmlUnsetProp(node: xmlNodePtr, name: *const xmlChar) -> i32;
    fn xmlReconciliateNs(doc: xmlDocPtr, tree: xmlNodePtr) -> i32;
    fn xmlDocFormatDump(
        f: *mut FILE,
        cur: xmlDocPtr,
        format: i32,
    ) -> i32;
    fn xmlDocDump(f: *mut FILE, cur: xmlDocPtr) -> i32;
    fn xmlElemDump(f: *mut FILE, doc: xmlDocPtr, cur: xmlNodePtr);
    fn xmlSaveFile(filename: *const i8, cur: xmlDocPtr) -> i32;
    fn xmlSaveFormatFile(
        filename: *const i8,
        cur: xmlDocPtr,
        format: i32,
    ) -> i32;
    fn xmlNodeDumpOutput(
        buf: xmlOutputBufferPtr,
        doc: xmlDocPtr,
        cur: xmlNodePtr,
        level: i32,
        format: i32,
        encoding: *const i8,
    );
    fn xmlSaveFormatFileEnc(
        filename: *const i8,
        cur: xmlDocPtr,
        encoding: *const i8,
        format: i32,
    ) -> i32;
    fn xmlSaveFileEnc(
        filename: *const i8,
        cur: xmlDocPtr,
        encoding: *const i8,
    ) -> i32;
    fn xmlIsXHTML(systemID: *const xmlChar, publicID: *const xmlChar) -> i32;
    fn xmlGetDocCompressMode(doc: *const xmlDoc) -> i32;
    fn xmlSetDocCompressMode(doc: xmlDocPtr, mode: i32);
    fn xmlGetCompressMode() -> i32;
    fn xmlSetCompressMode(mode: i32);
    fn xmlNextElementSibling(node: xmlNodePtr) -> xmlNodePtr;
    fn xmlFirstElementChild(parent: xmlNodePtr) -> xmlNodePtr;
    fn xmlLastElementChild(parent: xmlNodePtr) -> xmlNodePtr;
    fn xmlPreviousElementSibling(node: xmlNodePtr) -> xmlNodePtr;
    fn xmlGetLastError() -> xmlErrorPtr;
    fn xmlResetLastError();
    fn xmlResetError(err: xmlErrorPtr);
    fn xmlCopyError(from: xmlErrorPtr, to: xmlErrorPtr) -> i32;
    fn xmlGetID(doc: xmlDocPtr, ID: *const xmlChar) -> xmlAttrPtr;
    fn xmlIsID(doc: xmlDocPtr, elem: xmlNodePtr, attr: xmlAttrPtr) -> i32;
    fn xmlRemoveID(doc: xmlDocPtr, attr: xmlAttrPtr) -> i32;
    fn xmlIsRef(doc: xmlDocPtr, elem: xmlNodePtr, attr: xmlAttrPtr) -> i32;
    fn xmlRemoveRef(doc: xmlDocPtr, attr: xmlAttrPtr) -> i32;
    fn xmlNewValidCtxt() -> xmlValidCtxtPtr;
    fn xmlValidateRoot(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> i32;
    fn xmlValidNormalizeAttributeValue(
        doc: xmlDocPtr,
        elem: xmlNodePtr,
        name: *const xmlChar,
        value: *const xmlChar,
    ) -> *mut xmlChar;
    fn xmlValidCtxtNormalizeAttributeValue(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlNodePtr,
        name: *const xmlChar,
        value: *const xmlChar,
    ) -> *mut xmlChar;
    fn xmlValidateDtd(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        dtd: xmlDtdPtr,
    ) -> i32;
    fn xmlValidateDtdFinal(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> i32;
    fn xmlUTF8Strlen(utf: *const xmlChar) -> i32;
    fn xmlUTF8Charcmp(utf1: *const xmlChar, utf2: *const xmlChar) -> i32;
    fn xmlUTF8Size(utf: *const xmlChar) -> i32;
    fn xmlInitializePredefinedEntities();
    fn xmlNewEntity(
        doc: xmlDocPtr,
        name: *const xmlChar,
        type_0: i32,
        ExternalID: *const xmlChar,
        SystemID: *const xmlChar,
        content: *const xmlChar,
    ) -> xmlEntityPtr;
    fn xmlAddDocEntity(
        doc: xmlDocPtr,
        name: *const xmlChar,
        type_0: i32,
        ExternalID: *const xmlChar,
        SystemID: *const xmlChar,
        content: *const xmlChar,
    ) -> xmlEntityPtr;
    fn xmlAddDtdEntity(
        doc: xmlDocPtr,
        name: *const xmlChar,
        type_0: i32,
        ExternalID: *const xmlChar,
        SystemID: *const xmlChar,
        content: *const xmlChar,
    ) -> xmlEntityPtr;
    fn xmlGetPredefinedEntity(name: *const xmlChar) -> xmlEntityPtr;
    fn xmlGetDocEntity(doc: *const xmlDoc, name: *const xmlChar) -> xmlEntityPtr;
    fn xmlGetDtdEntity(doc: xmlDocPtr, name: *const xmlChar) -> xmlEntityPtr;
    fn xmlGetParameterEntity(doc: xmlDocPtr, name: *const xmlChar) -> xmlEntityPtr;
    fn xmlEncodeEntities(doc: xmlDocPtr, input: *const xmlChar) -> *const xmlChar;
    fn xmlEncodeEntitiesReentrant(doc: xmlDocPtr, input: *const xmlChar) -> *mut xmlChar;
    fn xmlEncodeSpecialChars(doc: *const xmlDoc, input: *const xmlChar) -> *mut xmlChar;
=======
    
    pub type _IO_codecvt;
    pub type _IO_marker;
    
    
    
    pub type _xmlHashTable;
    pub type _xmlStartTag;
    
    
    
    pub type _xmlRegexp;
    
    
    
    
    
    pub type _xmlRelaxNGParserCtxt;
    
    
    static mut stdout: * mut crate::src::python::libxml::_IO_FILE;
    fn PyType_IsSubtype(_: * mut crate::src::python::libxml::_typeobject, _: * mut crate::src::python::libxml::_typeobject) -> i32;
    static mut _Py_NoneStruct: crate::src::python::libxml::_object;
    static mut PyFile_Type: crate::src::python::libxml::_typeobject;
    fn PyFile_AsFile(_: * mut crate::src::python::libxml::_object) -> * mut crate::src::python::libxml::_IO_FILE;
    fn _PyArg_ParseTuple_SizeT(
        _: * mut crate::src::python::libxml::_object,
        _: * const i8,
        _: ...
    ) -> i32;
    fn xmlCheckVersion(version: i32);
    fn xmlStrdup(cur: * const u8) -> * mut u8;
    fn xmlStrndup(cur: * const u8, len: i32) -> * mut u8;
    fn xmlCharStrndup(cur: * const i8, len: i32) -> * mut u8;
    fn xmlCharStrdup(cur: * const i8) -> * mut u8;
    fn xmlStrsub(
        str: * const u8,
        start: i32,
        len: i32,
    ) -> * mut u8;
    fn xmlStrchr(str: * const u8, val: u8) -> * const u8;
    fn xmlStrstr(str: * const u8, val: * const u8) -> * const u8;
    fn xmlStrcasestr(str: * const u8, val: * const u8) -> * const u8;
    fn xmlStrcmp(str1: * const u8, str2: * const u8) -> i32;
    fn xmlStrncmp(
        str1: * const u8,
        str2: * const u8,
        len: i32,
    ) -> i32;
    fn xmlStrcasecmp(str1: * const u8, str2: * const u8) -> i32;
    fn xmlStrncasecmp(
        str1: * const u8,
        str2: * const u8,
        len: i32,
    ) -> i32;
    fn xmlStrEqual(str1: * const u8, str2: * const u8) -> i32;
    fn xmlStrQEqual(
        pref: * const u8,
        name: * const u8,
        str: * const u8,
    ) -> i32;
    fn xmlStrlen(str: * const u8) -> i32;
    fn xmlStrcat(cur: * mut u8, add: * const u8) -> * mut u8;
    fn xmlStrncat(
        cur: * mut u8,
        add: * const u8,
        len: i32,
    ) -> * mut u8;
    fn xmlStrncatNew(
        str1: * const u8,
        str2: * const u8,
        len: i32,
    ) -> * mut u8;
    fn xmlCheckUTF8(utf: * const u8) -> i32;
    fn xmlUTF8Strsize(utf: * const u8, len: i32) -> i32;
    fn xmlUTF8Strndup(utf: * const u8, len: i32) -> * mut u8;
    fn xmlUTF8Strpos(utf: * const u8, pos: i32) -> * const u8;
    fn xmlUTF8Strloc(utf: * const u8, utfchar: * const u8) -> i32;
    fn xmlUTF8Strsub(
        utf: * const u8,
        start: i32,
        len: i32,
    ) -> * mut u8;
    fn xmlValidateDocument(ctxt: * mut crate::src::python::libxml::_xmlValidCtxt, doc: * mut crate::src::python::libxml::_xmlDoc) -> i32;
    fn xmlInitializeDict() -> i32;
    fn xmlDictCleanup();
    fn xmlRegexpCompile(regexp: * const u8) -> * mut crate::src::python::libxml2_py::_xmlRegexp;
    fn xmlRegFreeRegexp(regexp: * mut crate::src::python::libxml2_py::_xmlRegexp);
    fn xmlRegexpExec(comp: * mut crate::src::python::libxml2_py::_xmlRegexp, value: * const u8) -> i32;
    fn xmlRegexpPrint(output: * mut crate::src::python::libxml::_IO_FILE, regexp: * mut crate::src::python::libxml2_py::_xmlRegexp);
    fn xmlRegexpIsDeterminist(comp: * mut crate::src::python::libxml2_py::_xmlRegexp) -> i32;
    fn xmlValidateNCName(value: * const u8, space: i32) -> i32;
    fn xmlValidateQName(value: * const u8, space: i32) -> i32;
    fn xmlValidateName(value: * const u8, space: i32) -> i32;
    fn xmlValidateNMToken(value: * const u8, space: i32) -> i32;
    fn xmlBuildQName(
        ncname: * const u8,
        prefix: * const u8,
        memory: * mut u8,
        len: i32,
    ) -> * mut u8;
    fn xmlCreateIntSubset(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        name: * const u8,
        ExternalID: * const u8,
        SystemID: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlDtd;
    fn xmlNewDtd(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        name: * const u8,
        ExternalID: * const u8,
        SystemID: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlDtd;
    fn xmlGetIntSubset(doc: * const crate::src::python::libxml::_xmlDoc) -> * mut crate::src::python::libxml::_xmlDtd;
    fn xmlFreeDtd(cur: * mut crate::src::python::libxml::_xmlDtd);
    fn xmlNewGlobalNs(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        href: * const u8,
        prefix: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlNs;
    fn xmlNewNs(
        node: * mut crate::src::python::libxml::_xmlNode,
        href: * const u8,
        prefix: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlNs;
    fn xmlFreeNs(cur: * mut crate::src::python::libxml::_xmlNs);
    fn xmlFreeNsList(cur: * mut crate::src::python::libxml::_xmlNs);
    fn xmlNewDoc(version: * const u8) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlFreeDoc(cur: * mut crate::src::python::libxml::_xmlDoc);
    fn xmlNewDocProp(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        name: * const u8,
        value: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlAttr;
    fn xmlNewProp(
        node: * mut crate::src::python::libxml::_xmlNode,
        name: * const u8,
        value: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlAttr;
    fn xmlNewNsProp(
        node: * mut crate::src::python::libxml::_xmlNode,
        ns: * mut crate::src::python::libxml::_xmlNs,
        name: * const u8,
        value: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlAttr;
    fn xmlNewNsPropEatName(
        node: * mut crate::src::python::libxml::_xmlNode,
        ns: * mut crate::src::python::libxml::_xmlNs,
        name: * mut u8,
        value: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlAttr;
    fn xmlFreePropList(cur: * mut crate::src::python::libxml::_xmlAttr);
    fn xmlFreeProp(cur: * mut crate::src::python::libxml::_xmlAttr);
    fn xmlCopyProp(target: * mut crate::src::python::libxml::_xmlNode, cur: * mut crate::src::python::libxml::_xmlAttr) -> * mut crate::src::python::libxml::_xmlAttr;
    fn xmlCopyPropList(target: * mut crate::src::python::libxml::_xmlNode, cur: * mut crate::src::python::libxml::_xmlAttr) -> * mut crate::src::python::libxml::_xmlAttr;
    fn xmlCopyDtd(dtd: * mut crate::src::python::libxml::_xmlDtd) -> * mut crate::src::python::libxml::_xmlDtd;
    fn xmlCopyDoc(doc: * mut crate::src::python::libxml::_xmlDoc, recursive: i32) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlNewDocNode(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        ns: * mut crate::src::python::libxml::_xmlNs,
        name: * const u8,
        content: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNewDocNodeEatName(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        ns: * mut crate::src::python::libxml::_xmlNs,
        name: * mut u8,
        content: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNewNodeEatName(ns: * mut crate::src::python::libxml::_xmlNs, name: * mut u8) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNewChild(
        parent: * mut crate::src::python::libxml::_xmlNode,
        ns: * mut crate::src::python::libxml::_xmlNs,
        name: * const u8,
        content: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNewDocText(doc: * const crate::src::python::libxml::_xmlDoc, content: * const u8) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNewText(content: * const u8) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNewDocPI(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        name: * const u8,
        content: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNewPI(name: * const u8, content: * const u8) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNewDocTextLen(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        content: * const u8,
        len: i32,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNewTextLen(content: * const u8, len: i32) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNewDocComment(doc: * mut crate::src::python::libxml::_xmlDoc, content: * const u8) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNewComment(content: * const u8) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNewCDataBlock(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        content: * const u8,
        len: i32,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNewCharRef(doc: * mut crate::src::python::libxml::_xmlDoc, name: * const u8) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNewReference(doc: * const crate::src::python::libxml::_xmlDoc, name: * const u8) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlCopyNode(node: * mut crate::src::python::libxml::_xmlNode, recursive: i32) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlDocCopyNode(
        node: * mut crate::src::python::libxml::_xmlNode,
        doc: * mut crate::src::python::libxml::_xmlDoc,
        recursive: i32,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlDocCopyNodeList(doc: * mut crate::src::python::libxml::_xmlDoc, node: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlCopyNodeList(node: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNewTextChild(
        parent: * mut crate::src::python::libxml::_xmlNode,
        ns: * mut crate::src::python::libxml::_xmlNs,
        name: * const u8,
        content: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNewDocRawNode(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        ns: * mut crate::src::python::libxml::_xmlNs,
        name: * const u8,
        content: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNewDocFragment(doc: * mut crate::src::python::libxml::_xmlDoc) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlGetLineNo(node: * const crate::src::python::libxml::_xmlNode) -> i64;
    fn xmlGetNodePath(node: * const crate::src::python::libxml::_xmlNode) -> * mut u8;
    fn xmlDocGetRootElement(doc: * const crate::src::python::libxml::_xmlDoc) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlGetLastChild(parent: * const crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNodeIsText(node: * const crate::src::python::libxml::_xmlNode) -> i32;
    fn xmlIsBlankNode(node: * const crate::src::python::libxml::_xmlNode) -> i32;
    fn xmlDocSetRootElement(doc: * mut crate::src::python::libxml::_xmlDoc, root: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNodeSetName(cur: * mut crate::src::python::libxml::_xmlNode, name: * const u8);
    fn xmlAddChild(parent: * mut crate::src::python::libxml::_xmlNode, cur: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlAddChildList(parent: * mut crate::src::python::libxml::_xmlNode, cur: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlReplaceNode(old: * mut crate::src::python::libxml::_xmlNode, cur: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlAddPrevSibling(cur: * mut crate::src::python::libxml::_xmlNode, elem: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlAddSibling(cur: * mut crate::src::python::libxml::_xmlNode, elem: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlAddNextSibling(cur: * mut crate::src::python::libxml::_xmlNode, elem: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlUnlinkNode(cur: * mut crate::src::python::libxml::_xmlNode);
    fn xmlTextMerge(first: * mut crate::src::python::libxml::_xmlNode, second: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlTextConcat(
        node: * mut crate::src::python::libxml::_xmlNode,
        content: * const u8,
        len: i32,
    ) -> i32;
    fn xmlFreeNodeList(cur: * mut crate::src::python::libxml::_xmlNode);
    fn xmlFreeNode(cur: * mut crate::src::python::libxml::_xmlNode);
    fn xmlSetTreeDoc(tree: * mut crate::src::python::libxml::_xmlNode, doc: * mut crate::src::python::libxml::_xmlDoc);
    fn xmlSetListDoc(list: * mut crate::src::python::libxml::_xmlNode, doc: * mut crate::src::python::libxml::_xmlDoc);
    fn xmlSearchNs(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        node: * mut crate::src::python::libxml::_xmlNode,
        nameSpace: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlNs;
    fn xmlSearchNsByHref(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        node: * mut crate::src::python::libxml::_xmlNode,
        href: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlNs;
    fn xmlSetNs(node: * mut crate::src::python::libxml::_xmlNode, ns: * mut crate::src::python::libxml::_xmlNs);
    fn xmlCopyNamespace(cur: * mut crate::src::python::libxml::_xmlNs) -> * mut crate::src::python::libxml::_xmlNs;
    fn xmlCopyNamespaceList(cur: * mut crate::src::python::libxml::_xmlNs) -> * mut crate::src::python::libxml::_xmlNs;
    fn xmlSetProp(
        node: * mut crate::src::python::libxml::_xmlNode,
        name: * const u8,
        value: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlAttr;
    fn xmlSetNsProp(
        node: * mut crate::src::python::libxml::_xmlNode,
        ns: * mut crate::src::python::libxml::_xmlNs,
        name: * const u8,
        value: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlAttr;
    fn xmlGetNoNsProp(node: * const crate::src::python::libxml::_xmlNode, name: * const u8) -> * mut u8;
    fn xmlGetProp(node: * const crate::src::python::libxml::_xmlNode, name: * const u8) -> * mut u8;
    fn xmlHasProp(node: * const crate::src::python::libxml::_xmlNode, name: * const u8) -> * mut crate::src::python::libxml::_xmlAttr;
    fn xmlHasNsProp(
        node: * const crate::src::python::libxml::_xmlNode,
        name: * const u8,
        nameSpace: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlAttr;
    fn xmlGetNsProp(
        node: * const crate::src::python::libxml::_xmlNode,
        name: * const u8,
        nameSpace: * const u8,
    ) -> * mut u8;
    fn xmlStringGetNodeList(doc: * const crate::src::python::libxml::_xmlDoc, value: * const u8) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlStringLenGetNodeList(
        doc: * const crate::src::python::libxml::_xmlDoc,
        value: * const u8,
        len: i32,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlNodeListGetString(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        list: * const crate::src::python::libxml::_xmlNode,
        inLine: i32,
    ) -> * mut u8;
    fn xmlNodeListGetRawString(
        doc: * const crate::src::python::libxml::_xmlDoc,
        list: * const crate::src::python::libxml::_xmlNode,
        inLine: i32,
    ) -> * mut u8;
    fn xmlNodeSetContent(cur: * mut crate::src::python::libxml::_xmlNode, content: * const u8);
    fn xmlNodeSetContentLen(cur: * mut crate::src::python::libxml::_xmlNode, content: * const u8, len: i32);
    fn xmlNodeAddContent(cur: * mut crate::src::python::libxml::_xmlNode, content: * const u8);
    fn xmlNodeAddContentLen(cur: * mut crate::src::python::libxml::_xmlNode, content: * const u8, len: i32);
    fn xmlNodeGetContent(cur: * const crate::src::python::libxml::_xmlNode) -> * mut u8;
    fn xmlNodeGetLang(cur: * const crate::src::python::libxml::_xmlNode) -> * mut u8;
    fn xmlNodeGetSpacePreserve(cur: * const crate::src::python::libxml::_xmlNode) -> i32;
    fn xmlNodeSetLang(cur: * mut crate::src::python::libxml::_xmlNode, lang: * const u8);
    fn xmlNodeSetSpacePreserve(cur: * mut crate::src::python::libxml::_xmlNode, val: i32);
    fn xmlNodeGetBase(doc: * const crate::src::python::libxml::_xmlDoc, cur: * const crate::src::python::libxml::_xmlNode) -> * mut u8;
    fn xmlNodeSetBase(cur: * mut crate::src::python::libxml::_xmlNode, uri: * const u8);
    fn xmlRemoveProp(cur: * mut crate::src::python::libxml::_xmlAttr) -> i32;
    fn xmlUnsetNsProp(
        node: * mut crate::src::python::libxml::_xmlNode,
        ns: * mut crate::src::python::libxml::_xmlNs,
        name: * const u8,
    ) -> i32;
    fn xmlUnsetProp(node: * mut crate::src::python::libxml::_xmlNode, name: * const u8) -> i32;
    fn xmlReconciliateNs(doc: * mut crate::src::python::libxml::_xmlDoc, tree: * mut crate::src::python::libxml::_xmlNode) -> i32;
    fn xmlDocFormatDump(
        f: * mut crate::src::python::libxml::_IO_FILE,
        cur: * mut crate::src::python::libxml::_xmlDoc,
        format: i32,
    ) -> i32;
    fn xmlDocDump(f: * mut crate::src::python::libxml::_IO_FILE, cur: * mut crate::src::python::libxml::_xmlDoc) -> i32;
    fn xmlElemDump(f: * mut crate::src::python::libxml::_IO_FILE, doc: * mut crate::src::python::libxml::_xmlDoc, cur: * mut crate::src::python::libxml::_xmlNode);
    fn xmlSaveFile(filename: * const i8, cur: * mut crate::src::python::libxml::_xmlDoc) -> i32;
    fn xmlSaveFormatFile(
        filename: * const i8,
        cur: * mut crate::src::python::libxml::_xmlDoc,
        format: i32,
    ) -> i32;
    fn xmlNodeDumpOutput(
        buf: * mut crate::src::python::libxml::_xmlOutputBuffer,
        doc: * mut crate::src::python::libxml::_xmlDoc,
        cur: * mut crate::src::python::libxml::_xmlNode,
        level: i32,
        format: i32,
        encoding: * const i8,
    );
    fn xmlSaveFormatFileEnc(
        filename: * const i8,
        cur: * mut crate::src::python::libxml::_xmlDoc,
        encoding: * const i8,
        format: i32,
    ) -> i32;
    fn xmlSaveFileEnc(
        filename: * const i8,
        cur: * mut crate::src::python::libxml::_xmlDoc,
        encoding: * const i8,
    ) -> i32;
    fn xmlIsXHTML(systemID: * const u8, publicID: * const u8) -> i32;
    fn xmlGetDocCompressMode(doc: * const crate::src::python::libxml::_xmlDoc) -> i32;
    fn xmlSetDocCompressMode(doc: * mut crate::src::python::libxml::_xmlDoc, mode: i32);
    fn xmlGetCompressMode() -> i32;
    fn xmlSetCompressMode(mode: i32);
    fn xmlNextElementSibling(node: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlFirstElementChild(parent: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlLastElementChild(parent: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlPreviousElementSibling(node: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlGetLastError() -> * mut crate::src::python::libxml::_xmlError;
    fn xmlResetLastError();
    fn xmlResetError(err: * mut crate::src::python::libxml::_xmlError);
    fn xmlCopyError(from: * mut crate::src::python::libxml::_xmlError, to: * mut crate::src::python::libxml::_xmlError) -> i32;
    fn xmlGetID(doc: * mut crate::src::python::libxml::_xmlDoc, ID: * const u8) -> * mut crate::src::python::libxml::_xmlAttr;
    fn xmlIsID(doc: * mut crate::src::python::libxml::_xmlDoc, elem: * mut crate::src::python::libxml::_xmlNode, attr: * mut crate::src::python::libxml::_xmlAttr) -> i32;
    fn xmlRemoveID(doc: * mut crate::src::python::libxml::_xmlDoc, attr: * mut crate::src::python::libxml::_xmlAttr) -> i32;
    fn xmlIsRef(doc: * mut crate::src::python::libxml::_xmlDoc, elem: * mut crate::src::python::libxml::_xmlNode, attr: * mut crate::src::python::libxml::_xmlAttr) -> i32;
    fn xmlRemoveRef(doc: * mut crate::src::python::libxml::_xmlDoc, attr: * mut crate::src::python::libxml::_xmlAttr) -> i32;
    fn xmlNewValidCtxt() -> * mut crate::src::python::libxml::_xmlValidCtxt;
    fn xmlValidateRoot(ctxt: * mut crate::src::python::libxml::_xmlValidCtxt, doc: * mut crate::src::python::libxml::_xmlDoc) -> i32;
    fn xmlValidNormalizeAttributeValue(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        elem: * mut crate::src::python::libxml::_xmlNode,
        name: * const u8,
        value: * const u8,
    ) -> * mut u8;
    fn xmlValidCtxtNormalizeAttributeValue(
        ctxt: * mut crate::src::python::libxml::_xmlValidCtxt,
        doc: * mut crate::src::python::libxml::_xmlDoc,
        elem: * mut crate::src::python::libxml::_xmlNode,
        name: * const u8,
        value: * const u8,
    ) -> * mut u8;
    fn xmlValidateDtd(
        ctxt: * mut crate::src::python::libxml::_xmlValidCtxt,
        doc: * mut crate::src::python::libxml::_xmlDoc,
        dtd: * mut crate::src::python::libxml::_xmlDtd,
    ) -> i32;
    fn xmlValidateDtdFinal(ctxt: * mut crate::src::python::libxml::_xmlValidCtxt, doc: * mut crate::src::python::libxml::_xmlDoc) -> i32;
    fn xmlUTF8Strlen(utf: * const u8) -> i32;
    fn xmlUTF8Charcmp(utf1: * const u8, utf2: * const u8) -> i32;
    fn xmlUTF8Size(utf: * const u8) -> i32;
    fn xmlInitializePredefinedEntities();
    fn xmlNewEntity(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        name: * const u8,
        type_0: i32,
        ExternalID: * const u8,
        SystemID: * const u8,
        content: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlEntity;
    fn xmlAddDocEntity(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        name: * const u8,
        type_0: i32,
        ExternalID: * const u8,
        SystemID: * const u8,
        content: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlEntity;
    fn xmlAddDtdEntity(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        name: * const u8,
        type_0: i32,
        ExternalID: * const u8,
        SystemID: * const u8,
        content: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlEntity;
    fn xmlGetPredefinedEntity(name: * const u8) -> * mut crate::src::python::libxml::_xmlEntity;
    fn xmlGetDocEntity(doc: * const crate::src::python::libxml::_xmlDoc, name: * const u8) -> * mut crate::src::python::libxml::_xmlEntity;
    fn xmlGetDtdEntity(doc: * mut crate::src::python::libxml::_xmlDoc, name: * const u8) -> * mut crate::src::python::libxml::_xmlEntity;
    fn xmlGetParameterEntity(doc: * mut crate::src::python::libxml::_xmlDoc, name: * const u8) -> * mut crate::src::python::libxml::_xmlEntity;
    fn xmlEncodeEntities(doc: * mut crate::src::python::libxml::_xmlDoc, input: * const u8) -> * const u8;
    fn xmlEncodeEntitiesReentrant(doc: * mut crate::src::python::libxml::_xmlDoc, input: * const u8) -> * mut u8;
    fn xmlEncodeSpecialChars(doc: * const crate::src::python::libxml::_xmlDoc, input: * const u8) -> * mut u8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    fn xmlCleanupPredefinedEntities();
    fn xmlInitCharEncodingHandlers();
    fn xmlCleanupCharEncodingHandlers();
    fn xmlAddEncodingAlias(
<<<<<<< HEAD
        name: *const i8,
        alias: *const i8,
    ) -> i32;
    fn xmlDelEncodingAlias(alias: *const i8) -> i32;
    fn xmlGetEncodingAlias(alias: *const i8) -> *const i8;
=======
        name: * const i8,
        alias: * const i8,
    ) -> i32;
    fn xmlDelEncodingAlias(alias: * const i8) -> i32;
    fn xmlGetEncodingAlias(alias: * const i8) -> * const i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    fn xmlCleanupEncodingAliases();
    fn xmlCleanupInputCallbacks();
    fn xmlRegisterDefaultInputCallbacks();
    fn xmlParserInputBufferRead(
<<<<<<< HEAD
        in_0: xmlParserInputBufferPtr,
        len: i32,
    ) -> i32;
    fn xmlParserInputBufferGrow(
        in_0: xmlParserInputBufferPtr,
        len: i32,
    ) -> i32;
    fn xmlParserInputBufferPush(
        in_0: xmlParserInputBufferPtr,
        len: i32,
        buf: *const i8,
    ) -> i32;
    fn xmlFreeParserInputBuffer(in_0: xmlParserInputBufferPtr);
    fn xmlParserGetDirectory(filename: *const i8) -> *mut i8;
    fn xmlCleanupOutputCallbacks();
    fn xmlPopOutputCallbacks() -> i32;
    fn xmlRegisterDefaultOutputCallbacks();
    fn xmlOutputBufferGetContent(out: xmlOutputBufferPtr) -> *const xmlChar;
    fn xmlOutputBufferWrite(
        out: xmlOutputBufferPtr,
        len: i32,
        buf: *const i8,
    ) -> i32;
    fn xmlOutputBufferWriteString(
        out: xmlOutputBufferPtr,
        str: *const i8,
    ) -> i32;
    fn xmlRegisterHTTPPostCallbacks();
    fn xmlNormalizeWindowsPath(path: *const xmlChar) -> *mut xmlChar;
    fn xmlCheckFilename(path: *const i8) -> i32;
    fn xmlFileMatch(filename: *const i8) -> i32;
    fn xmlIOHTTPMatch(filename: *const i8) -> i32;
    fn xmlIOFTPMatch(filename: *const i8) -> i32;
    fn xmlInitParser();
    fn xmlParseDoc(cur: *const xmlChar) -> xmlDocPtr;
    fn xmlParseFile(filename: *const i8) -> xmlDocPtr;
    fn xmlParseMemory(buffer: *const i8, size: i32) -> xmlDocPtr;
    fn xmlSubstituteEntitiesDefault(val: i32) -> i32;
    fn xmlKeepBlanksDefault(val: i32) -> i32;
    fn xmlStopParser(ctxt: xmlParserCtxtPtr);
    fn xmlPedanticParserDefault(val: i32) -> i32;
    fn xmlLineNumbersDefault(val: i32) -> i32;
    fn xmlRecoverDoc(cur: *const xmlChar) -> xmlDocPtr;
    fn xmlRecoverMemory(buffer: *const i8, size: i32) -> xmlDocPtr;
    fn xmlRecoverFile(filename: *const i8) -> xmlDocPtr;
    fn xmlParseDocument(ctxt: xmlParserCtxtPtr) -> i32;
    fn xmlParseExtParsedEnt(ctxt: xmlParserCtxtPtr) -> i32;
    fn xmlParseEntity(filename: *const i8) -> xmlDocPtr;
    fn xmlParseDTD(ExternalID: *const xmlChar, SystemID: *const xmlChar) -> xmlDtdPtr;
    fn xmlNewParserCtxt() -> xmlParserCtxtPtr;
    fn xmlInitParserCtxt(ctxt: xmlParserCtxtPtr) -> i32;
    fn xmlClearParserCtxt(ctxt: xmlParserCtxtPtr);
    fn xmlSetupParserForBuffer(
        ctxt: xmlParserCtxtPtr,
        buffer: *const xmlChar,
        filename: *const i8,
    );
    fn xmlCreateDocParserCtxt(cur: *const xmlChar) -> xmlParserCtxtPtr;
    fn xmlParseChunk(
        ctxt: xmlParserCtxtPtr,
        chunk: *const i8,
        size: i32,
        terminate: i32,
    ) -> i32;
    fn xmlByteConsumed(ctxt: xmlParserCtxtPtr) -> i64;
    fn xmlCtxtReset(ctxt: xmlParserCtxtPtr);
    fn xmlCtxtResetPush(
        ctxt: xmlParserCtxtPtr,
        chunk: *const i8,
        size: i32,
        filename: *const i8,
        encoding: *const i8,
    ) -> i32;
    fn xmlCtxtUseOptions(ctxt: xmlParserCtxtPtr, options: i32) -> i32;
    fn xmlReadDoc(
        cur: *const xmlChar,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> xmlDocPtr;
    fn xmlReadFile(
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> xmlDocPtr;
    fn xmlReadMemory(
        buffer: *const i8,
        size: i32,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> xmlDocPtr;
    fn xmlReadFd(
        fd: i32,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> xmlDocPtr;
    fn xmlCtxtReadDoc(
        ctxt: xmlParserCtxtPtr,
        cur: *const xmlChar,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> xmlDocPtr;
    fn xmlCtxtReadFile(
        ctxt: xmlParserCtxtPtr,
        filename: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> xmlDocPtr;
    fn xmlCtxtReadMemory(
        ctxt: xmlParserCtxtPtr,
        buffer: *const i8,
        size: i32,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> xmlDocPtr;
    fn xmlCtxtReadFd(
        ctxt: xmlParserCtxtPtr,
        fd: i32,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> xmlDocPtr;
=======
        in_0: * mut crate::src::python::libxml::_xmlParserInputBuffer,
        len: i32,
    ) -> i32;
    fn xmlParserInputBufferGrow(
        in_0: * mut crate::src::python::libxml::_xmlParserInputBuffer,
        len: i32,
    ) -> i32;
    fn xmlParserInputBufferPush(
        in_0: * mut crate::src::python::libxml::_xmlParserInputBuffer,
        len: i32,
        buf: * const i8,
    ) -> i32;
    fn xmlFreeParserInputBuffer(in_0: * mut crate::src::python::libxml::_xmlParserInputBuffer);
    fn xmlParserGetDirectory(filename: * const i8) -> * mut i8;
    fn xmlCleanupOutputCallbacks();
    fn xmlPopOutputCallbacks() -> i32;
    fn xmlRegisterDefaultOutputCallbacks();
    fn xmlOutputBufferGetContent(out: * mut crate::src::python::libxml::_xmlOutputBuffer) -> * const u8;
    fn xmlOutputBufferWrite(
        out: * mut crate::src::python::libxml::_xmlOutputBuffer,
        len: i32,
        buf: * const i8,
    ) -> i32;
    fn xmlOutputBufferWriteString(
        out: * mut crate::src::python::libxml::_xmlOutputBuffer,
        str: * const i8,
    ) -> i32;
    fn xmlRegisterHTTPPostCallbacks();
    fn xmlNormalizeWindowsPath(path: * const u8) -> * mut u8;
    fn xmlCheckFilename(path: * const i8) -> i32;
    fn xmlFileMatch(filename: * const i8) -> i32;
    fn xmlIOHTTPMatch(filename: * const i8) -> i32;
    fn xmlIOFTPMatch(filename: * const i8) -> i32;
    fn xmlInitParser();
    fn xmlParseDoc(cur: * const u8) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlParseFile(filename: * const i8) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlParseMemory(buffer: * const i8, size: i32) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlSubstituteEntitiesDefault(val: i32) -> i32;
    fn xmlKeepBlanksDefault(val: i32) -> i32;
    fn xmlStopParser(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlPedanticParserDefault(val: i32) -> i32;
    fn xmlLineNumbersDefault(val: i32) -> i32;
    fn xmlRecoverDoc(cur: * const u8) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlRecoverMemory(buffer: * const i8, size: i32) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlRecoverFile(filename: * const i8) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlParseDocument(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> i32;
    fn xmlParseExtParsedEnt(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> i32;
    fn xmlParseEntity(filename: * const i8) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlParseDTD(ExternalID: * const u8, SystemID: * const u8) -> * mut crate::src::python::libxml::_xmlDtd;
    fn xmlNewParserCtxt() -> * mut crate::src::python::libxml::_xmlParserCtxt;
    fn xmlInitParserCtxt(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> i32;
    fn xmlClearParserCtxt(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlSetupParserForBuffer(
        ctxt: * mut crate::src::python::libxml::_xmlParserCtxt,
        buffer: * const u8,
        filename: * const i8,
    );
    fn xmlCreateDocParserCtxt(cur: * const u8) -> * mut crate::src::python::libxml::_xmlParserCtxt;
    fn xmlParseChunk(
        ctxt: * mut crate::src::python::libxml::_xmlParserCtxt,
        chunk: * const i8,
        size: i32,
        terminate: i32,
    ) -> i32;
    fn xmlByteConsumed(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> i64;
    fn xmlCtxtReset(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlCtxtResetPush(
        ctxt: * mut crate::src::python::libxml::_xmlParserCtxt,
        chunk: * const i8,
        size: i32,
        filename: * const i8,
        encoding: * const i8,
    ) -> i32;
    fn xmlCtxtUseOptions(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt, options: i32) -> i32;
    fn xmlReadDoc(
        cur: * const u8,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlReadFile(
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlReadMemory(
        buffer: * const i8,
        size: i32,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlReadFd(
        fd: i32,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlCtxtReadDoc(
        ctxt: * mut crate::src::python::libxml::_xmlParserCtxt,
        cur: * const u8,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlCtxtReadFile(
        ctxt: * mut crate::src::python::libxml::_xmlParserCtxt,
        filename: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlCtxtReadMemory(
        ctxt: * mut crate::src::python::libxml::_xmlParserCtxt,
        buffer: * const i8,
        size: i32,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlCtxtReadFd(
        ctxt: * mut crate::src::python::libxml::_xmlParserCtxt,
        fd: i32,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::libxml::_xmlDoc;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    fn xmlSAXDefaultVersion(version: i32) -> i32;
    fn htmlDefaultSAXHandlerInit();
    fn xmlDefaultSAXHandlerInit();
    fn xmlInitGlobals();
    fn xmlCleanupGlobals();
<<<<<<< HEAD
    static mut xmlFree: xmlFreeFunc;
=======
    static mut xmlFree: Option<unsafe extern "C"  fn(_: * mut core::ffi::c_void,) -> ()>;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    fn xmlThrDefDefaultBufferSize(v: i32) -> i32;
    fn xmlThrDefDoValidityCheckingDefaultValue(v: i32) -> i32;
    fn xmlThrDefGetWarningsDefaultValue(v: i32) -> i32;
    fn xmlThrDefIndentTreeOutput(v: i32) -> i32;
<<<<<<< HEAD
    fn xmlThrDefTreeIndentString(v: *const i8) -> *const i8;
=======
    fn xmlThrDefTreeIndentString(v: * const i8) -> * const i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    fn xmlThrDefKeepBlanksDefaultValue(v: i32) -> i32;
    fn xmlThrDefLineNumbersDefaultValue(v: i32) -> i32;
    fn xmlThrDefLoadExtDtdDefaultValue(v: i32) -> i32;
    fn xmlThrDefParserDebugEntities(v: i32) -> i32;
    fn xmlThrDefPedanticParserDefaultValue(v: i32) -> i32;
    fn xmlThrDefSaveNoEmptyTags(v: i32) -> i32;
    fn xmlThrDefSubstituteEntitiesDefaultValue(v: i32) -> i32;
<<<<<<< HEAD
    fn xmlGetDtdElementDesc(dtd: xmlDtdPtr, name: *const xmlChar) -> xmlElementPtr;
    fn xmlIsMixedElement(doc: xmlDocPtr, name: *const xmlChar) -> i32;
    fn xmlValidateNotationUse(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        notationName: *const xmlChar,
    ) -> i32;
    fn xmlValidateDocumentFinal(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> i32;
    fn xmlValidateOneNamespace(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlNodePtr,
        prefix: *const xmlChar,
        ns: xmlNsPtr,
        value: *const xmlChar,
    ) -> i32;
    fn xmlValidateOneAttribute(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlNodePtr,
        attr: xmlAttrPtr,
        value: *const xmlChar,
    ) -> i32;
    fn xmlValidateOneElement(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlNodePtr,
    ) -> i32;
    fn xmlValidateElement(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlNodePtr,
    ) -> i32;
    fn xmlGetDtdAttrDesc(
        dtd: xmlDtdPtr,
        elem: *const xmlChar,
        name: *const xmlChar,
    ) -> xmlAttributePtr;
    fn xmlGetDtdQAttrDesc(
        dtd: xmlDtdPtr,
        elem: *const xmlChar,
        name: *const xmlChar,
        prefix: *const xmlChar,
    ) -> xmlAttributePtr;
    fn xmlGetDtdQElementDesc(
        dtd: xmlDtdPtr,
        name: *const xmlChar,
        prefix: *const xmlChar,
    ) -> xmlElementPtr;
    fn xmlValidateNameValue(value: *const xmlChar) -> i32;
    fn xmlValidateNamesValue(value: *const xmlChar) -> i32;
    fn xmlValidateNmtokenValue(value: *const xmlChar) -> i32;
    fn xmlValidateNmtokensValue(value: *const xmlChar) -> i32;
    fn xmlValidatePushElement(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlNodePtr,
        qname: *const xmlChar,
    ) -> i32;
    fn xmlValidatePushCData(
        ctxt: xmlValidCtxtPtr,
        data: *const xmlChar,
        len: i32,
    ) -> i32;
    fn xmlValidatePopElement(
        ctxt: xmlValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlNodePtr,
        qname: *const xmlChar,
    ) -> i32;
    fn xmlSchemaValidCtxtGetParserCtxt(ctxt: xmlSchemaValidCtxtPtr) -> xmlParserCtxtPtr;
    fn xmlSchemaNewParserCtxt(URL: *const i8) -> xmlSchemaParserCtxtPtr;
    fn xmlSchemaNewMemParserCtxt(
        buffer: *const i8,
        size: i32,
    ) -> xmlSchemaParserCtxtPtr;
    fn xmlSchemaNewDocParserCtxt(doc: xmlDocPtr) -> xmlSchemaParserCtxtPtr;
    fn xmlSchemaFreeParserCtxt(ctxt: xmlSchemaParserCtxtPtr);
    fn xmlSchemaIsValid(ctxt: xmlSchemaValidCtxtPtr) -> i32;
    fn xmlSchemaParse(ctxt: xmlSchemaParserCtxtPtr) -> xmlSchemaPtr;
    fn xmlSchemaFree(schema: xmlSchemaPtr);
    fn xmlSchemaDump(output: *mut FILE, schema: xmlSchemaPtr);
    fn xmlSchemaSetValidOptions(
        ctxt: xmlSchemaValidCtxtPtr,
        options: i32,
    ) -> i32;
    fn xmlSchemaValidateSetFilename(
        vctxt: xmlSchemaValidCtxtPtr,
        filename: *const i8,
    );
    fn xmlSchemaValidCtxtGetOptions(ctxt: xmlSchemaValidCtxtPtr) -> i32;
    fn xmlSchemaNewValidCtxt(schema: xmlSchemaPtr) -> xmlSchemaValidCtxtPtr;
    fn xmlSchemaValidateDoc(
        ctxt: xmlSchemaValidCtxtPtr,
        instance: xmlDocPtr,
    ) -> i32;
    fn xmlSchemaValidateOneElement(
        ctxt: xmlSchemaValidCtxtPtr,
        elem: xmlNodePtr,
    ) -> i32;
    fn xmlSchemaValidateFile(
        ctxt: xmlSchemaValidCtxtPtr,
        filename: *const i8,
=======
    fn xmlGetDtdElementDesc(dtd: * mut crate::src::python::libxml::_xmlDtd, name: * const u8) -> * mut crate::src::python::libxml2_py::_xmlElement;
    fn xmlIsMixedElement(doc: * mut crate::src::python::libxml::_xmlDoc, name: * const u8) -> i32;
    fn xmlValidateNotationUse(
        ctxt: * mut crate::src::python::libxml::_xmlValidCtxt,
        doc: * mut crate::src::python::libxml::_xmlDoc,
        notationName: * const u8,
    ) -> i32;
    fn xmlValidateDocumentFinal(ctxt: * mut crate::src::python::libxml::_xmlValidCtxt, doc: * mut crate::src::python::libxml::_xmlDoc) -> i32;
    fn xmlValidateOneNamespace(
        ctxt: * mut crate::src::python::libxml::_xmlValidCtxt,
        doc: * mut crate::src::python::libxml::_xmlDoc,
        elem: * mut crate::src::python::libxml::_xmlNode,
        prefix: * const u8,
        ns: * mut crate::src::python::libxml::_xmlNs,
        value: * const u8,
    ) -> i32;
    fn xmlValidateOneAttribute(
        ctxt: * mut crate::src::python::libxml::_xmlValidCtxt,
        doc: * mut crate::src::python::libxml::_xmlDoc,
        elem: * mut crate::src::python::libxml::_xmlNode,
        attr: * mut crate::src::python::libxml::_xmlAttr,
        value: * const u8,
    ) -> i32;
    fn xmlValidateOneElement(
        ctxt: * mut crate::src::python::libxml::_xmlValidCtxt,
        doc: * mut crate::src::python::libxml::_xmlDoc,
        elem: * mut crate::src::python::libxml::_xmlNode,
    ) -> i32;
    fn xmlValidateElement(
        ctxt: * mut crate::src::python::libxml::_xmlValidCtxt,
        doc: * mut crate::src::python::libxml::_xmlDoc,
        elem: * mut crate::src::python::libxml::_xmlNode,
    ) -> i32;
    fn xmlGetDtdAttrDesc(
        dtd: * mut crate::src::python::libxml::_xmlDtd,
        elem: * const u8,
        name: * const u8,
    ) -> * mut crate::src::python::libxml2_py::_xmlAttribute;
    fn xmlGetDtdQAttrDesc(
        dtd: * mut crate::src::python::libxml::_xmlDtd,
        elem: * const u8,
        name: * const u8,
        prefix: * const u8,
    ) -> * mut crate::src::python::libxml2_py::_xmlAttribute;
    fn xmlGetDtdQElementDesc(
        dtd: * mut crate::src::python::libxml::_xmlDtd,
        name: * const u8,
        prefix: * const u8,
    ) -> * mut crate::src::python::libxml2_py::_xmlElement;
    fn xmlValidateNameValue(value: * const u8) -> i32;
    fn xmlValidateNamesValue(value: * const u8) -> i32;
    fn xmlValidateNmtokenValue(value: * const u8) -> i32;
    fn xmlValidateNmtokensValue(value: * const u8) -> i32;
    fn xmlValidatePushElement(
        ctxt: * mut crate::src::python::libxml::_xmlValidCtxt,
        doc: * mut crate::src::python::libxml::_xmlDoc,
        elem: * mut crate::src::python::libxml::_xmlNode,
        qname: * const u8,
    ) -> i32;
    fn xmlValidatePushCData(
        ctxt: * mut crate::src::python::libxml::_xmlValidCtxt,
        data: * const u8,
        len: i32,
    ) -> i32;
    fn xmlValidatePopElement(
        ctxt: * mut crate::src::python::libxml::_xmlValidCtxt,
        doc: * mut crate::src::python::libxml::_xmlDoc,
        elem: * mut crate::src::python::libxml::_xmlNode,
        qname: * const u8,
    ) -> i32;
    fn xmlSchemaValidCtxtGetParserCtxt(ctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt) -> * mut crate::src::python::libxml::_xmlParserCtxt;
    fn xmlSchemaNewParserCtxt(URL: * const i8) -> * mut crate::src::python::types::_xmlSchemaParserCtxt;
    fn xmlSchemaNewMemParserCtxt(
        buffer: * const i8,
        size: i32,
    ) -> * mut crate::src::python::types::_xmlSchemaParserCtxt;
    fn xmlSchemaNewDocParserCtxt(doc: * mut crate::src::python::libxml::_xmlDoc) -> * mut crate::src::python::types::_xmlSchemaParserCtxt;
    fn xmlSchemaFreeParserCtxt(ctxt: * mut crate::src::python::types::_xmlSchemaParserCtxt);
    fn xmlSchemaIsValid(ctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt) -> i32;
    fn xmlSchemaParse(ctxt: * mut crate::src::python::types::_xmlSchemaParserCtxt) -> * mut crate::src::python::libxml2_py::_xmlSchema;
    fn xmlSchemaFree(schema: * mut crate::src::python::libxml2_py::_xmlSchema);
    fn xmlSchemaDump(output: * mut crate::src::python::libxml::_IO_FILE, schema: * mut crate::src::python::libxml2_py::_xmlSchema);
    fn xmlSchemaSetValidOptions(
        ctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt,
        options: i32,
    ) -> i32;
    fn xmlSchemaValidateSetFilename(
        vctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt,
        filename: * const i8,
    );
    fn xmlSchemaValidCtxtGetOptions(ctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt) -> i32;
    fn xmlSchemaNewValidCtxt(schema: * mut crate::src::python::libxml2_py::_xmlSchema) -> * mut crate::src::python::types::_xmlSchemaValidCtxt;
    fn xmlSchemaValidateDoc(
        ctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt,
        instance: * mut crate::src::python::libxml::_xmlDoc,
    ) -> i32;
    fn xmlSchemaValidateOneElement(
        ctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt,
        elem: * mut crate::src::python::libxml::_xmlNode,
    ) -> i32;
    fn xmlSchemaValidateFile(
        ctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt,
        filename: * const i8,
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
        options: i32,
    ) -> i32;
    fn xmlSchemaInitTypes();
    fn xmlSchemaCleanupTypes();
<<<<<<< HEAD
    fn xmlSchemaCollapseString(value: *const xmlChar) -> *mut xmlChar;
    fn xmlSchemaWhiteSpaceReplace(value: *const xmlChar) -> *mut xmlChar;
    fn xmlNewTextReader(
        input: xmlParserInputBufferPtr,
        URI: *const i8,
    ) -> xmlTextReaderPtr;
    fn xmlNewTextReaderFilename(URI: *const i8) -> xmlTextReaderPtr;
    fn xmlTextReaderSetup(
        reader: xmlTextReaderPtr,
        input: xmlParserInputBufferPtr,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> i32;
    fn xmlTextReaderRead(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderReadInnerXml(reader: xmlTextReaderPtr) -> *mut xmlChar;
    fn xmlTextReaderReadOuterXml(reader: xmlTextReaderPtr) -> *mut xmlChar;
    fn xmlTextReaderReadString(reader: xmlTextReaderPtr) -> *mut xmlChar;
    fn xmlTextReaderReadAttributeValue(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderAttributeCount(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderDepth(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderHasAttributes(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderHasValue(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderIsDefault(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderIsEmptyElement(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderNodeType(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderQuoteChar(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderReadState(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderIsNamespaceDecl(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderConstBaseUri(reader: xmlTextReaderPtr) -> *const xmlChar;
    fn xmlTextReaderConstLocalName(reader: xmlTextReaderPtr) -> *const xmlChar;
    fn xmlTextReaderConstName(reader: xmlTextReaderPtr) -> *const xmlChar;
    fn xmlTextReaderConstNamespaceUri(reader: xmlTextReaderPtr) -> *const xmlChar;
    fn xmlTextReaderConstPrefix(reader: xmlTextReaderPtr) -> *const xmlChar;
    fn xmlTextReaderConstXmlLang(reader: xmlTextReaderPtr) -> *const xmlChar;
    fn xmlTextReaderConstString(
        reader: xmlTextReaderPtr,
        str: *const xmlChar,
    ) -> *const xmlChar;
    fn xmlTextReaderConstValue(reader: xmlTextReaderPtr) -> *const xmlChar;
    fn xmlTextReaderClose(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderGetAttributeNo(
        reader: xmlTextReaderPtr,
        no: i32,
    ) -> *mut xmlChar;
    fn xmlTextReaderGetAttribute(
        reader: xmlTextReaderPtr,
        name: *const xmlChar,
    ) -> *mut xmlChar;
    fn xmlTextReaderGetAttributeNs(
        reader: xmlTextReaderPtr,
        localName: *const xmlChar,
        namespaceURI: *const xmlChar,
    ) -> *mut xmlChar;
    fn xmlTextReaderGetRemainder(reader: xmlTextReaderPtr) -> xmlParserInputBufferPtr;
    fn xmlTextReaderLookupNamespace(
        reader: xmlTextReaderPtr,
        prefix: *const xmlChar,
    ) -> *mut xmlChar;
    fn xmlTextReaderMoveToAttributeNo(
        reader: xmlTextReaderPtr,
        no: i32,
    ) -> i32;
    fn xmlTextReaderMoveToAttribute(
        reader: xmlTextReaderPtr,
        name: *const xmlChar,
    ) -> i32;
    fn xmlTextReaderMoveToAttributeNs(
        reader: xmlTextReaderPtr,
        localName: *const xmlChar,
        namespaceURI: *const xmlChar,
    ) -> i32;
    fn xmlTextReaderMoveToFirstAttribute(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderMoveToNextAttribute(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderMoveToElement(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderNormalization(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderConstEncoding(reader: xmlTextReaderPtr) -> *const xmlChar;
    fn xmlTextReaderSetParserProp(
        reader: xmlTextReaderPtr,
=======
    fn xmlSchemaCollapseString(value: * const u8) -> * mut u8;
    fn xmlSchemaWhiteSpaceReplace(value: * const u8) -> * mut u8;
    fn xmlNewTextReader(
        input: * mut crate::src::python::libxml::_xmlParserInputBuffer,
        URI: * const i8,
    ) -> * mut crate::src::python::types::_xmlTextReader;
    fn xmlNewTextReaderFilename(URI: * const i8) -> * mut crate::src::python::types::_xmlTextReader;
    fn xmlTextReaderSetup(
        reader: * mut crate::src::python::types::_xmlTextReader,
        input: * mut crate::src::python::libxml::_xmlParserInputBuffer,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> i32;
    fn xmlTextReaderRead(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderReadInnerXml(reader: * mut crate::src::python::types::_xmlTextReader) -> * mut u8;
    fn xmlTextReaderReadOuterXml(reader: * mut crate::src::python::types::_xmlTextReader) -> * mut u8;
    fn xmlTextReaderReadString(reader: * mut crate::src::python::types::_xmlTextReader) -> * mut u8;
    fn xmlTextReaderReadAttributeValue(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderAttributeCount(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderDepth(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderHasAttributes(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderHasValue(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderIsDefault(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderIsEmptyElement(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderNodeType(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderQuoteChar(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderReadState(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderIsNamespaceDecl(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderConstBaseUri(reader: * mut crate::src::python::types::_xmlTextReader) -> * const u8;
    fn xmlTextReaderConstLocalName(reader: * mut crate::src::python::types::_xmlTextReader) -> * const u8;
    fn xmlTextReaderConstName(reader: * mut crate::src::python::types::_xmlTextReader) -> * const u8;
    fn xmlTextReaderConstNamespaceUri(reader: * mut crate::src::python::types::_xmlTextReader) -> * const u8;
    fn xmlTextReaderConstPrefix(reader: * mut crate::src::python::types::_xmlTextReader) -> * const u8;
    fn xmlTextReaderConstXmlLang(reader: * mut crate::src::python::types::_xmlTextReader) -> * const u8;
    fn xmlTextReaderConstString(
        reader: * mut crate::src::python::types::_xmlTextReader,
        str: * const u8,
    ) -> * const u8;
    fn xmlTextReaderConstValue(reader: * mut crate::src::python::types::_xmlTextReader) -> * const u8;
    fn xmlTextReaderClose(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderGetAttributeNo(
        reader: * mut crate::src::python::types::_xmlTextReader,
        no: i32,
    ) -> * mut u8;
    fn xmlTextReaderGetAttribute(
        reader: * mut crate::src::python::types::_xmlTextReader,
        name: * const u8,
    ) -> * mut u8;
    fn xmlTextReaderGetAttributeNs(
        reader: * mut crate::src::python::types::_xmlTextReader,
        localName: * const u8,
        namespaceURI: * const u8,
    ) -> * mut u8;
    fn xmlTextReaderGetRemainder(reader: * mut crate::src::python::types::_xmlTextReader) -> * mut crate::src::python::libxml::_xmlParserInputBuffer;
    fn xmlTextReaderLookupNamespace(
        reader: * mut crate::src::python::types::_xmlTextReader,
        prefix: * const u8,
    ) -> * mut u8;
    fn xmlTextReaderMoveToAttributeNo(
        reader: * mut crate::src::python::types::_xmlTextReader,
        no: i32,
    ) -> i32;
    fn xmlTextReaderMoveToAttribute(
        reader: * mut crate::src::python::types::_xmlTextReader,
        name: * const u8,
    ) -> i32;
    fn xmlTextReaderMoveToAttributeNs(
        reader: * mut crate::src::python::types::_xmlTextReader,
        localName: * const u8,
        namespaceURI: * const u8,
    ) -> i32;
    fn xmlTextReaderMoveToFirstAttribute(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderMoveToNextAttribute(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderMoveToElement(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderNormalization(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderConstEncoding(reader: * mut crate::src::python::types::_xmlTextReader) -> * const u8;
    fn xmlTextReaderSetParserProp(
        reader: * mut crate::src::python::types::_xmlTextReader,
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
        prop: i32,
        value: i32,
    ) -> i32;
    fn xmlTextReaderGetParserProp(
<<<<<<< HEAD
        reader: xmlTextReaderPtr,
        prop: i32,
    ) -> i32;
    fn xmlTextReaderCurrentNode(reader: xmlTextReaderPtr) -> xmlNodePtr;
    fn xmlTextReaderGetParserLineNumber(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderGetParserColumnNumber(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderPreserve(reader: xmlTextReaderPtr) -> xmlNodePtr;
    fn xmlTextReaderCurrentDoc(reader: xmlTextReaderPtr) -> xmlDocPtr;
    fn xmlTextReaderExpand(reader: xmlTextReaderPtr) -> xmlNodePtr;
    fn xmlTextReaderNext(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderNextSibling(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderIsValid(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderRelaxNGValidate(
        reader: xmlTextReaderPtr,
        rng: *const i8,
    ) -> i32;
    fn xmlTextReaderRelaxNGValidateCtxt(
        reader: xmlTextReaderPtr,
        ctxt: xmlRelaxNGValidCtxtPtr,
        options: i32,
    ) -> i32;
    fn xmlTextReaderRelaxNGSetSchema(
        reader: xmlTextReaderPtr,
        schema: xmlRelaxNGPtr,
    ) -> i32;
    fn xmlTextReaderSchemaValidate(
        reader: xmlTextReaderPtr,
        xsd: *const i8,
    ) -> i32;
    fn xmlTextReaderSchemaValidateCtxt(
        reader: xmlTextReaderPtr,
        ctxt: xmlSchemaValidCtxtPtr,
        options: i32,
    ) -> i32;
    fn xmlTextReaderSetSchema(
        reader: xmlTextReaderPtr,
        schema: xmlSchemaPtr,
    ) -> i32;
    fn xmlTextReaderConstXmlVersion(reader: xmlTextReaderPtr) -> *const xmlChar;
    fn xmlTextReaderStandalone(reader: xmlTextReaderPtr) -> i32;
    fn xmlTextReaderByteConsumed(reader: xmlTextReaderPtr) -> i64;
    fn xmlUCSIsLinearBSyllabary(code: i32) -> i32;
    fn xmlIsLetter(c: i32) -> i32;
    fn xmlCreateFileParserCtxt(filename: *const i8) -> xmlParserCtxtPtr;
    fn xmlCreateURLParserCtxt(
        filename: *const i8,
        options: i32,
    ) -> xmlParserCtxtPtr;
    fn xmlCreateMemoryParserCtxt(
        buffer: *const i8,
        size: i32,
    ) -> xmlParserCtxtPtr;
    fn xmlCreateEntityParserCtxt(
        URL: *const xmlChar,
        ID: *const xmlChar,
        base: *const xmlChar,
    ) -> xmlParserCtxtPtr;
    fn xmlPopInput(ctxt: xmlParserCtxtPtr) -> xmlChar;
    fn xmlParseName(ctxt: xmlParserCtxtPtr) -> *const xmlChar;
    fn xmlParseNmtoken(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    fn xmlParseAttValue(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    fn xmlParseSystemLiteral(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    fn xmlParsePubidLiteral(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    fn xmlParseCharData(ctxt: xmlParserCtxtPtr, cdata: i32);
    fn xmlParseComment(ctxt: xmlParserCtxtPtr);
    fn xmlParsePITarget(ctxt: xmlParserCtxtPtr) -> *const xmlChar;
    fn xmlParsePI(ctxt: xmlParserCtxtPtr);
    fn xmlParseNotationDecl(ctxt: xmlParserCtxtPtr);
    fn xmlParseEntityDecl(ctxt: xmlParserCtxtPtr);
    fn xmlParseAttributeListDecl(ctxt: xmlParserCtxtPtr);
    fn xmlParseElementDecl(ctxt: xmlParserCtxtPtr) -> i32;
    fn xmlParseMarkupDecl(ctxt: xmlParserCtxtPtr);
    fn xmlParseCharRef(ctxt: xmlParserCtxtPtr) -> i32;
    fn xmlParseEntityRef(ctxt: xmlParserCtxtPtr) -> xmlEntityPtr;
    fn xmlParseReference(ctxt: xmlParserCtxtPtr);
    fn xmlParsePEReference(ctxt: xmlParserCtxtPtr);
    fn xmlParseDocTypeDecl(ctxt: xmlParserCtxtPtr);
    fn xmlParseStartTag(ctxt: xmlParserCtxtPtr) -> *const xmlChar;
    fn xmlParseEndTag(ctxt: xmlParserCtxtPtr);
    fn xmlParseCDSect(ctxt: xmlParserCtxtPtr);
    fn xmlParseContent(ctxt: xmlParserCtxtPtr);
    fn xmlParseElement(ctxt: xmlParserCtxtPtr);
    fn xmlParseVersionNum(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    fn xmlParseVersionInfo(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    fn xmlParseEncName(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    fn xmlParseEncodingDecl(ctxt: xmlParserCtxtPtr) -> *const xmlChar;
    fn xmlParseSDDecl(ctxt: xmlParserCtxtPtr) -> i32;
    fn xmlParseXMLDecl(ctxt: xmlParserCtxtPtr);
    fn xmlParseTextDecl(ctxt: xmlParserCtxtPtr);
    fn xmlParseMisc(ctxt: xmlParserCtxtPtr);
    fn xmlParseExternalSubset(
        ctxt: xmlParserCtxtPtr,
        ExternalID: *const xmlChar,
        SystemID: *const xmlChar,
    );
    fn xmlStringDecodeEntities(
        ctxt: xmlParserCtxtPtr,
        str: *const xmlChar,
        what: i32,
        end: xmlChar,
        end2: xmlChar,
        end3: xmlChar,
    ) -> *mut xmlChar;
    fn xmlStringLenDecodeEntities(
        ctxt: xmlParserCtxtPtr,
        str: *const xmlChar,
        len: i32,
        what: i32,
        end: xmlChar,
        end2: xmlChar,
        end3: xmlChar,
    ) -> *mut xmlChar;
    fn nodePush(ctxt: xmlParserCtxtPtr, value: xmlNodePtr) -> i32;
    fn nodePop(ctxt: xmlParserCtxtPtr) -> xmlNodePtr;
    fn namePop(ctxt: xmlParserCtxtPtr) -> *const xmlChar;
    fn namePush(ctxt: xmlParserCtxtPtr, value: *const xmlChar) -> i32;
    fn xmlSkipBlankChars(ctxt: xmlParserCtxtPtr) -> i32;
    fn xmlParserHandlePEReference(ctxt: xmlParserCtxtPtr);
    fn xmlCheckLanguageID(lang: *const xmlChar) -> i32;
    fn xmlCopyCharMultiByte(out: *mut xmlChar, val: i32) -> i32;
    fn xmlCopyChar(len: i32, out: *mut xmlChar, val: i32) -> i32;
    fn xmlNextChar(ctxt: xmlParserCtxtPtr);
    fn htmlInitAutoClose();
    fn htmlCreateFileParserCtxt(
        filename: *const i8,
        encoding: *const i8,
    ) -> htmlParserCtxtPtr;
    fn xmlParseQuotedString(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    fn xmlParseNamespace(ctxt: xmlParserCtxtPtr);
    fn xmlNamespaceParseNSDef(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    fn xmlScanName(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    fn xmlNamespaceParseNCName(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
    fn xmlParserHandleReference(ctxt: xmlParserCtxtPtr);
    fn xmlDecodeEntities(
        ctxt: xmlParserCtxtPtr,
        len: i32,
        what: i32,
        end: xmlChar,
        end2: xmlChar,
        end3: xmlChar,
    ) -> *mut xmlChar;
    fn xmlHandleEntity(ctxt: xmlParserCtxtPtr, entity: xmlEntityPtr);
    fn xmlNewCatalog(sgml: i32) -> xmlCatalogPtr;
    fn xmlLoadACatalog(filename: *const i8) -> xmlCatalogPtr;
    fn xmlLoadSGMLSuperCatalog(filename: *const i8) -> xmlCatalogPtr;
    fn xmlConvertSGMLCatalog(catal: xmlCatalogPtr) -> i32;
    fn xmlACatalogAdd(
        catal: xmlCatalogPtr,
        type_0: *const xmlChar,
        orig: *const xmlChar,
        replace: *const xmlChar,
    ) -> i32;
    fn xmlACatalogRemove(catal: xmlCatalogPtr, value: *const xmlChar) -> i32;
    fn xmlACatalogResolve(
        catal: xmlCatalogPtr,
        pubID: *const xmlChar,
        sysID: *const xmlChar,
    ) -> *mut xmlChar;
    fn xmlACatalogResolveSystem(
        catal: xmlCatalogPtr,
        sysID: *const xmlChar,
    ) -> *mut xmlChar;
    fn xmlACatalogResolvePublic(
        catal: xmlCatalogPtr,
        pubID: *const xmlChar,
    ) -> *mut xmlChar;
    fn xmlACatalogResolveURI(catal: xmlCatalogPtr, URI: *const xmlChar) -> *mut xmlChar;
    fn xmlACatalogDump(catal: xmlCatalogPtr, out: *mut FILE);
    fn xmlFreeCatalog(catal: xmlCatalogPtr);
    fn xmlCatalogIsEmpty(catal: xmlCatalogPtr) -> i32;
    fn xmlInitializeCatalog();
    fn xmlLoadCatalog(filename: *const i8) -> i32;
    fn xmlLoadCatalogs(paths: *const i8);
    fn xmlCatalogCleanup();
    fn xmlCatalogDump(out: *mut FILE);
    fn xmlCatalogResolve(pubID: *const xmlChar, sysID: *const xmlChar) -> *mut xmlChar;
    fn xmlCatalogResolveSystem(sysID: *const xmlChar) -> *mut xmlChar;
    fn xmlCatalogResolvePublic(pubID: *const xmlChar) -> *mut xmlChar;
    fn xmlCatalogResolveURI(URI: *const xmlChar) -> *mut xmlChar;
    fn xmlCatalogAdd(
        type_0: *const xmlChar,
        orig: *const xmlChar,
        replace: *const xmlChar,
    ) -> i32;
    fn xmlCatalogRemove(value: *const xmlChar) -> i32;
    fn xmlParseCatalogFile(filename: *const i8) -> xmlDocPtr;
    fn xmlCatalogConvert() -> i32;
    fn xmlCatalogSetDebug(level: i32) -> i32;
    fn xmlCatalogGetSystem(sysID: *const xmlChar) -> *const xmlChar;
    fn xmlCatalogGetPublic(pubID: *const xmlChar) -> *const xmlChar;
    fn xmlNanoFTPInit();
    fn xmlNanoFTPCleanup();
    fn xmlNanoFTPScanProxy(URL: *const i8);
    fn xmlNanoFTPProxy(
        host: *const i8,
        port: i32,
        user: *const i8,
        passwd: *const i8,
=======
        reader: * mut crate::src::python::types::_xmlTextReader,
        prop: i32,
    ) -> i32;
    fn xmlTextReaderCurrentNode(reader: * mut crate::src::python::types::_xmlTextReader) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlTextReaderGetParserLineNumber(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderGetParserColumnNumber(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderPreserve(reader: * mut crate::src::python::types::_xmlTextReader) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlTextReaderCurrentDoc(reader: * mut crate::src::python::types::_xmlTextReader) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlTextReaderExpand(reader: * mut crate::src::python::types::_xmlTextReader) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlTextReaderNext(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderNextSibling(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderIsValid(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderRelaxNGValidate(
        reader: * mut crate::src::python::types::_xmlTextReader,
        rng: * const i8,
    ) -> i32;
    fn xmlTextReaderRelaxNGValidateCtxt(
        reader: * mut crate::src::python::types::_xmlTextReader,
        ctxt: * mut crate::src::python::types::_xmlRelaxNGValidCtxt,
        options: i32,
    ) -> i32;
    fn xmlTextReaderRelaxNGSetSchema(
        reader: * mut crate::src::python::types::_xmlTextReader,
        schema: * mut crate::src::python::types::_xmlRelaxNG,
    ) -> i32;
    fn xmlTextReaderSchemaValidate(
        reader: * mut crate::src::python::types::_xmlTextReader,
        xsd: * const i8,
    ) -> i32;
    fn xmlTextReaderSchemaValidateCtxt(
        reader: * mut crate::src::python::types::_xmlTextReader,
        ctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt,
        options: i32,
    ) -> i32;
    fn xmlTextReaderSetSchema(
        reader: * mut crate::src::python::types::_xmlTextReader,
        schema: * mut crate::src::python::libxml2_py::_xmlSchema,
    ) -> i32;
    fn xmlTextReaderConstXmlVersion(reader: * mut crate::src::python::types::_xmlTextReader) -> * const u8;
    fn xmlTextReaderStandalone(reader: * mut crate::src::python::types::_xmlTextReader) -> i32;
    fn xmlTextReaderByteConsumed(reader: * mut crate::src::python::types::_xmlTextReader) -> i64;
    fn xmlUCSIsLinearBSyllabary(code: i32) -> i32;
    fn xmlIsLetter(c: i32) -> i32;
    fn xmlCreateFileParserCtxt(filename: * const i8) -> * mut crate::src::python::libxml::_xmlParserCtxt;
    fn xmlCreateURLParserCtxt(
        filename: * const i8,
        options: i32,
    ) -> * mut crate::src::python::libxml::_xmlParserCtxt;
    fn xmlCreateMemoryParserCtxt(
        buffer: * const i8,
        size: i32,
    ) -> * mut crate::src::python::libxml::_xmlParserCtxt;
    fn xmlCreateEntityParserCtxt(
        URL: * const u8,
        ID: * const u8,
        base: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlParserCtxt;
    fn xmlPopInput(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> u8;
    fn xmlParseName(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * const u8;
    fn xmlParseNmtoken(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * mut u8;
    fn xmlParseAttValue(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * mut u8;
    fn xmlParseSystemLiteral(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * mut u8;
    fn xmlParsePubidLiteral(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * mut u8;
    fn xmlParseCharData(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt, cdata: i32);
    fn xmlParseComment(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlParsePITarget(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * const u8;
    fn xmlParsePI(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlParseNotationDecl(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlParseEntityDecl(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlParseAttributeListDecl(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlParseElementDecl(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> i32;
    fn xmlParseMarkupDecl(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlParseCharRef(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> i32;
    fn xmlParseEntityRef(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * mut crate::src::python::libxml::_xmlEntity;
    fn xmlParseReference(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlParsePEReference(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlParseDocTypeDecl(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlParseStartTag(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * const u8;
    fn xmlParseEndTag(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlParseCDSect(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlParseContent(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlParseElement(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlParseVersionNum(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * mut u8;
    fn xmlParseVersionInfo(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * mut u8;
    fn xmlParseEncName(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * mut u8;
    fn xmlParseEncodingDecl(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * const u8;
    fn xmlParseSDDecl(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> i32;
    fn xmlParseXMLDecl(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlParseTextDecl(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlParseMisc(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlParseExternalSubset(
        ctxt: * mut crate::src::python::libxml::_xmlParserCtxt,
        ExternalID: * const u8,
        SystemID: * const u8,
    );
    fn xmlStringDecodeEntities(
        ctxt: * mut crate::src::python::libxml::_xmlParserCtxt,
        str: * const u8,
        what: i32,
        end: u8,
        end2: u8,
        end3: u8,
    ) -> * mut u8;
    fn xmlStringLenDecodeEntities(
        ctxt: * mut crate::src::python::libxml::_xmlParserCtxt,
        str: * const u8,
        len: i32,
        what: i32,
        end: u8,
        end2: u8,
        end3: u8,
    ) -> * mut u8;
    fn nodePush(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt, value: * mut crate::src::python::libxml::_xmlNode) -> i32;
    fn nodePop(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * mut crate::src::python::libxml::_xmlNode;
    fn namePop(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * const u8;
    fn namePush(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt, value: * const u8) -> i32;
    fn xmlSkipBlankChars(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> i32;
    fn xmlParserHandlePEReference(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlCheckLanguageID(lang: * const u8) -> i32;
    fn xmlCopyCharMultiByte(out: * mut u8, val: i32) -> i32;
    fn xmlCopyChar(len: i32, out: * mut u8, val: i32) -> i32;
    fn xmlNextChar(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn htmlInitAutoClose();
    fn htmlCreateFileParserCtxt(
        filename: * const i8,
        encoding: * const i8,
    ) -> * mut crate::src::python::libxml::_xmlParserCtxt;
    fn xmlParseQuotedString(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * mut u8;
    fn xmlParseNamespace(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlNamespaceParseNSDef(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * mut u8;
    fn xmlScanName(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * mut u8;
    fn xmlNamespaceParseNCName(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> * mut u8;
    fn xmlParserHandleReference(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn xmlDecodeEntities(
        ctxt: * mut crate::src::python::libxml::_xmlParserCtxt,
        len: i32,
        what: i32,
        end: u8,
        end2: u8,
        end3: u8,
    ) -> * mut u8;
    fn xmlHandleEntity(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt, entity: * mut crate::src::python::libxml::_xmlEntity);
    fn xmlNewCatalog(sgml: i32) -> * mut crate::src::python::types::_xmlCatalog;
    fn xmlLoadACatalog(filename: * const i8) -> * mut crate::src::python::types::_xmlCatalog;
    fn xmlLoadSGMLSuperCatalog(filename: * const i8) -> * mut crate::src::python::types::_xmlCatalog;
    fn xmlConvertSGMLCatalog(catal: * mut crate::src::python::types::_xmlCatalog) -> i32;
    fn xmlACatalogAdd(
        catal: * mut crate::src::python::types::_xmlCatalog,
        type_0: * const u8,
        orig: * const u8,
        replace: * const u8,
    ) -> i32;
    fn xmlACatalogRemove(catal: * mut crate::src::python::types::_xmlCatalog, value: * const u8) -> i32;
    fn xmlACatalogResolve(
        catal: * mut crate::src::python::types::_xmlCatalog,
        pubID: * const u8,
        sysID: * const u8,
    ) -> * mut u8;
    fn xmlACatalogResolveSystem(
        catal: * mut crate::src::python::types::_xmlCatalog,
        sysID: * const u8,
    ) -> * mut u8;
    fn xmlACatalogResolvePublic(
        catal: * mut crate::src::python::types::_xmlCatalog,
        pubID: * const u8,
    ) -> * mut u8;
    fn xmlACatalogResolveURI(catal: * mut crate::src::python::types::_xmlCatalog, URI: * const u8) -> * mut u8;
    fn xmlACatalogDump(catal: * mut crate::src::python::types::_xmlCatalog, out: * mut crate::src::python::libxml::_IO_FILE);
    fn xmlFreeCatalog(catal: * mut crate::src::python::types::_xmlCatalog);
    fn xmlCatalogIsEmpty(catal: * mut crate::src::python::types::_xmlCatalog) -> i32;
    fn xmlInitializeCatalog();
    fn xmlLoadCatalog(filename: * const i8) -> i32;
    fn xmlLoadCatalogs(paths: * const i8);
    fn xmlCatalogCleanup();
    fn xmlCatalogDump(out: * mut crate::src::python::libxml::_IO_FILE);
    fn xmlCatalogResolve(pubID: * const u8, sysID: * const u8) -> * mut u8;
    fn xmlCatalogResolveSystem(sysID: * const u8) -> * mut u8;
    fn xmlCatalogResolvePublic(pubID: * const u8) -> * mut u8;
    fn xmlCatalogResolveURI(URI: * const u8) -> * mut u8;
    fn xmlCatalogAdd(
        type_0: * const u8,
        orig: * const u8,
        replace: * const u8,
    ) -> i32;
    fn xmlCatalogRemove(value: * const u8) -> i32;
    fn xmlParseCatalogFile(filename: * const i8) -> * mut crate::src::python::libxml::_xmlDoc;
    fn xmlCatalogConvert() -> i32;
    fn xmlCatalogSetDebug(level: i32) -> i32;
    fn xmlCatalogGetSystem(sysID: * const u8) -> * const u8;
    fn xmlCatalogGetPublic(pubID: * const u8) -> * const u8;
    fn xmlNanoFTPInit();
    fn xmlNanoFTPCleanup();
    fn xmlNanoFTPScanProxy(URL: * const i8);
    fn xmlNanoFTPProxy(
        host: * const i8,
        port: i32,
        user: * const i8,
        passwd: * const i8,
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
        type_0: i32,
    );
    fn xmlNanoHTTPInit();
    fn xmlNanoHTTPCleanup();
<<<<<<< HEAD
    fn xmlNanoHTTPScanProxy(URL: *const i8);
    fn xmlCreateURI() -> xmlURIPtr;
    fn xmlBuildURI(URI: *const xmlChar, base: *const xmlChar) -> *mut xmlChar;
    fn xmlBuildRelativeURI(URI: *const xmlChar, base: *const xmlChar) -> *mut xmlChar;
    fn xmlParseURI(str: *const i8) -> xmlURIPtr;
    fn xmlParseURIRaw(str: *const i8, raw: i32) -> xmlURIPtr;
    fn xmlParseURIReference(uri: xmlURIPtr, str: *const i8) -> i32;
    fn xmlSaveUri(uri: xmlURIPtr) -> *mut xmlChar;
    fn xmlPrintURI(stream: *mut FILE, uri: xmlURIPtr);
    fn xmlURIEscapeStr(str: *const xmlChar, list: *const xmlChar) -> *mut xmlChar;
    fn xmlURIUnescapeString(
        str: *const i8,
        len: i32,
        target: *mut i8,
    ) -> *mut i8;
    fn xmlNormalizeURIPath(path: *mut i8) -> i32;
    fn xmlURIEscape(str: *const xmlChar) -> *mut xmlChar;
    fn xmlFreeURI(uri: xmlURIPtr);
    fn xmlCanonicPath(path: *const xmlChar) -> *mut xmlChar;
    fn xmlPathToURI(path: *const xmlChar) -> *mut xmlChar;
    fn xmlXPathCmpNodes(node1: xmlNodePtr, node2: xmlNodePtr) -> i32;
    fn xmlXPathCastNumberToBoolean(val: f64) -> i32;
    fn xmlXPathCastStringToBoolean(val: *const xmlChar) -> i32;
    fn xmlXPathCastBooleanToNumber(val: i32) -> f64;
    fn xmlXPathCastStringToNumber(val: *const xmlChar) -> f64;
    fn xmlXPathCastNodeToNumber(node: xmlNodePtr) -> f64;
    fn xmlXPathCastBooleanToString(val: i32) -> *mut xmlChar;
    fn xmlXPathCastNumberToString(val: f64) -> *mut xmlChar;
    fn xmlXPathCastNodeToString(node: xmlNodePtr) -> *mut xmlChar;
    fn xmlXPathNewContext(doc: xmlDocPtr) -> xmlXPathContextPtr;
    fn xmlXPathFreeContext(ctxt: xmlXPathContextPtr);
    fn xmlXPathContextSetCache(
        ctxt: xmlXPathContextPtr,
=======
    fn xmlNanoHTTPScanProxy(URL: * const i8);
    fn xmlCreateURI() -> * mut crate::src::python::libxml2_py::_xmlURI;
    fn xmlBuildURI(URI: * const u8, base: * const u8) -> * mut u8;
    fn xmlBuildRelativeURI(URI: * const u8, base: * const u8) -> * mut u8;
    fn xmlParseURI(str: * const i8) -> * mut crate::src::python::libxml2_py::_xmlURI;
    fn xmlParseURIRaw(str: * const i8, raw: i32) -> * mut crate::src::python::libxml2_py::_xmlURI;
    fn xmlParseURIReference(uri: * mut crate::src::python::libxml2_py::_xmlURI, str: * const i8) -> i32;
    fn xmlSaveUri(uri: * mut crate::src::python::libxml2_py::_xmlURI) -> * mut u8;
    fn xmlPrintURI(stream: * mut crate::src::python::libxml::_IO_FILE, uri: * mut crate::src::python::libxml2_py::_xmlURI);
    fn xmlURIEscapeStr(str: * const u8, list: * const u8) -> * mut u8;
    fn xmlURIUnescapeString(
        str: * const i8,
        len: i32,
        target: * mut i8,
    ) -> * mut i8;
    fn xmlNormalizeURIPath(path: * mut i8) -> i32;
    fn xmlURIEscape(str: * const u8) -> * mut u8;
    fn xmlFreeURI(uri: * mut crate::src::python::libxml2_py::_xmlURI);
    fn xmlCanonicPath(path: * const u8) -> * mut u8;
    fn xmlPathToURI(path: * const u8) -> * mut u8;
    fn xmlXPathCmpNodes(node1: * mut crate::src::python::libxml::_xmlNode, node2: * mut crate::src::python::libxml::_xmlNode) -> i32;
    fn xmlXPathCastNumberToBoolean(val: f64) -> i32;
    fn xmlXPathCastStringToBoolean(val: * const u8) -> i32;
    fn xmlXPathCastBooleanToNumber(val: i32) -> f64;
    fn xmlXPathCastStringToNumber(val: * const u8) -> f64;
    fn xmlXPathCastNodeToNumber(node: * mut crate::src::python::libxml::_xmlNode) -> f64;
    fn xmlXPathCastBooleanToString(val: i32) -> * mut u8;
    fn xmlXPathCastNumberToString(val: f64) -> * mut u8;
    fn xmlXPathCastNodeToString(node: * mut crate::src::python::libxml::_xmlNode) -> * mut u8;
    fn xmlXPathNewContext(doc: * mut crate::src::python::libxml::_xmlDoc) -> * mut crate::src::python::libxml::_xmlXPathContext;
    fn xmlXPathFreeContext(ctxt: * mut crate::src::python::libxml::_xmlXPathContext);
    fn xmlXPathContextSetCache(
        ctxt: * mut crate::src::python::libxml::_xmlXPathContext,
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
        active: i32,
        value: i32,
        options: i32,
    ) -> i32;
<<<<<<< HEAD
    fn xmlXPathOrderDocElems(doc: xmlDocPtr) -> i64;
    fn xmlXPathNodeEval(
        node: xmlNodePtr,
        str: *const xmlChar,
        ctx: xmlXPathContextPtr,
    ) -> xmlXPathObjectPtr;
    fn xmlXPathEval(str: *const xmlChar, ctx: xmlXPathContextPtr) -> xmlXPathObjectPtr;
    fn xmlXPathEvalExpression(
        str: *const xmlChar,
        ctxt: xmlXPathContextPtr,
    ) -> xmlXPathObjectPtr;
    fn xmlXPathInit();
    fn xmlXPathIsNaN(val: f64) -> i32;
    fn xmlXPathIsInf(val: f64) -> i32;
    fn xmlXPathPopBoolean(ctxt: xmlXPathParserContextPtr) -> i32;
    fn xmlXPathPopNumber(ctxt: xmlXPathParserContextPtr) -> f64;
    fn xmlXPathPopString(ctxt: xmlXPathParserContextPtr) -> *mut xmlChar;
    fn xmlXPatherror(
        ctxt: xmlXPathParserContextPtr,
        file: *const i8,
        line: i32,
        no: i32,
    );
    fn xmlXPathErr(ctxt: xmlXPathParserContextPtr, error: i32);
    fn xmlXPathRegisterNs(
        ctxt: xmlXPathContextPtr,
        prefix: *const xmlChar,
        ns_uri: *const xmlChar,
    ) -> i32;
    fn xmlXPathNsLookup(
        ctxt: xmlXPathContextPtr,
        prefix: *const xmlChar,
    ) -> *const xmlChar;
    fn xmlXPathRegisteredNsCleanup(ctxt: xmlXPathContextPtr);
    fn xmlXPathRegisteredFuncsCleanup(ctxt: xmlXPathContextPtr);
    fn xmlXPathVariableLookup(
        ctxt: xmlXPathContextPtr,
        name: *const xmlChar,
    ) -> xmlXPathObjectPtr;
    fn xmlXPathVariableLookupNS(
        ctxt: xmlXPathContextPtr,
        name: *const xmlChar,
        ns_uri: *const xmlChar,
    ) -> xmlXPathObjectPtr;
    fn xmlXPathRegisteredVariablesCleanup(ctxt: xmlXPathContextPtr);
    fn xmlXPathNewParserContext(
        str: *const xmlChar,
        ctxt: xmlXPathContextPtr,
    ) -> xmlXPathParserContextPtr;
    fn xmlXPathFreeParserContext(ctxt: xmlXPathParserContextPtr);
    fn valuePop(ctxt: xmlXPathParserContextPtr) -> xmlXPathObjectPtr;
    fn xmlXPathNewString(val: *const xmlChar) -> xmlXPathObjectPtr;
    fn xmlXPathNewCString(val: *const i8) -> xmlXPathObjectPtr;
    fn xmlXPathNewFloat(val: f64) -> xmlXPathObjectPtr;
    fn xmlXPathNewBoolean(val: i32) -> xmlXPathObjectPtr;
    fn xmlXPathNewNodeSet(val: xmlNodePtr) -> xmlXPathObjectPtr;
    fn xmlXPathNewValueTree(val: xmlNodePtr) -> xmlXPathObjectPtr;
    fn xmlXPathRoot(ctxt: xmlXPathParserContextPtr);
    fn xmlXPathEvalExpr(ctxt: xmlXPathParserContextPtr);
    fn xmlXPathParseName(ctxt: xmlXPathParserContextPtr) -> *mut xmlChar;
    fn xmlXPathParseNCName(ctxt: xmlXPathParserContextPtr) -> *mut xmlChar;
    fn xmlXPathStringEvalNumber(str: *const xmlChar) -> f64;
    fn xmlXPathRegisterAllFunctions(ctxt: xmlXPathContextPtr);
    fn xmlXPathEqualValues(ctxt: xmlXPathParserContextPtr) -> i32;
    fn xmlXPathNotEqualValues(ctxt: xmlXPathParserContextPtr) -> i32;
    fn xmlXPathCompareValues(
        ctxt: xmlXPathParserContextPtr,
        inf: i32,
        strict: i32,
    ) -> i32;
    fn xmlXPathValueFlipSign(ctxt: xmlXPathParserContextPtr);
    fn xmlXPathAddValues(ctxt: xmlXPathParserContextPtr);
    fn xmlXPathSubValues(ctxt: xmlXPathParserContextPtr);
    fn xmlXPathMultValues(ctxt: xmlXPathParserContextPtr);
    fn xmlXPathDivValues(ctxt: xmlXPathParserContextPtr);
    fn xmlXPathModValues(ctxt: xmlXPathParserContextPtr);
    fn xmlXPathIsNodeType(name: *const xmlChar) -> i32;
    fn xmlXPathNextSelf(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
    fn xmlXPathNextChild(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
    fn xmlXPathNextDescendant(
        ctxt: xmlXPathParserContextPtr,
        cur: xmlNodePtr,
    ) -> xmlNodePtr;
    fn xmlXPathNextDescendantOrSelf(
        ctxt: xmlXPathParserContextPtr,
        cur: xmlNodePtr,
    ) -> xmlNodePtr;
    fn xmlXPathNextParent(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
    fn xmlXPathNextAncestorOrSelf(
        ctxt: xmlXPathParserContextPtr,
        cur: xmlNodePtr,
    ) -> xmlNodePtr;
    fn xmlXPathNextFollowingSibling(
        ctxt: xmlXPathParserContextPtr,
        cur: xmlNodePtr,
    ) -> xmlNodePtr;
    fn xmlXPathNextFollowing(
        ctxt: xmlXPathParserContextPtr,
        cur: xmlNodePtr,
    ) -> xmlNodePtr;
    fn xmlXPathNextNamespace(
        ctxt: xmlXPathParserContextPtr,
        cur: xmlNodePtr,
    ) -> xmlNodePtr;
    fn xmlXPathNextAttribute(
        ctxt: xmlXPathParserContextPtr,
        cur: xmlNodePtr,
    ) -> xmlNodePtr;
    fn xmlXPathNextPreceding(
        ctxt: xmlXPathParserContextPtr,
        cur: xmlNodePtr,
    ) -> xmlNodePtr;
    fn xmlXPathNextAncestor(
        ctxt: xmlXPathParserContextPtr,
        cur: xmlNodePtr,
    ) -> xmlNodePtr;
    fn xmlXPathNextPrecedingSibling(
        ctxt: xmlXPathParserContextPtr,
        cur: xmlNodePtr,
    ) -> xmlNodePtr;
    fn xmlXPathLastFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathPositionFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathCountFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathIdFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathLocalNameFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathNamespaceURIFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathStringFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathStringLengthFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathConcatFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathContainsFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathStartsWithFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathSubstringFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathSubstringBeforeFunction(
        ctxt: xmlXPathParserContextPtr,
        nargs: i32,
    );
    fn xmlXPathSubstringAfterFunction(
        ctxt: xmlXPathParserContextPtr,
        nargs: i32,
    );
    fn xmlXPathNormalizeFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathTranslateFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathNotFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathTrueFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathFalseFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathLangFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathNumberFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathSumFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathFloorFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathCeilingFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathRoundFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathBooleanFunction(ctxt: xmlXPathParserContextPtr, nargs: i32);
    fn xmlXPathNodeSetFreeNs(ns: xmlNsPtr);
    fn xmlDebugDumpString(output: *mut FILE, str: *const xmlChar);
    fn xmlDebugDumpAttr(output: *mut FILE, attr: xmlAttrPtr, depth: i32);
    fn xmlDebugDumpAttrList(output: *mut FILE, attr: xmlAttrPtr, depth: i32);
    fn xmlDebugDumpOneNode(output: *mut FILE, node: xmlNodePtr, depth: i32);
    fn xmlDebugDumpNode(output: *mut FILE, node: xmlNodePtr, depth: i32);
    fn xmlDebugDumpNodeList(output: *mut FILE, node: xmlNodePtr, depth: i32);
    fn xmlDebugDumpDocumentHead(output: *mut FILE, doc: xmlDocPtr);
    fn xmlDebugDumpDocument(output: *mut FILE, doc: xmlDocPtr);
    fn xmlDebugDumpDTD(output: *mut FILE, dtd: xmlDtdPtr);
    fn xmlDebugDumpEntities(output: *mut FILE, doc: xmlDocPtr);
    fn xmlDebugCheckDocument(output: *mut FILE, doc: xmlDocPtr) -> i32;
    fn xmlLsOneNode(output: *mut FILE, node: xmlNodePtr);
    fn xmlLsCountNode(node: xmlNodePtr) -> i32;
    fn xmlBoolToText(boolval: i32) -> *const i8;
    fn xmlShellPrintXPathError(errorType: i32, arg: *const i8);
    fn xmlShellPrintNode(node: xmlNodePtr);
    fn htmlNewDoc(URI: *const xmlChar, ExternalID: *const xmlChar) -> htmlDocPtr;
    fn htmlNewDocNoDtD(URI: *const xmlChar, ExternalID: *const xmlChar) -> htmlDocPtr;
    fn htmlGetMetaEncoding(doc: htmlDocPtr) -> *const xmlChar;
    fn htmlSetMetaEncoding(doc: htmlDocPtr, encoding: *const xmlChar) -> i32;
    fn htmlDocDump(f: *mut FILE, cur: xmlDocPtr) -> i32;
    fn htmlSaveFile(filename: *const i8, cur: xmlDocPtr) -> i32;
    fn htmlNodeDumpFile(out: *mut FILE, doc: xmlDocPtr, cur: xmlNodePtr);
    fn htmlNodeDumpFileFormat(
        out: *mut FILE,
        doc: xmlDocPtr,
        cur: xmlNodePtr,
        encoding: *const i8,
        format: i32,
    ) -> i32;
    fn htmlSaveFileEnc(
        filename: *const i8,
        cur: xmlDocPtr,
        encoding: *const i8,
    ) -> i32;
    fn htmlSaveFileFormat(
        filename: *const i8,
        cur: xmlDocPtr,
        encoding: *const i8,
        format: i32,
    ) -> i32;
    fn htmlNodeDumpFormatOutput(
        buf: xmlOutputBufferPtr,
        doc: xmlDocPtr,
        cur: xmlNodePtr,
        encoding: *const i8,
        format: i32,
    );
    fn htmlDocContentDumpOutput(
        buf: xmlOutputBufferPtr,
        cur: xmlDocPtr,
        encoding: *const i8,
    );
    fn htmlDocContentDumpFormatOutput(
        buf: xmlOutputBufferPtr,
        cur: xmlDocPtr,
        encoding: *const i8,
        format: i32,
    );
    fn htmlNodeDumpOutput(
        buf: xmlOutputBufferPtr,
        doc: xmlDocPtr,
        cur: xmlNodePtr,
        encoding: *const i8,
    );
    fn htmlIsBooleanAttr(name: *const xmlChar) -> i32;
    fn xmlXIncludeProcess(doc: xmlDocPtr) -> i32;
    fn xmlXIncludeProcessFlags(doc: xmlDocPtr, flags: i32) -> i32;
    fn xmlXIncludeProcessTree(tree: xmlNodePtr) -> i32;
    fn xmlXIncludeProcessTreeFlags(tree: xmlNodePtr, flags: i32) -> i32;
    fn xmlXPtrNewContext(
        doc: xmlDocPtr,
        here: xmlNodePtr,
        origin: xmlNodePtr,
    ) -> xmlXPathContextPtr;
    fn xmlXPtrEval(str: *const xmlChar, ctx: xmlXPathContextPtr) -> xmlXPathObjectPtr;
=======
    fn xmlXPathOrderDocElems(doc: * mut crate::src::python::libxml::_xmlDoc) -> i64;
    fn xmlXPathNodeEval(
        node: * mut crate::src::python::libxml::_xmlNode,
        str: * const u8,
        ctx: * mut crate::src::python::libxml::_xmlXPathContext,
    ) -> * mut crate::src::python::libxml::_xmlXPathObject;
    fn xmlXPathEval(str: * const u8, ctx: * mut crate::src::python::libxml::_xmlXPathContext) -> * mut crate::src::python::libxml::_xmlXPathObject;
    fn xmlXPathEvalExpression(
        str: * const u8,
        ctxt: * mut crate::src::python::libxml::_xmlXPathContext,
    ) -> * mut crate::src::python::libxml::_xmlXPathObject;
    fn xmlXPathInit();
    fn xmlXPathIsNaN(val: f64) -> i32;
    fn xmlXPathIsInf(val: f64) -> i32;
    fn xmlXPathPopBoolean(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext) -> i32;
    fn xmlXPathPopNumber(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext) -> f64;
    fn xmlXPathPopString(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext) -> * mut u8;
    fn xmlXPatherror(
        ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext,
        file: * const i8,
        line: i32,
        no: i32,
    );
    fn xmlXPathErr(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, error: i32);
    fn xmlXPathRegisterNs(
        ctxt: * mut crate::src::python::libxml::_xmlXPathContext,
        prefix: * const u8,
        ns_uri: * const u8,
    ) -> i32;
    fn xmlXPathNsLookup(
        ctxt: * mut crate::src::python::libxml::_xmlXPathContext,
        prefix: * const u8,
    ) -> * const u8;
    fn xmlXPathRegisteredNsCleanup(ctxt: * mut crate::src::python::libxml::_xmlXPathContext);
    fn xmlXPathRegisteredFuncsCleanup(ctxt: * mut crate::src::python::libxml::_xmlXPathContext);
    fn xmlXPathVariableLookup(
        ctxt: * mut crate::src::python::libxml::_xmlXPathContext,
        name: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlXPathObject;
    fn xmlXPathVariableLookupNS(
        ctxt: * mut crate::src::python::libxml::_xmlXPathContext,
        name: * const u8,
        ns_uri: * const u8,
    ) -> * mut crate::src::python::libxml::_xmlXPathObject;
    fn xmlXPathRegisteredVariablesCleanup(ctxt: * mut crate::src::python::libxml::_xmlXPathContext);
    fn xmlXPathNewParserContext(
        str: * const u8,
        ctxt: * mut crate::src::python::libxml::_xmlXPathContext,
    ) -> * mut crate::src::python::libxml::_xmlXPathParserContext;
    fn xmlXPathFreeParserContext(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext);
    fn valuePop(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext) -> * mut crate::src::python::libxml::_xmlXPathObject;
    fn xmlXPathNewString(val: * const u8) -> * mut crate::src::python::libxml::_xmlXPathObject;
    fn xmlXPathNewCString(val: * const i8) -> * mut crate::src::python::libxml::_xmlXPathObject;
    fn xmlXPathNewFloat(val: f64) -> * mut crate::src::python::libxml::_xmlXPathObject;
    fn xmlXPathNewBoolean(val: i32) -> * mut crate::src::python::libxml::_xmlXPathObject;
    fn xmlXPathNewNodeSet(val: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlXPathObject;
    fn xmlXPathNewValueTree(val: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlXPathObject;
    fn xmlXPathRoot(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext);
    fn xmlXPathEvalExpr(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext);
    fn xmlXPathParseName(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext) -> * mut u8;
    fn xmlXPathParseNCName(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext) -> * mut u8;
    fn xmlXPathStringEvalNumber(str: * const u8) -> f64;
    fn xmlXPathRegisterAllFunctions(ctxt: * mut crate::src::python::libxml::_xmlXPathContext);
    fn xmlXPathEqualValues(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext) -> i32;
    fn xmlXPathNotEqualValues(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext) -> i32;
    fn xmlXPathCompareValues(
        ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext,
        inf: i32,
        strict: i32,
    ) -> i32;
    fn xmlXPathValueFlipSign(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext);
    fn xmlXPathAddValues(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext);
    fn xmlXPathSubValues(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext);
    fn xmlXPathMultValues(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext);
    fn xmlXPathDivValues(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext);
    fn xmlXPathModValues(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext);
    fn xmlXPathIsNodeType(name: * const u8) -> i32;
    fn xmlXPathNextSelf(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, cur: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlXPathNextChild(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, cur: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlXPathNextDescendant(
        ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext,
        cur: * mut crate::src::python::libxml::_xmlNode,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlXPathNextDescendantOrSelf(
        ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext,
        cur: * mut crate::src::python::libxml::_xmlNode,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlXPathNextParent(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, cur: * mut crate::src::python::libxml::_xmlNode) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlXPathNextAncestorOrSelf(
        ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext,
        cur: * mut crate::src::python::libxml::_xmlNode,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlXPathNextFollowingSibling(
        ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext,
        cur: * mut crate::src::python::libxml::_xmlNode,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlXPathNextFollowing(
        ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext,
        cur: * mut crate::src::python::libxml::_xmlNode,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlXPathNextNamespace(
        ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext,
        cur: * mut crate::src::python::libxml::_xmlNode,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlXPathNextAttribute(
        ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext,
        cur: * mut crate::src::python::libxml::_xmlNode,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlXPathNextPreceding(
        ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext,
        cur: * mut crate::src::python::libxml::_xmlNode,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlXPathNextAncestor(
        ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext,
        cur: * mut crate::src::python::libxml::_xmlNode,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlXPathNextPrecedingSibling(
        ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext,
        cur: * mut crate::src::python::libxml::_xmlNode,
    ) -> * mut crate::src::python::libxml::_xmlNode;
    fn xmlXPathLastFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathPositionFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathCountFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathIdFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathLocalNameFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathNamespaceURIFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathStringFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathStringLengthFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathConcatFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathContainsFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathStartsWithFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathSubstringFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathSubstringBeforeFunction(
        ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext,
        nargs: i32,
    );
    fn xmlXPathSubstringAfterFunction(
        ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext,
        nargs: i32,
    );
    fn xmlXPathNormalizeFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathTranslateFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathNotFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathTrueFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathFalseFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathLangFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathNumberFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathSumFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathFloorFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathCeilingFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathRoundFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathBooleanFunction(ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext, nargs: i32);
    fn xmlXPathNodeSetFreeNs(ns: * mut crate::src::python::libxml::_xmlNs);
    fn xmlDebugDumpString(output: * mut crate::src::python::libxml::_IO_FILE, str: * const u8);
    fn xmlDebugDumpAttr(output: * mut crate::src::python::libxml::_IO_FILE, attr: * mut crate::src::python::libxml::_xmlAttr, depth: i32);
    fn xmlDebugDumpAttrList(output: * mut crate::src::python::libxml::_IO_FILE, attr: * mut crate::src::python::libxml::_xmlAttr, depth: i32);
    fn xmlDebugDumpOneNode(output: * mut crate::src::python::libxml::_IO_FILE, node: * mut crate::src::python::libxml::_xmlNode, depth: i32);
    fn xmlDebugDumpNode(output: * mut crate::src::python::libxml::_IO_FILE, node: * mut crate::src::python::libxml::_xmlNode, depth: i32);
    fn xmlDebugDumpNodeList(output: * mut crate::src::python::libxml::_IO_FILE, node: * mut crate::src::python::libxml::_xmlNode, depth: i32);
    fn xmlDebugDumpDocumentHead(output: * mut crate::src::python::libxml::_IO_FILE, doc: * mut crate::src::python::libxml::_xmlDoc);
    fn xmlDebugDumpDocument(output: * mut crate::src::python::libxml::_IO_FILE, doc: * mut crate::src::python::libxml::_xmlDoc);
    fn xmlDebugDumpDTD(output: * mut crate::src::python::libxml::_IO_FILE, dtd: * mut crate::src::python::libxml::_xmlDtd);
    fn xmlDebugDumpEntities(output: * mut crate::src::python::libxml::_IO_FILE, doc: * mut crate::src::python::libxml::_xmlDoc);
    fn xmlDebugCheckDocument(output: * mut crate::src::python::libxml::_IO_FILE, doc: * mut crate::src::python::libxml::_xmlDoc) -> i32;
    fn xmlLsOneNode(output: * mut crate::src::python::libxml::_IO_FILE, node: * mut crate::src::python::libxml::_xmlNode);
    fn xmlLsCountNode(node: * mut crate::src::python::libxml::_xmlNode) -> i32;
    fn xmlBoolToText(boolval: i32) -> * const i8;
    fn xmlShellPrintXPathError(errorType: i32, arg: * const i8);
    fn xmlShellPrintNode(node: * mut crate::src::python::libxml::_xmlNode);
    fn htmlNewDoc(URI: * const u8, ExternalID: * const u8) -> * mut crate::src::python::libxml::_xmlDoc;
    fn htmlNewDocNoDtD(URI: * const u8, ExternalID: * const u8) -> * mut crate::src::python::libxml::_xmlDoc;
    fn htmlGetMetaEncoding(doc: * mut crate::src::python::libxml::_xmlDoc) -> * const u8;
    fn htmlSetMetaEncoding(doc: * mut crate::src::python::libxml::_xmlDoc, encoding: * const u8) -> i32;
    fn htmlDocDump(f: * mut crate::src::python::libxml::_IO_FILE, cur: * mut crate::src::python::libxml::_xmlDoc) -> i32;
    fn htmlSaveFile(filename: * const i8, cur: * mut crate::src::python::libxml::_xmlDoc) -> i32;
    fn htmlNodeDumpFile(out: * mut crate::src::python::libxml::_IO_FILE, doc: * mut crate::src::python::libxml::_xmlDoc, cur: * mut crate::src::python::libxml::_xmlNode);
    fn htmlNodeDumpFileFormat(
        out: * mut crate::src::python::libxml::_IO_FILE,
        doc: * mut crate::src::python::libxml::_xmlDoc,
        cur: * mut crate::src::python::libxml::_xmlNode,
        encoding: * const i8,
        format: i32,
    ) -> i32;
    fn htmlSaveFileEnc(
        filename: * const i8,
        cur: * mut crate::src::python::libxml::_xmlDoc,
        encoding: * const i8,
    ) -> i32;
    fn htmlSaveFileFormat(
        filename: * const i8,
        cur: * mut crate::src::python::libxml::_xmlDoc,
        encoding: * const i8,
        format: i32,
    ) -> i32;
    fn htmlNodeDumpFormatOutput(
        buf: * mut crate::src::python::libxml::_xmlOutputBuffer,
        doc: * mut crate::src::python::libxml::_xmlDoc,
        cur: * mut crate::src::python::libxml::_xmlNode,
        encoding: * const i8,
        format: i32,
    );
    fn htmlDocContentDumpOutput(
        buf: * mut crate::src::python::libxml::_xmlOutputBuffer,
        cur: * mut crate::src::python::libxml::_xmlDoc,
        encoding: * const i8,
    );
    fn htmlDocContentDumpFormatOutput(
        buf: * mut crate::src::python::libxml::_xmlOutputBuffer,
        cur: * mut crate::src::python::libxml::_xmlDoc,
        encoding: * const i8,
        format: i32,
    );
    fn htmlNodeDumpOutput(
        buf: * mut crate::src::python::libxml::_xmlOutputBuffer,
        doc: * mut crate::src::python::libxml::_xmlDoc,
        cur: * mut crate::src::python::libxml::_xmlNode,
        encoding: * const i8,
    );
    fn htmlIsBooleanAttr(name: * const u8) -> i32;
    fn xmlXIncludeProcess(doc: * mut crate::src::python::libxml::_xmlDoc) -> i32;
    fn xmlXIncludeProcessFlags(doc: * mut crate::src::python::libxml::_xmlDoc, flags: i32) -> i32;
    fn xmlXIncludeProcessTree(tree: * mut crate::src::python::libxml::_xmlNode) -> i32;
    fn xmlXIncludeProcessTreeFlags(tree: * mut crate::src::python::libxml::_xmlNode, flags: i32) -> i32;
    fn xmlXPtrNewContext(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        here: * mut crate::src::python::libxml::_xmlNode,
        origin: * mut crate::src::python::libxml::_xmlNode,
    ) -> * mut crate::src::python::libxml::_xmlXPathContext;
    fn xmlXPtrEval(str: * const u8, ctx: * mut crate::src::python::libxml::_xmlXPathContext) -> * mut crate::src::python::libxml::_xmlXPathObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    fn xmlUCSIsAegeanNumbers(code: i32) -> i32;
    fn xmlUCSIsAlphabeticPresentationForms(code: i32) -> i32;
    fn xmlUCSIsArabic(code: i32) -> i32;
    fn xmlUCSIsArabicPresentationFormsA(code: i32) -> i32;
    fn xmlUCSIsArabicPresentationFormsB(code: i32) -> i32;
    fn xmlUCSIsArmenian(code: i32) -> i32;
    fn xmlUCSIsArrows(code: i32) -> i32;
    fn xmlUCSIsBasicLatin(code: i32) -> i32;
    fn xmlUCSIsBengali(code: i32) -> i32;
    fn xmlUCSIsBlockElements(code: i32) -> i32;
    fn xmlUCSIsBopomofo(code: i32) -> i32;
    fn xmlUCSIsBopomofoExtended(code: i32) -> i32;
    fn xmlUCSIsBoxDrawing(code: i32) -> i32;
    fn xmlUCSIsBraillePatterns(code: i32) -> i32;
    fn xmlUCSIsBuhid(code: i32) -> i32;
    fn xmlUCSIsByzantineMusicalSymbols(code: i32) -> i32;
    fn xmlUCSIsCJKCompatibility(code: i32) -> i32;
    fn xmlUCSIsCJKCompatibilityForms(code: i32) -> i32;
    fn xmlUCSIsCJKCompatibilityIdeographs(code: i32) -> i32;
    fn xmlUCSIsCJKCompatibilityIdeographsSupplement(code: i32) -> i32;
    fn xmlUCSIsCJKRadicalsSupplement(code: i32) -> i32;
    fn xmlUCSIsCJKSymbolsandPunctuation(code: i32) -> i32;
    fn xmlUCSIsCJKUnifiedIdeographs(code: i32) -> i32;
    fn xmlUCSIsCJKUnifiedIdeographsExtensionA(code: i32) -> i32;
    fn xmlUCSIsCJKUnifiedIdeographsExtensionB(code: i32) -> i32;
    fn xmlUCSIsCherokee(code: i32) -> i32;
    fn xmlUCSIsCombiningDiacriticalMarks(code: i32) -> i32;
    fn xmlUCSIsCombiningDiacriticalMarksforSymbols(code: i32) -> i32;
    fn xmlUCSIsCombiningHalfMarks(code: i32) -> i32;
    fn xmlUCSIsCombiningMarksforSymbols(code: i32) -> i32;
    fn xmlUCSIsControlPictures(code: i32) -> i32;
    fn xmlUCSIsCurrencySymbols(code: i32) -> i32;
    fn xmlUCSIsCypriotSyllabary(code: i32) -> i32;
    fn xmlUCSIsCyrillic(code: i32) -> i32;
    fn xmlUCSIsCyrillicSupplement(code: i32) -> i32;
    fn xmlUCSIsDeseret(code: i32) -> i32;
    fn xmlUCSIsDevanagari(code: i32) -> i32;
    fn xmlUCSIsDingbats(code: i32) -> i32;
    fn xmlUCSIsEnclosedAlphanumerics(code: i32) -> i32;
    fn xmlUCSIsEnclosedCJKLettersandMonths(code: i32) -> i32;
    fn xmlUCSIsEthiopic(code: i32) -> i32;
    fn xmlUCSIsGeneralPunctuation(code: i32) -> i32;
    fn xmlUCSIsGeometricShapes(code: i32) -> i32;
    fn xmlUCSIsGeorgian(code: i32) -> i32;
    fn xmlUCSIsGothic(code: i32) -> i32;
    fn xmlUCSIsGreek(code: i32) -> i32;
    fn xmlUCSIsGreekExtended(code: i32) -> i32;
    fn xmlUCSIsGreekandCoptic(code: i32) -> i32;
    fn xmlUCSIsGujarati(code: i32) -> i32;
    fn xmlUCSIsGurmukhi(code: i32) -> i32;
    fn xmlUCSIsHalfwidthandFullwidthForms(code: i32) -> i32;
    fn xmlUCSIsHangulCompatibilityJamo(code: i32) -> i32;
    fn xmlUCSIsHangulJamo(code: i32) -> i32;
    fn xmlUCSIsHangulSyllables(code: i32) -> i32;
    fn xmlUCSIsHanunoo(code: i32) -> i32;
    fn xmlUCSIsHebrew(code: i32) -> i32;
    fn xmlUCSIsHighPrivateUseSurrogates(code: i32) -> i32;
    fn xmlUCSIsHighSurrogates(code: i32) -> i32;
    fn xmlUCSIsHiragana(code: i32) -> i32;
    fn xmlUCSIsIPAExtensions(code: i32) -> i32;
    fn xmlUCSIsIdeographicDescriptionCharacters(code: i32) -> i32;
    fn xmlUCSIsKanbun(code: i32) -> i32;
    fn xmlUCSIsKangxiRadicals(code: i32) -> i32;
    fn xmlUCSIsKannada(code: i32) -> i32;
    fn xmlUCSIsKatakana(code: i32) -> i32;
    fn xmlUCSIsKatakanaPhoneticExtensions(code: i32) -> i32;
    fn xmlUCSIsKhmer(code: i32) -> i32;
    fn xmlUCSIsKhmerSymbols(code: i32) -> i32;
    fn xmlUCSIsLao(code: i32) -> i32;
    fn xmlUCSIsLatin1Supplement(code: i32) -> i32;
    fn xmlUCSIsLatinExtendedA(code: i32) -> i32;
    fn xmlUCSIsLatinExtendedB(code: i32) -> i32;
    fn xmlUCSIsLatinExtendedAdditional(code: i32) -> i32;
    fn xmlUCSIsLetterlikeSymbols(code: i32) -> i32;
    fn xmlUCSIsLimbu(code: i32) -> i32;
    fn xmlUCSIsLinearBIdeograms(code: i32) -> i32;
    fn xmlIsPubidChar(ch: u32) -> i32;
<<<<<<< HEAD
    fn libxml_deprecationWarning(func: *const i8) -> i32;
    fn libxml_xmlErrorPtrWrap(error: xmlErrorPtr) -> *mut PyObject;
    fn libxml_xmlSchemaValidCtxtPtrWrap(valid: xmlSchemaValidCtxtPtr) -> *mut PyObject;
    fn libxml_xmlSchemaParserCtxtPtrWrap(ctxt: xmlSchemaParserCtxtPtr) -> *mut PyObject;
    fn libxml_xmlSchemaPtrWrap(ctxt: xmlSchemaPtr) -> *mut PyObject;
    fn libxml_xmlRelaxNGValidCtxtPtrWrap(valid: xmlRelaxNGValidCtxtPtr) -> *mut PyObject;
    fn libxml_xmlRelaxNGParserCtxtPtrWrap(
        ctxt: xmlRelaxNGParserCtxtPtr,
    ) -> *mut PyObject;
    fn libxml_xmlRelaxNGPtrWrap(ctxt: xmlRelaxNGPtr) -> *mut PyObject;
    fn libxml_xmlTextReaderPtrWrap(reader: xmlTextReaderPtr) -> *mut PyObject;
    fn libxml_xmlRegexpPtrWrap(regexp: xmlRegexpPtr) -> *mut PyObject;
    fn libxml_xmlParserInputBufferPtrWrap(
        buffer: xmlParserInputBufferPtr,
    ) -> *mut PyObject;
    fn libxml_xmlURIPtrWrap(uri: xmlURIPtr) -> *mut PyObject;
    fn libxml_xmlCatalogPtrWrap(obj: xmlCatalogPtr) -> *mut PyObject;
    fn libxml_xmlValidCtxtPtrWrap(valid: xmlValidCtxtPtr) -> *mut PyObject;
    fn libxml_xmlXPathObjectPtrWrap(obj: xmlXPathObjectPtr) -> *mut PyObject;
    fn libxml_xmlXPathParserContextPtrWrap(
        ctxt: xmlXPathParserContextPtr,
    ) -> *mut PyObject;
    fn libxml_xmlParserCtxtPtrWrap(ctxt: xmlParserCtxtPtr) -> *mut PyObject;
    fn libxml_xmlXPathContextPtrWrap(ctxt: xmlXPathContextPtr) -> *mut PyObject;
    fn libxml_doubleWrap(val: f64) -> *mut PyObject;
    fn libxml_xmlElementPtrWrap(ns: xmlElementPtr) -> *mut PyObject;
    fn libxml_xmlAttributePtrWrap(ns: xmlAttributePtr) -> *mut PyObject;
    fn libxml_xmlNsPtrWrap(ns: xmlNsPtr) -> *mut PyObject;
    fn libxml_xmlNodePtrWrap(node: xmlNodePtr) -> *mut PyObject;
    fn libxml_xmlDocPtrWrap(doc: xmlDocPtr) -> *mut PyObject;
    fn libxml_xmlCharPtrConstWrap(str: *const xmlChar) -> *mut PyObject;
    fn libxml_charPtrConstWrap(str: *const i8) -> *mut PyObject;
    fn libxml_charPtrWrap(str: *mut i8) -> *mut PyObject;
    fn libxml_xmlCharPtrWrap(str: *mut xmlChar) -> *mut PyObject;
    fn libxml_longWrap(val: i64) -> *mut PyObject;
    fn libxml_intWrap(val: i32) -> *mut PyObject;
    fn xmlRelaxNGInitTypes() -> i32;
    fn xmlRelaxNGCleanupTypes();
    fn xmlRelaxNGNewParserCtxt(URL: *const i8) -> xmlRelaxNGParserCtxtPtr;
    fn xmlRelaxNGNewMemParserCtxt(
        buffer: *const i8,
        size: i32,
    ) -> xmlRelaxNGParserCtxtPtr;
    fn xmlRelaxNGNewDocParserCtxt(doc: xmlDocPtr) -> xmlRelaxNGParserCtxtPtr;
    fn xmlRelaxParserSetFlag(
        ctxt: xmlRelaxNGParserCtxtPtr,
        flag: i32,
    ) -> i32;
    fn xmlRelaxNGFreeParserCtxt(ctxt: xmlRelaxNGParserCtxtPtr);
    fn xmlRelaxNGParse(ctxt: xmlRelaxNGParserCtxtPtr) -> xmlRelaxNGPtr;
    fn xmlRelaxNGFree(schema: xmlRelaxNGPtr);
    fn xmlRelaxNGDump(output: *mut FILE, schema: xmlRelaxNGPtr);
    fn xmlRelaxNGDumpTree(output: *mut FILE, schema: xmlRelaxNGPtr);
    fn xmlRelaxNGNewValidCtxt(schema: xmlRelaxNGPtr) -> xmlRelaxNGValidCtxtPtr;
    fn xmlRelaxNGValidateDoc(
        ctxt: xmlRelaxNGValidCtxtPtr,
        doc: xmlDocPtr,
    ) -> i32;
    fn xmlRelaxNGValidatePushElement(
        ctxt: xmlRelaxNGValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlNodePtr,
    ) -> i32;
    fn xmlRelaxNGValidatePushCData(
        ctxt: xmlRelaxNGValidCtxtPtr,
        data: *const xmlChar,
        len: i32,
    ) -> i32;
    fn xmlRelaxNGValidatePopElement(
        ctxt: xmlRelaxNGValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlNodePtr,
    ) -> i32;
    fn xmlRelaxNGValidateFullElement(
        ctxt: xmlRelaxNGValidCtxtPtr,
        doc: xmlDocPtr,
        elem: xmlNodePtr,
=======
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    fn xmlRelaxNGInitTypes() -> i32;
    fn xmlRelaxNGCleanupTypes();
    fn xmlRelaxNGNewParserCtxt(URL: * const i8) -> * mut crate::src::python::libxml2_py::_xmlRelaxNGParserCtxt;
    fn xmlRelaxNGNewMemParserCtxt(
        buffer: * const i8,
        size: i32,
    ) -> * mut crate::src::python::libxml2_py::_xmlRelaxNGParserCtxt;
    fn xmlRelaxNGNewDocParserCtxt(doc: * mut crate::src::python::libxml::_xmlDoc) -> * mut crate::src::python::libxml2_py::_xmlRelaxNGParserCtxt;
    fn xmlRelaxParserSetFlag(
        ctxt: * mut crate::src::python::libxml2_py::_xmlRelaxNGParserCtxt,
        flag: i32,
    ) -> i32;
    fn xmlRelaxNGFreeParserCtxt(ctxt: * mut crate::src::python::libxml2_py::_xmlRelaxNGParserCtxt);
    fn xmlRelaxNGParse(ctxt: * mut crate::src::python::libxml2_py::_xmlRelaxNGParserCtxt) -> * mut crate::src::python::types::_xmlRelaxNG;
    fn xmlRelaxNGFree(schema: * mut crate::src::python::types::_xmlRelaxNG);
    fn xmlRelaxNGDump(output: * mut crate::src::python::libxml::_IO_FILE, schema: * mut crate::src::python::types::_xmlRelaxNG);
    fn xmlRelaxNGDumpTree(output: * mut crate::src::python::libxml::_IO_FILE, schema: * mut crate::src::python::types::_xmlRelaxNG);
    fn xmlRelaxNGNewValidCtxt(schema: * mut crate::src::python::types::_xmlRelaxNG) -> * mut crate::src::python::types::_xmlRelaxNGValidCtxt;
    fn xmlRelaxNGValidateDoc(
        ctxt: * mut crate::src::python::types::_xmlRelaxNGValidCtxt,
        doc: * mut crate::src::python::libxml::_xmlDoc,
    ) -> i32;
    fn xmlRelaxNGValidatePushElement(
        ctxt: * mut crate::src::python::types::_xmlRelaxNGValidCtxt,
        doc: * mut crate::src::python::libxml::_xmlDoc,
        elem: * mut crate::src::python::libxml::_xmlNode,
    ) -> i32;
    fn xmlRelaxNGValidatePushCData(
        ctxt: * mut crate::src::python::types::_xmlRelaxNGValidCtxt,
        data: * const u8,
        len: i32,
    ) -> i32;
    fn xmlRelaxNGValidatePopElement(
        ctxt: * mut crate::src::python::types::_xmlRelaxNGValidCtxt,
        doc: * mut crate::src::python::libxml::_xmlDoc,
        elem: * mut crate::src::python::libxml::_xmlNode,
    ) -> i32;
    fn xmlRelaxNGValidateFullElement(
        ctxt: * mut crate::src::python::types::_xmlRelaxNGValidCtxt,
        doc: * mut crate::src::python::libxml::_xmlDoc,
        elem: * mut crate::src::python::libxml::_xmlNode,
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    ) -> i32;
    fn xmlIsIdeographic(ch: u32) -> i32;
    fn xmlIsExtender(ch: u32) -> i32;
    fn xmlIsDigit(ch: u32) -> i32;
    fn xmlIsCombining(ch: u32) -> i32;
    fn xmlIsChar(ch: u32) -> i32;
    fn xmlIsBlank(ch: u32) -> i32;
    fn xmlIsBaseChar(ch: u32) -> i32;
    fn htmlCtxtReadFd(
<<<<<<< HEAD
        ctxt: xmlParserCtxtPtr,
        fd: i32,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> htmlDocPtr;
    fn htmlCtxtReadMemory(
        ctxt: xmlParserCtxtPtr,
        buffer: *const i8,
        size: i32,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> htmlDocPtr;
    fn htmlCtxtReadFile(
        ctxt: xmlParserCtxtPtr,
        filename: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> htmlDocPtr;
    fn htmlCtxtReadDoc(
        ctxt: xmlParserCtxtPtr,
        cur: *const xmlChar,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> htmlDocPtr;
    fn htmlReadFd(
        fd: i32,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> htmlDocPtr;
    fn htmlReadMemory(
        buffer: *const i8,
        size: i32,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> htmlDocPtr;
    fn htmlReadFile(
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> htmlDocPtr;
    fn htmlReadDoc(
        cur: *const xmlChar,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> htmlDocPtr;
    fn htmlCtxtUseOptions(ctxt: htmlParserCtxtPtr, options: i32) -> i32;
    fn htmlCtxtReset(ctxt: htmlParserCtxtPtr);
    fn htmlFreeParserCtxt(ctxt: htmlParserCtxtPtr);
    fn htmlParseChunk(
        ctxt: htmlParserCtxtPtr,
        chunk: *const i8,
=======
        ctxt: * mut crate::src::python::libxml::_xmlParserCtxt,
        fd: i32,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::libxml::_xmlDoc;
    fn htmlCtxtReadMemory(
        ctxt: * mut crate::src::python::libxml::_xmlParserCtxt,
        buffer: * const i8,
        size: i32,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::libxml::_xmlDoc;
    fn htmlCtxtReadFile(
        ctxt: * mut crate::src::python::libxml::_xmlParserCtxt,
        filename: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::libxml::_xmlDoc;
    fn htmlCtxtReadDoc(
        ctxt: * mut crate::src::python::libxml::_xmlParserCtxt,
        cur: * const u8,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::libxml::_xmlDoc;
    fn htmlReadFd(
        fd: i32,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::libxml::_xmlDoc;
    fn htmlReadMemory(
        buffer: * const i8,
        size: i32,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::libxml::_xmlDoc;
    fn htmlReadFile(
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::libxml::_xmlDoc;
    fn htmlReadDoc(
        cur: * const u8,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::libxml::_xmlDoc;
    fn htmlCtxtUseOptions(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt, options: i32) -> i32;
    fn htmlCtxtReset(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn htmlFreeParserCtxt(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn htmlParseChunk(
        ctxt: * mut crate::src::python::libxml::_xmlParserCtxt,
        chunk: * const i8,
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
        size: i32,
        terminate: i32,
    ) -> i32;
    fn htmlHandleOmittedElem(val: i32) -> i32;
<<<<<<< HEAD
    fn htmlIsScriptAttribute(name: *const xmlChar) -> i32;
    fn htmlParseFile(
        filename: *const i8,
        encoding: *const i8,
    ) -> htmlDocPtr;
    fn htmlParseDoc(cur: *const xmlChar, encoding: *const i8) -> htmlDocPtr;
    fn htmlParseDocument(ctxt: htmlParserCtxtPtr) -> i32;
    fn htmlCreateMemoryParserCtxt(
        buffer: *const i8,
        size: i32,
    ) -> htmlParserCtxtPtr;
    fn htmlNewParserCtxt() -> htmlParserCtxtPtr;
    fn htmlParseElement(ctxt: htmlParserCtxtPtr);
    fn htmlParseCharRef(ctxt: htmlParserCtxtPtr) -> i32;
    fn htmlAutoCloseTag(
        doc: htmlDocPtr,
        name: *const xmlChar,
        elem: htmlNodePtr,
    ) -> i32;
    fn htmlIsAutoClosed(doc: htmlDocPtr, elem: htmlNodePtr) -> i32;
    fn xmlReaderWalker(doc: xmlDocPtr) -> xmlTextReaderPtr;
    fn xmlReaderForDoc(
        cur: *const xmlChar,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> xmlTextReaderPtr;
    fn xmlReaderForFile(
        filename: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> xmlTextReaderPtr;
    fn xmlReaderForMemory(
        buffer: *const i8,
        size: i32,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> xmlTextReaderPtr;
    fn xmlReaderForFd(
        fd: i32,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> xmlTextReaderPtr;
    fn xmlReaderNewWalker(reader: xmlTextReaderPtr, doc: xmlDocPtr) -> i32;
    fn xmlReaderNewDoc(
        reader: xmlTextReaderPtr,
        cur: *const xmlChar,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> i32;
    fn xmlReaderNewFile(
        reader: xmlTextReaderPtr,
        filename: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> i32;
    fn xmlReaderNewMemory(
        reader: xmlTextReaderPtr,
        buffer: *const i8,
        size: i32,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> i32;
    fn xmlReaderNewFd(
        reader: xmlTextReaderPtr,
        fd: i32,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> i32;
    fn xmlTextReaderLocatorLineNumber(locator: xmlTextReaderLocatorPtr) -> i32;
    fn xmlTextReaderLocatorBaseURI(locator: xmlTextReaderLocatorPtr) -> *mut xmlChar;
=======
    fn htmlIsScriptAttribute(name: * const u8) -> i32;
    fn htmlParseFile(
        filename: * const i8,
        encoding: * const i8,
    ) -> * mut crate::src::python::libxml::_xmlDoc;
    fn htmlParseDoc(cur: * const u8, encoding: * const i8) -> * mut crate::src::python::libxml::_xmlDoc;
    fn htmlParseDocument(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> i32;
    fn htmlCreateMemoryParserCtxt(
        buffer: * const i8,
        size: i32,
    ) -> * mut crate::src::python::libxml::_xmlParserCtxt;
    fn htmlNewParserCtxt() -> * mut crate::src::python::libxml::_xmlParserCtxt;
    fn htmlParseElement(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt);
    fn htmlParseCharRef(ctxt: * mut crate::src::python::libxml::_xmlParserCtxt) -> i32;
    fn htmlAutoCloseTag(
        doc: * mut crate::src::python::libxml::_xmlDoc,
        name: * const u8,
        elem: * mut crate::src::python::libxml::_xmlNode,
    ) -> i32;
    fn htmlIsAutoClosed(doc: * mut crate::src::python::libxml::_xmlDoc, elem: * mut crate::src::python::libxml::_xmlNode) -> i32;
    fn xmlReaderWalker(doc: * mut crate::src::python::libxml::_xmlDoc) -> * mut crate::src::python::types::_xmlTextReader;
    fn xmlReaderForDoc(
        cur: * const u8,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::types::_xmlTextReader;
    fn xmlReaderForFile(
        filename: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::types::_xmlTextReader;
    fn xmlReaderForMemory(
        buffer: * const i8,
        size: i32,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::types::_xmlTextReader;
    fn xmlReaderForFd(
        fd: i32,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> * mut crate::src::python::types::_xmlTextReader;
    fn xmlReaderNewWalker(reader: * mut crate::src::python::types::_xmlTextReader, doc: * mut crate::src::python::libxml::_xmlDoc) -> i32;
    fn xmlReaderNewDoc(
        reader: * mut crate::src::python::types::_xmlTextReader,
        cur: * const u8,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> i32;
    fn xmlReaderNewFile(
        reader: * mut crate::src::python::types::_xmlTextReader,
        filename: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> i32;
    fn xmlReaderNewMemory(
        reader: * mut crate::src::python::types::_xmlTextReader,
        buffer: * const i8,
        size: i32,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> i32;
    fn xmlReaderNewFd(
        reader: * mut crate::src::python::types::_xmlTextReader,
        fd: i32,
        URL: * const i8,
        encoding: * const i8,
        options: i32,
    ) -> i32;
    fn xmlTextReaderLocatorLineNumber(locator: * mut core::ffi::c_void) -> i32;
    fn xmlTextReaderLocatorBaseURI(locator: * mut core::ffi::c_void) -> * mut u8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    fn xmlUCSIsCatLl(code: i32) -> i32;
    fn xmlUCSIsMalayalam(code: i32) -> i32;
    fn xmlUCSIsMathematicalAlphanumericSymbols(code: i32) -> i32;
    fn xmlUCSIsMathematicalOperators(code: i32) -> i32;
    fn xmlUCSIsMiscellaneousMathematicalSymbolsA(code: i32) -> i32;
    fn xmlUCSIsMiscellaneousMathematicalSymbolsB(code: i32) -> i32;
    fn xmlUCSIsMiscellaneousSymbols(code: i32) -> i32;
    fn xmlUCSIsMiscellaneousSymbolsandArrows(code: i32) -> i32;
    fn xmlUCSIsMiscellaneousTechnical(code: i32) -> i32;
    fn xmlUCSIsMongolian(code: i32) -> i32;
    fn xmlUCSIsMusicalSymbols(code: i32) -> i32;
    fn xmlUCSIsMyanmar(code: i32) -> i32;
    fn xmlUCSIsNumberForms(code: i32) -> i32;
    fn xmlUCSIsOgham(code: i32) -> i32;
    fn xmlUCSIsOldItalic(code: i32) -> i32;
    fn xmlUCSIsLowSurrogates(code: i32) -> i32;
    fn xmlUCSIsCatL(code: i32) -> i32;
    fn xmlUCSIsCatCs(code: i32) -> i32;
    fn xmlUCSIsCatCo(code: i32) -> i32;
    fn xmlUCSIsCatCf(code: i32) -> i32;
    fn xmlUCSIsCatCc(code: i32) -> i32;
    fn xmlUCSIsCatC(code: i32) -> i32;
<<<<<<< HEAD
    fn xmlUCSIsBlock(code: i32, block: *const i8) -> i32;
=======
    fn xmlUCSIsBlock(code: i32, block: * const i8) -> i32;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    fn xmlUCSIsYijingHexagramSymbols(code: i32) -> i32;
    fn xmlUCSIsYiSyllables(code: i32) -> i32;
    fn xmlUCSIsYiRadicals(code: i32) -> i32;
    fn xmlUCSIsVariationSelectorsSupplement(code: i32) -> i32;
    fn xmlUCSIsVariationSelectors(code: i32) -> i32;
    fn xmlUCSIsUnifiedCanadianAboriginalSyllabics(code: i32) -> i32;
    fn xmlUCSIsUgaritic(code: i32) -> i32;
    fn xmlUCSIsTibetan(code: i32) -> i32;
    fn xmlUCSIsThai(code: i32) -> i32;
    fn xmlUCSIsThaana(code: i32) -> i32;
    fn xmlUCSIsTelugu(code: i32) -> i32;
    fn xmlUCSIsTamil(code: i32) -> i32;
    fn xmlUCSIsTaiXuanJingSymbols(code: i32) -> i32;
    fn xmlUCSIsTaiLe(code: i32) -> i32;
    fn xmlUCSIsTags(code: i32) -> i32;
    fn xmlUCSIsTagbanwa(code: i32) -> i32;
    fn xmlUCSIsTagalog(code: i32) -> i32;
    fn xmlUCSIsSyriac(code: i32) -> i32;
    fn xmlUCSIsSupplementaryPrivateUseAreaB(code: i32) -> i32;
    fn xmlUCSIsSupplementaryPrivateUseAreaA(code: i32) -> i32;
    fn xmlUCSIsSupplementalMathematicalOperators(code: i32) -> i32;
    fn xmlUCSIsSupplementalArrowsB(code: i32) -> i32;
    fn xmlUCSIsSupplementalArrowsA(code: i32) -> i32;
    fn xmlUCSIsSuperscriptsandSubscripts(code: i32) -> i32;
    fn xmlUCSIsOpticalCharacterRecognition(code: i32) -> i32;
    fn xmlUCSIsOriya(code: i32) -> i32;
    fn xmlUCSIsOsmanya(code: i32) -> i32;
    fn xmlUCSIsPhoneticExtensions(code: i32) -> i32;
    fn xmlUCSIsSpecials(code: i32) -> i32;
    fn xmlUCSIsSpacingModifierLetters(code: i32) -> i32;
    fn xmlUCSIsPrivateUse(code: i32) -> i32;
    fn xmlUCSIsSmallFormVariants(code: i32) -> i32;
    fn xmlUCSIsSinhala(code: i32) -> i32;
    fn xmlUCSIsShavian(code: i32) -> i32;
    fn xmlUCSIsRunic(code: i32) -> i32;
    fn xmlUCSIsPrivateUseArea(code: i32) -> i32;
    fn xmlUCSIsCatPc(code: i32) -> i32;
    fn xmlUCSIsCatLm(code: i32) -> i32;
    fn xmlUCSIsCatLo(code: i32) -> i32;
    fn xmlUCSIsCatLt(code: i32) -> i32;
    fn xmlUCSIsCatLu(code: i32) -> i32;
    fn xmlUCSIsCatM(code: i32) -> i32;
    fn xmlUCSIsCatMc(code: i32) -> i32;
    fn xmlUCSIsCatMe(code: i32) -> i32;
    fn xmlUCSIsCatMn(code: i32) -> i32;
    fn xmlUCSIsCatN(code: i32) -> i32;
    fn xmlUCSIsCatNd(code: i32) -> i32;
    fn xmlUCSIsCatNl(code: i32) -> i32;
    fn xmlUCSIsCatNo(code: i32) -> i32;
    fn xmlUCSIsCatP(code: i32) -> i32;
    fn xmlUCSIsCatSo(code: i32) -> i32;
    fn xmlUCSIsCatPf(code: i32) -> i32;
    fn xmlUCSIsCatPe(code: i32) -> i32;
    fn xmlUCSIsCatPd(code: i32) -> i32;
    fn xmlUCSIsCatPi(code: i32) -> i32;
    fn xmlUCSIsCatPo(code: i32) -> i32;
    fn xmlUCSIsCatPs(code: i32) -> i32;
    fn xmlUCSIsCatS(code: i32) -> i32;
    fn xmlUCSIsCatSc(code: i32) -> i32;
    fn xmlUCSIsCatSm(code: i32) -> i32;
    fn xmlUCSIsCatSk(code: i32) -> i32;
    fn xmlUCSIsCatZ(code: i32) -> i32;
    fn xmlUCSIsCatZl(code: i32) -> i32;
    fn xmlUCSIsCatZp(code: i32) -> i32;
    fn xmlUCSIsCatZs(code: i32) -> i32;
<<<<<<< HEAD
    fn xmlUCSIsCat(code: i32, cat: *const i8) -> i32;
}
=======
    fn xmlUCSIsCat(code: i32, cat: * const i8) -> i32;
}
pub use crate::src::python::libxml::libxml_deprecationWarning;
pub use crate::src::python::types::libxml_charPtrConstWrap;
pub use crate::src::python::types::libxml_charPtrWrap;
pub use crate::src::python::types::libxml_doubleWrap;
pub use crate::src::python::types::libxml_intWrap;
pub use crate::src::python::types::libxml_longWrap;
pub use crate::src::python::types::libxml_xmlAttributePtrWrap;
pub use crate::src::python::types::libxml_xmlCatalogPtrWrap;
pub use crate::src::python::types::libxml_xmlCharPtrConstWrap;
pub use crate::src::python::types::libxml_xmlCharPtrWrap;
pub use crate::src::python::types::libxml_xmlDocPtrWrap;
pub use crate::src::python::types::libxml_xmlElementPtrWrap;
pub use crate::src::python::types::libxml_xmlErrorPtrWrap;
pub use crate::src::python::types::libxml_xmlNodePtrWrap;
pub use crate::src::python::types::libxml_xmlNsPtrWrap;
pub use crate::src::python::types::libxml_xmlParserCtxtPtrWrap;
pub use crate::src::python::types::libxml_xmlParserInputBufferPtrWrap;
pub use crate::src::python::types::libxml_xmlRegexpPtrWrap;
pub use crate::src::python::types::libxml_xmlRelaxNGParserCtxtPtrWrap;
pub use crate::src::python::types::libxml_xmlRelaxNGPtrWrap;
pub use crate::src::python::types::libxml_xmlRelaxNGValidCtxtPtrWrap;
pub use crate::src::python::types::libxml_xmlSchemaParserCtxtPtrWrap;
pub use crate::src::python::types::libxml_xmlSchemaPtrWrap;
pub use crate::src::python::types::libxml_xmlSchemaValidCtxtPtrWrap;
pub use crate::src::python::types::libxml_xmlTextReaderPtrWrap;
pub use crate::src::python::types::libxml_xmlURIPtrWrap;
pub use crate::src::python::types::libxml_xmlValidCtxtPtrWrap;
pub use crate::src::python::types::libxml_xmlXPathContextPtrWrap;
pub use crate::src::python::types::libxml_xmlXPathObjectPtrWrap;
pub use crate::src::python::types::libxml_xmlXPathParserContextPtrWrap;
pub use crate::src::python::libxml::PyMemberDef;
pub use crate::src::python::libxml::_xmlBuf;
pub use crate::src::python::libxml::_xmlXPathCompExpr;
pub use crate::src::python::types::_IO_wide_data;
pub use crate::src::python::types::_xmlAutomata;
pub use crate::src::python::types::_xmlAutomataState;
pub use crate::src::python::types::_xmlCatalog;
pub use crate::src::python::types::_xmlDict;
pub use crate::src::python::types::_xmlRelaxNG;
pub use crate::src::python::types::_xmlRelaxNGValidCtxt;
pub use crate::src::python::types::_xmlSchemaParserCtxt;
pub use crate::src::python::types::_xmlSchemaValidCtxt;
pub use crate::src::python::types::_xmlTextReader;
pub use crate::src::python::types::_xmlValidState;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
pub type size_t = u64;
pub type __off_t = i64;
pub type __off64_t = i64;
pub type __ssize_t = i64;
<<<<<<< HEAD
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: i32,
    pub _IO_read_ptr: *mut i8,
    pub _IO_read_end: *mut i8,
    pub _IO_read_base: *mut i8,
    pub _IO_write_base: *mut i8,
    pub _IO_write_ptr: *mut i8,
    pub _IO_write_end: *mut i8,
    pub _IO_buf_base: *mut i8,
    pub _IO_buf_end: *mut i8,
    pub _IO_save_base: *mut i8,
    pub _IO_backup_base: *mut i8,
    pub _IO_save_end: *mut i8,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: i32,
    pub _flags2: i32,
    pub _old_offset: __off_t,
    pub _cur_column: u16,
    pub _vtable_offset: i8,
    pub _shortbuf: [i8; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: i32,
    pub _unused2: [i8; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type ssize_t = __ssize_t;
pub type Py_ssize_t = ssize_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _typeobject {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub ob_size: Py_ssize_t,
    pub tp_name: *const i8,
    pub tp_basicsize: Py_ssize_t,
    pub tp_itemsize: Py_ssize_t,
    pub tp_dealloc: destructor,
    pub tp_print: printfunc,
    pub tp_getattr: getattrfunc,
    pub tp_setattr: setattrfunc,
    pub tp_compare: cmpfunc,
    pub tp_repr: reprfunc,
    pub tp_as_number: *mut PyNumberMethods,
    pub tp_as_sequence: *mut PySequenceMethods,
    pub tp_as_mapping: *mut PyMappingMethods,
    pub tp_hash: hashfunc,
    pub tp_call: ternaryfunc,
    pub tp_str: reprfunc,
    pub tp_getattro: getattrofunc,
    pub tp_setattro: setattrofunc,
    pub tp_as_buffer: *mut PyBufferProcs,
    pub tp_flags: i64,
    pub tp_doc: *const i8,
    pub tp_traverse: traverseproc,
    pub tp_clear: inquiry,
    pub tp_richcompare: richcmpfunc,
    pub tp_weaklistoffset: Py_ssize_t,
    pub tp_iter: getiterfunc,
    pub tp_iternext: iternextfunc,
    pub tp_methods: *mut PyMethodDef,
    pub tp_members: *mut PyMemberDef,
    pub tp_getset: *mut PyGetSetDef,
    pub tp_base: *mut _typeobject,
    pub tp_dict: *mut PyObject,
    pub tp_descr_get: descrgetfunc,
    pub tp_descr_set: descrsetfunc,
    pub tp_dictoffset: Py_ssize_t,
    pub tp_init: initproc,
    pub tp_alloc: allocfunc,
    pub tp_new: newfunc,
    pub tp_free: freefunc,
    pub tp_is_gc: inquiry,
    pub tp_bases: *mut PyObject,
    pub tp_mro: *mut PyObject,
    pub tp_cache: *mut PyObject,
    pub tp_subclasses: *mut PyObject,
    pub tp_weaklist: *mut PyObject,
    pub tp_del: destructor,
    pub tp_version_tag: u32,
}
pub type destructor = Option::<unsafe extern "C" fn(*mut PyObject) -> ()>;
pub type PyObject = _object;
pub type inquiry = Option::<unsafe extern "C" fn(*mut PyObject) -> i32>;
pub type freefunc = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type newfunc = Option::<
    unsafe extern "C" fn(*mut _typeobject, *mut PyObject, *mut PyObject) -> *mut PyObject,
>;
pub type allocfunc = Option::<
    unsafe extern "C" fn(*mut _typeobject, Py_ssize_t) -> *mut PyObject,
>;
pub type initproc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut PyObject, *mut PyObject) -> i32,
>;
pub type descrsetfunc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut PyObject, *mut PyObject) -> i32,
>;
pub type descrgetfunc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut PyObject, *mut PyObject) -> *mut PyObject,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyGetSetDef {
    pub name: *mut i8,
    pub get: getter,
    pub set: setter,
    pub doc: *mut i8,
    pub closure: *mut libc::c_void,
}
pub type setter = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut PyObject, *mut libc::c_void) -> i32,
>;
pub type getter = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut libc::c_void) -> *mut PyObject,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyMethodDef {
    pub ml_name: *const i8,
    pub ml_meth: PyCFunction,
    pub ml_flags: i32,
    pub ml_doc: *const i8,
}
pub type PyCFunction = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut PyObject) -> *mut PyObject,
>;
pub type iternextfunc = Option::<unsafe extern "C" fn(*mut PyObject) -> *mut PyObject>;
pub type getiterfunc = Option::<unsafe extern "C" fn(*mut PyObject) -> *mut PyObject>;
pub type richcmpfunc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut PyObject, i32) -> *mut PyObject,
>;
pub type traverseproc = Option::<
    unsafe extern "C" fn(*mut PyObject, visitproc, *mut libc::c_void) -> i32,
>;
pub type visitproc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut libc::c_void) -> i32,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyBufferProcs {
    pub bf_getreadbuffer: readbufferproc,
    pub bf_getwritebuffer: writebufferproc,
    pub bf_getsegcount: segcountproc,
    pub bf_getcharbuffer: charbufferproc,
    pub bf_getbuffer: getbufferproc,
    pub bf_releasebuffer: releasebufferproc,
}
pub type releasebufferproc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut Py_buffer) -> (),
>;
pub type Py_buffer = bufferinfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bufferinfo {
    pub buf: *mut libc::c_void,
    pub obj: *mut PyObject,
    pub len: Py_ssize_t,
    pub itemsize: Py_ssize_t,
    pub readonly: i32,
    pub ndim: i32,
    pub format: *mut i8,
    pub shape: *mut Py_ssize_t,
    pub strides: *mut Py_ssize_t,
    pub suboffsets: *mut Py_ssize_t,
    pub smalltable: [Py_ssize_t; 2],
    pub internal: *mut libc::c_void,
}
pub type getbufferproc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut Py_buffer, i32) -> i32,
>;
pub type charbufferproc = Option::<
    unsafe extern "C" fn(*mut PyObject, Py_ssize_t, *mut *mut i8) -> Py_ssize_t,
>;
pub type segcountproc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut Py_ssize_t) -> Py_ssize_t,
>;
pub type writebufferproc = Option::<
    unsafe extern "C" fn(*mut PyObject, Py_ssize_t, *mut *mut libc::c_void) -> Py_ssize_t,
>;
pub type readbufferproc = Option::<
    unsafe extern "C" fn(*mut PyObject, Py_ssize_t, *mut *mut libc::c_void) -> Py_ssize_t,
>;
pub type setattrofunc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut PyObject, *mut PyObject) -> i32,
>;
pub type getattrofunc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut PyObject) -> *mut PyObject,
>;
pub type reprfunc = Option::<unsafe extern "C" fn(*mut PyObject) -> *mut PyObject>;
pub type ternaryfunc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut PyObject, *mut PyObject) -> *mut PyObject,
>;
pub type hashfunc = Option::<unsafe extern "C" fn(*mut PyObject) -> i64>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyMappingMethods {
    pub mp_length: lenfunc,
    pub mp_subscript: binaryfunc,
    pub mp_ass_subscript: objobjargproc,
}
pub type objobjargproc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut PyObject, *mut PyObject) -> i32,
>;
pub type binaryfunc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut PyObject) -> *mut PyObject,
>;
pub type lenfunc = Option::<unsafe extern "C" fn(*mut PyObject) -> Py_ssize_t>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PySequenceMethods {
    pub sq_length: lenfunc,
    pub sq_concat: binaryfunc,
    pub sq_repeat: ssizeargfunc,
    pub sq_item: ssizeargfunc,
    pub sq_slice: ssizessizeargfunc,
    pub sq_ass_item: ssizeobjargproc,
    pub sq_ass_slice: ssizessizeobjargproc,
    pub sq_contains: objobjproc,
    pub sq_inplace_concat: binaryfunc,
    pub sq_inplace_repeat: ssizeargfunc,
}
pub type ssizeargfunc = Option::<
    unsafe extern "C" fn(*mut PyObject, Py_ssize_t) -> *mut PyObject,
>;
pub type objobjproc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut PyObject) -> i32,
>;
pub type ssizessizeobjargproc = Option::<
    unsafe extern "C" fn(
        *mut PyObject,
        Py_ssize_t,
        Py_ssize_t,
        *mut PyObject,
    ) -> i32,
>;
pub type ssizeobjargproc = Option::<
    unsafe extern "C" fn(*mut PyObject, Py_ssize_t, *mut PyObject) -> i32,
>;
pub type ssizessizeargfunc = Option::<
    unsafe extern "C" fn(*mut PyObject, Py_ssize_t, Py_ssize_t) -> *mut PyObject,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyNumberMethods {
    pub nb_add: binaryfunc,
    pub nb_subtract: binaryfunc,
    pub nb_multiply: binaryfunc,
    pub nb_divide: binaryfunc,
    pub nb_remainder: binaryfunc,
    pub nb_divmod: binaryfunc,
    pub nb_power: ternaryfunc,
    pub nb_negative: unaryfunc,
    pub nb_positive: unaryfunc,
    pub nb_absolute: unaryfunc,
    pub nb_nonzero: inquiry,
    pub nb_invert: unaryfunc,
    pub nb_lshift: binaryfunc,
    pub nb_rshift: binaryfunc,
    pub nb_and: binaryfunc,
    pub nb_xor: binaryfunc,
    pub nb_or: binaryfunc,
    pub nb_coerce: coercion,
    pub nb_int: unaryfunc,
    pub nb_long: unaryfunc,
    pub nb_float: unaryfunc,
    pub nb_oct: unaryfunc,
    pub nb_hex: unaryfunc,
    pub nb_inplace_add: binaryfunc,
    pub nb_inplace_subtract: binaryfunc,
    pub nb_inplace_multiply: binaryfunc,
    pub nb_inplace_divide: binaryfunc,
    pub nb_inplace_remainder: binaryfunc,
    pub nb_inplace_power: ternaryfunc,
    pub nb_inplace_lshift: binaryfunc,
    pub nb_inplace_rshift: binaryfunc,
    pub nb_inplace_and: binaryfunc,
    pub nb_inplace_xor: binaryfunc,
    pub nb_inplace_or: binaryfunc,
    pub nb_floor_divide: binaryfunc,
    pub nb_true_divide: binaryfunc,
    pub nb_inplace_floor_divide: binaryfunc,
    pub nb_inplace_true_divide: binaryfunc,
    pub nb_index: unaryfunc,
}
pub type unaryfunc = Option::<unsafe extern "C" fn(*mut PyObject) -> *mut PyObject>;
pub type coercion = Option::<
    unsafe extern "C" fn(*mut *mut PyObject, *mut *mut PyObject) -> i32,
>;
pub type cmpfunc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut PyObject) -> i32,
>;
pub type setattrfunc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut i8, *mut PyObject) -> i32,
>;
pub type getattrfunc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut i8) -> *mut PyObject,
>;
pub type printfunc = Option::<
    unsafe extern "C" fn(*mut PyObject, *mut FILE, i32) -> i32,
>;
pub type PyTypeObject = _typeobject;
pub type xmlChar = u8;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserInputBuffer {
    pub context: *mut libc::c_void,
    pub readcallback: xmlInputReadCallback,
    pub closecallback: xmlInputCloseCallback,
    pub encoder: xmlCharEncodingHandlerPtr,
    pub buffer: xmlBufPtr,
    pub raw: xmlBufPtr,
    pub compressed: i32,
    pub error: i32,
    pub rawconsumed: u64,
}
pub type xmlBufPtr = *mut xmlBuf;
pub type xmlBuf = _xmlBuf;
pub type xmlCharEncodingHandlerPtr = *mut xmlCharEncodingHandler;
pub type xmlCharEncodingHandler = _xmlCharEncodingHandler;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlCharEncodingHandler {
    pub name: *mut i8,
    pub input: xmlCharEncodingInputFunc,
    pub output: xmlCharEncodingOutputFunc,
    pub iconv_in: iconv_t,
    pub iconv_out: iconv_t,
}
pub type iconv_t = *mut libc::c_void;
pub type xmlCharEncodingOutputFunc = Option::<
    unsafe extern "C" fn(
        *mut u8,
        *mut i32,
        *const u8,
        *mut i32,
    ) -> i32,
>;
pub type xmlCharEncodingInputFunc = Option::<
    unsafe extern "C" fn(
        *mut u8,
        *mut i32,
        *const u8,
        *mut i32,
    ) -> i32,
>;
pub type xmlInputCloseCallback = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> i32,
>;
pub type xmlInputReadCallback = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *mut i8,
        i32,
    ) -> i32,
>;
pub type xmlParserInputBuffer = _xmlParserInputBuffer;
pub type xmlParserInputBufferPtr = *mut xmlParserInputBuffer;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlOutputBuffer {
    pub context: *mut libc::c_void,
    pub writecallback: xmlOutputWriteCallback,
    pub closecallback: xmlOutputCloseCallback,
    pub encoder: xmlCharEncodingHandlerPtr,
    pub buffer: xmlBufPtr,
    pub conv: xmlBufPtr,
    pub written: i32,
    pub error: i32,
}
pub type xmlOutputCloseCallback = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> i32,
>;
pub type xmlOutputWriteCallback = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const i8,
        i32,
    ) -> i32,
>;
pub type xmlOutputBuffer = _xmlOutputBuffer;
pub type xmlOutputBufferPtr = *mut xmlOutputBuffer;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserInput {
    pub buf: xmlParserInputBufferPtr,
    pub filename: *const i8,
    pub directory: *const i8,
    pub base: *const xmlChar,
    pub cur: *const xmlChar,
    pub end: *const xmlChar,
    pub length: i32,
    pub line: i32,
    pub col: i32,
    pub consumed: u64,
    pub free: xmlParserInputDeallocate,
    pub encoding: *const xmlChar,
    pub version: *const xmlChar,
    pub standalone: i32,
    pub id: i32,
}
pub type xmlParserInputDeallocate = Option::<unsafe extern "C" fn(*mut xmlChar) -> ()>;
pub type xmlParserInput = _xmlParserInput;
pub type xmlParserInputPtr = *mut xmlParserInput;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserCtxt {
    pub sax: *mut _xmlSAXHandler,
    pub userData: *mut libc::c_void,
    pub myDoc: xmlDocPtr,
    pub wellFormed: i32,
    pub replaceEntities: i32,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub standalone: i32,
    pub html: i32,
    pub input: xmlParserInputPtr,
    pub inputNr: i32,
    pub inputMax: i32,
    pub inputTab: *mut xmlParserInputPtr,
    pub node: xmlNodePtr,
    pub nodeNr: i32,
    pub nodeMax: i32,
    pub nodeTab: *mut xmlNodePtr,
    pub record_info: i32,
    pub node_seq: xmlParserNodeInfoSeq,
    pub errNo: i32,
    pub hasExternalSubset: i32,
    pub hasPErefs: i32,
    pub external: i32,
    pub valid: i32,
    pub validate: i32,
    pub vctxt: xmlValidCtxt,
    pub instate: xmlParserInputState,
    pub token: i32,
    pub directory: *mut i8,
    pub name: *const xmlChar,
    pub nameNr: i32,
    pub nameMax: i32,
    pub nameTab: *mut *const xmlChar,
    pub nbChars: i64,
    pub checkIndex: i64,
    pub keepBlanks: i32,
    pub disableSAX: i32,
    pub inSubset: i32,
    pub intSubName: *const xmlChar,
    pub extSubURI: *mut xmlChar,
    pub extSubSystem: *mut xmlChar,
    pub space: *mut i32,
    pub spaceNr: i32,
    pub spaceMax: i32,
    pub spaceTab: *mut i32,
    pub depth: i32,
    pub entity: xmlParserInputPtr,
    pub charset: i32,
    pub nodelen: i32,
    pub nodemem: i32,
    pub pedantic: i32,
    pub _private: *mut libc::c_void,
    pub loadsubset: i32,
    pub linenumbers: i32,
    pub catalogs: *mut libc::c_void,
    pub recovery: i32,
    pub progressive: i32,
    pub dict: xmlDictPtr,
    pub atts: *mut *const xmlChar,
    pub maxatts: i32,
    pub docdict: i32,
    pub str_xml: *const xmlChar,
    pub str_xmlns: *const xmlChar,
    pub str_xml_ns: *const xmlChar,
    pub sax2: i32,
    pub nsNr: i32,
    pub nsMax: i32,
    pub nsTab: *mut *const xmlChar,
    pub attallocs: *mut i32,
    pub pushTab: *mut xmlStartTag,
    pub attsDefault: xmlHashTablePtr,
    pub attsSpecial: xmlHashTablePtr,
    pub nsWellFormed: i32,
    pub options: i32,
    pub dictNames: i32,
    pub freeElemsNr: i32,
    pub freeElems: xmlNodePtr,
    pub freeAttrsNr: i32,
    pub freeAttrs: xmlAttrPtr,
    pub lastError: xmlError,
    pub parseMode: xmlParserMode,
    pub nbentities: u64,
    pub sizeentities: u64,
    pub nodeInfo: *mut xmlParserNodeInfo,
    pub nodeInfoNr: i32,
    pub nodeInfoMax: i32,
    pub nodeInfoTab: *mut xmlParserNodeInfo,
    pub input_id: i32,
    pub sizeentcopy: u64,
}
pub type xmlParserNodeInfo = _xmlParserNodeInfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserNodeInfo {
    pub node: *const _xmlNode,
    pub begin_pos: u64,
    pub begin_line: u64,
    pub end_pos: u64,
    pub end_line: u64,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNode {
    pub _private: *mut libc::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub content: *mut xmlChar,
    pub properties: *mut _xmlAttr,
    pub nsDef: *mut xmlNs,
    pub psvi: *mut libc::c_void,
    pub line: u16,
    pub extra: u16,
}
pub type xmlNs = _xmlNs;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNs {
    pub next: *mut _xmlNs,
    pub type_0: xmlNsType,
    pub href: *const xmlChar,
    pub prefix: *const xmlChar,
    pub _private: *mut libc::c_void,
    pub context: *mut _xmlDoc,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDoc {
    pub _private: *mut libc::c_void,
    pub type_0: xmlElementType,
    pub name: *mut i8,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub compression: i32,
    pub standalone: i32,
    pub intSubset: *mut _xmlDtd,
    pub extSubset: *mut _xmlDtd,
    pub oldNs: *mut _xmlNs,
    pub version: *const xmlChar,
    pub encoding: *const xmlChar,
    pub ids: *mut libc::c_void,
    pub refs: *mut libc::c_void,
    pub URL: *const xmlChar,
    pub charset: i32,
    pub dict: *mut _xmlDict,
    pub psvi: *mut libc::c_void,
    pub parseFlags: i32,
    pub properties: i32,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlDtd {
    pub _private: *mut libc::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDoc,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub notations: *mut libc::c_void,
    pub elements: *mut libc::c_void,
    pub attributes: *mut libc::c_void,
    pub entities: *mut libc::c_void,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub pentities: *mut libc::c_void,
}
=======
// #[derive(Copy, Clone)]

pub type _IO_FILE = crate::src::python::libxml::_IO_FILE;
pub type _IO_lock_t = ();
pub type FILE = crate::src::python::libxml::_IO_FILE;
pub type ssize_t = i64;
pub type Py_ssize_t = i64;
// #[derive(Copy, Clone)]

pub type _object = crate::src::python::libxml::_object;
// #[derive(Copy, Clone)]

pub type _typeobject = crate::src::python::libxml::_typeobject;
pub type destructor<'a1> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,) -> ()>;
pub type PyObject = crate::src::python::libxml::_object;
pub type inquiry<'a1> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,) -> i32>;
pub type freefunc<'a1> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,) -> ()>;
pub type newfunc<'a1, 'a2, 'a3, 'a4> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_typeobject>,_: Option<&'a2 mut crate::src::python::libxml::_object>,_: Option<&'a3 mut crate::src::python::libxml::_object>,) -> Option<&'a4 mut crate::src::python::libxml::_object>>;
pub type allocfunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_typeobject>,_: i64,) -> Option<&'a2 mut crate::src::python::libxml::_object>>;
pub type initproc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut crate::src::python::libxml::_object>,_: Option<&'a3 mut crate::src::python::libxml::_object>,) -> i32>;
pub type descrsetfunc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut crate::src::python::libxml::_object>,_: Option<&'a3 mut crate::src::python::libxml::_object>,) -> i32>;
pub type descrgetfunc<'a1, 'a2, 'a3, 'a4> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut crate::src::python::libxml::_object>,_: Option<&'a3 mut crate::src::python::libxml::_object>,) -> Option<&'a4 mut crate::src::python::libxml::_object>>;
// #[derive(Copy, Clone)]

pub type PyGetSetDef = crate::src::python::libxml::PyGetSetDef;
pub type setter<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut crate::src::python::libxml::_object>,_: Option<&'a3 mut core::ffi::c_void>,) -> i32>;
pub type getter<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut core::ffi::c_void>,) -> Option<&'a3 mut crate::src::python::libxml::_object>>;
// #[derive(Copy, Clone)]

pub type PyMethodDef = crate::src::python::libxml::PyMethodDef;
pub type PyCFunction<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut crate::src::python::libxml::_object>,) -> Option<&'a3 mut crate::src::python::libxml::_object>>;
pub type iternextfunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,) -> Option<&'a2 mut crate::src::python::libxml::_object>>;
pub type getiterfunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,) -> Option<&'a2 mut crate::src::python::libxml::_object>>;
pub type richcmpfunc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut crate::src::python::libxml::_object>,_: i32,) -> Option<&'a3 mut crate::src::python::libxml::_object>>;
pub type traverseproc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<unsafe extern "C"  fn(_: * mut crate::src::python::libxml::_object,_: * mut core::ffi::c_void,) -> i32>,_: Option<&'a2 mut core::ffi::c_void>,) -> i32>;
pub type visitproc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut core::ffi::c_void>,) -> i32>;
// #[derive(Copy, Clone)]

pub type PyBufferProcs = crate::src::python::libxml::PyBufferProcs;
pub type releasebufferproc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut crate::src::python::libxml::bufferinfo>,) -> ()>;
pub type Py_buffer = crate::src::python::libxml::bufferinfo;
// #[derive(Copy, Clone)]

pub type bufferinfo = crate::src::python::libxml::bufferinfo;
pub type getbufferproc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut crate::src::python::libxml::bufferinfo>,_: i32,) -> i32>;
pub type charbufferproc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: i64,_: Option<&'a2 mut Option<&'a3 mut i8>>,) -> i64>;
pub type segcountproc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut i64>,) -> i64>;
pub type writebufferproc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: i64,_: Option<&'a2 mut Option<&'a3 mut core::ffi::c_void>>,) -> i64>;
pub type readbufferproc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: i64,_: Option<&'a2 mut Option<&'a3 mut core::ffi::c_void>>,) -> i64>;
pub type setattrofunc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut crate::src::python::libxml::_object>,_: Option<&'a3 mut crate::src::python::libxml::_object>,) -> i32>;
pub type getattrofunc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut crate::src::python::libxml::_object>,) -> Option<&'a3 mut crate::src::python::libxml::_object>>;
pub type reprfunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,) -> Option<&'a2 mut crate::src::python::libxml::_object>>;
pub type ternaryfunc<'a1, 'a2, 'a3, 'a4> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut crate::src::python::libxml::_object>,_: Option<&'a3 mut crate::src::python::libxml::_object>,) -> Option<&'a4 mut crate::src::python::libxml::_object>>;
pub type hashfunc<'a1> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,) -> i64>;
// #[derive(Copy, Clone)]

pub type PyMappingMethods = crate::src::python::libxml::PyMappingMethods;
pub type objobjargproc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut crate::src::python::libxml::_object>,_: Option<&'a3 mut crate::src::python::libxml::_object>,) -> i32>;
pub type binaryfunc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut crate::src::python::libxml::_object>,) -> Option<&'a3 mut crate::src::python::libxml::_object>>;
pub type lenfunc<'a1> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,) -> i64>;
// #[derive(Copy, Clone)]

pub type PySequenceMethods = crate::src::python::libxml::PySequenceMethods;
pub type ssizeargfunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: i64,) -> Option<&'a2 mut crate::src::python::libxml::_object>>;
pub type objobjproc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut crate::src::python::libxml::_object>,) -> i32>;
pub type ssizessizeobjargproc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: i64,_: i64,_: Option<&'a2 mut crate::src::python::libxml::_object>,) -> i32>;
pub type ssizeobjargproc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: i64,_: Option<&'a2 mut crate::src::python::libxml::_object>,) -> i32>;
pub type ssizessizeargfunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: i64,_: i64,) -> Option<&'a2 mut crate::src::python::libxml::_object>>;
// #[derive(Copy, Clone)]

pub type PyNumberMethods = crate::src::python::libxml::PyNumberMethods;
pub type unaryfunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,) -> Option<&'a2 mut crate::src::python::libxml::_object>>;
pub type coercion<'a1, 'a2, 'a3, 'a4> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut Option<&'a2 mut crate::src::python::libxml::_object>>,_: Option<&'a3 mut Option<&'a4 mut crate::src::python::libxml::_object>>,) -> i32>;
pub type cmpfunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut crate::src::python::libxml::_object>,) -> i32>;
pub type setattrfunc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut i8>,_: Option<&'a3 mut crate::src::python::libxml::_object>,) -> i32>;
pub type getattrfunc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut i8>,) -> Option<&'a3 mut crate::src::python::libxml::_object>>;
pub type printfunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_object>,_: Option<&'a2 mut crate::src::python::libxml::_IO_FILE>,_: i32,) -> i32>;
pub type PyTypeObject = crate::src::python::libxml::_typeobject;
pub type xmlChar = u8;
// #[derive(Copy, Clone)]

pub type _xmlParserInputBuffer = crate::src::python::libxml::_xmlParserInputBuffer;
pub type xmlBufPtr = * mut crate::src::python::libxml::_xmlBuf;
pub type xmlBuf = crate::src::python::libxml::_xmlBuf;
pub type xmlCharEncodingHandlerPtr = * mut crate::src::python::libxml::_xmlCharEncodingHandler;
pub type xmlCharEncodingHandler = crate::src::python::libxml::_xmlCharEncodingHandler;
// #[derive(Copy, Clone)]

pub type _xmlCharEncodingHandler = crate::src::python::libxml::_xmlCharEncodingHandler;
pub type iconv_t = * mut core::ffi::c_void;
pub type xmlCharEncodingOutputFunc<'a1, 'a2, 'a3, 'a4> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut u8>,_: Option<&'a2 mut i32>,_: Option<&'a3 u8>,_: Option<&'a4 mut i32>,) -> i32>;
pub type xmlCharEncodingInputFunc<'a1, 'a2, 'a3, 'a4> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut u8>,_: Option<&'a2 mut i32>,_: Option<&'a3 u8>,_: Option<&'a4 mut i32>,) -> i32>;
pub type xmlInputCloseCallback<'a1> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,) -> i32>;
pub type xmlInputReadCallback<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 mut i8>,_: i32,) -> i32>;
pub type xmlParserInputBuffer = crate::src::python::libxml::_xmlParserInputBuffer;
pub type xmlParserInputBufferPtr = * mut crate::src::python::libxml::_xmlParserInputBuffer;
// #[derive(Copy, Clone)]

pub type _xmlOutputBuffer = crate::src::python::libxml::_xmlOutputBuffer;
pub type xmlOutputCloseCallback<'a1> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,) -> i32>;
pub type xmlOutputWriteCallback<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 i8>,_: i32,) -> i32>;
pub type xmlOutputBuffer = crate::src::python::libxml::_xmlOutputBuffer;
pub type xmlOutputBufferPtr = * mut crate::src::python::libxml::_xmlOutputBuffer;
// #[derive(Copy, Clone)]

pub type _xmlParserInput = crate::src::python::libxml::_xmlParserInput;
pub type xmlParserInputDeallocate<'a1> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut u8>,) -> ()>;
pub type xmlParserInput = crate::src::python::libxml::_xmlParserInput;
pub type xmlParserInputPtr = * mut crate::src::python::libxml::_xmlParserInput;
// #[derive(Copy, Clone)]

pub type _xmlParserCtxt = crate::src::python::libxml::_xmlParserCtxt;
pub type xmlParserNodeInfo = crate::src::python::libxml::_xmlParserNodeInfo;
// #[derive(Copy, Clone)]

pub type _xmlParserNodeInfo = crate::src::python::libxml::_xmlParserNodeInfo;
// #[derive(Copy, Clone)]

pub type _xmlNode = crate::src::python::libxml::_xmlNode;
pub type xmlNs = crate::src::python::libxml::_xmlNs;
// #[derive(Copy, Clone)]

pub type _xmlNs = crate::src::python::libxml::_xmlNs;
// #[derive(Copy, Clone)]

pub type _xmlDoc = crate::src::python::libxml::_xmlDoc;
// #[derive(Copy, Clone)]

pub type _xmlDtd = crate::src::python::libxml::_xmlDtd;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
pub type xmlElementType = u32;
pub const XML_XINCLUDE_END: xmlElementType = 20;
pub const XML_XINCLUDE_START: xmlElementType = 19;
pub const XML_NAMESPACE_DECL: xmlElementType = 18;
pub const XML_ENTITY_DECL: xmlElementType = 17;
pub const XML_ATTRIBUTE_DECL: xmlElementType = 16;
pub const XML_ELEMENT_DECL: xmlElementType = 15;
pub const XML_DTD_NODE: xmlElementType = 14;
pub const XML_HTML_DOCUMENT_NODE: xmlElementType = 13;
pub const XML_NOTATION_NODE: xmlElementType = 12;
pub const XML_DOCUMENT_FRAG_NODE: xmlElementType = 11;
pub const XML_DOCUMENT_TYPE_NODE: xmlElementType = 10;
pub const XML_DOCUMENT_NODE: xmlElementType = 9;
pub const XML_COMMENT_NODE: xmlElementType = 8;
pub const XML_PI_NODE: xmlElementType = 7;
pub const XML_ENTITY_NODE: xmlElementType = 6;
pub const XML_ENTITY_REF_NODE: xmlElementType = 5;
pub const XML_CDATA_SECTION_NODE: xmlElementType = 4;
pub const XML_TEXT_NODE: xmlElementType = 3;
pub const XML_ATTRIBUTE_NODE: xmlElementType = 2;
pub const XML_ELEMENT_NODE: xmlElementType = 1;
<<<<<<< HEAD
pub type xmlNsType = xmlElementType;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlAttr {
    pub _private: *mut libc::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlNode,
    pub next: *mut _xmlAttr,
    pub prev: *mut _xmlAttr,
    pub doc: *mut _xmlDoc,
    pub ns: *mut xmlNs,
    pub atype: xmlAttributeType,
    pub psvi: *mut libc::c_void,
}
=======
pub type xmlNsType = u32;
// #[derive(Copy, Clone)]

pub type _xmlAttr = crate::src::python::libxml::_xmlAttr;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
pub type xmlAttributeType = u32;
pub const XML_ATTRIBUTE_NOTATION: xmlAttributeType = 10;
pub const XML_ATTRIBUTE_ENUMERATION: xmlAttributeType = 9;
pub const XML_ATTRIBUTE_NMTOKENS: xmlAttributeType = 8;
pub const XML_ATTRIBUTE_NMTOKEN: xmlAttributeType = 7;
pub const XML_ATTRIBUTE_ENTITIES: xmlAttributeType = 6;
pub const XML_ATTRIBUTE_ENTITY: xmlAttributeType = 5;
pub const XML_ATTRIBUTE_IDREFS: xmlAttributeType = 4;
pub const XML_ATTRIBUTE_IDREF: xmlAttributeType = 3;
pub const XML_ATTRIBUTE_ID: xmlAttributeType = 2;
pub const XML_ATTRIBUTE_CDATA: xmlAttributeType = 1;
pub type xmlParserMode = u32;
pub const XML_PARSE_READER: xmlParserMode = 5;
pub const XML_PARSE_PUSH_SAX: xmlParserMode = 4;
pub const XML_PARSE_PUSH_DOM: xmlParserMode = 3;
pub const XML_PARSE_SAX: xmlParserMode = 2;
pub const XML_PARSE_DOM: xmlParserMode = 1;
pub const XML_PARSE_UNKNOWN: xmlParserMode = 0;
<<<<<<< HEAD
pub type xmlError = _xmlError;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlError {
    pub domain: i32,
    pub code: i32,
    pub message: *mut i8,
    pub level: xmlErrorLevel,
    pub file: *mut i8,
    pub line: i32,
    pub str1: *mut i8,
    pub str2: *mut i8,
    pub str3: *mut i8,
    pub int1: i32,
    pub int2: i32,
    pub ctxt: *mut libc::c_void,
    pub node: *mut libc::c_void,
}
=======
pub type xmlError = crate::src::python::libxml::_xmlError;
// #[derive(Copy, Clone)]

pub type _xmlError = crate::src::python::libxml::_xmlError;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
pub type xmlErrorLevel = u32;
pub const XML_ERR_FATAL: xmlErrorLevel = 3;
pub const XML_ERR_ERROR: xmlErrorLevel = 2;
pub const XML_ERR_WARNING: xmlErrorLevel = 1;
pub const XML_ERR_NONE: xmlErrorLevel = 0;
<<<<<<< HEAD
pub type xmlAttrPtr = *mut xmlAttr;
pub type xmlAttr = _xmlAttr;
pub type xmlNodePtr = *mut xmlNode;
pub type xmlNode = _xmlNode;
pub type xmlHashTablePtr = *mut xmlHashTable;
pub type xmlHashTable = _xmlHashTable;
pub type xmlStartTag = _xmlStartTag;
pub type xmlDictPtr = *mut xmlDict;
pub type xmlDict = _xmlDict;
=======
pub type xmlAttrPtr = * mut crate::src::python::libxml::_xmlAttr;
pub type xmlAttr = crate::src::python::libxml::_xmlAttr;
pub type xmlNodePtr = * mut crate::src::python::libxml::_xmlNode;
pub type xmlNode = crate::src::python::libxml::_xmlNode;
pub type xmlHashTablePtr = * mut crate::src::python::libxml2_py::_xmlHashTable;
pub type xmlHashTable = crate::src::python::libxml2_py::_xmlHashTable;
pub type xmlStartTag = crate::src::python::libxml2_py::_xmlStartTag;
pub type xmlDictPtr = * mut crate::src::python::types::_xmlDict;
pub type xmlDict = crate::src::python::types::_xmlDict;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
pub type xmlParserInputState = i32;
pub const XML_PARSER_PUBLIC_LITERAL: xmlParserInputState = 16;
pub const XML_PARSER_IGNORE: xmlParserInputState = 15;
pub const XML_PARSER_EPILOG: xmlParserInputState = 14;
pub const XML_PARSER_SYSTEM_LITERAL: xmlParserInputState = 13;
pub const XML_PARSER_ATTRIBUTE_VALUE: xmlParserInputState = 12;
pub const XML_PARSER_ENTITY_VALUE: xmlParserInputState = 11;
pub const XML_PARSER_ENTITY_DECL: xmlParserInputState = 10;
pub const XML_PARSER_END_TAG: xmlParserInputState = 9;
pub const XML_PARSER_CDATA_SECTION: xmlParserInputState = 8;
pub const XML_PARSER_CONTENT: xmlParserInputState = 7;
pub const XML_PARSER_START_TAG: xmlParserInputState = 6;
pub const XML_PARSER_COMMENT: xmlParserInputState = 5;
pub const XML_PARSER_PROLOG: xmlParserInputState = 4;
pub const XML_PARSER_DTD: xmlParserInputState = 3;
pub const XML_PARSER_PI: xmlParserInputState = 2;
pub const XML_PARSER_MISC: xmlParserInputState = 1;
pub const XML_PARSER_START: xmlParserInputState = 0;
pub const XML_PARSER_EOF: xmlParserInputState = -1;
<<<<<<< HEAD
pub type xmlValidCtxt = _xmlValidCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlValidCtxt {
    pub userData: *mut libc::c_void,
    pub error: xmlValidityErrorFunc,
    pub warning: xmlValidityWarningFunc,
    pub node: xmlNodePtr,
    pub nodeNr: i32,
    pub nodeMax: i32,
    pub nodeTab: *mut xmlNodePtr,
    pub flags: u32,
    pub doc: xmlDocPtr,
    pub valid: i32,
    pub vstate: *mut xmlValidState,
    pub vstateNr: i32,
    pub vstateMax: i32,
    pub vstateTab: *mut xmlValidState,
    pub am: xmlAutomataPtr,
    pub state: xmlAutomataStatePtr,
}
pub type xmlAutomataStatePtr = *mut xmlAutomataState;
pub type xmlAutomataState = _xmlAutomataState;
pub type xmlAutomataPtr = *mut xmlAutomata;
pub type xmlAutomata = _xmlAutomata;
pub type xmlValidState = _xmlValidState;
pub type xmlDocPtr = *mut xmlDoc;
pub type xmlDoc = _xmlDoc;
pub type xmlValidityWarningFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const i8, ...) -> (),
>;
pub type xmlValidityErrorFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const i8, ...) -> (),
>;
pub type xmlParserNodeInfoSeq = _xmlParserNodeInfoSeq;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlParserNodeInfoSeq {
    pub maximum: u64,
    pub length: u64,
    pub buffer: *mut xmlParserNodeInfo,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXHandler {
    pub internalSubset: internalSubsetSAXFunc,
    pub isStandalone: isStandaloneSAXFunc,
    pub hasInternalSubset: hasInternalSubsetSAXFunc,
    pub hasExternalSubset: hasExternalSubsetSAXFunc,
    pub resolveEntity: resolveEntitySAXFunc,
    pub getEntity: getEntitySAXFunc,
    pub entityDecl: entityDeclSAXFunc,
    pub notationDecl: notationDeclSAXFunc,
    pub attributeDecl: attributeDeclSAXFunc,
    pub elementDecl: elementDeclSAXFunc,
    pub unparsedEntityDecl: unparsedEntityDeclSAXFunc,
    pub setDocumentLocator: setDocumentLocatorSAXFunc,
    pub startDocument: startDocumentSAXFunc,
    pub endDocument: endDocumentSAXFunc,
    pub startElement: startElementSAXFunc,
    pub endElement: endElementSAXFunc,
    pub reference: referenceSAXFunc,
    pub characters: charactersSAXFunc,
    pub ignorableWhitespace: ignorableWhitespaceSAXFunc,
    pub processingInstruction: processingInstructionSAXFunc,
    pub comment: commentSAXFunc,
    pub warning: warningSAXFunc,
    pub error: errorSAXFunc,
    pub fatalError: fatalErrorSAXFunc,
    pub getParameterEntity: getParameterEntitySAXFunc,
    pub cdataBlock: cdataBlockSAXFunc,
    pub externalSubset: externalSubsetSAXFunc,
    pub initialized: u32,
    pub _private: *mut libc::c_void,
    pub startElementNs: startElementNsSAX2Func,
    pub endElementNs: endElementNsSAX2Func,
    pub serror: xmlStructuredErrorFunc,
}
pub type xmlStructuredErrorFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, xmlErrorPtr) -> (),
>;
pub type xmlErrorPtr = *mut xmlError;
pub type endElementNsSAX2Func = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
        *const xmlChar,
    ) -> (),
>;
pub type startElementNsSAX2Func = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
        *const xmlChar,
        i32,
        *mut *const xmlChar,
        i32,
        i32,
        *mut *const xmlChar,
    ) -> (),
>;
pub type externalSubsetSAXFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
        *const xmlChar,
    ) -> (),
>;
pub type cdataBlockSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar, i32) -> (),
>;
pub type getParameterEntitySAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> xmlEntityPtr,
>;
pub type xmlEntityPtr = *mut xmlEntity;
pub type xmlEntity = _xmlEntity;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlEntity {
    pub _private: *mut libc::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDtd,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub orig: *mut xmlChar,
    pub content: *mut xmlChar,
    pub length: i32,
    pub etype: xmlEntityType,
    pub ExternalID: *const xmlChar,
    pub SystemID: *const xmlChar,
    pub nexte: *mut _xmlEntity,
    pub URI: *const xmlChar,
    pub owner: i32,
    pub checked: i32,
}
=======
pub type xmlValidCtxt = crate::src::python::libxml::_xmlValidCtxt;
// #[derive(Copy, Clone)]

pub type _xmlValidCtxt = crate::src::python::libxml::_xmlValidCtxt;
pub type xmlAutomataStatePtr = * mut crate::src::python::types::_xmlAutomataState;
pub type xmlAutomataState = crate::src::python::types::_xmlAutomataState;
pub type xmlAutomataPtr = * mut crate::src::python::types::_xmlAutomata;
pub type xmlAutomata = crate::src::python::types::_xmlAutomata;
pub type xmlValidState = crate::src::python::types::_xmlValidState;
pub type xmlDocPtr = * mut crate::src::python::libxml::_xmlDoc;
pub type xmlDoc = crate::src::python::libxml::_xmlDoc;
pub type xmlValidityWarningFunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 i8>,...) -> ()>;
pub type xmlValidityErrorFunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 i8>,...) -> ()>;
pub type xmlParserNodeInfoSeq = crate::src::python::libxml::_xmlParserNodeInfoSeq;
// #[derive(Copy, Clone)]

pub type _xmlParserNodeInfoSeq = crate::src::python::libxml::_xmlParserNodeInfoSeq;
// #[derive(Copy, Clone)]

pub type _xmlSAXHandler = crate::src::python::libxml::_xmlSAXHandler;
pub type xmlStructuredErrorFunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 mut crate::src::python::libxml::_xmlError>,) -> ()>;
pub type xmlErrorPtr = * mut crate::src::python::libxml::_xmlError;
pub type endElementNsSAX2Func<'a1, 'a2, 'a3, 'a4> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,_: Option<&'a3 u8>,_: Option<&'a4 u8>,) -> ()>;
pub type startElementNsSAX2Func<'a1, 'a2, 'a3, 'a4, 'a5, 'a6, 'a7, 'a8> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,_: Option<&'a3 u8>,_: Option<&'a4 u8>,_: i32,_: Option<&'a5 mut Option<&'a6 u8>>,_: i32,_: i32,_: Option<&'a7 mut Option<&'a8 u8>>,) -> ()>;
pub type externalSubsetSAXFunc<'a1, 'a2, 'a3, 'a4> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,_: Option<&'a3 u8>,_: Option<&'a4 u8>,) -> ()>;
pub type cdataBlockSAXFunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,_: i32,) -> ()>;
pub type getParameterEntitySAXFunc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,) -> Option<&'a3 mut crate::src::python::libxml::_xmlEntity>>;
pub type xmlEntityPtr = * mut crate::src::python::libxml::_xmlEntity;
pub type xmlEntity = crate::src::python::libxml::_xmlEntity;
// #[derive(Copy, Clone)]

pub type _xmlEntity = crate::src::python::libxml::_xmlEntity;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
pub type xmlEntityType = u32;
pub const XML_INTERNAL_PREDEFINED_ENTITY: xmlEntityType = 6;
pub const XML_EXTERNAL_PARAMETER_ENTITY: xmlEntityType = 5;
pub const XML_INTERNAL_PARAMETER_ENTITY: xmlEntityType = 4;
pub const XML_EXTERNAL_GENERAL_UNPARSED_ENTITY: xmlEntityType = 3;
pub const XML_EXTERNAL_GENERAL_PARSED_ENTITY: xmlEntityType = 2;
pub const XML_INTERNAL_GENERAL_ENTITY: xmlEntityType = 1;
<<<<<<< HEAD
pub type fatalErrorSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const i8, ...) -> (),
>;
pub type errorSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const i8, ...) -> (),
>;
pub type warningSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const i8, ...) -> (),
>;
pub type commentSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
>;
pub type processingInstructionSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar, *const xmlChar) -> (),
>;
pub type ignorableWhitespaceSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar, i32) -> (),
>;
pub type charactersSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar, i32) -> (),
>;
pub type referenceSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
>;
pub type endElementSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
>;
pub type startElementSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar, *mut *const xmlChar) -> (),
>;
pub type endDocumentSAXFunc = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type startDocumentSAXFunc = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type setDocumentLocatorSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, xmlSAXLocatorPtr) -> (),
>;
pub type xmlSAXLocatorPtr = *mut xmlSAXLocator;
pub type xmlSAXLocator = _xmlSAXLocator;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSAXLocator {
    pub getPublicId: Option::<unsafe extern "C" fn(*mut libc::c_void) -> *const xmlChar>,
    pub getSystemId: Option::<unsafe extern "C" fn(*mut libc::c_void) -> *const xmlChar>,
    pub getLineNumber: Option::<unsafe extern "C" fn(*mut libc::c_void) -> i32>,
    pub getColumnNumber: Option::<
        unsafe extern "C" fn(*mut libc::c_void) -> i32,
    >,
}
pub type unparsedEntityDeclSAXFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
        *const xmlChar,
        *const xmlChar,
    ) -> (),
>;
pub type elementDeclSAXFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        i32,
        xmlElementContentPtr,
    ) -> (),
>;
pub type xmlElementContentPtr = *mut xmlElementContent;
pub type xmlElementContent = _xmlElementContent;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlElementContent {
    pub type_0: xmlElementContentType,
    pub ocur: xmlElementContentOccur,
    pub name: *const xmlChar,
    pub c1: *mut _xmlElementContent,
    pub c2: *mut _xmlElementContent,
    pub parent: *mut _xmlElementContent,
    pub prefix: *const xmlChar,
}
=======
pub type fatalErrorSAXFunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 i8>,...) -> ()>;
pub type errorSAXFunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 i8>,...) -> ()>;
pub type warningSAXFunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 i8>,...) -> ()>;
pub type commentSAXFunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,) -> ()>;
pub type processingInstructionSAXFunc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,_: Option<&'a3 u8>,) -> ()>;
pub type ignorableWhitespaceSAXFunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,_: i32,) -> ()>;
pub type charactersSAXFunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,_: i32,) -> ()>;
pub type referenceSAXFunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,) -> ()>;
pub type endElementSAXFunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,) -> ()>;
pub type startElementSAXFunc<'a1, 'a2, 'a3, 'a4> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,_: Option<&'a3 mut Option<&'a4 u8>>,) -> ()>;
pub type endDocumentSAXFunc<'a1> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,) -> ()>;
pub type startDocumentSAXFunc<'a1> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,) -> ()>;
pub type setDocumentLocatorSAXFunc<'a1, 'a2> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 mut crate::src::python::libxml::_xmlSAXLocator>,) -> ()>;
pub type xmlSAXLocatorPtr = * mut crate::src::python::libxml::_xmlSAXLocator;
pub type xmlSAXLocator = crate::src::python::libxml::_xmlSAXLocator;
// #[derive(Copy, Clone)]

pub type _xmlSAXLocator = crate::src::python::libxml::_xmlSAXLocator;
pub type unparsedEntityDeclSAXFunc<'a1, 'a2, 'a3, 'a4, 'a5> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,_: Option<&'a3 u8>,_: Option<&'a4 u8>,_: Option<&'a5 u8>,) -> ()>;
pub type elementDeclSAXFunc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,_: i32,_: Option<&'a3 mut crate::src::python::libxml::_xmlElementContent>,) -> ()>;
pub type xmlElementContentPtr = * mut crate::src::python::libxml::_xmlElementContent;
pub type xmlElementContent = crate::src::python::libxml::_xmlElementContent;
// #[derive(Copy, Clone)]

pub type _xmlElementContent = crate::src::python::libxml::_xmlElementContent;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
pub type xmlElementContentOccur = u32;
pub const XML_ELEMENT_CONTENT_PLUS: xmlElementContentOccur = 4;
pub const XML_ELEMENT_CONTENT_MULT: xmlElementContentOccur = 3;
pub const XML_ELEMENT_CONTENT_OPT: xmlElementContentOccur = 2;
pub const XML_ELEMENT_CONTENT_ONCE: xmlElementContentOccur = 1;
pub type xmlElementContentType = u32;
pub const XML_ELEMENT_CONTENT_OR: xmlElementContentType = 4;
pub const XML_ELEMENT_CONTENT_SEQ: xmlElementContentType = 3;
pub const XML_ELEMENT_CONTENT_ELEMENT: xmlElementContentType = 2;
pub const XML_ELEMENT_CONTENT_PCDATA: xmlElementContentType = 1;
<<<<<<< HEAD
pub type attributeDeclSAXFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
        i32,
        i32,
        *const xmlChar,
        xmlEnumerationPtr,
    ) -> (),
>;
pub type xmlEnumerationPtr = *mut xmlEnumeration;
pub type xmlEnumeration = _xmlEnumeration;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlEnumeration {
    pub next: *mut _xmlEnumeration,
    pub name: *const xmlChar,
}
pub type notationDeclSAXFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
        *const xmlChar,
    ) -> (),
>;
pub type entityDeclSAXFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        i32,
        *const xmlChar,
        *const xmlChar,
        *mut xmlChar,
    ) -> (),
>;
pub type getEntitySAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> xmlEntityPtr,
>;
pub type resolveEntitySAXFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
    ) -> xmlParserInputPtr,
>;
pub type hasExternalSubsetSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> i32,
>;
pub type hasInternalSubsetSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> i32,
>;
pub type isStandaloneSAXFunc = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> i32,
>;
pub type internalSubsetSAXFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
        *const xmlChar,
    ) -> (),
>;
pub type xmlParserCtxt = _xmlParserCtxt;
pub type xmlParserCtxtPtr = *mut xmlParserCtxt;
=======
pub type attributeDeclSAXFunc<'a1, 'a2, 'a3, 'a4, 'a5> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,_: Option<&'a3 u8>,_: i32,_: i32,_: Option<&'a4 u8>,_: Option<&'a5 mut crate::src::python::libxml::_xmlEnumeration>,) -> ()>;
pub type xmlEnumerationPtr = * mut crate::src::python::libxml::_xmlEnumeration;
pub type xmlEnumeration = crate::src::python::libxml::_xmlEnumeration;
// #[derive(Copy, Clone)]

pub type _xmlEnumeration = crate::src::python::libxml::_xmlEnumeration;
pub type notationDeclSAXFunc<'a1, 'a2, 'a3, 'a4> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,_: Option<&'a3 u8>,_: Option<&'a4 u8>,) -> ()>;
pub type entityDeclSAXFunc<'a1, 'a2, 'a3, 'a4, 'a5> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,_: i32,_: Option<&'a3 u8>,_: Option<&'a4 u8>,_: Option<&'a5 mut u8>,) -> ()>;
pub type getEntitySAXFunc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,) -> Option<&'a3 mut crate::src::python::libxml::_xmlEntity>>;
pub type resolveEntitySAXFunc<'a1, 'a2, 'a3, 'a4> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,_: Option<&'a3 u8>,) -> Option<&'a4 mut crate::src::python::libxml::_xmlParserInput>>;
pub type hasExternalSubsetSAXFunc<'a1> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,) -> i32>;
pub type hasInternalSubsetSAXFunc<'a1> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,) -> i32>;
pub type isStandaloneSAXFunc<'a1> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,) -> i32>;
pub type internalSubsetSAXFunc<'a1, 'a2, 'a3, 'a4> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,_: Option<&'a3 u8>,_: Option<&'a4 u8>,) -> ()>;
pub type xmlParserCtxt = crate::src::python::libxml::_xmlParserCtxt;
pub type xmlParserCtxtPtr = * mut crate::src::python::libxml::_xmlParserCtxt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
pub type xmlAttributeDefault = u32;
pub const XML_ATTRIBUTE_FIXED: xmlAttributeDefault = 4;
pub const XML_ATTRIBUTE_IMPLIED: xmlAttributeDefault = 3;
pub const XML_ATTRIBUTE_REQUIRED: xmlAttributeDefault = 2;
pub const XML_ATTRIBUTE_NONE: xmlAttributeDefault = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlAttribute {
<<<<<<< HEAD
    pub _private: *mut libc::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDtd,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub nexth: *mut _xmlAttribute,
    pub atype: xmlAttributeType,
    pub def: xmlAttributeDefault,
    pub defaultValue: *const xmlChar,
    pub tree: xmlEnumerationPtr,
    pub prefix: *const xmlChar,
    pub elem: *const xmlChar,
}
pub type xmlAttribute = _xmlAttribute;
pub type xmlAttributePtr = *mut xmlAttribute;
=======
    pub _private: * mut core::ffi::c_void,
    pub type_0: u32,
    pub name: * const u8,
    pub children: * mut crate::src::python::libxml::_xmlNode,
    pub last: * mut crate::src::python::libxml::_xmlNode,
    pub parent: * mut crate::src::python::libxml::_xmlDtd,
    pub next: * mut crate::src::python::libxml::_xmlNode,
    pub prev: * mut crate::src::python::libxml::_xmlNode,
    pub doc: * mut crate::src::python::libxml::_xmlDoc,
    pub nexth: * mut crate::src::python::libxml2_py::_xmlAttribute,
    pub atype: u32,
    pub def: u32,
    pub defaultValue: * const u8,
    pub tree: * mut crate::src::python::libxml::_xmlEnumeration,
    pub prefix: * const u8,
    pub elem: * const u8,
}
impl _xmlAttribute {
    pub const fn new() -> Self {
        _xmlAttribute {
        _private: (0 as * mut core::ffi::c_void),
        type_0: 0,
        name: (0 as * const u8),
        children: (0 as * mut crate::src::python::libxml::_xmlNode),
        last: (0 as * mut crate::src::python::libxml::_xmlNode),
        parent: (0 as * mut crate::src::python::libxml::_xmlDtd),
        next: (0 as * mut crate::src::python::libxml::_xmlNode),
        prev: (0 as * mut crate::src::python::libxml::_xmlNode),
        doc: (0 as * mut crate::src::python::libxml::_xmlDoc),
        nexth: (0 as * mut crate::src::python::libxml2_py::_xmlAttribute),
        atype: 0,
        def: 0,
        defaultValue: (0 as * const u8),
        tree: (0 as * mut crate::src::python::libxml::_xmlEnumeration),
        prefix: (0 as * const u8),
        elem: (0 as * const u8)
        }
    }
}

impl std::default::Default for _xmlAttribute {
    fn default() -> Self { _xmlAttribute::new() }
}

pub type xmlAttribute = crate::src::python::libxml2_py::_xmlAttribute;
pub type xmlAttributePtr = * mut crate::src::python::libxml2_py::_xmlAttribute;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
pub type xmlElementTypeVal = u32;
pub const XML_ELEMENT_TYPE_ELEMENT: xmlElementTypeVal = 4;
pub const XML_ELEMENT_TYPE_MIXED: xmlElementTypeVal = 3;
pub const XML_ELEMENT_TYPE_ANY: xmlElementTypeVal = 2;
pub const XML_ELEMENT_TYPE_EMPTY: xmlElementTypeVal = 1;
pub const XML_ELEMENT_TYPE_UNDEFINED: xmlElementTypeVal = 0;
<<<<<<< HEAD
pub type xmlRegexp = _xmlRegexp;
pub type xmlRegexpPtr = *mut xmlRegexp;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlElement {
    pub _private: *mut libc::c_void,
    pub type_0: xmlElementType,
    pub name: *const xmlChar,
    pub children: *mut _xmlNode,
    pub last: *mut _xmlNode,
    pub parent: *mut _xmlDtd,
    pub next: *mut _xmlNode,
    pub prev: *mut _xmlNode,
    pub doc: *mut _xmlDoc,
    pub etype: xmlElementTypeVal,
    pub content: xmlElementContentPtr,
    pub attributes: xmlAttributePtr,
    pub prefix: *const xmlChar,
    pub contModel: xmlRegexpPtr,
}
pub type xmlElement = _xmlElement;
pub type xmlElementPtr = *mut xmlElement;
pub type xmlNsPtr = *mut xmlNs;
pub type xmlDtd = _xmlDtd;
pub type xmlDtdPtr = *mut xmlDtd;
pub type xmlFreeFunc = Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>;
pub type xmlValidCtxtPtr = *mut xmlValidCtxt;
pub type xmlSchemaAnnotPtr = *mut xmlSchemaAnnot;
pub type xmlSchemaAnnot = _xmlSchemaAnnot;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAnnot {
    pub next: *mut _xmlSchemaAnnot,
    pub content: xmlNodePtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchema {
    pub name: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub version: *const xmlChar,
    pub id: *const xmlChar,
    pub doc: xmlDocPtr,
    pub annot: xmlSchemaAnnotPtr,
    pub flags: i32,
    pub typeDecl: xmlHashTablePtr,
    pub attrDecl: xmlHashTablePtr,
    pub attrgrpDecl: xmlHashTablePtr,
    pub elemDecl: xmlHashTablePtr,
    pub notaDecl: xmlHashTablePtr,
    pub schemasImports: xmlHashTablePtr,
    pub _private: *mut libc::c_void,
    pub groupDecl: xmlHashTablePtr,
    pub dict: xmlDictPtr,
    pub includes: *mut libc::c_void,
    pub preserve: i32,
    pub counter: i32,
    pub idcDef: xmlHashTablePtr,
    pub volatiles: *mut libc::c_void,
}
pub type xmlSchema = _xmlSchema;
pub type xmlSchemaPtr = *mut xmlSchema;
pub type xmlSchemaParserCtxt = _xmlSchemaParserCtxt;
pub type xmlSchemaParserCtxtPtr = *mut xmlSchemaParserCtxt;
pub type xmlSchemaValidCtxt = _xmlSchemaValidCtxt;
pub type xmlSchemaValidCtxtPtr = *mut xmlSchemaValidCtxt;
pub type htmlParserCtxtPtr = xmlParserCtxtPtr;
pub type htmlDocPtr = xmlDocPtr;
pub type htmlNodePtr = xmlNodePtr;
pub type xmlCatalog = _xmlCatalog;
pub type xmlCatalogPtr = *mut xmlCatalog;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlURI {
    pub scheme: *mut i8,
    pub opaque: *mut i8,
    pub authority: *mut i8,
    pub server: *mut i8,
    pub user: *mut i8,
    pub port: i32,
    pub path: *mut i8,
    pub query: *mut i8,
    pub fragment: *mut i8,
    pub cleanup: i32,
    pub query_raw: *mut i8,
}
pub type xmlURI = _xmlURI;
pub type xmlURIPtr = *mut xmlURI;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlXPathContext {
    pub doc: xmlDocPtr,
    pub node: xmlNodePtr,
    pub nb_variables_unused: i32,
    pub max_variables_unused: i32,
    pub varHash: xmlHashTablePtr,
    pub nb_types: i32,
    pub max_types: i32,
    pub types: xmlXPathTypePtr,
    pub nb_funcs_unused: i32,
    pub max_funcs_unused: i32,
    pub funcHash: xmlHashTablePtr,
    pub nb_axis: i32,
    pub max_axis: i32,
    pub axis: xmlXPathAxisPtr,
    pub namespaces: *mut xmlNsPtr,
    pub nsNr: i32,
    pub user: *mut libc::c_void,
    pub contextSize: i32,
    pub proximityPosition: i32,
    pub xptr: i32,
    pub here: xmlNodePtr,
    pub origin: xmlNodePtr,
    pub nsHash: xmlHashTablePtr,
    pub varLookupFunc: xmlXPathVariableLookupFunc,
    pub varLookupData: *mut libc::c_void,
    pub extra: *mut libc::c_void,
    pub function: *const xmlChar,
    pub functionURI: *const xmlChar,
    pub funcLookupFunc: xmlXPathFuncLookupFunc,
    pub funcLookupData: *mut libc::c_void,
    pub tmpNsList: *mut xmlNsPtr,
    pub tmpNsNr: i32,
    pub userData: *mut libc::c_void,
    pub error: xmlStructuredErrorFunc,
    pub lastError: xmlError,
    pub debugNode: xmlNodePtr,
    pub dict: xmlDictPtr,
    pub flags: i32,
    pub cache: *mut libc::c_void,
    pub opLimit: u64,
    pub opCount: u64,
    pub depth: i32,
}
pub type xmlXPathFuncLookupFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
    ) -> xmlXPathFunction,
>;
pub type xmlXPathFunction = Option::<
    unsafe extern "C" fn(xmlXPathParserContextPtr, i32) -> (),
>;
pub type xmlXPathParserContextPtr = *mut xmlXPathParserContext;
pub type xmlXPathParserContext = _xmlXPathParserContext;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlXPathParserContext {
    pub cur: *const xmlChar,
    pub base: *const xmlChar,
    pub error: i32,
    pub context: xmlXPathContextPtr,
    pub value: xmlXPathObjectPtr,
    pub valueNr: i32,
    pub valueMax: i32,
    pub valueTab: *mut xmlXPathObjectPtr,
    pub comp: xmlXPathCompExprPtr,
    pub xptr: i32,
    pub ancestor: xmlNodePtr,
    pub valueFrame: i32,
}
pub type xmlXPathCompExprPtr = *mut xmlXPathCompExpr;
pub type xmlXPathCompExpr = _xmlXPathCompExpr;
pub type xmlXPathObjectPtr = *mut xmlXPathObject;
pub type xmlXPathObject = _xmlXPathObject;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlXPathObject {
    pub type_0: xmlXPathObjectType,
    pub nodesetval: xmlNodeSetPtr,
    pub boolval: i32,
    pub floatval: f64,
    pub stringval: *mut xmlChar,
    pub user: *mut libc::c_void,
    pub index: i32,
    pub user2: *mut libc::c_void,
    pub index2: i32,
}
pub type xmlNodeSetPtr = *mut xmlNodeSet;
pub type xmlNodeSet = _xmlNodeSet;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlNodeSet {
    pub nodeNr: i32,
    pub nodeMax: i32,
    pub nodeTab: *mut xmlNodePtr,
}
=======
pub type xmlRegexp = crate::src::python::libxml2_py::_xmlRegexp;
pub type xmlRegexpPtr = * mut crate::src::python::libxml2_py::_xmlRegexp;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlElement {
    pub _private: * mut core::ffi::c_void,
    pub type_0: u32,
    pub name: * const u8,
    pub children: * mut crate::src::python::libxml::_xmlNode,
    pub last: * mut crate::src::python::libxml::_xmlNode,
    pub parent: * mut crate::src::python::libxml::_xmlDtd,
    pub next: * mut crate::src::python::libxml::_xmlNode,
    pub prev: * mut crate::src::python::libxml::_xmlNode,
    pub doc: * mut crate::src::python::libxml::_xmlDoc,
    pub etype: u32,
    pub content: * mut crate::src::python::libxml::_xmlElementContent,
    pub attributes: * mut crate::src::python::libxml2_py::_xmlAttribute,
    pub prefix: * const u8,
    pub contModel: * mut crate::src::python::libxml2_py::_xmlRegexp,
}
impl _xmlElement {
    pub const fn new() -> Self {
        _xmlElement {
        _private: (0 as * mut core::ffi::c_void),
        type_0: 0,
        name: (0 as * const u8),
        children: (0 as * mut crate::src::python::libxml::_xmlNode),
        last: (0 as * mut crate::src::python::libxml::_xmlNode),
        parent: (0 as * mut crate::src::python::libxml::_xmlDtd),
        next: (0 as * mut crate::src::python::libxml::_xmlNode),
        prev: (0 as * mut crate::src::python::libxml::_xmlNode),
        doc: (0 as * mut crate::src::python::libxml::_xmlDoc),
        etype: 0,
        content: (0 as * mut crate::src::python::libxml::_xmlElementContent),
        attributes: (0 as * mut crate::src::python::libxml2_py::_xmlAttribute),
        prefix: (0 as * const u8),
        contModel: (0 as * mut crate::src::python::libxml2_py::_xmlRegexp)
        }
    }
}

impl std::default::Default for _xmlElement {
    fn default() -> Self { _xmlElement::new() }
}

pub type xmlElement = crate::src::python::libxml2_py::_xmlElement;
pub type xmlElementPtr = * mut crate::src::python::libxml2_py::_xmlElement;
pub type xmlNsPtr = * mut crate::src::python::libxml::_xmlNs;
pub type xmlDtd = crate::src::python::libxml::_xmlDtd;
pub type xmlDtdPtr = * mut crate::src::python::libxml::_xmlDtd;
pub type xmlFreeFunc<'a1> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,) -> ()>;
pub type xmlValidCtxtPtr = * mut crate::src::python::libxml::_xmlValidCtxt;
pub type xmlSchemaAnnotPtr = * mut crate::src::python::libxml2_py::_xmlSchemaAnnot;
pub type xmlSchemaAnnot = crate::src::python::libxml2_py::_xmlSchemaAnnot;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAnnot {
    pub next: * mut crate::src::python::libxml2_py::_xmlSchemaAnnot,
    pub content: * mut crate::src::python::libxml::_xmlNode,
}
impl _xmlSchemaAnnot {
    pub const fn new() -> Self {
        _xmlSchemaAnnot {
        next: (0 as * mut crate::src::python::libxml2_py::_xmlSchemaAnnot),
        content: (0 as * mut crate::src::python::libxml::_xmlNode)
        }
    }
}

impl std::default::Default for _xmlSchemaAnnot {
    fn default() -> Self { _xmlSchemaAnnot::new() }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchema {
    pub name: * const u8,
    pub targetNamespace: * const u8,
    pub version: * const u8,
    pub id: * const u8,
    pub doc: * mut crate::src::python::libxml::_xmlDoc,
    pub annot: * mut crate::src::python::libxml2_py::_xmlSchemaAnnot,
    pub flags: i32,
    pub typeDecl: * mut crate::src::python::libxml2_py::_xmlHashTable,
    pub attrDecl: * mut crate::src::python::libxml2_py::_xmlHashTable,
    pub attrgrpDecl: * mut crate::src::python::libxml2_py::_xmlHashTable,
    pub elemDecl: * mut crate::src::python::libxml2_py::_xmlHashTable,
    pub notaDecl: * mut crate::src::python::libxml2_py::_xmlHashTable,
    pub schemasImports: * mut crate::src::python::libxml2_py::_xmlHashTable,
    pub _private: * mut core::ffi::c_void,
    pub groupDecl: * mut crate::src::python::libxml2_py::_xmlHashTable,
    pub dict: * mut crate::src::python::types::_xmlDict,
    pub includes: * mut core::ffi::c_void,
    pub preserve: i32,
    pub counter: i32,
    pub idcDef: * mut crate::src::python::libxml2_py::_xmlHashTable,
    pub volatiles: * mut core::ffi::c_void,
}
impl _xmlSchema {
    pub const fn new() -> Self {
        _xmlSchema {
        name: (0 as * const u8),
        targetNamespace: (0 as * const u8),
        version: (0 as * const u8),
        id: (0 as * const u8),
        doc: (0 as * mut crate::src::python::libxml::_xmlDoc),
        annot: (0 as * mut crate::src::python::libxml2_py::_xmlSchemaAnnot),
        flags: 0,
        typeDecl: (0 as * mut crate::src::python::libxml2_py::_xmlHashTable),
        attrDecl: (0 as * mut crate::src::python::libxml2_py::_xmlHashTable),
        attrgrpDecl: (0 as * mut crate::src::python::libxml2_py::_xmlHashTable),
        elemDecl: (0 as * mut crate::src::python::libxml2_py::_xmlHashTable),
        notaDecl: (0 as * mut crate::src::python::libxml2_py::_xmlHashTable),
        schemasImports: (0 as * mut crate::src::python::libxml2_py::_xmlHashTable),
        _private: (0 as * mut core::ffi::c_void),
        groupDecl: (0 as * mut crate::src::python::libxml2_py::_xmlHashTable),
        dict: (0 as * mut crate::src::python::types::_xmlDict),
        includes: (0 as * mut core::ffi::c_void),
        preserve: 0,
        counter: 0,
        idcDef: (0 as * mut crate::src::python::libxml2_py::_xmlHashTable),
        volatiles: (0 as * mut core::ffi::c_void)
        }
    }
}

impl std::default::Default for _xmlSchema {
    fn default() -> Self { _xmlSchema::new() }
}

pub type xmlSchema = crate::src::python::libxml2_py::_xmlSchema;
pub type xmlSchemaPtr = * mut crate::src::python::libxml2_py::_xmlSchema;
pub type xmlSchemaParserCtxt = crate::src::python::types::_xmlSchemaParserCtxt;
pub type xmlSchemaParserCtxtPtr = * mut crate::src::python::types::_xmlSchemaParserCtxt;
pub type xmlSchemaValidCtxt = crate::src::python::types::_xmlSchemaValidCtxt;
pub type xmlSchemaValidCtxtPtr = * mut crate::src::python::types::_xmlSchemaValidCtxt;
pub type htmlParserCtxtPtr = * mut crate::src::python::libxml::_xmlParserCtxt;
pub type htmlDocPtr = * mut crate::src::python::libxml::_xmlDoc;
pub type htmlNodePtr = * mut crate::src::python::libxml::_xmlNode;
pub type xmlCatalog = crate::src::python::types::_xmlCatalog;
pub type xmlCatalogPtr = * mut crate::src::python::types::_xmlCatalog;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlURI {
    pub scheme: * mut i8,
    pub opaque: * mut i8,
    pub authority: * mut i8,
    pub server: * mut i8,
    pub user: * mut i8,
    pub port: i32,
    pub path: * mut i8,
    pub query: * mut i8,
    pub fragment: * mut i8,
    pub cleanup: i32,
    pub query_raw: * mut i8,
}
impl _xmlURI {
    pub const fn new() -> Self {
        _xmlURI {
        scheme: (0 as * mut i8),
        opaque: (0 as * mut i8),
        authority: (0 as * mut i8),
        server: (0 as * mut i8),
        user: (0 as * mut i8),
        port: 0,
        path: (0 as * mut i8),
        query: (0 as * mut i8),
        fragment: (0 as * mut i8),
        cleanup: 0,
        query_raw: (0 as * mut i8)
        }
    }
}

impl std::default::Default for _xmlURI {
    fn default() -> Self { _xmlURI::new() }
}

pub type xmlURI = crate::src::python::libxml2_py::_xmlURI;
pub type xmlURIPtr = * mut crate::src::python::libxml2_py::_xmlURI;
// #[derive(Copy, Clone)]

pub type _xmlXPathContext = crate::src::python::libxml::_xmlXPathContext;
pub type xmlXPathFuncLookupFunc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,_: Option<&'a3 u8>,) -> Option<unsafe extern "C"  fn(_: * mut crate::src::python::libxml::_xmlXPathParserContext,_: i32,) -> ()>>;
pub type xmlXPathFunction<'a1> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_xmlXPathParserContext>,_: i32,) -> ()>;
pub type xmlXPathParserContextPtr = * mut crate::src::python::libxml::_xmlXPathParserContext;
pub type xmlXPathParserContext = crate::src::python::libxml::_xmlXPathParserContext;
// #[derive(Copy, Clone)]

pub type _xmlXPathParserContext = crate::src::python::libxml::_xmlXPathParserContext;
pub type xmlXPathCompExprPtr = * mut crate::src::python::libxml::_xmlXPathCompExpr;
pub type xmlXPathCompExpr = crate::src::python::libxml::_xmlXPathCompExpr;
pub type xmlXPathObjectPtr = * mut crate::src::python::libxml::_xmlXPathObject;
pub type xmlXPathObject = crate::src::python::libxml::_xmlXPathObject;
// #[derive(Copy, Clone)]

pub type _xmlXPathObject = crate::src::python::libxml::_xmlXPathObject;
pub type xmlNodeSetPtr = * mut crate::src::python::libxml::_xmlNodeSet;
pub type xmlNodeSet = crate::src::python::libxml::_xmlNodeSet;
// #[derive(Copy, Clone)]

pub type _xmlNodeSet = crate::src::python::libxml::_xmlNodeSet;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
pub type xmlXPathObjectType = u32;
pub const XPATH_XSLT_TREE: xmlXPathObjectType = 9;
pub const XPATH_USERS: xmlXPathObjectType = 8;
pub const XPATH_STRING: xmlXPathObjectType = 4;
pub const XPATH_NUMBER: xmlXPathObjectType = 3;
pub const XPATH_BOOLEAN: xmlXPathObjectType = 2;
pub const XPATH_NODESET: xmlXPathObjectType = 1;
pub const XPATH_UNDEFINED: xmlXPathObjectType = 0;
<<<<<<< HEAD
pub type xmlXPathContextPtr = *mut xmlXPathContext;
pub type xmlXPathContext = _xmlXPathContext;
pub type xmlXPathVariableLookupFunc = Option::<
    unsafe extern "C" fn(
        *mut libc::c_void,
        *const xmlChar,
        *const xmlChar,
    ) -> xmlXPathObjectPtr,
>;
pub type xmlXPathAxisPtr = *mut xmlXPathAxis;
pub type xmlXPathAxis = _xmlXPathAxis;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlXPathAxis {
    pub name: *const xmlChar,
    pub func: xmlXPathAxisFunc,
}
pub type xmlXPathAxisFunc = Option::<
    unsafe extern "C" fn(
        xmlXPathParserContextPtr,
        xmlXPathObjectPtr,
    ) -> xmlXPathObjectPtr,
>;
pub type xmlXPathTypePtr = *mut xmlXPathType;
pub type xmlXPathType = _xmlXPathType;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlXPathType {
    pub name: *const xmlChar,
    pub func: xmlXPathConvertFunc,
}
pub type xmlXPathConvertFunc = Option::<
    unsafe extern "C" fn(xmlXPathObjectPtr, i32) -> i32,
>;
pub type xmlRelaxNG = _xmlRelaxNG;
pub type xmlRelaxNGPtr = *mut xmlRelaxNG;
pub type xmlRelaxNGParserCtxt = _xmlRelaxNGParserCtxt;
pub type xmlRelaxNGParserCtxtPtr = *mut xmlRelaxNGParserCtxt;
pub type xmlRelaxNGValidCtxt = _xmlRelaxNGValidCtxt;
pub type xmlRelaxNGValidCtxtPtr = *mut xmlRelaxNGValidCtxt;
pub type xmlTextReader = _xmlTextReader;
pub type xmlTextReaderPtr = *mut xmlTextReader;
pub type xmlTextReaderLocatorPtr = *mut libc::c_void;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyxmlNode_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlNodePtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyxmlXPathContext_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlXPathContextPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyxmlXPathParserContext_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlXPathParserContextPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyparserCtxt_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlParserCtxtPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyValidCtxt_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlValidCtxtPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Pycatalog_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlCatalogPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyxmlReg_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlRegexpPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyxmlTextReader_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlTextReaderPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyxmlTextReaderLocator_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlTextReaderLocatorPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyError_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlErrorPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyoutputBuffer_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlOutputBufferPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyinputBuffer_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlParserInputBufferPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyURI_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlURIPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyrelaxNgSchema_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlRelaxNGPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyrelaxNgParserCtxt_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlRelaxNGParserCtxtPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PyrelaxNgValidCtxt_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlRelaxNGValidCtxtPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PySchema_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlSchemaPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PySchemaParserCtxt_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlSchemaParserCtxtPtr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct PySchemaValidCtxt_Object {
    pub ob_refcnt: Py_ssize_t,
    pub ob_type: *mut _typeobject,
    pub obj: xmlSchemaValidCtxtPtr,
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlAutoCloseTag(
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: htmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut elem: htmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
=======
pub type xmlXPathContextPtr = * mut crate::src::python::libxml::_xmlXPathContext;
pub type xmlXPathContext = crate::src::python::libxml::_xmlXPathContext;
pub type xmlXPathVariableLookupFunc<'a1, 'a2, 'a3, 'a4> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut core::ffi::c_void>,_: Option<&'a2 u8>,_: Option<&'a3 u8>,) -> Option<&'a4 mut crate::src::python::libxml::_xmlXPathObject>>;
pub type xmlXPathAxisPtr = * mut crate::src::python::libxml::_xmlXPathAxis;
pub type xmlXPathAxis = crate::src::python::libxml::_xmlXPathAxis;
// #[derive(Copy, Clone)]

pub type _xmlXPathAxis = crate::src::python::libxml::_xmlXPathAxis;
pub type xmlXPathAxisFunc<'a1, 'a2, 'a3> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_xmlXPathParserContext>,_: Option<&'a2 mut crate::src::python::libxml::_xmlXPathObject>,) -> Option<&'a3 mut crate::src::python::libxml::_xmlXPathObject>>;
pub type xmlXPathTypePtr = * mut crate::src::python::libxml::_xmlXPathType;
pub type xmlXPathType = crate::src::python::libxml::_xmlXPathType;
// #[derive(Copy, Clone)]

pub type _xmlXPathType = crate::src::python::libxml::_xmlXPathType;
pub type xmlXPathConvertFunc<'a1> = Option<unsafe extern "C"  fn(_: Option<&'a1 mut crate::src::python::libxml::_xmlXPathObject>,_: i32,) -> i32>;
pub type xmlRelaxNG = crate::src::python::types::_xmlRelaxNG;
pub type xmlRelaxNGPtr = * mut crate::src::python::types::_xmlRelaxNG;
pub type xmlRelaxNGParserCtxt = crate::src::python::libxml2_py::_xmlRelaxNGParserCtxt;
pub type xmlRelaxNGParserCtxtPtr = * mut crate::src::python::libxml2_py::_xmlRelaxNGParserCtxt;
pub type xmlRelaxNGValidCtxt = crate::src::python::types::_xmlRelaxNGValidCtxt;
pub type xmlRelaxNGValidCtxtPtr = * mut crate::src::python::types::_xmlRelaxNGValidCtxt;
pub type xmlTextReader = crate::src::python::types::_xmlTextReader;
pub type xmlTextReaderPtr = * mut crate::src::python::types::_xmlTextReader;
pub type xmlTextReaderLocatorPtr = * mut core::ffi::c_void;
// #[derive(Copy, Clone)]

pub type PyxmlNode_Object<'a> = crate::src::python::libxml::PyxmlNode_Object<'a>;
// #[derive(Copy, Clone)]

pub type PyxmlXPathContext_Object<'a> = crate::src::python::libxml::PyxmlXPathContext_Object<'a>;
// #[derive(Copy, Clone)]
#[repr(C)]
pub struct PyxmlXPathParserContext_Object<'a> {
    pub ob_refcnt: i64,
    pub ob_type: Option<&'a mut crate::src::python::libxml::_typeobject>,
    pub obj: * mut crate::src::python::libxml::_xmlXPathParserContext,
}
impl<'a> PyxmlXPathParserContext_Object<'a> {
    pub const fn new() -> Self {
        PyxmlXPathParserContext_Object {
        ob_refcnt: 0,
        ob_type: None,
        obj: (0 as * mut crate::src::python::libxml::_xmlXPathParserContext)
        }
    }
}

impl<'a> std::default::Default for PyxmlXPathParserContext_Object<'a> {
    fn default() -> Self { PyxmlXPathParserContext_Object::new() }
}

// #[derive(Copy, Clone)]

pub type PyparserCtxt_Object<'a> = crate::src::python::libxml::PyparserCtxt_Object<'a>;
// #[derive(Copy, Clone)]

pub type PyValidCtxt_Object<'a> = crate::src::python::libxml::PyValidCtxt_Object<'a>;
// #[derive(Copy, Clone)]
#[repr(C)]
pub struct Pycatalog_Object<'a> {
    pub ob_refcnt: i64,
    pub ob_type: Option<&'a mut crate::src::python::libxml::_typeobject>,
    pub obj: * mut crate::src::python::types::_xmlCatalog,
}
impl<'a> Pycatalog_Object<'a> {
    pub const fn new() -> Self {
        Pycatalog_Object {
        ob_refcnt: 0,
        ob_type: None,
        obj: (0 as * mut crate::src::python::types::_xmlCatalog)
        }
    }
}

impl<'a> std::default::Default for Pycatalog_Object<'a> {
    fn default() -> Self { Pycatalog_Object::new() }
}

// #[derive(Copy, Clone)]
#[repr(C)]
pub struct PyxmlReg_Object<'a> {
    pub ob_refcnt: i64,
    pub ob_type: Option<&'a mut crate::src::python::libxml::_typeobject>,
    pub obj: * mut crate::src::python::libxml2_py::_xmlRegexp,
}
impl<'a> PyxmlReg_Object<'a> {
    pub const fn new() -> Self {
        PyxmlReg_Object {
        ob_refcnt: 0,
        ob_type: None,
        obj: (0 as * mut crate::src::python::libxml2_py::_xmlRegexp)
        }
    }
}

impl<'a> std::default::Default for PyxmlReg_Object<'a> {
    fn default() -> Self { PyxmlReg_Object::new() }
}

// #[derive(Copy, Clone)]

pub type PyxmlTextReader_Object<'a> = crate::src::python::libxml::PyxmlTextReader_Object<'a>;
// #[derive(Copy, Clone)]
#[repr(C)]
pub struct PyxmlTextReaderLocator_Object<'a> {
    pub ob_refcnt: i64,
    pub ob_type: Option<&'a mut crate::src::python::libxml::_typeobject>,
    pub obj: * mut core::ffi::c_void,
}
impl<'a> PyxmlTextReaderLocator_Object<'a> {
    pub const fn new() -> Self {
        PyxmlTextReaderLocator_Object {
        ob_refcnt: 0,
        ob_type: None,
        obj: (0 as * mut core::ffi::c_void)
        }
    }
}

impl<'a> std::default::Default for PyxmlTextReaderLocator_Object<'a> {
    fn default() -> Self { PyxmlTextReaderLocator_Object::new() }
}

// #[derive(Copy, Clone)]
#[repr(C)]
pub struct PyError_Object<'a> {
    pub ob_refcnt: i64,
    pub ob_type: Option<&'a mut crate::src::python::libxml::_typeobject>,
    pub obj: * mut crate::src::python::libxml::_xmlError,
}
impl<'a> PyError_Object<'a> {
    pub const fn new() -> Self {
        PyError_Object {
        ob_refcnt: 0,
        ob_type: None,
        obj: (0 as * mut crate::src::python::libxml::_xmlError)
        }
    }
}

impl<'a> std::default::Default for PyError_Object<'a> {
    fn default() -> Self { PyError_Object::new() }
}

// #[derive(Copy, Clone)]

pub type PyoutputBuffer_Object<'a> = crate::src::python::libxml::PyoutputBuffer_Object<'a>;
// #[derive(Copy, Clone)]
#[repr(C)]
pub struct PyinputBuffer_Object<'a> {
    pub ob_refcnt: i64,
    pub ob_type: Option<&'a mut crate::src::python::libxml::_typeobject>,
    pub obj: * mut crate::src::python::libxml::_xmlParserInputBuffer,
}
impl<'a> PyinputBuffer_Object<'a> {
    pub const fn new() -> Self {
        PyinputBuffer_Object {
        ob_refcnt: 0,
        ob_type: None,
        obj: (0 as * mut crate::src::python::libxml::_xmlParserInputBuffer)
        }
    }
}

impl<'a> std::default::Default for PyinputBuffer_Object<'a> {
    fn default() -> Self { PyinputBuffer_Object::new() }
}

// #[derive(Copy, Clone)]
#[repr(C)]
pub struct PyURI_Object<'a> {
    pub ob_refcnt: i64,
    pub ob_type: Option<&'a mut crate::src::python::libxml::_typeobject>,
    pub obj: * mut crate::src::python::libxml2_py::_xmlURI,
}
impl<'a> PyURI_Object<'a> {
    pub const fn new() -> Self {
        PyURI_Object {
        ob_refcnt: 0,
        ob_type: None,
        obj: (0 as * mut crate::src::python::libxml2_py::_xmlURI)
        }
    }
}

impl<'a> std::default::Default for PyURI_Object<'a> {
    fn default() -> Self { PyURI_Object::new() }
}

// #[derive(Copy, Clone)]
#[repr(C)]
pub struct PyrelaxNgSchema_Object<'a> {
    pub ob_refcnt: i64,
    pub ob_type: Option<&'a mut crate::src::python::libxml::_typeobject>,
    pub obj: * mut crate::src::python::types::_xmlRelaxNG,
}
impl<'a> PyrelaxNgSchema_Object<'a> {
    pub const fn new() -> Self {
        PyrelaxNgSchema_Object {
        ob_refcnt: 0,
        ob_type: None,
        obj: (0 as * mut crate::src::python::types::_xmlRelaxNG)
        }
    }
}

impl<'a> std::default::Default for PyrelaxNgSchema_Object<'a> {
    fn default() -> Self { PyrelaxNgSchema_Object::new() }
}

// #[derive(Copy, Clone)]
#[repr(C)]
pub struct PyrelaxNgParserCtxt_Object<'a> {
    pub ob_refcnt: i64,
    pub ob_type: Option<&'a mut crate::src::python::libxml::_typeobject>,
    pub obj: * mut crate::src::python::libxml2_py::_xmlRelaxNGParserCtxt,
}
impl<'a> PyrelaxNgParserCtxt_Object<'a> {
    pub const fn new() -> Self {
        PyrelaxNgParserCtxt_Object {
        ob_refcnt: 0,
        ob_type: None,
        obj: (0 as * mut crate::src::python::libxml2_py::_xmlRelaxNGParserCtxt)
        }
    }
}

impl<'a> std::default::Default for PyrelaxNgParserCtxt_Object<'a> {
    fn default() -> Self { PyrelaxNgParserCtxt_Object::new() }
}

// #[derive(Copy, Clone)]

pub type PyrelaxNgValidCtxt_Object<'a> = crate::src::python::libxml::PyrelaxNgValidCtxt_Object<'a>;
// #[derive(Copy, Clone)]
#[repr(C)]
pub struct PySchema_Object<'a> {
    pub ob_refcnt: i64,
    pub ob_type: Option<&'a mut crate::src::python::libxml::_typeobject>,
    pub obj: * mut crate::src::python::libxml2_py::_xmlSchema,
}
impl<'a> PySchema_Object<'a> {
    pub const fn new() -> Self {
        PySchema_Object {
        ob_refcnt: 0,
        ob_type: None,
        obj: (0 as * mut crate::src::python::libxml2_py::_xmlSchema)
        }
    }
}

impl<'a> std::default::Default for PySchema_Object<'a> {
    fn default() -> Self { PySchema_Object::new() }
}

// #[derive(Copy, Clone)]
#[repr(C)]
pub struct PySchemaParserCtxt_Object<'a> {
    pub ob_refcnt: i64,
    pub ob_type: Option<&'a mut crate::src::python::libxml::_typeobject>,
    pub obj: * mut crate::src::python::types::_xmlSchemaParserCtxt,
}
impl<'a> PySchemaParserCtxt_Object<'a> {
    pub const fn new() -> Self {
        PySchemaParserCtxt_Object {
        ob_refcnt: 0,
        ob_type: None,
        obj: (0 as * mut crate::src::python::types::_xmlSchemaParserCtxt)
        }
    }
}

impl<'a> std::default::Default for PySchemaParserCtxt_Object<'a> {
    fn default() -> Self { PySchemaParserCtxt_Object::new() }
}

// #[derive(Copy, Clone)]

pub type PySchemaValidCtxt_Object<'a> = crate::src::python::libxml::PySchemaValidCtxt_Object<'a>;
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlAutoCloseTag(
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OzO:htmlAutoCloseTag\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut pyobj_elem as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as htmlDocPtr;
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    c_retval = htmlAutoCloseTag(doc, name, elem);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlCreateFileParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut filename: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut filename: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:htmlCreateFileParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut filename as *mut *mut i8,
        &mut encoding as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = htmlCreateFileParserCtxt(filename, encoding);
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlCreateMemoryParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut buffer: *mut i8 = 0 as *mut i8;
    let mut py_buffsize0: Py_ssize_t = 0;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut buffer: * mut i8 = 0 as *mut i8;
    let mut py_buffsize0: i64 = 0;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut size: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"s#i:htmlCreateMemoryParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut buffer as *mut *mut i8,
        &mut py_buffsize0 as *mut Py_ssize_t,
        &mut size as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = htmlCreateMemoryParserCtxt(buffer, size);
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlCtxtReadDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut u8 = 0 as *mut xmlChar;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozzzi:htmlCtxtReadDoc\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut cur as *mut *mut xmlChar,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = htmlCtxtReadDoc(ctxt, cur, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlCtxtReadFd(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut fd: i32 = 0;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut fd: i32 = 0;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oizzi:htmlCtxtReadFd\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut fd as *mut i32,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = htmlCtxtReadFd(ctxt, fd, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlCtxtReadFile(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut filename: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut filename: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozzi:htmlCtxtReadFile\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut filename as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = htmlCtxtReadFile(ctxt, filename, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlCtxtReadMemory(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut buffer: *mut i8 = 0 as *mut i8;
    let mut py_buffsize0: Py_ssize_t = 0;
    let mut size: i32 = 0;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut buffer: * mut i8 = 0 as *mut i8;
    let mut py_buffsize0: i64 = 0;
    let mut size: i32 = 0;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Os#izzi:htmlCtxtReadMemory\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut buffer as *mut *mut i8,
        &mut py_buffsize0 as *mut Py_ssize_t,
        &mut size as *mut i32,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = htmlCtxtReadMemory(ctxt, buffer, size, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlCtxtReset(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:htmlCtxtReset\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    htmlCtxtReset(ctxt);
<<<<<<< HEAD
    let ref mut fresh0 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh0 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh0 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlCtxtUseOptions(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:htmlCtxtUseOptions\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = htmlCtxtUseOptions(ctxt, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlDefaultSAXHandlerInit(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"htmlDefaultSAXHandlerInit\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    htmlDefaultSAXHandlerInit();
<<<<<<< HEAD
    let ref mut fresh1 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh1 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh1 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlDocContentDumpFormatOutput(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut buf: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut pyobj_buf: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut buf: * mut crate::src::python::libxml::_xmlOutputBuffer = 0 as *mut xmlOutputBuffer;
    let mut pyobj_buf: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut format: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOzi:htmlDocContentDumpFormatOutput\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_buf as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut encoding as *mut *mut i8,
        &mut format as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    buf = if pyobj_buf == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlOutputBufferPtr
    } else {
        (*(pyobj_buf as *mut PyoutputBuffer_Object)).obj
    };
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    htmlDocContentDumpFormatOutput(buf, cur, encoding, format);
<<<<<<< HEAD
    let ref mut fresh2 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh2 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh2 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlDocContentDumpOutput(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut buf: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut pyobj_buf: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut buf: * mut crate::src::python::libxml::_xmlOutputBuffer = 0 as *mut xmlOutputBuffer;
    let mut pyobj_buf: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOz:htmlDocContentDumpOutput\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_buf as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut encoding as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    buf = if pyobj_buf == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlOutputBufferPtr
    } else {
        (*(pyobj_buf as *mut PyoutputBuffer_Object)).obj
    };
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    htmlDocContentDumpOutput(buf, cur, encoding);
<<<<<<< HEAD
    let ref mut fresh3 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh3 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh3 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlDocDump(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut pyobj_f: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut f: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_f: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:htmlDocDump\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_f as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    f = if pyobj_f == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_f).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_f).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_f)
    } else {
        stdout
    };
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = htmlDocDump(f, cur);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlFreeParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:htmlFreeParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    htmlFreeParserCtxt(ctxt);
<<<<<<< HEAD
    let ref mut fresh4 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh4 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh4 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlGetMetaEncoding(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut doc: htmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:htmlGetMetaEncoding\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as htmlDocPtr;
    c_retval = htmlGetMetaEncoding(doc);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlHandleOmittedElem(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut val: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:htmlHandleOmittedElem\0" as *const u8 as *const i8
            as *mut i8,
        &mut val as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = htmlHandleOmittedElem(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlInitAutoClose(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"htmlInitAutoClose\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    htmlInitAutoClose();
<<<<<<< HEAD
    let ref mut fresh5 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh5 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh5 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlIsAutoClosed(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: htmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: htmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:htmlIsAutoClosed\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as htmlDocPtr;
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    c_retval = htmlIsAutoClosed(doc, elem);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlIsBooleanAttr(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:htmlIsBooleanAttr\0" as *const u8 as *const i8
            as *mut i8,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = htmlIsBooleanAttr(name);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlIsScriptAttribute(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:htmlIsScriptAttribute\0" as *const u8 as *const i8
            as *mut i8,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = htmlIsScriptAttribute(name);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlNewDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut URI: * mut u8 = 0 as *mut xmlChar;
    let mut ExternalID: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:htmlNewDoc\0" as *const u8 as *const i8 as *mut i8,
        &mut URI as *mut *mut xmlChar,
        &mut ExternalID as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = htmlNewDoc(URI, ExternalID);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlNewDocNoDtD(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut URI: * mut u8 = 0 as *mut xmlChar;
    let mut ExternalID: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:htmlNewDocNoDtD\0" as *const u8 as *const i8 as *mut i8,
        &mut URI as *mut *mut xmlChar,
        &mut ExternalID as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = htmlNewDocNoDtD(URI, ExternalID);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlNewParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    c_retval = htmlNewParserCtxt();
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlNodeDumpFile(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut out: *mut FILE = 0 as *mut FILE;
    let mut pyobj_out: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut out: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_out: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOO:htmlNodeDumpFile\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_out as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    out = if pyobj_out == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_out).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_out).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_out)
    } else {
        stdout
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    htmlNodeDumpFile(out, doc, cur);
<<<<<<< HEAD
    let ref mut fresh6 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh6 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh6 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlNodeDumpFileFormat(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut out: *mut FILE = 0 as *mut FILE;
    let mut pyobj_out: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut out: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_out: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut format: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOOzi:htmlNodeDumpFileFormat\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_out as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut encoding as *mut *mut i8,
        &mut format as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    out = if pyobj_out == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_out).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_out).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_out)
    } else {
        stdout
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = htmlNodeDumpFileFormat(out, doc, cur, encoding, format);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlNodeDumpFormatOutput(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut buf: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut pyobj_buf: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut buf: * mut crate::src::python::libxml::_xmlOutputBuffer = 0 as *mut xmlOutputBuffer;
    let mut pyobj_buf: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut format: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOOzi:htmlNodeDumpFormatOutput\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_buf as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut encoding as *mut *mut i8,
        &mut format as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    buf = if pyobj_buf == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlOutputBufferPtr
    } else {
        (*(pyobj_buf as *mut PyoutputBuffer_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    htmlNodeDumpFormatOutput(buf, doc, cur, encoding, format);
<<<<<<< HEAD
    let ref mut fresh7 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh7 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh7 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlNodeDumpOutput(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut buf: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut pyobj_buf: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut buf: * mut crate::src::python::libxml::_xmlOutputBuffer = 0 as *mut xmlOutputBuffer;
    let mut pyobj_buf: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOOz:htmlNodeDumpOutput\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_buf as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut encoding as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    buf = if pyobj_buf == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlOutputBufferPtr
    } else {
        (*(pyobj_buf as *mut PyoutputBuffer_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    htmlNodeDumpOutput(buf, doc, cur, encoding);
<<<<<<< HEAD
    let ref mut fresh8 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh8 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh8 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlParseCharRef(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:htmlParseCharRef\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = htmlParseCharRef(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlParseChunk(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut chunk: *mut i8 = 0 as *mut i8;
    let mut py_buffsize0: Py_ssize_t = 0;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut chunk: * mut i8 = 0 as *mut i8;
    let mut py_buffsize0: i64 = 0;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut size: i32 = 0;
    let mut terminate: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Os#ii:htmlParseChunk\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut chunk as *mut *mut i8,
        &mut py_buffsize0 as *mut Py_ssize_t,
        &mut size as *mut i32,
        &mut terminate as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = htmlParseChunk(ctxt, chunk, size, terminate);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlParseDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut cur: * mut u8 = 0 as *mut xmlChar;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:htmlParseDoc\0" as *const u8 as *const i8 as *mut i8,
        &mut cur as *mut *mut xmlChar,
        &mut encoding as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = htmlParseDoc(cur, encoding);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlParseDocument(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:htmlParseDocument\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = htmlParseDocument(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlParseElement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: htmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:htmlParseElement\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    htmlParseElement(ctxt);
<<<<<<< HEAD
    let ref mut fresh9 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh9 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh9 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlParseFile(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut filename: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:htmlParseFile\0" as *const u8 as *const i8 as *mut i8,
        &mut filename as *mut *mut i8,
        &mut encoding as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = htmlParseFile(filename, encoding);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlReadDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut cur: * mut u8 = 0 as *mut xmlChar;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zzzi:htmlReadDoc\0" as *const u8 as *const i8 as *mut i8,
        &mut cur as *mut *mut xmlChar,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = htmlReadDoc(cur, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlReadFd(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut fd: i32 = 0;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut fd: i32 = 0;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"izzi:htmlReadFd\0" as *const u8 as *const i8 as *mut i8,
        &mut fd as *mut i32,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = htmlReadFd(fd, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlReadFile(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut filename: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zzi:htmlReadFile\0" as *const u8 as *const i8 as *mut i8,
        &mut filename as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = htmlReadFile(filename, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlReadMemory(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: htmlDocPtr = 0 as *mut xmlDoc;
    let mut buffer: *mut i8 = 0 as *mut i8;
    let mut py_buffsize0: Py_ssize_t = 0;
    let mut size: i32 = 0;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut buffer: * mut i8 = 0 as *mut i8;
    let mut py_buffsize0: i64 = 0;
    let mut size: i32 = 0;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"s#izzi:htmlReadMemory\0" as *const u8 as *const i8
            as *mut i8,
        &mut buffer as *mut *mut i8,
        &mut py_buffsize0 as *mut Py_ssize_t,
        &mut size as *mut i32,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = htmlReadMemory(buffer, size, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlSaveFile(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: *mut i8 = 0 as *mut i8;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: * mut i8 = 0 as *mut i8;
    let mut cur: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zO:htmlSaveFile\0" as *const u8 as *const i8 as *mut i8,
        &mut filename as *mut *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = htmlSaveFile(filename, cur);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlSaveFileEnc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: *mut i8 = 0 as *mut i8;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: * mut i8 = 0 as *mut i8;
    let mut cur: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zOz:htmlSaveFileEnc\0" as *const u8 as *const i8
            as *mut i8,
        &mut filename as *mut *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut encoding as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = htmlSaveFileEnc(filename, cur, encoding);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlSaveFileFormat(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: *mut i8 = 0 as *mut i8;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: * mut i8 = 0 as *mut i8;
    let mut cur: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut format: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zOzi:htmlSaveFileFormat\0" as *const u8 as *const i8
            as *mut i8,
        &mut filename as *mut *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut encoding as *mut *mut i8,
        &mut format as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = htmlSaveFileFormat(filename, cur, encoding, format);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_htmlSetMetaEncoding(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: htmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut encoding: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:htmlSetMetaEncoding\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut encoding as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as htmlDocPtr;
    c_retval = htmlSetMetaEncoding(doc, encoding);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_namePop(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:namePop\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = namePop(ctxt);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_namePush(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:namePush\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = namePush(ctxt, value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_nodePop(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:nodePop\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = nodePop(ctxt);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_nodePush(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut value: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_value: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut value: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_value: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:nodePush\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_value as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    value = if pyobj_value == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_value as *mut PyxmlNode_Object)).obj
    };
    c_retval = nodePush(ctxt, value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_valuePop(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlXPathObject = 0 as *mut xmlXPathObject;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:valuePop\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    c_retval = valuePop(ctxt);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlACatalogAdd(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
    let mut type_0: *mut xmlChar = 0 as *mut xmlChar;
    let mut orig: *mut xmlChar = 0 as *mut xmlChar;
    let mut replace: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut catal: * mut crate::src::python::types::_xmlCatalog = 0 as *mut xmlCatalog;
    let mut pyobj_catal: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut type_0: * mut u8 = 0 as *mut xmlChar;
    let mut orig: * mut u8 = 0 as *mut xmlChar;
    let mut replace: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozzz:xmlACatalogAdd\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_catal as *mut *mut PyObject,
        &mut type_0 as *mut *mut xmlChar,
        &mut orig as *mut *mut xmlChar,
        &mut replace as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    catal = if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlCatalogPtr
    } else {
        (*(pyobj_catal as *mut Pycatalog_Object)).obj
    };
    c_retval = xmlACatalogAdd(catal, type_0, orig, replace);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlACatalogDump(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
    let mut out: *mut FILE = 0 as *mut FILE;
    let mut pyobj_out: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut catal: * mut crate::src::python::types::_xmlCatalog = 0 as *mut xmlCatalog;
    let mut pyobj_catal: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut out: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_out: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlACatalogDump\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_catal as *mut *mut PyObject,
        &mut pyobj_out as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    catal = if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlCatalogPtr
    } else {
        (*(pyobj_catal as *mut Pycatalog_Object)).obj
    };
    out = if pyobj_out == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_out).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_out).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_out)
    } else {
        stdout
    };
    xmlACatalogDump(catal, out);
<<<<<<< HEAD
    let ref mut fresh10 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh10 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh10 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlACatalogRemove(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut catal: * mut crate::src::python::types::_xmlCatalog = 0 as *mut xmlCatalog;
    let mut pyobj_catal: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlACatalogRemove\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_catal as *mut *mut PyObject,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    catal = if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlCatalogPtr
    } else {
        (*(pyobj_catal as *mut Pycatalog_Object)).obj
    };
    c_retval = xmlACatalogRemove(catal, value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlACatalogResolve(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
    let mut pubID: *mut xmlChar = 0 as *mut xmlChar;
    let mut sysID: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut catal: * mut crate::src::python::types::_xmlCatalog = 0 as *mut xmlCatalog;
    let mut pyobj_catal: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut pubID: * mut u8 = 0 as *mut xmlChar;
    let mut sysID: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozz:xmlACatalogResolve\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_catal as *mut *mut PyObject,
        &mut pubID as *mut *mut xmlChar,
        &mut sysID as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    catal = if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlCatalogPtr
    } else {
        (*(pyobj_catal as *mut Pycatalog_Object)).obj
    };
    c_retval = xmlACatalogResolve(catal, pubID, sysID);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlACatalogResolvePublic(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
    let mut pubID: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut catal: * mut crate::src::python::types::_xmlCatalog = 0 as *mut xmlCatalog;
    let mut pyobj_catal: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut pubID: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlACatalogResolvePublic\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_catal as *mut *mut PyObject,
        &mut pubID as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    catal = if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlCatalogPtr
    } else {
        (*(pyobj_catal as *mut Pycatalog_Object)).obj
    };
    c_retval = xmlACatalogResolvePublic(catal, pubID);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlACatalogResolveSystem(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
    let mut sysID: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut catal: * mut crate::src::python::types::_xmlCatalog = 0 as *mut xmlCatalog;
    let mut pyobj_catal: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut sysID: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlACatalogResolveSystem\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_catal as *mut *mut PyObject,
        &mut sysID as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    catal = if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlCatalogPtr
    } else {
        (*(pyobj_catal as *mut Pycatalog_Object)).obj
    };
    c_retval = xmlACatalogResolveSystem(catal, sysID);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlACatalogResolveURI(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut catal: * mut crate::src::python::types::_xmlCatalog = 0 as *mut xmlCatalog;
    let mut pyobj_catal: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut URI: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlACatalogResolveURI\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_catal as *mut *mut PyObject,
        &mut URI as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    catal = if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlCatalogPtr
    } else {
        (*(pyobj_catal as *mut Pycatalog_Object)).obj
    };
    c_retval = xmlACatalogResolveURI(catal, URI);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlAddChild(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_parent: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut parent: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_parent: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlAddChild\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_parent as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    parent = if pyobj_parent == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_parent as *mut PyxmlNode_Object)).obj
    };
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlAddChild(parent, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlAddChildList(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_parent: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut parent: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_parent: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlAddChildList\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_parent as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    parent = if pyobj_parent == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_parent as *mut PyxmlNode_Object)).obj
    };
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlAddChildList(parent, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlAddDocEntity(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut type_0: i32 = 0;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlEntity = 0 as *mut xmlEntity;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut type_0: i32 = 0;
    let mut ExternalID: * mut u8 = 0 as *mut xmlChar;
    let mut SystemID: * mut u8 = 0 as *mut xmlChar;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozizzz:xmlAddDocEntity\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut type_0 as *mut i32,
        &mut ExternalID as *mut *mut xmlChar,
        &mut SystemID as *mut *mut xmlChar,
        &mut content as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlAddDocEntity(doc, name, type_0, ExternalID, SystemID, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlAddDtdEntity(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut type_0: i32 = 0;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlEntity = 0 as *mut xmlEntity;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut type_0: i32 = 0;
    let mut ExternalID: * mut u8 = 0 as *mut xmlChar;
    let mut SystemID: * mut u8 = 0 as *mut xmlChar;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozizzz:xmlAddDtdEntity\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut type_0 as *mut i32,
        &mut ExternalID as *mut *mut xmlChar,
        &mut SystemID as *mut *mut xmlChar,
        &mut content as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlAddDtdEntity(doc, name, type_0, ExternalID, SystemID, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlAddEncodingAlias(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut name: *mut i8 = 0 as *mut i8;
    let mut alias: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut name: * mut i8 = 0 as *mut i8;
    let mut alias: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:xmlAddEncodingAlias\0" as *const u8 as *const i8
            as *mut i8,
        &mut name as *mut *mut i8,
        &mut alias as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlAddEncodingAlias(name, alias);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlAddNextSibling(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlAddNextSibling\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlAddNextSibling(cur, elem);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlAddPrevSibling(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlAddPrevSibling\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlAddPrevSibling(cur, elem);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlAddSibling(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlAddSibling\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlAddSibling(cur, elem);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlBoolToText(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const i8 = 0 as *const i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const i8 = 0 as *const i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut boolval: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlBoolToText\0" as *const u8 as *const i8 as *mut i8,
        &mut boolval as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlBoolToText(boolval);
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlBuildQName(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ncname: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut memory: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ncname: * mut u8 = 0 as *mut xmlChar;
    let mut prefix: * mut u8 = 0 as *mut xmlChar;
    let mut memory: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zzzi:xmlBuildQName\0" as *const u8 as *const i8 as *mut i8,
        &mut ncname as *mut *mut xmlChar,
        &mut prefix as *mut *mut xmlChar,
        &mut memory as *mut *mut xmlChar,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlBuildQName(ncname, prefix, memory, len);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlBuildRelativeURI(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut base: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut URI: * mut u8 = 0 as *mut xmlChar;
    let mut base: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:xmlBuildRelativeURI\0" as *const u8 as *const i8
            as *mut i8,
        &mut URI as *mut *mut xmlChar,
        &mut base as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlBuildRelativeURI(URI, base);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlBuildURI(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
    let mut base: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut URI: * mut u8 = 0 as *mut xmlChar;
    let mut base: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:xmlBuildURI\0" as *const u8 as *const i8 as *mut i8,
        &mut URI as *mut *mut xmlChar,
        &mut base as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlBuildURI(URI, base);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlByteConsumed(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i64 = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i64 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlByteConsumed\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlByteConsumed(ctxt);
    py_retval = libxml_longWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCanonicPath(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut path: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut path: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlCanonicPath\0" as *const u8 as *const i8 as *mut i8,
        &mut path as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCanonicPath(path);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogAdd(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut type_0: *mut xmlChar = 0 as *mut xmlChar;
    let mut orig: *mut xmlChar = 0 as *mut xmlChar;
    let mut replace: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut type_0: * mut u8 = 0 as *mut xmlChar;
    let mut orig: * mut u8 = 0 as *mut xmlChar;
    let mut replace: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zzz:xmlCatalogAdd\0" as *const u8 as *const i8 as *mut i8,
        &mut type_0 as *mut *mut xmlChar,
        &mut orig as *mut *mut xmlChar,
        &mut replace as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCatalogAdd(type_0, orig, replace);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogCleanup(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    xmlCatalogCleanup();
    let ref mut fresh11 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    xmlCatalogCleanup();
    let ref mut fresh11 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh11 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogConvert(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    c_retval = xmlCatalogConvert();
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogDump(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut out: *mut FILE = 0 as *mut FILE;
    let mut pyobj_out: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut out: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_out: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlCatalogDump\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_out as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    out = if pyobj_out == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_out).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_out).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_out)
    } else {
        stdout
    };
    xmlCatalogDump(out);
<<<<<<< HEAD
    let ref mut fresh12 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh12 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh12 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogGetPublic(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut pubID: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut pubID: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlCatalogGetPublic\0" as *const u8 as *const i8
            as *mut i8,
        &mut pubID as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCatalogGetPublic(pubID);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogGetSystem(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut sysID: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut sysID: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlCatalogGetSystem\0" as *const u8 as *const i8
            as *mut i8,
        &mut sysID as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCatalogGetSystem(sysID);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogIsEmpty(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut catal: * mut crate::src::python::types::_xmlCatalog = 0 as *mut xmlCatalog;
    let mut pyobj_catal: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlCatalogIsEmpty\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_catal as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    catal = if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlCatalogPtr
    } else {
        (*(pyobj_catal as *mut Pycatalog_Object)).obj
    };
    c_retval = xmlCatalogIsEmpty(catal);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogRemove(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlCatalogRemove\0" as *const u8 as *const i8 as *mut i8,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCatalogRemove(value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogResolve(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut pubID: *mut xmlChar = 0 as *mut xmlChar;
    let mut sysID: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut pubID: * mut u8 = 0 as *mut xmlChar;
    let mut sysID: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:xmlCatalogResolve\0" as *const u8 as *const i8
            as *mut i8,
        &mut pubID as *mut *mut xmlChar,
        &mut sysID as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCatalogResolve(pubID, sysID);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogResolvePublic(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut pubID: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut pubID: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlCatalogResolvePublic\0" as *const u8 as *const i8
            as *mut i8,
        &mut pubID as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCatalogResolvePublic(pubID);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogResolveSystem(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut sysID: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut sysID: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlCatalogResolveSystem\0" as *const u8 as *const i8
            as *mut i8,
        &mut sysID as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCatalogResolveSystem(sysID);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogResolveURI(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut URI: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut URI: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlCatalogResolveURI\0" as *const u8 as *const i8
            as *mut i8,
        &mut URI as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCatalogResolveURI(URI);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCatalogSetDebug(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut level: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlCatalogSetDebug\0" as *const u8 as *const i8
            as *mut i8,
        &mut level as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCatalogSetDebug(level);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCharStrdup(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut cur: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlCharStrdup\0" as *const u8 as *const i8 as *mut i8,
        &mut cur as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCharStrdup(cur);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCharStrndup(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut cur: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zi:xmlCharStrndup\0" as *const u8 as *const i8 as *mut i8,
        &mut cur as *mut *mut i8,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCharStrndup(cur, len);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCheckFilename(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut path: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut path: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlCheckFilename\0" as *const u8 as *const i8 as *mut i8,
        &mut path as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCheckFilename(path);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCheckLanguageID(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut lang: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut lang: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlCheckLanguageID\0" as *const u8 as *const i8
            as *mut i8,
        &mut lang as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCheckLanguageID(lang);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCheckUTF8(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut utf: *mut u8 = 0 as *mut u8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut utf: * mut u8 = 0 as *mut u8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlCheckUTF8\0" as *const u8 as *const i8 as *mut i8,
        &mut utf as *mut *mut u8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCheckUTF8(utf);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCheckVersion(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut version: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlCheckVersion\0" as *const u8 as *const i8 as *mut i8,
        &mut version as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    xmlCheckVersion(version);
<<<<<<< HEAD
    let ref mut fresh13 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh13 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh13 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCleanupCharEncodingHandlers(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlCleanupCharEncodingHandlers\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    xmlCleanupCharEncodingHandlers();
<<<<<<< HEAD
    let ref mut fresh14 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh14 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh14 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCleanupEncodingAliases(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    xmlCleanupEncodingAliases();
    let ref mut fresh15 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    xmlCleanupEncodingAliases();
    let ref mut fresh15 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh15 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCleanupGlobals(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlCleanupGlobals\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    xmlCleanupGlobals();
<<<<<<< HEAD
    let ref mut fresh16 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh16 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh16 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCleanupInputCallbacks(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    xmlCleanupInputCallbacks();
    let ref mut fresh17 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    xmlCleanupInputCallbacks();
    let ref mut fresh17 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh17 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCleanupOutputCallbacks(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    xmlCleanupOutputCallbacks();
    let ref mut fresh18 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    xmlCleanupOutputCallbacks();
    let ref mut fresh18 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh18 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCleanupPredefinedEntities(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    xmlCleanupPredefinedEntities();
    let ref mut fresh19 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    xmlCleanupPredefinedEntities();
    let ref mut fresh19 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh19 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlClearParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlClearParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlClearParserCtxt(ctxt);
<<<<<<< HEAD
    let ref mut fresh20 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh20 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh20 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlConvertSGMLCatalog(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut catal: * mut crate::src::python::types::_xmlCatalog = 0 as *mut xmlCatalog;
    let mut pyobj_catal: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlConvertSGMLCatalog\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_catal as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    catal = if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlCatalogPtr
    } else {
        (*(pyobj_catal as *mut Pycatalog_Object)).obj
    };
    c_retval = xmlConvertSGMLCatalog(catal);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyChar(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut len: i32 = 0;
    let mut out: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut len: i32 = 0;
    let mut out: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut val: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"izi:xmlCopyChar\0" as *const u8 as *const i8 as *mut i8,
        &mut len as *mut i32,
        &mut out as *mut *mut xmlChar,
        &mut val as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCopyChar(len, out, val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyCharMultiByte(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut out: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut out: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut val: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zi:xmlCopyCharMultiByte\0" as *const u8 as *const i8
            as *mut i8,
        &mut out as *mut *mut xmlChar,
        &mut val as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCopyCharMultiByte(out, val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut recursive: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlCopyDoc\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut recursive as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlCopyDoc(doc, recursive);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyDtd(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut pyobj_dtd: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDtd = 0 as *mut xmlDtd;
    let mut dtd: * mut crate::src::python::libxml::_xmlDtd = 0 as *mut xmlDtd;
    let mut pyobj_dtd: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlCopyDtd\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_dtd as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    dtd = (if pyobj_dtd == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_dtd as *mut PyxmlNode_Object)).obj
    }) as xmlDtdPtr;
    c_retval = xmlCopyDtd(dtd);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyError(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut from: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_from: *mut PyObject = 0 as *mut PyObject;
    let mut to: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_to: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut from: * mut crate::src::python::libxml::_xmlError = 0 as *mut xmlError;
    let mut pyobj_from: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut to: * mut crate::src::python::libxml::_xmlError = 0 as *mut xmlError;
    let mut pyobj_to: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlCopyError\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_from as *mut *mut PyObject,
        &mut pyobj_to as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    from = if pyobj_from == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlErrorPtr
    } else {
        (*(pyobj_from as *mut PyError_Object)).obj
    };
    to = if pyobj_to == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlErrorPtr
    } else {
        (*(pyobj_to as *mut PyError_Object)).obj
    };
    c_retval = xmlCopyError(from, to);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyNamespace(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNsPtr = 0 as *mut xmlNs;
    let mut cur: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut cur: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlCopyNamespace\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlNsPtr;
    c_retval = xmlCopyNamespace(cur);
    py_retval = libxml_xmlNsPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyNamespaceList(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNsPtr = 0 as *mut xmlNs;
    let mut cur: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut cur: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlCopyNamespaceList\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlNsPtr;
    c_retval = xmlCopyNamespaceList(cur);
    py_retval = libxml_xmlNsPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyNode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut extended: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlCopyNode\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut extended as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlCopyNode(node, extended);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyNodeList(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlCopyNodeList\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlCopyNodeList(node);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyProp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut target: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_target: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut target: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_target: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlCopyProp\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_target as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    target = if pyobj_target == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_target as *mut PyxmlNode_Object)).obj
    };
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlAttrPtr;
    c_retval = xmlCopyProp(target, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCopyPropList(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut target: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_target: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut target: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_target: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlCopyPropList\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_target as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    target = if pyobj_target == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_target as *mut PyxmlNode_Object)).obj
    };
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlAttrPtr;
    c_retval = xmlCopyPropList(target, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCreateDocParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut cur: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlCreateDocParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut cur as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCreateDocParserCtxt(cur);
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCreateEntityParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut URL: *mut xmlChar = 0 as *mut xmlChar;
    let mut ID: *mut xmlChar = 0 as *mut xmlChar;
    let mut base: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut URL: * mut u8 = 0 as *mut xmlChar;
    let mut ID: * mut u8 = 0 as *mut xmlChar;
    let mut base: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zzz:xmlCreateEntityParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut URL as *mut *mut xmlChar,
        &mut ID as *mut *mut xmlChar,
        &mut base as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCreateEntityParserCtxt(URL, ID, base);
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCreateFileParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut filename: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut filename: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlCreateFileParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut filename as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCreateFileParserCtxt(filename);
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCreateIntSubset(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDtd = 0 as *mut xmlDtd;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut ExternalID: * mut u8 = 0 as *mut xmlChar;
    let mut SystemID: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozzz:xmlCreateIntSubset\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut ExternalID as *mut *mut xmlChar,
        &mut SystemID as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlCreateIntSubset(doc, name, ExternalID, SystemID);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCreateMemoryParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut buffer: *mut i8 = 0 as *mut i8;
    let mut py_buffsize0: Py_ssize_t = 0;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut buffer: * mut i8 = 0 as *mut i8;
    let mut py_buffsize0: i64 = 0;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut size: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"s#i:xmlCreateMemoryParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut buffer as *mut *mut i8,
        &mut py_buffsize0 as *mut Py_ssize_t,
        &mut size as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCreateMemoryParserCtxt(buffer, size);
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCreateURI(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlURIPtr = 0 as *mut xmlURI;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    c_retval = xmlCreateURI();
    py_retval = libxml_xmlURIPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCreateURLParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut filename: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut filename: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zi:xmlCreateURLParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut filename as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlCreateURLParserCtxt(filename, options);
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCtxtReadDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut u8 = 0 as *mut xmlChar;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozzzi:xmlCtxtReadDoc\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut cur as *mut *mut xmlChar,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlCtxtReadDoc(ctxt, cur, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCtxtReadFd(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut fd: i32 = 0;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut fd: i32 = 0;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oizzi:xmlCtxtReadFd\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut fd as *mut i32,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlCtxtReadFd(ctxt, fd, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCtxtReadFile(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut filename: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut filename: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozzi:xmlCtxtReadFile\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut filename as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlCtxtReadFile(ctxt, filename, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCtxtReadMemory(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut buffer: *mut i8 = 0 as *mut i8;
    let mut py_buffsize0: Py_ssize_t = 0;
    let mut size: i32 = 0;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut buffer: * mut i8 = 0 as *mut i8;
    let mut py_buffsize0: i64 = 0;
    let mut size: i32 = 0;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Os#izzi:xmlCtxtReadMemory\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut buffer as *mut *mut i8,
        &mut py_buffsize0 as *mut Py_ssize_t,
        &mut size as *mut i32,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlCtxtReadMemory(ctxt, buffer, size, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCtxtReset(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlCtxtReset\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlCtxtReset(ctxt);
<<<<<<< HEAD
    let ref mut fresh21 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh21 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh21 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCtxtResetPush(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut chunk: *mut i8 = 0 as *mut i8;
    let mut py_buffsize0: Py_ssize_t = 0;
    let mut size: i32 = 0;
    let mut filename: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut chunk: * mut i8 = 0 as *mut i8;
    let mut py_buffsize0: i64 = 0;
    let mut size: i32 = 0;
    let mut filename: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Os#izz:xmlCtxtResetPush\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut chunk as *mut *mut i8,
        &mut py_buffsize0 as *mut Py_ssize_t,
        &mut size as *mut i32,
        &mut filename as *mut *mut i8,
        &mut encoding as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlCtxtResetPush(ctxt, chunk, size, filename, encoding);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlCtxtUseOptions(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlCtxtUseOptions\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlCtxtUseOptions(ctxt, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugCheckDocument(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut output: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_output: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlDebugCheckDocument\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_output as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    output = if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_output).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_output).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_output)
    } else {
        stdout
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlDebugCheckDocument(output, doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpAttr(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_attr: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut output: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_output: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut attr: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut pyobj_attr: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut depth: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOi:xmlDebugDumpAttr\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_output as *mut *mut PyObject,
        &mut pyobj_attr as *mut *mut PyObject,
        &mut depth as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    output = if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_output).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_output).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_output)
    } else {
        stdout
    };
    attr = (if pyobj_attr == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_attr as *mut PyxmlNode_Object)).obj
    }) as xmlAttrPtr;
    xmlDebugDumpAttr(output, attr, depth);
<<<<<<< HEAD
    let ref mut fresh22 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh22 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh22 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpAttrList(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_attr: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut output: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_output: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut attr: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut pyobj_attr: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut depth: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOi:xmlDebugDumpAttrList\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_output as *mut *mut PyObject,
        &mut pyobj_attr as *mut *mut PyObject,
        &mut depth as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    output = if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_output).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_output).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_output)
    } else {
        stdout
    };
    attr = (if pyobj_attr == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_attr as *mut PyxmlNode_Object)).obj
    }) as xmlAttrPtr;
    xmlDebugDumpAttrList(output, attr, depth);
<<<<<<< HEAD
    let ref mut fresh23 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh23 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh23 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpDTD(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut pyobj_dtd: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut output: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_output: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut dtd: * mut crate::src::python::libxml::_xmlDtd = 0 as *mut xmlDtd;
    let mut pyobj_dtd: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlDebugDumpDTD\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_output as *mut *mut PyObject,
        &mut pyobj_dtd as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    output = if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_output).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_output).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_output)
    } else {
        stdout
    };
    dtd = (if pyobj_dtd == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_dtd as *mut PyxmlNode_Object)).obj
    }) as xmlDtdPtr;
    xmlDebugDumpDTD(output, dtd);
<<<<<<< HEAD
    let ref mut fresh24 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh24 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh24 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpDocument(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut output: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_output: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlDebugDumpDocument\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_output as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    output = if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_output).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_output).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_output)
    } else {
        stdout
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    xmlDebugDumpDocument(output, doc);
<<<<<<< HEAD
    let ref mut fresh25 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh25 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh25 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpDocumentHead(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut output: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_output: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlDebugDumpDocumentHead\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_output as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    output = if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_output).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_output).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_output)
    } else {
        stdout
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    xmlDebugDumpDocumentHead(output, doc);
<<<<<<< HEAD
    let ref mut fresh26 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh26 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh26 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpEntities(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut output: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_output: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlDebugDumpEntities\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_output as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    output = if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_output).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_output).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_output)
    } else {
        stdout
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    xmlDebugDumpEntities(output, doc);
<<<<<<< HEAD
    let ref mut fresh27 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh27 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh27 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpNode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut output: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_output: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut depth: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOi:xmlDebugDumpNode\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_output as *mut *mut PyObject,
        &mut pyobj_node as *mut *mut PyObject,
        &mut depth as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    output = if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_output).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_output).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_output)
    } else {
        stdout
    };
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    xmlDebugDumpNode(output, node, depth);
<<<<<<< HEAD
    let ref mut fresh28 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh28 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh28 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpNodeList(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut output: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_output: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut depth: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOi:xmlDebugDumpNodeList\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_output as *mut *mut PyObject,
        &mut pyobj_node as *mut *mut PyObject,
        &mut depth as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    output = if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_output).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_output).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_output)
    } else {
        stdout
    };
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    xmlDebugDumpNodeList(output, node, depth);
<<<<<<< HEAD
    let ref mut fresh29 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh29 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh29 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpOneNode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut output: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_output: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut depth: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOi:xmlDebugDumpOneNode\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_output as *mut *mut PyObject,
        &mut pyobj_node as *mut *mut PyObject,
        &mut depth as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    output = if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_output).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_output).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_output)
    } else {
        stdout
    };
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    xmlDebugDumpOneNode(output, node, depth);
<<<<<<< HEAD
    let ref mut fresh30 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh30 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh30 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDebugDumpString(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut output: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_output: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut str: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlDebugDumpString\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_output as *mut *mut PyObject,
        &mut str as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    output = if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_output).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_output).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_output)
    } else {
        stdout
    };
    xmlDebugDumpString(output, str);
<<<<<<< HEAD
    let ref mut fresh31 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh31 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh31 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDecodeEntities(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut len: i32 = 0;
    let mut what: i32 = 0;
    let mut end: xmlChar = 0;
    let mut end2: xmlChar = 0;
    let mut end3: xmlChar = 0;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut len: i32 = 0;
    let mut what: i32 = 0;
    let mut end: u8 = 0;
    let mut end2: u8 = 0;
    let mut end3: u8 = 0;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlDecodeEntities\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oiiccc:xmlDecodeEntities\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut len as *mut i32,
        &mut what as *mut i32,
        &mut end as *mut xmlChar,
        &mut end2 as *mut xmlChar,
        &mut end3 as *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlDecodeEntities(ctxt, len, what, end, end2, end3);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDefaultSAXHandlerInit(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlDefaultSAXHandlerInit\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    xmlDefaultSAXHandlerInit();
<<<<<<< HEAD
    let ref mut fresh32 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh32 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh32 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDelEncodingAlias(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut alias: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut alias: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlDelEncodingAlias\0" as *const u8 as *const i8
            as *mut i8,
        &mut alias as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlDelEncodingAlias(alias);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDictCleanup(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(b"xmlDictCleanup\0" as *const u8 as *const i8)
        == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    xmlDictCleanup();
<<<<<<< HEAD
    let ref mut fresh33 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh33 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh33 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDocCopyNode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut extended: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOi:xmlDocCopyNode\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut extended as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlDocCopyNode(node, doc, extended);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDocCopyNodeList(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlDocCopyNodeList\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_node as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlDocCopyNodeList(doc, node);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDocDump(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut pyobj_f: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut f: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_f: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlDocDump\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_f as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    f = if pyobj_f == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_f).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_f).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_f)
    } else {
        stdout
    };
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlDocDump(f, cur);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDocFormatDump(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut pyobj_f: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut f: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_f: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut format: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOi:xmlDocFormatDump\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_f as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut format as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    f = if pyobj_f == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_f).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_f).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_f)
    } else {
        stdout
    };
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlDocFormatDump(f, cur, format);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDocGetRootElement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlDocGetRootElement\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as *mut xmlDoc;
    c_retval = xmlDocGetRootElement(doc);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlDocSetRootElement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut root: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_root: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut root: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_root: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlDocSetRootElement\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_root as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    root = if pyobj_root == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_root as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlDocSetRootElement(doc, root);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlElemDump(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut pyobj_f: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut f: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_f: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOO:xmlElemDump\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_f as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    f = if pyobj_f == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_f).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_f).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_f)
    } else {
        stdout
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    xmlElemDump(f, doc, cur);
<<<<<<< HEAD
    let ref mut fresh34 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh34 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh34 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlEncodeEntities(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut input: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut input: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlEncodeEntities\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlEncodeEntities\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut input as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlEncodeEntities(doc, input);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlEncodeEntitiesReentrant(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut input: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut input: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlEncodeEntitiesReentrant\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut input as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlEncodeEntitiesReentrant(doc, input);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlEncodeSpecialChars(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut input: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut input: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlEncodeSpecialChars\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut input as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as *mut xmlDoc;
    c_retval = xmlEncodeSpecialChars(doc, input);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlErrorGetCode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut Error: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_Error: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut Error: * mut crate::src::python::libxml::_xmlError = 0 as *mut xmlError;
    let mut pyobj_Error: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlErrorGetCode\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_Error as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    Error = if pyobj_Error == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlErrorPtr
    } else {
        (*(pyobj_Error as *mut PyError_Object)).obj
    };
    c_retval = (*Error).code;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlErrorGetDomain(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut Error: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_Error: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut Error: * mut crate::src::python::libxml::_xmlError = 0 as *mut xmlError;
    let mut pyobj_Error: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlErrorGetDomain\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_Error as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    Error = if pyobj_Error == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlErrorPtr
    } else {
        (*(pyobj_Error as *mut PyError_Object)).obj
    };
    c_retval = (*Error).domain;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlErrorGetFile(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const i8 = 0 as *const i8;
    let mut Error: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_Error: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const i8 = 0 as *const i8;
    let mut Error: * mut crate::src::python::libxml::_xmlError = 0 as *mut xmlError;
    let mut pyobj_Error: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlErrorGetFile\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_Error as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    Error = if pyobj_Error == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlErrorPtr
    } else {
        (*(pyobj_Error as *mut PyError_Object)).obj
    };
    c_retval = (*Error).file;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlErrorGetLevel(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut Error: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_Error: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut Error: * mut crate::src::python::libxml::_xmlError = 0 as *mut xmlError;
    let mut pyobj_Error: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlErrorGetLevel\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_Error as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    Error = if pyobj_Error == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlErrorPtr
    } else {
        (*(pyobj_Error as *mut PyError_Object)).obj
    };
    c_retval = (*Error).level as i32;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlErrorGetLine(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut Error: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_Error: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut Error: * mut crate::src::python::libxml::_xmlError = 0 as *mut xmlError;
    let mut pyobj_Error: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlErrorGetLine\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_Error as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    Error = if pyobj_Error == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlErrorPtr
    } else {
        (*(pyobj_Error as *mut PyError_Object)).obj
    };
    c_retval = (*Error).line;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlErrorGetMessage(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const i8 = 0 as *const i8;
    let mut Error: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_Error: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const i8 = 0 as *const i8;
    let mut Error: * mut crate::src::python::libxml::_xmlError = 0 as *mut xmlError;
    let mut pyobj_Error: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlErrorGetMessage\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_Error as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    Error = if pyobj_Error == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlErrorPtr
    } else {
        (*(pyobj_Error as *mut PyError_Object)).obj
    };
    c_retval = (*Error).message;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFileMatch(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlFileMatch\0" as *const u8 as *const i8 as *mut i8,
        &mut filename as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlFileMatch(filename);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFirstElementChild(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_parent: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut parent: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_parent: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlFirstElementChild\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_parent as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    parent = if pyobj_parent == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_parent as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlFirstElementChild(parent);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeCatalog(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut catal: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut pyobj_catal: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut catal: * mut crate::src::python::types::_xmlCatalog = 0 as *mut xmlCatalog;
    let mut pyobj_catal: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlFreeCatalog\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_catal as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    catal = if pyobj_catal == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlCatalogPtr
    } else {
        (*(pyobj_catal as *mut Pycatalog_Object)).obj
    };
    xmlFreeCatalog(catal);
<<<<<<< HEAD
    let ref mut fresh35 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh35 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh35 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut cur: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlFreeDoc\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    xmlFreeDoc(cur);
<<<<<<< HEAD
    let ref mut fresh36 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh36 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh36 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeDtd(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut cur: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut cur: * mut crate::src::python::libxml::_xmlDtd = 0 as *mut xmlDtd;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlFreeDtd\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlDtdPtr;
    xmlFreeDtd(cur);
<<<<<<< HEAD
    let ref mut fresh37 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh37 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh37 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeNode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlFreeNode\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    xmlFreeNode(cur);
<<<<<<< HEAD
    let ref mut fresh38 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh38 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh38 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeNodeList(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlFreeNodeList\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    xmlFreeNodeList(cur);
<<<<<<< HEAD
    let ref mut fresh39 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh39 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh39 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeNs(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut cur: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut cur: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlFreeNs\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlNsPtr;
    xmlFreeNs(cur);
<<<<<<< HEAD
    let ref mut fresh40 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh40 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh40 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeNsList(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut cur: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut cur: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlFreeNsList\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlNsPtr;
    xmlFreeNsList(cur);
<<<<<<< HEAD
    let ref mut fresh41 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh41 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh41 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeParserInputBuffer(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut in_0: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_in: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut in_0: * mut crate::src::python::libxml::_xmlParserInputBuffer = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_in: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlFreeParserInputBuffer\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_in as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    in_0 = if pyobj_in == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserInputBufferPtr
    } else {
        (*(pyobj_in as *mut PyinputBuffer_Object)).obj
    };
    xmlFreeParserInputBuffer(in_0);
<<<<<<< HEAD
    let ref mut fresh42 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh42 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh42 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeProp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut cur: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut cur: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlFreeProp\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlAttrPtr;
    xmlFreeProp(cur);
<<<<<<< HEAD
    let ref mut fresh43 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh43 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh43 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreePropList(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut cur: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut cur: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlFreePropList\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlAttrPtr;
    xmlFreePropList(cur);
<<<<<<< HEAD
    let ref mut fresh44 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh44 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh44 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlFreeURI(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut uri: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_uri: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut uri: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_uri: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlFreeURI\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_uri as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    uri = if pyobj_uri == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_uri as *mut PyURI_Object)).obj
    };
    xmlFreeURI(uri);
<<<<<<< HEAD
    let ref mut fresh45 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh45 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh45 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetCompressMode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    c_retval = xmlGetCompressMode();
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetDocCompressMode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlGetDocCompressMode\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as *mut xmlDoc;
    c_retval = xmlGetDocCompressMode(doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetDocEntity(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlEntity = 0 as *mut xmlEntity;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlGetDocEntity\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as *mut xmlDoc;
    c_retval = xmlGetDocEntity(doc, name);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetDtdAttrDesc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttributePtr = 0 as *mut xmlAttribute;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut pyobj_dtd: *mut PyObject = 0 as *mut PyObject;
    let mut elem: *mut xmlChar = 0 as *mut xmlChar;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml2_py::_xmlAttribute = 0 as *mut xmlAttribute;
    let mut dtd: * mut crate::src::python::libxml::_xmlDtd = 0 as *mut xmlDtd;
    let mut pyobj_dtd: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut u8 = 0 as *mut xmlChar;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozz:xmlGetDtdAttrDesc\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_dtd as *mut *mut PyObject,
        &mut elem as *mut *mut xmlChar,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    dtd = (if pyobj_dtd == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_dtd as *mut PyxmlNode_Object)).obj
    }) as xmlDtdPtr;
    c_retval = xmlGetDtdAttrDesc(dtd, elem, name);
    py_retval = libxml_xmlAttributePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetDtdElementDesc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlElementPtr = 0 as *mut xmlElement;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut pyobj_dtd: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml2_py::_xmlElement = 0 as *mut xmlElement;
    let mut dtd: * mut crate::src::python::libxml::_xmlDtd = 0 as *mut xmlDtd;
    let mut pyobj_dtd: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlGetDtdElementDesc\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_dtd as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    dtd = (if pyobj_dtd == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_dtd as *mut PyxmlNode_Object)).obj
    }) as xmlDtdPtr;
    c_retval = xmlGetDtdElementDesc(dtd, name);
    py_retval = libxml_xmlElementPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetDtdEntity(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlEntity = 0 as *mut xmlEntity;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlGetDtdEntity\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlGetDtdEntity(doc, name);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetDtdQAttrDesc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttributePtr = 0 as *mut xmlAttribute;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut pyobj_dtd: *mut PyObject = 0 as *mut PyObject;
    let mut elem: *mut xmlChar = 0 as *mut xmlChar;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml2_py::_xmlAttribute = 0 as *mut xmlAttribute;
    let mut dtd: * mut crate::src::python::libxml::_xmlDtd = 0 as *mut xmlDtd;
    let mut pyobj_dtd: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut u8 = 0 as *mut xmlChar;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut prefix: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozzz:xmlGetDtdQAttrDesc\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_dtd as *mut *mut PyObject,
        &mut elem as *mut *mut xmlChar,
        &mut name as *mut *mut xmlChar,
        &mut prefix as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    dtd = (if pyobj_dtd == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_dtd as *mut PyxmlNode_Object)).obj
    }) as xmlDtdPtr;
    c_retval = xmlGetDtdQAttrDesc(dtd, elem, name, prefix);
    py_retval = libxml_xmlAttributePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetDtdQElementDesc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlElementPtr = 0 as *mut xmlElement;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut pyobj_dtd: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml2_py::_xmlElement = 0 as *mut xmlElement;
    let mut dtd: * mut crate::src::python::libxml::_xmlDtd = 0 as *mut xmlDtd;
    let mut pyobj_dtd: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut prefix: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozz:xmlGetDtdQElementDesc\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_dtd as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut prefix as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    dtd = (if pyobj_dtd == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_dtd as *mut PyxmlNode_Object)).obj
    }) as xmlDtdPtr;
    c_retval = xmlGetDtdQElementDesc(dtd, name, prefix);
    py_retval = libxml_xmlElementPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetEncodingAlias(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const i8 = 0 as *const i8;
    let mut alias: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const i8 = 0 as *const i8;
    let mut alias: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlGetEncodingAlias\0" as *const u8 as *const i8
            as *mut i8,
        &mut alias as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlGetEncodingAlias(alias);
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetID(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut ID: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut ID: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlGetID\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut ID as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlGetID(doc, ID);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetIntSubset(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDtd = 0 as *mut xmlDtd;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlGetIntSubset\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as *mut xmlDoc;
    c_retval = xmlGetIntSubset(doc);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetLastChild(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_parent: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut parent: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_parent: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlGetLastChild\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_parent as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    parent = if pyobj_parent == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_parent as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlGetLastChild(parent);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetLastError(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlErrorPtr = 0 as *mut xmlError;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlError = 0 as *mut xmlError;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    c_retval = xmlGetLastError();
    py_retval = libxml_xmlErrorPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetLineNo(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i64 = 0;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i64 = 0;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlGetLineNo\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlGetLineNo(node);
    py_retval = libxml_longWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetNoNsProp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlGetNoNsProp\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlGetNoNsProp(node, name);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetNodePath(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlGetNodePath\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlGetNodePath(node);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetNsProp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut nameSpace: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut nameSpace: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozz:xmlGetNsProp\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut nameSpace as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlGetNsProp(node, name, nameSpace);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetParameterEntity(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlEntity = 0 as *mut xmlEntity;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlGetParameterEntity\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlGetParameterEntity(doc, name);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetPredefinedEntity(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlEntity = 0 as *mut xmlEntity;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlGetPredefinedEntity\0" as *const u8 as *const i8
            as *mut i8,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlGetPredefinedEntity(name);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlGetProp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlGetProp\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlGetProp(node, name);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlHandleEntity(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut entity: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut pyobj_entity: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut entity: * mut crate::src::python::libxml::_xmlEntity = 0 as *mut xmlEntity;
    let mut pyobj_entity: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlHandleEntity\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlHandleEntity\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_entity as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    entity = (if pyobj_entity == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_entity as *mut PyxmlNode_Object)).obj
    }) as xmlEntityPtr;
    xmlHandleEntity(ctxt, entity);
<<<<<<< HEAD
    let ref mut fresh46 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh46 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh46 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlHasNsProp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut nameSpace: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut nameSpace: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozz:xmlHasNsProp\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut nameSpace as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlHasNsProp(node, name, nameSpace);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlHasProp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlHasProp\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlHasProp(node, name);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIOFTPMatch(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlIOFTPMatch\0" as *const u8 as *const i8 as *mut i8,
        &mut filename as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlIOFTPMatch(filename);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIOHTTPMatch(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlIOHTTPMatch\0" as *const u8 as *const i8 as *mut i8,
        &mut filename as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlIOHTTPMatch(filename);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlInitCharEncodingHandlers(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlInitCharEncodingHandlers\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    xmlInitCharEncodingHandlers();
<<<<<<< HEAD
    let ref mut fresh47 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh47 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh47 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlInitGlobals(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(b"xmlInitGlobals\0" as *const u8 as *const i8)
        == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    xmlInitGlobals();
<<<<<<< HEAD
    let ref mut fresh48 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh48 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh48 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlInitParser(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    xmlInitParser();
    let ref mut fresh49 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    xmlInitParser();
    let ref mut fresh49 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh49 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlInitParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlInitParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlInitParserCtxt(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlInitializeCatalog(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    xmlInitializeCatalog();
    let ref mut fresh50 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    xmlInitializeCatalog();
    let ref mut fresh50 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh50 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlInitializeDict(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    if libxml_deprecationWarning(
        b"xmlInitializeDict\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlInitializeDict();
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlInitializePredefinedEntities(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlInitializePredefinedEntities\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    xmlInitializePredefinedEntities();
<<<<<<< HEAD
    let ref mut fresh51 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh51 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh51 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsBaseChar(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut ch: u32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlIsBaseChar\0" as *const u8 as *const i8 as *mut i8,
        &mut ch as *mut u32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlIsBaseChar(ch);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsBlank(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut ch: u32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlIsBlank\0" as *const u8 as *const i8 as *mut i8,
        &mut ch as *mut u32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlIsBlank(ch);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsBlankNode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlIsBlankNode\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlIsBlankNode(node);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsChar(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut ch: u32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlIsChar\0" as *const u8 as *const i8 as *mut i8,
        &mut ch as *mut u32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlIsChar(ch);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsCombining(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut ch: u32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlIsCombining\0" as *const u8 as *const i8 as *mut i8,
        &mut ch as *mut u32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlIsCombining(ch);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsDigit(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut ch: u32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlIsDigit\0" as *const u8 as *const i8 as *mut i8,
        &mut ch as *mut u32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlIsDigit(ch);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsExtender(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut ch: u32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlIsExtender\0" as *const u8 as *const i8 as *mut i8,
        &mut ch as *mut u32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlIsExtender(ch);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsID(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_attr: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut attr: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut pyobj_attr: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOO:xmlIsID\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
        &mut pyobj_attr as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    attr = (if pyobj_attr == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_attr as *mut PyxmlNode_Object)).obj
    }) as xmlAttrPtr;
    c_retval = xmlIsID(doc, elem, attr);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsIdeographic(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut ch: u32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlIsIdeographic\0" as *const u8 as *const i8 as *mut i8,
        &mut ch as *mut u32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlIsIdeographic(ch);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsLetter(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut c: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlIsLetter\0" as *const u8 as *const i8 as *mut i8,
        &mut c as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlIsLetter(c);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsMixedElement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlIsMixedElement\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlIsMixedElement(doc, name);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsPubidChar(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut ch: u32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlIsPubidChar\0" as *const u8 as *const i8 as *mut i8,
        &mut ch as *mut u32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlIsPubidChar(ch);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsRef(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_attr: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut attr: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut pyobj_attr: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(b"xmlIsRef\0" as *const u8 as *const i8)
        == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOO:xmlIsRef\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
        &mut pyobj_attr as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    attr = (if pyobj_attr == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_attr as *mut PyxmlNode_Object)).obj
    }) as xmlAttrPtr;
    c_retval = xmlIsRef(doc, elem, attr);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlIsXHTML(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut systemID: *mut xmlChar = 0 as *mut xmlChar;
    let mut publicID: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut systemID: * mut u8 = 0 as *mut xmlChar;
    let mut publicID: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:xmlIsXHTML\0" as *const u8 as *const i8 as *mut i8,
        &mut systemID as *mut *mut xmlChar,
        &mut publicID as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlIsXHTML(systemID, publicID);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlKeepBlanksDefault(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut val: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlKeepBlanksDefault\0" as *const u8 as *const i8
            as *mut i8,
        &mut val as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlKeepBlanksDefault(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlLastElementChild(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_parent: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut parent: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_parent: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlLastElementChild\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_parent as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    parent = if pyobj_parent == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_parent as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlLastElementChild(parent);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlLineNumbersDefault(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut val: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlLineNumbersDefault\0" as *const u8 as *const i8
            as *mut i8,
        &mut val as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlLineNumbersDefault(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlLoadACatalog(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut filename: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::types::_xmlCatalog = 0 as *mut xmlCatalog;
    let mut filename: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlLoadACatalog\0" as *const u8 as *const i8 as *mut i8,
        &mut filename as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlLoadACatalog(filename);
    py_retval = libxml_xmlCatalogPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlLoadCatalog(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlLoadCatalog\0" as *const u8 as *const i8 as *mut i8,
        &mut filename as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlLoadCatalog(filename);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlLoadCatalogs(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut pathss: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut pathss: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlLoadCatalogs\0" as *const u8 as *const i8 as *mut i8,
        &mut pathss as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    xmlLoadCatalogs(pathss);
<<<<<<< HEAD
    let ref mut fresh52 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh52 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh52 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlLoadSGMLSuperCatalog(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlCatalogPtr = 0 as *mut xmlCatalog;
    let mut filename: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::types::_xmlCatalog = 0 as *mut xmlCatalog;
    let mut filename: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlLoadSGMLSuperCatalog\0" as *const u8 as *const i8
            as *mut i8,
        &mut filename as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlLoadSGMLSuperCatalog(filename);
    py_retval = libxml_xmlCatalogPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlLsCountNode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlLsCountNode\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlLsCountNode(node);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlLsOneNode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut output: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_output: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlLsOneNode\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_output as *mut *mut PyObject,
        &mut pyobj_node as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    output = if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_output).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_output).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_output)
    } else {
        stdout
    };
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    xmlLsOneNode(output, node);
<<<<<<< HEAD
    let ref mut fresh53 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh53 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh53 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNamespaceParseNCName(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlNamespaceParseNCName\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlNamespaceParseNCName\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlNamespaceParseNCName(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNamespaceParseNSDef(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlNamespaceParseNSDef\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlNamespaceParseNSDef\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlNamespaceParseNSDef(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNanoFTPCleanup(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlNanoFTPCleanup\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    xmlNanoFTPCleanup();
<<<<<<< HEAD
    let ref mut fresh54 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh54 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh54 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNanoFTPInit(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(b"xmlNanoFTPInit\0" as *const u8 as *const i8)
        == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    xmlNanoFTPInit();
<<<<<<< HEAD
    let ref mut fresh55 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh55 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh55 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNanoFTPProxy(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut host: *mut i8 = 0 as *mut i8;
    let mut port: i32 = 0;
    let mut user: *mut i8 = 0 as *mut i8;
    let mut passwd: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut host: * mut i8 = 0 as *mut i8;
    let mut port: i32 = 0;
    let mut user: * mut i8 = 0 as *mut i8;
    let mut passwd: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut type_0: i32 = 0;
    if libxml_deprecationWarning(
        b"xmlNanoFTPProxy\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zizzi:xmlNanoFTPProxy\0" as *const u8 as *const i8
            as *mut i8,
        &mut host as *mut *mut i8,
        &mut port as *mut i32,
        &mut user as *mut *mut i8,
        &mut passwd as *mut *mut i8,
        &mut type_0 as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    xmlNanoFTPProxy(host, port, user, passwd, type_0);
<<<<<<< HEAD
    let ref mut fresh56 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh56 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh56 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNanoFTPScanProxy(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut URL: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut URL: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlNanoFTPScanProxy\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlNanoFTPScanProxy\0" as *const u8 as *const i8
            as *mut i8,
        &mut URL as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    xmlNanoFTPScanProxy(URL);
<<<<<<< HEAD
    let ref mut fresh57 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh57 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh57 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNanoHTTPCleanup(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    xmlNanoHTTPCleanup();
    let ref mut fresh58 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    xmlNanoHTTPCleanup();
    let ref mut fresh58 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh58 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNanoHTTPInit(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    xmlNanoHTTPInit();
    let ref mut fresh59 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    xmlNanoHTTPInit();
    let ref mut fresh59 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh59 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNanoHTTPScanProxy(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut URL: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut URL: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlNanoHTTPScanProxy\0" as *const u8 as *const i8
            as *mut i8,
        &mut URL as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    xmlNanoHTTPScanProxy(URL);
<<<<<<< HEAD
    let ref mut fresh60 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh60 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh60 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewCDataBlock(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozi:xmlNewCDataBlock\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut content as *mut *mut xmlChar,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlNewCDataBlock(doc, content, len);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewCatalog(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlCatalogPtr = 0 as *mut xmlCatalog;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::types::_xmlCatalog = 0 as *mut xmlCatalog;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut sgml: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlNewCatalog\0" as *const u8 as *const i8 as *mut i8,
        &mut sgml as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlNewCatalog(sgml);
    py_retval = libxml_xmlCatalogPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewCharRef(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlNewCharRef\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlNewCharRef(doc, name);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewChild(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_parent: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut parent: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_parent: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut ns: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut pyobj_ns: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOzz:xmlNewChild\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_parent as *mut *mut PyObject,
        &mut pyobj_ns as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut content as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    parent = if pyobj_parent == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_parent as *mut PyxmlNode_Object)).obj
    };
    ns = (if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_ns as *mut PyxmlNode_Object)).obj
    }) as xmlNsPtr;
    c_retval = xmlNewChild(parent, ns, name, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewComment(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlNewComment\0" as *const u8 as *const i8 as *mut i8,
        &mut content as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlNewComment(content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut version: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut version: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlNewDoc\0" as *const u8 as *const i8 as *mut i8,
        &mut version as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlNewDoc(version);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocComment(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlNewDocComment\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut content as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlNewDocComment(doc, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocFragment(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlNewDocFragment\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlNewDocFragment(doc);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocNode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut ns: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut pyobj_ns: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOzz:xmlNewDocNode\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_ns as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut content as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    ns = (if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_ns as *mut PyxmlNode_Object)).obj
    }) as xmlNsPtr;
    c_retval = xmlNewDocNode(doc, ns, name, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocNodeEatName(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut ns: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut pyobj_ns: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOzz:xmlNewDocNodeEatName\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_ns as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut content as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    ns = (if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_ns as *mut PyxmlNode_Object)).obj
    }) as xmlNsPtr;
    c_retval = xmlNewDocNodeEatName(doc, ns, name, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocPI(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozz:xmlNewDocPI\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut content as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlNewDocPI(doc, name, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocProp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozz:xmlNewDocProp\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlNewDocProp(doc, name, value);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocRawNode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut ns: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut pyobj_ns: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOzz:xmlNewDocRawNode\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_ns as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut content as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    ns = (if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_ns as *mut PyxmlNode_Object)).obj
    }) as xmlNsPtr;
    c_retval = xmlNewDocRawNode(doc, ns, name, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocText(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlNewDocText\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut content as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as *mut xmlDoc;
    c_retval = xmlNewDocText(doc, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDocTextLen(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozi:xmlNewDocTextLen\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut content as *mut *mut xmlChar,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlNewDocTextLen(doc, content, len);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewDtd(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDtd = 0 as *mut xmlDtd;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut ExternalID: * mut u8 = 0 as *mut xmlChar;
    let mut SystemID: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozzz:xmlNewDtd\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut ExternalID as *mut *mut xmlChar,
        &mut SystemID as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlNewDtd(doc, name, ExternalID, SystemID);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewEntity(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut type_0: i32 = 0;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlEntity = 0 as *mut xmlEntity;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut type_0: i32 = 0;
    let mut ExternalID: * mut u8 = 0 as *mut xmlChar;
    let mut SystemID: * mut u8 = 0 as *mut xmlChar;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozizzz:xmlNewEntity\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut type_0 as *mut i32,
        &mut ExternalID as *mut *mut xmlChar,
        &mut SystemID as *mut *mut xmlChar,
        &mut content as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlNewEntity(doc, name, type_0, ExternalID, SystemID, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewGlobalNs(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNsPtr = 0 as *mut xmlNs;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut href: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut href: * mut u8 = 0 as *mut xmlChar;
    let mut prefix: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(b"xmlNewGlobalNs\0" as *const u8 as *const i8)
        == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozz:xmlNewGlobalNs\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut href as *mut *mut xmlChar,
        &mut prefix as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlNewGlobalNs(doc, href, prefix);
    py_retval = libxml_xmlNsPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewNodeEatName(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut ns: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut pyobj_ns: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlNewNodeEatName\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ns as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ns = (if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_ns as *mut PyxmlNode_Object)).obj
    }) as xmlNsPtr;
    c_retval = xmlNewNodeEatName(ns, name);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewNs(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNsPtr = 0 as *mut xmlNs;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut href: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut href: * mut u8 = 0 as *mut xmlChar;
    let mut prefix: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozz:xmlNewNs\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut href as *mut *mut xmlChar,
        &mut prefix as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlNewNs(node, href, prefix);
    py_retval = libxml_xmlNsPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewNsProp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut ns: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut pyobj_ns: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOzz:xmlNewNsProp\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut pyobj_ns as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    ns = (if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_ns as *mut PyxmlNode_Object)).obj
    }) as xmlNsPtr;
    c_retval = xmlNewNsProp(node, ns, name, value);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewNsPropEatName(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut ns: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut pyobj_ns: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOzz:xmlNewNsPropEatName\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut pyobj_ns as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    ns = (if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_ns as *mut PyxmlNode_Object)).obj
    }) as xmlNsPtr;
    c_retval = xmlNewNsPropEatName(node, ns, name, value);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewPI(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:xmlNewPI\0" as *const u8 as *const i8 as *mut i8,
        &mut name as *mut *mut xmlChar,
        &mut content as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlNewPI(name, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    c_retval = xmlNewParserCtxt();
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewProp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozz:xmlNewProp\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlNewProp(node, name, value);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewReference(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlNewReference\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as *mut xmlDoc;
    c_retval = xmlNewReference(doc, name);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewText(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlNewText\0" as *const u8 as *const i8 as *mut i8,
        &mut content as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlNewText(content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewTextChild(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut parent: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_parent: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut parent: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_parent: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut ns: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut pyobj_ns: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOzz:xmlNewTextChild\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_parent as *mut *mut PyObject,
        &mut pyobj_ns as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut content as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    parent = if pyobj_parent == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_parent as *mut PyxmlNode_Object)).obj
    };
    ns = (if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_ns as *mut PyxmlNode_Object)).obj
    }) as xmlNsPtr;
    c_retval = xmlNewTextChild(parent, ns, name, content);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewTextLen(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zi:xmlNewTextLen\0" as *const u8 as *const i8 as *mut i8,
        &mut content as *mut *mut xmlChar,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlNewTextLen(content, len);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewTextReader(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_input: *mut PyObject = 0 as *mut PyObject;
    let mut URI: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut input: * mut crate::src::python::libxml::_xmlParserInputBuffer = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_input: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut URI: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlNewTextReader\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_input as *mut *mut PyObject,
        &mut URI as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    input = if pyobj_input == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserInputBufferPtr
    } else {
        (*(pyobj_input as *mut PyinputBuffer_Object)).obj
    };
    c_retval = xmlNewTextReader(input, URI);
    py_retval = libxml_xmlTextReaderPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewTextReaderFilename(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut URI: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut URI: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlNewTextReaderFilename\0" as *const u8 as *const i8
            as *mut i8,
        &mut URI as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlNewTextReaderFilename(URI);
    py_retval = libxml_xmlTextReaderPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNewValidCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlValidCtxt = 0 as *mut xmlValidCtxt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    c_retval = xmlNewValidCtxt();
    py_retval = libxml_xmlValidCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNextChar(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlNextChar\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlNextChar(ctxt);
<<<<<<< HEAD
    let ref mut fresh61 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh61 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh61 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNextElementSibling(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlNextElementSibling\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlNextElementSibling(node);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeAddContent(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlNodeAddContent\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut content as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    xmlNodeAddContent(cur, content);
<<<<<<< HEAD
    let ref mut fresh62 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh62 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh62 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeAddContentLen(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozi:xmlNodeAddContentLen\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut content as *mut *mut xmlChar,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    xmlNodeAddContentLen(cur, content, len);
<<<<<<< HEAD
    let ref mut fresh63 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh63 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh63 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeDumpOutput(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut buf: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut pyobj_buf: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut level: i32 = 0;
    let mut format: i32 = 0;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut buf: * mut crate::src::python::libxml::_xmlOutputBuffer = 0 as *mut xmlOutputBuffer;
    let mut pyobj_buf: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut level: i32 = 0;
    let mut format: i32 = 0;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOOiiz:xmlNodeDumpOutput\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_buf as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut level as *mut i32,
        &mut format as *mut i32,
        &mut encoding as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    buf = if pyobj_buf == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlOutputBufferPtr
    } else {
        (*(pyobj_buf as *mut PyoutputBuffer_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    xmlNodeDumpOutput(buf, doc, cur, level, format, encoding);
<<<<<<< HEAD
    let ref mut fresh64 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh64 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh64 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeGetBase(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut cur: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlNodeGetBase\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as *mut xmlDoc;
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlNodeGetBase(doc, cur);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeGetContent(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlNodeGetContent\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlNodeGetContent(cur);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeGetLang(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlNodeGetLang\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlNodeGetLang(cur);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeGetSpacePreserve(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut cur: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlNodeGetSpacePreserve\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlNodeGetSpacePreserve(cur);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeIsText(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut node: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlNodeIsText\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlNodeIsText(node);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeListGetRawString(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut list: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_list: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut list: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_list: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut inLine: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOi:xmlNodeListGetRawString\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_list as *mut *mut PyObject,
        &mut inLine as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as *mut xmlDoc;
    list = if pyobj_list == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_list as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlNodeListGetRawString(doc, list, inLine);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeListGetString(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut list: *mut xmlNode = 0 as *mut xmlNode;
    let mut pyobj_list: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut list: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_list: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut inLine: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOi:xmlNodeListGetString\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_list as *mut *mut PyObject,
        &mut inLine as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    list = if pyobj_list == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_list as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlNodeListGetString(doc, list, inLine);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeSetBase(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut uri: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut uri: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlNodeSetBase\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut uri as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    xmlNodeSetBase(cur, uri);
<<<<<<< HEAD
    let ref mut fresh65 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh65 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh65 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeSetContent(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlNodeSetContent\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut content as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    xmlNodeSetContent(cur, content);
<<<<<<< HEAD
    let ref mut fresh66 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh66 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh66 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeSetContentLen(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozi:xmlNodeSetContentLen\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut content as *mut *mut xmlChar,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    xmlNodeSetContentLen(cur, content, len);
<<<<<<< HEAD
    let ref mut fresh67 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh67 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh67 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeSetLang(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut lang: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut lang: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlNodeSetLang\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut lang as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    xmlNodeSetLang(cur, lang);
<<<<<<< HEAD
    let ref mut fresh68 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh68 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh68 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeSetName(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlNodeSetName\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    xmlNodeSetName(cur, name);
<<<<<<< HEAD
    let ref mut fresh69 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh69 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh69 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNodeSetSpacePreserve(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut val: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlNodeSetSpacePreserve\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut val as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    xmlNodeSetSpacePreserve(cur, val);
<<<<<<< HEAD
    let ref mut fresh70 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh70 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh70 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNormalizeURIPath(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut path: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut path: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlNormalizeURIPath\0" as *const u8 as *const i8
            as *mut i8,
        &mut path as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlNormalizeURIPath(path);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlNormalizeWindowsPath(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut path: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut path: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlNormalizeWindowsPath\0" as *const u8 as *const i8
            as *mut i8,
        &mut path as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlNormalizeWindowsPath(path);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlOutputBufferGetContent(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut out: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut pyobj_out: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut out: * mut crate::src::python::libxml::_xmlOutputBuffer = 0 as *mut xmlOutputBuffer;
    let mut pyobj_out: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlOutputBufferGetContent\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_out as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    out = if pyobj_out == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlOutputBufferPtr
    } else {
        (*(pyobj_out as *mut PyoutputBuffer_Object)).obj
    };
    c_retval = xmlOutputBufferGetContent(out);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlOutputBufferWrite(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut out: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut pyobj_out: *mut PyObject = 0 as *mut PyObject;
    let mut len: i32 = 0;
    let mut buf: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut out: * mut crate::src::python::libxml::_xmlOutputBuffer = 0 as *mut xmlOutputBuffer;
    let mut pyobj_out: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut len: i32 = 0;
    let mut buf: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oiz:xmlOutputBufferWrite\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_out as *mut *mut PyObject,
        &mut len as *mut i32,
        &mut buf as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    out = if pyobj_out == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlOutputBufferPtr
    } else {
        (*(pyobj_out as *mut PyoutputBuffer_Object)).obj
    };
    c_retval = xmlOutputBufferWrite(out, len, buf);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlOutputBufferWriteString(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut out: xmlOutputBufferPtr = 0 as *mut xmlOutputBuffer;
    let mut pyobj_out: *mut PyObject = 0 as *mut PyObject;
    let mut str: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut out: * mut crate::src::python::libxml::_xmlOutputBuffer = 0 as *mut xmlOutputBuffer;
    let mut pyobj_out: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut str: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlOutputBufferWriteString\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_out as *mut *mut PyObject,
        &mut str as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    out = if pyobj_out == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlOutputBufferPtr
    } else {
        (*(pyobj_out as *mut PyoutputBuffer_Object)).obj
    };
    c_retval = xmlOutputBufferWriteString(out, str);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseAttValue(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseAttValue\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParseAttValue(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseAttributeListDecl(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseAttributeListDecl\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParseAttributeListDecl(ctxt);
<<<<<<< HEAD
    let ref mut fresh71 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh71 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh71 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseCDSect(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseCDSect\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParseCDSect(ctxt);
<<<<<<< HEAD
    let ref mut fresh72 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh72 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh72 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseCatalogFile(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut filename: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlParseCatalogFile\0" as *const u8 as *const i8
            as *mut i8,
        &mut filename as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlParseCatalogFile(filename);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseCharData(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut cdata: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlParseCharData\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut cdata as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParseCharData(ctxt, cdata);
<<<<<<< HEAD
    let ref mut fresh73 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh73 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh73 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseCharRef(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseCharRef\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParseCharRef(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseChunk(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut chunk: *mut i8 = 0 as *mut i8;
    let mut py_buffsize0: Py_ssize_t = 0;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut chunk: * mut i8 = 0 as *mut i8;
    let mut py_buffsize0: i64 = 0;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut size: i32 = 0;
    let mut terminate: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Os#ii:xmlParseChunk\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut chunk as *mut *mut i8,
        &mut py_buffsize0 as *mut Py_ssize_t,
        &mut size as *mut i32,
        &mut terminate as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParseChunk(ctxt, chunk, size, terminate);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseComment(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseComment\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParseComment(ctxt);
<<<<<<< HEAD
    let ref mut fresh74 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh74 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh74 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseContent(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseContent\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParseContent(ctxt);
<<<<<<< HEAD
    let ref mut fresh75 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh75 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh75 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseDTD(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDtd = 0 as *mut xmlDtd;
    let mut ExternalID: * mut u8 = 0 as *mut xmlChar;
    let mut SystemID: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:xmlParseDTD\0" as *const u8 as *const i8 as *mut i8,
        &mut ExternalID as *mut *mut xmlChar,
        &mut SystemID as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlParseDTD(ExternalID, SystemID);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut cur: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlParseDoc\0" as *const u8 as *const i8 as *mut i8,
        &mut cur as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlParseDoc(cur);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseDocTypeDecl(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseDocTypeDecl\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParseDocTypeDecl(ctxt);
<<<<<<< HEAD
    let ref mut fresh76 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh76 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh76 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseDocument(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseDocument\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParseDocument(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseElement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseElement\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParseElement(ctxt);
<<<<<<< HEAD
    let ref mut fresh77 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh77 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh77 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseElementDecl(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseElementDecl\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParseElementDecl(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseEncName(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseEncName\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParseEncName(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseEncodingDecl(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseEncodingDecl\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParseEncodingDecl(ctxt);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseEndTag(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseEndTag\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParseEndTag(ctxt);
<<<<<<< HEAD
    let ref mut fresh78 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh78 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh78 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseEntity(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut filename: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlParseEntity\0" as *const u8 as *const i8 as *mut i8,
        &mut filename as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlParseEntity(filename);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseEntityDecl(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseEntityDecl\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParseEntityDecl(ctxt);
<<<<<<< HEAD
    let ref mut fresh79 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh79 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh79 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseEntityRef(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlEntityPtr = 0 as *mut xmlEntity;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlEntity = 0 as *mut xmlEntity;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseEntityRef\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParseEntityRef(ctxt);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseExtParsedEnt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseExtParsedEnt\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParseExtParsedEnt(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseExternalSubset(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut ExternalID: *mut xmlChar = 0 as *mut xmlChar;
    let mut SystemID: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut ExternalID: * mut u8 = 0 as *mut xmlChar;
    let mut SystemID: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozz:xmlParseExternalSubset\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut ExternalID as *mut *mut xmlChar,
        &mut SystemID as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParseExternalSubset(ctxt, ExternalID, SystemID);
<<<<<<< HEAD
    let ref mut fresh80 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh80 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh80 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseFile(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut filename: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlParseFile\0" as *const u8 as *const i8 as *mut i8,
        &mut filename as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlParseFile(filename);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseMarkupDecl(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseMarkupDecl\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParseMarkupDecl(ctxt);
<<<<<<< HEAD
    let ref mut fresh81 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh81 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh81 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseMemory(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut buffer: *mut i8 = 0 as *mut i8;
    let mut py_buffsize0: Py_ssize_t = 0;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut buffer: * mut i8 = 0 as *mut i8;
    let mut py_buffsize0: i64 = 0;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut size: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"s#i:xmlParseMemory\0" as *const u8 as *const i8 as *mut i8,
        &mut buffer as *mut *mut i8,
        &mut py_buffsize0 as *mut Py_ssize_t,
        &mut size as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlParseMemory(buffer, size);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseMisc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseMisc\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParseMisc(ctxt);
<<<<<<< HEAD
    let ref mut fresh82 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh82 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh82 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseName(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseName\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParseName(ctxt);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseNamespace(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlParseNamespace\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseNamespace\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParseNamespace(ctxt);
<<<<<<< HEAD
    let ref mut fresh83 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh83 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh83 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseNmtoken(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseNmtoken\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParseNmtoken(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseNotationDecl(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseNotationDecl\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParseNotationDecl(ctxt);
<<<<<<< HEAD
    let ref mut fresh84 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh84 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh84 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParsePEReference(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParsePEReference\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParsePEReference(ctxt);
<<<<<<< HEAD
    let ref mut fresh85 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh85 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh85 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParsePI(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParsePI\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParsePI(ctxt);
<<<<<<< HEAD
    let ref mut fresh86 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh86 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh86 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParsePITarget(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParsePITarget\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParsePITarget(ctxt);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParsePubidLiteral(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParsePubidLiteral\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParsePubidLiteral(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseQuotedString(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlParseQuotedString\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseQuotedString\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParseQuotedString(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseReference(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseReference\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParseReference(ctxt);
<<<<<<< HEAD
    let ref mut fresh87 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh87 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh87 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseSDDecl(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseSDDecl\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParseSDDecl(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseStartTag(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseStartTag\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParseStartTag(ctxt);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseSystemLiteral(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseSystemLiteral\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParseSystemLiteral(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseTextDecl(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseTextDecl\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParseTextDecl(ctxt);
<<<<<<< HEAD
    let ref mut fresh88 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh88 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh88 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseURI(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlURIPtr = 0 as *mut xmlURI;
    let mut str: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut str: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlParseURI\0" as *const u8 as *const i8 as *mut i8,
        &mut str as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlParseURI(str);
    py_retval = libxml_xmlURIPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseURIRaw(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlURIPtr = 0 as *mut xmlURI;
    let mut str: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut str: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut raw: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zi:xmlParseURIRaw\0" as *const u8 as *const i8 as *mut i8,
        &mut str as *mut *mut i8,
        &mut raw as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlParseURIRaw(str, raw);
    py_retval = libxml_xmlURIPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseURIReference(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut uri: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_uri: *mut PyObject = 0 as *mut PyObject;
    let mut str: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut uri: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_uri: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut str: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlParseURIReference\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_uri as *mut *mut PyObject,
        &mut str as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    uri = if pyobj_uri == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_uri as *mut PyURI_Object)).obj
    };
    c_retval = xmlParseURIReference(uri, str);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseVersionInfo(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseVersionInfo\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParseVersionInfo(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseVersionNum(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseVersionNum\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlParseVersionNum(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParseXMLDecl(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParseXMLDecl\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParseXMLDecl(ctxt);
<<<<<<< HEAD
    let ref mut fresh89 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh89 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh89 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserGetDirectory(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut i8 = 0 as *mut i8;
    let mut filename: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut i8 = 0 as *mut i8;
    let mut filename: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlParserGetDirectory\0" as *const u8 as *const i8
            as *mut i8,
        &mut filename as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlParserGetDirectory(filename);
    py_retval = libxml_charPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserGetDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParserGetDoc\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = (*ctxt).myDoc;
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserGetIsValid(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParserGetIsValid\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = (*ctxt).valid;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserGetWellFormed(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParserGetWellFormed\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = (*ctxt).wellFormed;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserHandlePEReference(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParserHandlePEReference\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParserHandlePEReference(ctxt);
<<<<<<< HEAD
    let ref mut fresh90 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh90 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh90 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserHandleReference(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlParserHandleReference\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlParserHandleReference\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlParserHandleReference(ctxt);
<<<<<<< HEAD
    let ref mut fresh91 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh91 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh91 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserInputBufferGrow(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut in_0: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_in: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut in_0: * mut crate::src::python::libxml::_xmlParserInputBuffer = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_in: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlParserInputBufferGrow\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_in as *mut *mut PyObject,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    in_0 = if pyobj_in == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserInputBufferPtr
    } else {
        (*(pyobj_in as *mut PyinputBuffer_Object)).obj
    };
    c_retval = xmlParserInputBufferGrow(in_0, len);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserInputBufferPush(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut in_0: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_in: *mut PyObject = 0 as *mut PyObject;
    let mut len: i32 = 0;
    let mut buf: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut in_0: * mut crate::src::python::libxml::_xmlParserInputBuffer = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_in: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut len: i32 = 0;
    let mut buf: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oiz:xmlParserInputBufferPush\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_in as *mut *mut PyObject,
        &mut len as *mut i32,
        &mut buf as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    in_0 = if pyobj_in == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserInputBufferPtr
    } else {
        (*(pyobj_in as *mut PyinputBuffer_Object)).obj
    };
    c_retval = xmlParserInputBufferPush(in_0, len, buf);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserInputBufferRead(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut in_0: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_in: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut in_0: * mut crate::src::python::libxml::_xmlParserInputBuffer = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_in: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlParserInputBufferRead\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_in as *mut *mut PyObject,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    in_0 = if pyobj_in == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserInputBufferPtr
    } else {
        (*(pyobj_in as *mut PyinputBuffer_Object)).obj
    };
    c_retval = xmlParserInputBufferRead(in_0, len);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserSetLineNumbers(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut linenumbers: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlParserSetLineNumbers\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut linenumbers as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    (*ctxt).linenumbers = linenumbers;
<<<<<<< HEAD
    let ref mut fresh92 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh92 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh92 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserSetLoadSubset(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut loadsubset: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlParserSetLoadSubset\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut loadsubset as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    (*ctxt).loadsubset = loadsubset;
<<<<<<< HEAD
    let ref mut fresh93 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh93 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh93 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserSetPedantic(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut pedantic: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlParserSetPedantic\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pedantic as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    (*ctxt).pedantic = pedantic;
<<<<<<< HEAD
    let ref mut fresh94 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh94 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh94 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserSetReplaceEntities(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut replaceEntities: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlParserSetReplaceEntities\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut replaceEntities as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    (*ctxt).replaceEntities = replaceEntities;
<<<<<<< HEAD
    let ref mut fresh95 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh95 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh95 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlParserSetValidate(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut validate: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlParserSetValidate\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut validate as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    (*ctxt).validate = validate;
<<<<<<< HEAD
    let ref mut fresh96 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh96 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh96 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlPathToURI(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut path: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut path: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlPathToURI\0" as *const u8 as *const i8 as *mut i8,
        &mut path as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlPathToURI(path);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlPedanticParserDefault(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut val: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlPedanticParserDefault\0" as *const u8 as *const i8
            as *mut i8,
        &mut val as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlPedanticParserDefault(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlPopInput(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlChar = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: u8 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlPopInput\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlPopInput(ctxt);
    py_retval = libxml_intWrap(c_retval as i32);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlPopOutputCallbacks(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    c_retval = xmlPopOutputCallbacks();
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlPreviousElementSibling(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlPreviousElementSibling\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlPreviousElementSibling(node);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlPrintURI(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut stream: *mut FILE = 0 as *mut FILE;
    let mut pyobj_stream: *mut PyObject = 0 as *mut PyObject;
    let mut uri: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_uri: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut stream: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_stream: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut uri: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_uri: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlPrintURI\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_stream as *mut *mut PyObject,
        &mut pyobj_uri as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    stream = if pyobj_stream == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_stream).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_stream).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_stream)
    } else {
        stdout
    };
    uri = if pyobj_uri == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_uri as *mut PyURI_Object)).obj
    };
    xmlPrintURI(stream, uri);
<<<<<<< HEAD
    let ref mut fresh97 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh97 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh97 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReadDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut cur: * mut u8 = 0 as *mut xmlChar;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zzzi:xmlReadDoc\0" as *const u8 as *const i8 as *mut i8,
        &mut cur as *mut *mut xmlChar,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlReadDoc(cur, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReadFd(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut fd: i32 = 0;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut fd: i32 = 0;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"izzi:xmlReadFd\0" as *const u8 as *const i8 as *mut i8,
        &mut fd as *mut i32,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlReadFd(fd, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReadFile(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut filename: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zzi:xmlReadFile\0" as *const u8 as *const i8 as *mut i8,
        &mut filename as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlReadFile(filename, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReadMemory(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut buffer: *mut i8 = 0 as *mut i8;
    let mut py_buffsize0: Py_ssize_t = 0;
    let mut size: i32 = 0;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut buffer: * mut i8 = 0 as *mut i8;
    let mut py_buffsize0: i64 = 0;
    let mut size: i32 = 0;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"s#izzi:xmlReadMemory\0" as *const u8 as *const i8
            as *mut i8,
        &mut buffer as *mut *mut i8,
        &mut py_buffsize0 as *mut Py_ssize_t,
        &mut size as *mut i32,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlReadMemory(buffer, size, URL, encoding, options);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderForDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut cur: * mut u8 = 0 as *mut xmlChar;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zzzi:xmlReaderForDoc\0" as *const u8 as *const i8
            as *mut i8,
        &mut cur as *mut *mut xmlChar,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlReaderForDoc(cur, URL, encoding, options);
    py_retval = libxml_xmlTextReaderPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderForFd(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut fd: i32 = 0;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut fd: i32 = 0;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"izzi:xmlReaderForFd\0" as *const u8 as *const i8
            as *mut i8,
        &mut fd as *mut i32,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlReaderForFd(fd, URL, encoding, options);
    py_retval = libxml_xmlTextReaderPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderForFile(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut filename: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut filename: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zzi:xmlReaderForFile\0" as *const u8 as *const i8
            as *mut i8,
        &mut filename as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlReaderForFile(filename, encoding, options);
    py_retval = libxml_xmlTextReaderPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderForMemory(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut buffer: *mut i8 = 0 as *mut i8;
    let mut size: i32 = 0;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut buffer: * mut i8 = 0 as *mut i8;
    let mut size: i32 = 0;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zizzi:xmlReaderForMemory\0" as *const u8 as *const i8
            as *mut i8,
        &mut buffer as *mut *mut i8,
        &mut size as *mut i32,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlReaderForMemory(buffer, size, URL, encoding, options);
    py_retval = libxml_xmlTextReaderPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderNewDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut u8 = 0 as *mut xmlChar;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozzzi:xmlReaderNewDoc\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut cur as *mut *mut xmlChar,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlReaderNewDoc(reader, cur, URL, encoding, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderNewFd(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut fd: i32 = 0;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut fd: i32 = 0;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oizzi:xmlReaderNewFd\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut fd as *mut i32,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlReaderNewFd(reader, fd, URL, encoding, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderNewFile(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut filename: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut filename: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozzi:xmlReaderNewFile\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut filename as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlReaderNewFile(reader, filename, encoding, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderNewMemory(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut buffer: *mut i8 = 0 as *mut i8;
    let mut size: i32 = 0;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut buffer: * mut i8 = 0 as *mut i8;
    let mut size: i32 = 0;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozizzi:xmlReaderNewMemory\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut buffer as *mut *mut i8,
        &mut size as *mut i32,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlReaderNewMemory(reader, buffer, size, URL, encoding, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderNewWalker(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlReaderNewWalker\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlReaderNewWalker(reader, doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReaderWalker(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlReaderWalker\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlReaderWalker(doc);
    py_retval = libxml_xmlTextReaderPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReconciliateNs(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut tree: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_tree: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut tree: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_tree: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlReconciliateNs\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_tree as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    tree = if pyobj_tree == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_tree as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlReconciliateNs(doc, tree);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRecoverDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut cur: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlRecoverDoc\0" as *const u8 as *const i8 as *mut i8,
        &mut cur as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlRecoverDoc(cur);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRecoverFile(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut filename: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut filename: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlRecoverFile\0" as *const u8 as *const i8 as *mut i8,
        &mut filename as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlRecoverFile(filename);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRecoverMemory(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut buffer: *mut i8 = 0 as *mut i8;
    let mut py_buffsize0: Py_ssize_t = 0;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut buffer: * mut i8 = 0 as *mut i8;
    let mut py_buffsize0: i64 = 0;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut size: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"s#i:xmlRecoverMemory\0" as *const u8 as *const i8
            as *mut i8,
        &mut buffer as *mut *mut i8,
        &mut py_buffsize0 as *mut Py_ssize_t,
        &mut size as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlRecoverMemory(buffer, size);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRegFreeRegexp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut regexp: xmlRegexpPtr = 0 as *mut xmlRegexp;
    let mut pyobj_regexp: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut regexp: * mut crate::src::python::libxml2_py::_xmlRegexp = 0 as *mut xmlRegexp;
    let mut pyobj_regexp: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlRegFreeRegexp\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_regexp as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    regexp = if pyobj_regexp == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRegexpPtr
    } else {
        (*(pyobj_regexp as *mut PyxmlReg_Object)).obj
    };
    xmlRegFreeRegexp(regexp);
<<<<<<< HEAD
    let ref mut fresh98 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh98 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh98 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRegexpCompile(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlRegexpPtr = 0 as *mut xmlRegexp;
    let mut regexp: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml2_py::_xmlRegexp = 0 as *mut xmlRegexp;
    let mut regexp: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlRegexpCompile\0" as *const u8 as *const i8 as *mut i8,
        &mut regexp as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlRegexpCompile(regexp);
    py_retval = libxml_xmlRegexpPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRegexpExec(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut comp: xmlRegexpPtr = 0 as *mut xmlRegexp;
    let mut pyobj_comp: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut comp: * mut crate::src::python::libxml2_py::_xmlRegexp = 0 as *mut xmlRegexp;
    let mut pyobj_comp: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlRegexpExec\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_comp as *mut *mut PyObject,
        &mut content as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    comp = if pyobj_comp == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRegexpPtr
    } else {
        (*(pyobj_comp as *mut PyxmlReg_Object)).obj
    };
    c_retval = xmlRegexpExec(comp, content);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRegexpIsDeterminist(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut comp: xmlRegexpPtr = 0 as *mut xmlRegexp;
    let mut pyobj_comp: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut comp: * mut crate::src::python::libxml2_py::_xmlRegexp = 0 as *mut xmlRegexp;
    let mut pyobj_comp: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlRegexpIsDeterminist\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_comp as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    comp = if pyobj_comp == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRegexpPtr
    } else {
        (*(pyobj_comp as *mut PyxmlReg_Object)).obj
    };
    c_retval = xmlRegexpIsDeterminist(comp);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRegexpPrint(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut regexp: xmlRegexpPtr = 0 as *mut xmlRegexp;
    let mut pyobj_regexp: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut output: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_output: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut regexp: * mut crate::src::python::libxml2_py::_xmlRegexp = 0 as *mut xmlRegexp;
    let mut pyobj_regexp: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlRegexpPrint\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_output as *mut *mut PyObject,
        &mut pyobj_regexp as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    output = if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_output).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_output).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_output)
    } else {
        stdout
    };
    regexp = if pyobj_regexp == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRegexpPtr
    } else {
        (*(pyobj_regexp as *mut PyxmlReg_Object)).obj
    };
    xmlRegexpPrint(output, regexp);
<<<<<<< HEAD
    let ref mut fresh99 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh99 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh99 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRegisterDefaultInputCallbacks(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    xmlRegisterDefaultInputCallbacks();
    let ref mut fresh100 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    xmlRegisterDefaultInputCallbacks();
    let ref mut fresh100 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh100 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRegisterDefaultOutputCallbacks(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    xmlRegisterDefaultOutputCallbacks();
    let ref mut fresh101 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    xmlRegisterDefaultOutputCallbacks();
    let ref mut fresh101 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh101 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRegisterHTTPPostCallbacks(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    xmlRegisterHTTPPostCallbacks();
    let ref mut fresh102 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    xmlRegisterHTTPPostCallbacks();
    let ref mut fresh102 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh102 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGCleanupTypes(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlRelaxNGCleanupTypes\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    xmlRelaxNGCleanupTypes();
<<<<<<< HEAD
    let ref mut fresh103 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh103 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh103 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGDump(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut schema: xmlRelaxNGPtr = 0 as *mut xmlRelaxNG;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut output: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_output: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut schema: * mut crate::src::python::types::_xmlRelaxNG = 0 as *mut xmlRelaxNG;
    let mut pyobj_schema: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlRelaxNGDump\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_output as *mut *mut PyObject,
        &mut pyobj_schema as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    output = if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_output).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_output).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_output)
    } else {
        stdout
    };
    schema = if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRelaxNGPtr
    } else {
        (*(pyobj_schema as *mut PyrelaxNgSchema_Object)).obj
    };
    xmlRelaxNGDump(output, schema);
<<<<<<< HEAD
    let ref mut fresh104 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh104 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh104 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGDumpTree(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut schema: xmlRelaxNGPtr = 0 as *mut xmlRelaxNG;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut output: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_output: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut schema: * mut crate::src::python::types::_xmlRelaxNG = 0 as *mut xmlRelaxNG;
    let mut pyobj_schema: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlRelaxNGDumpTree\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_output as *mut *mut PyObject,
        &mut pyobj_schema as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    output = if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_output).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_output).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_output)
    } else {
        stdout
    };
    schema = if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRelaxNGPtr
    } else {
        (*(pyobj_schema as *mut PyrelaxNgSchema_Object)).obj
    };
    xmlRelaxNGDumpTree(output, schema);
<<<<<<< HEAD
    let ref mut fresh105 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh105 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh105 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGFree(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut schema: xmlRelaxNGPtr = 0 as *mut xmlRelaxNG;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut schema: * mut crate::src::python::types::_xmlRelaxNG = 0 as *mut xmlRelaxNG;
    let mut pyobj_schema: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlRelaxNGFree\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_schema as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    schema = if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRelaxNGPtr
    } else {
        (*(pyobj_schema as *mut PyrelaxNgSchema_Object)).obj
    };
    xmlRelaxNGFree(schema);
<<<<<<< HEAD
    let ref mut fresh106 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh106 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh106 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGFreeParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlRelaxNGParserCtxtPtr = 0 as *mut xmlRelaxNGParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml2_py::_xmlRelaxNGParserCtxt = 0 as *mut xmlRelaxNGParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlRelaxNGFreeParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRelaxNGParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyrelaxNgParserCtxt_Object)).obj
    };
    xmlRelaxNGFreeParserCtxt(ctxt);
<<<<<<< HEAD
    let ref mut fresh107 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh107 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh107 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGInitTypes(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    if libxml_deprecationWarning(
        b"xmlRelaxNGInitTypes\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlRelaxNGInitTypes();
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGNewDocParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlRelaxNGParserCtxtPtr = 0 as *mut xmlRelaxNGParserCtxt;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml2_py::_xmlRelaxNGParserCtxt = 0 as *mut xmlRelaxNGParserCtxt;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlRelaxNGNewDocParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlRelaxNGNewDocParserCtxt(doc);
    py_retval = libxml_xmlRelaxNGParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGNewMemParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlRelaxNGParserCtxtPtr = 0 as *mut xmlRelaxNGParserCtxt;
    let mut buffer: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml2_py::_xmlRelaxNGParserCtxt = 0 as *mut xmlRelaxNGParserCtxt;
    let mut buffer: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut size: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zi:xmlRelaxNGNewMemParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut buffer as *mut *mut i8,
        &mut size as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlRelaxNGNewMemParserCtxt(buffer, size);
    py_retval = libxml_xmlRelaxNGParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGNewParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlRelaxNGParserCtxtPtr = 0 as *mut xmlRelaxNGParserCtxt;
    let mut URL: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml2_py::_xmlRelaxNGParserCtxt = 0 as *mut xmlRelaxNGParserCtxt;
    let mut URL: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlRelaxNGNewParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut URL as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlRelaxNGNewParserCtxt(URL);
    py_retval = libxml_xmlRelaxNGParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGNewValidCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut schema: xmlRelaxNGPtr = 0 as *mut xmlRelaxNG;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::types::_xmlRelaxNGValidCtxt = 0 as *mut xmlRelaxNGValidCtxt;
    let mut schema: * mut crate::src::python::types::_xmlRelaxNG = 0 as *mut xmlRelaxNG;
    let mut pyobj_schema: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlRelaxNGNewValidCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_schema as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    schema = if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRelaxNGPtr
    } else {
        (*(pyobj_schema as *mut PyrelaxNgSchema_Object)).obj
    };
    c_retval = xmlRelaxNGNewValidCtxt(schema);
    py_retval = libxml_xmlRelaxNGValidCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGParse(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlRelaxNGPtr = 0 as *mut xmlRelaxNG;
    let mut ctxt: xmlRelaxNGParserCtxtPtr = 0 as *mut xmlRelaxNGParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::types::_xmlRelaxNG = 0 as *mut xmlRelaxNG;
    let mut ctxt: * mut crate::src::python::libxml2_py::_xmlRelaxNGParserCtxt = 0 as *mut xmlRelaxNGParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlRelaxNGParse\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRelaxNGParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyrelaxNgParserCtxt_Object)).obj
    };
    c_retval = xmlRelaxNGParse(ctxt);
    py_retval = libxml_xmlRelaxNGPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGValidateDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::types::_xmlRelaxNGValidCtxt = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlRelaxNGValidateDoc\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRelaxNGValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyrelaxNgValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlRelaxNGValidateDoc(ctxt, doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGValidateFullElement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::types::_xmlRelaxNGValidCtxt = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOO:xmlRelaxNGValidateFullElement\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRelaxNGValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyrelaxNgValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlRelaxNGValidateFullElement(ctxt, doc, elem);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGValidatePopElement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::types::_xmlRelaxNGValidCtxt = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOO:xmlRelaxNGValidatePopElement\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRelaxNGValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyrelaxNgValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlRelaxNGValidatePopElement(ctxt, doc, elem);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGValidatePushCData(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut data: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::types::_xmlRelaxNGValidCtxt = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut data: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozi:xmlRelaxNGValidatePushCData\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut data as *mut *mut xmlChar,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRelaxNGValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyrelaxNgValidCtxt_Object)).obj
    };
    c_retval = xmlRelaxNGValidatePushCData(ctxt, data, len);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxNGValidatePushElement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::types::_xmlRelaxNGValidCtxt = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOO:xmlRelaxNGValidatePushElement\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRelaxNGValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyrelaxNgValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlRelaxNGValidatePushElement(ctxt, doc, elem);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRelaxParserSetFlag(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlRelaxNGParserCtxtPtr = 0 as *mut xmlRelaxNGParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml2_py::_xmlRelaxNGParserCtxt = 0 as *mut xmlRelaxNGParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut flags: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlRelaxParserSetFlag\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut flags as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRelaxNGParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyrelaxNgParserCtxt_Object)).obj
    };
    c_retval = xmlRelaxParserSetFlag(ctxt, flags);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRemoveID(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_attr: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut attr: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut pyobj_attr: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlRemoveID\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_attr as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    attr = (if pyobj_attr == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_attr as *mut PyxmlNode_Object)).obj
    }) as xmlAttrPtr;
    c_retval = xmlRemoveID(doc, attr);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRemoveProp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut cur: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut cur: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlRemoveProp\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlAttrPtr;
    c_retval = xmlRemoveProp(cur);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlRemoveRef(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_attr: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut attr: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut pyobj_attr: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(b"xmlRemoveRef\0" as *const u8 as *const i8)
        == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlRemoveRef\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_attr as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    attr = (if pyobj_attr == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_attr as *mut PyxmlNode_Object)).obj
    }) as xmlAttrPtr;
    c_retval = xmlRemoveRef(doc, attr);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlReplaceNode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut old: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_old: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut old: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_old: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlReplaceNode\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_old as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    old = if pyobj_old == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_old as *mut PyxmlNode_Object)).obj
    };
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlReplaceNode(old, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlResetError(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut err: xmlErrorPtr = 0 as *mut xmlError;
    let mut pyobj_err: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut err: * mut crate::src::python::libxml::_xmlError = 0 as *mut xmlError;
    let mut pyobj_err: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlResetError\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_err as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    err = if pyobj_err == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlErrorPtr
    } else {
        (*(pyobj_err as *mut PyError_Object)).obj
    };
    xmlResetError(err);
<<<<<<< HEAD
    let ref mut fresh108 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh108 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh108 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlResetLastError(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    xmlResetLastError();
    let ref mut fresh109 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    xmlResetLastError();
    let ref mut fresh109 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh109 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSAXDefaultVersion(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut version: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlSAXDefaultVersion\0" as *const u8 as *const i8
            as *mut i8,
        &mut version as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlSAXDefaultVersion(version);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSaveFile(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: *mut i8 = 0 as *mut i8;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: * mut i8 = 0 as *mut i8;
    let mut cur: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zO:xmlSaveFile\0" as *const u8 as *const i8 as *mut i8,
        &mut filename as *mut *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlSaveFile(filename, cur);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSaveFileEnc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: *mut i8 = 0 as *mut i8;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: * mut i8 = 0 as *mut i8;
    let mut cur: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zOz:xmlSaveFileEnc\0" as *const u8 as *const i8 as *mut i8,
        &mut filename as *mut *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut encoding as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlSaveFileEnc(filename, cur, encoding);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSaveFormatFile(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: *mut i8 = 0 as *mut i8;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: * mut i8 = 0 as *mut i8;
    let mut cur: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut format: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zOi:xmlSaveFormatFile\0" as *const u8 as *const i8
            as *mut i8,
        &mut filename as *mut *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut format as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlSaveFormatFile(filename, cur, format);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSaveFormatFileEnc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: *mut i8 = 0 as *mut i8;
    let mut cur: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut filename: * mut i8 = 0 as *mut i8;
    let mut cur: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut format: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zOzi:xmlSaveFormatFileEnc\0" as *const u8 as *const i8
            as *mut i8,
        &mut filename as *mut *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
        &mut encoding as *mut *mut i8,
        &mut format as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = (if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlSaveFormatFileEnc(filename, cur, encoding, format);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSaveUri(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut uri: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_uri: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut uri: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_uri: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlSaveUri\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_uri as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    uri = if pyobj_uri == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_uri as *mut PyURI_Object)).obj
    };
    c_retval = xmlSaveUri(uri);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlScanName(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(b"xmlScanName\0" as *const u8 as *const i8)
        == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlScanName\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlScanName(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaCleanupTypes(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlSchemaCleanupTypes\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    xmlSchemaCleanupTypes();
<<<<<<< HEAD
    let ref mut fresh110 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh110 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh110 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaCollapseString(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlSchemaCollapseString\0" as *const u8 as *const i8
            as *mut i8,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlSchemaCollapseString(value);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaDump(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut output: *mut FILE = 0 as *mut FILE;
    let mut pyobj_output: *mut PyObject = 0 as *mut PyObject;
    let mut schema: xmlSchemaPtr = 0 as *mut xmlSchema;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut output: * mut crate::src::python::libxml::_IO_FILE = 0 as *mut FILE;
    let mut pyobj_output: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut schema: * mut crate::src::python::libxml2_py::_xmlSchema = 0 as *mut xmlSchema;
    let mut pyobj_schema: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlSchemaDump\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_output as *mut *mut PyObject,
        &mut pyobj_schema as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    output = if pyobj_output == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut FILE
    } else if (*pyobj_output).ob_type == &mut PyFile_Type as *mut PyTypeObject
            || PyType_IsSubtype((*pyobj_output).ob_type, &mut PyFile_Type) != 0
        {
        PyFile_AsFile(pyobj_output)
    } else {
        stdout
    };
    schema = if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlSchemaPtr
    } else {
        (*(pyobj_schema as *mut PySchema_Object)).obj
    };
    xmlSchemaDump(output, schema);
<<<<<<< HEAD
    let ref mut fresh111 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh111 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh111 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaFree(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut schema: xmlSchemaPtr = 0 as *mut xmlSchema;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut schema: * mut crate::src::python::libxml2_py::_xmlSchema = 0 as *mut xmlSchema;
    let mut pyobj_schema: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlSchemaFree\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_schema as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    schema = if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlSchemaPtr
    } else {
        (*(pyobj_schema as *mut PySchema_Object)).obj
    };
    xmlSchemaFree(schema);
<<<<<<< HEAD
    let ref mut fresh112 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh112 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh112 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaFreeParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::types::_xmlSchemaParserCtxt = 0 as *mut xmlSchemaParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlSchemaFreeParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlSchemaParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PySchemaParserCtxt_Object)).obj
    };
    xmlSchemaFreeParserCtxt(ctxt);
<<<<<<< HEAD
    let ref mut fresh113 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh113 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh113 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaInitTypes(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(
        b"xmlSchemaInitTypes\0" as *const u8 as *const i8,
    ) == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    xmlSchemaInitTypes();
<<<<<<< HEAD
    let ref mut fresh114 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh114 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh114 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaIsValid(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlSchemaIsValid\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlSchemaValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PySchemaValidCtxt_Object)).obj
    };
    c_retval = xmlSchemaIsValid(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaNewDocParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::types::_xmlSchemaParserCtxt = 0 as *mut xmlSchemaParserCtxt;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlSchemaNewDocParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlSchemaNewDocParserCtxt(doc);
    py_retval = libxml_xmlSchemaParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaNewMemParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut buffer: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::types::_xmlSchemaParserCtxt = 0 as *mut xmlSchemaParserCtxt;
    let mut buffer: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut size: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zi:xmlSchemaNewMemParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut buffer as *mut *mut i8,
        &mut size as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlSchemaNewMemParserCtxt(buffer, size);
    py_retval = libxml_xmlSchemaParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaNewParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut URL: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::types::_xmlSchemaParserCtxt = 0 as *mut xmlSchemaParserCtxt;
    let mut URL: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlSchemaNewParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut URL as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlSchemaNewParserCtxt(URL);
    py_retval = libxml_xmlSchemaParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaNewValidCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut schema: xmlSchemaPtr = 0 as *mut xmlSchema;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::types::_xmlSchemaValidCtxt = 0 as *mut xmlSchemaValidCtxt;
    let mut schema: * mut crate::src::python::libxml2_py::_xmlSchema = 0 as *mut xmlSchema;
    let mut pyobj_schema: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlSchemaNewValidCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_schema as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    schema = if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlSchemaPtr
    } else {
        (*(pyobj_schema as *mut PySchema_Object)).obj
    };
    c_retval = xmlSchemaNewValidCtxt(schema);
    py_retval = libxml_xmlSchemaValidCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaParse(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlSchemaPtr = 0 as *mut xmlSchema;
    let mut ctxt: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml2_py::_xmlSchema = 0 as *mut xmlSchema;
    let mut ctxt: * mut crate::src::python::types::_xmlSchemaParserCtxt = 0 as *mut xmlSchemaParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlSchemaParse\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlSchemaParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PySchemaParserCtxt_Object)).obj
    };
    c_retval = xmlSchemaParse(ctxt);
    py_retval = libxml_xmlSchemaPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaSetValidOptions(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlSchemaSetValidOptions\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlSchemaValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PySchemaValidCtxt_Object)).obj
    };
    c_retval = xmlSchemaSetValidOptions(ctxt, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaValidCtxtGetOptions(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlSchemaValidCtxtGetOptions\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlSchemaValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PySchemaValidCtxt_Object)).obj
    };
    c_retval = xmlSchemaValidCtxtGetOptions(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaValidCtxtGetParserCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut ctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlSchemaValidCtxtGetParserCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlSchemaValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PySchemaValidCtxt_Object)).obj
    };
    c_retval = xmlSchemaValidCtxtGetParserCtxt(ctxt);
    py_retval = libxml_xmlParserCtxtPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaValidateDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlSchemaValidateDoc\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlSchemaValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PySchemaValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlSchemaValidateDoc(ctxt, doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaValidateFile(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut filename: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut filename: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozi:xmlSchemaValidateFile\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut filename as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlSchemaValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PySchemaValidCtxt_Object)).obj
    };
    c_retval = xmlSchemaValidateFile(ctxt, filename, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaValidateOneElement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlSchemaValidateOneElement\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlSchemaValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PySchemaValidCtxt_Object)).obj
    };
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlSchemaValidateOneElement(ctxt, elem);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaValidateSetFilename(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut vctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_vctxt: *mut PyObject = 0 as *mut PyObject;
    let mut filename: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut vctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_vctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut filename: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlSchemaValidateSetFilename\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_vctxt as *mut *mut PyObject,
        &mut filename as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    vctxt = if pyobj_vctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlSchemaValidCtxtPtr
    } else {
        (*(pyobj_vctxt as *mut PySchemaValidCtxt_Object)).obj
    };
    xmlSchemaValidateSetFilename(vctxt, filename);
<<<<<<< HEAD
    let ref mut fresh115 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh115 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh115 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSchemaWhiteSpaceReplace(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlSchemaWhiteSpaceReplace\0" as *const u8 as *const i8
            as *mut i8,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlSchemaWhiteSpaceReplace(value);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSearchNs(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNsPtr = 0 as *mut xmlNs;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut nameSpace: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut nameSpace: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOz:xmlSearchNs\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_node as *mut *mut PyObject,
        &mut nameSpace as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlSearchNs(doc, node, nameSpace);
    py_retval = libxml_xmlNsPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSearchNsByHref(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNsPtr = 0 as *mut xmlNs;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut href: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut href: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOz:xmlSearchNsByHref\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_node as *mut *mut PyObject,
        &mut href as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlSearchNsByHref(doc, node, href);
    py_retval = libxml_xmlNsPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSetCompressMode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut mode: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlSetCompressMode\0" as *const u8 as *const i8
            as *mut i8,
        &mut mode as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    xmlSetCompressMode(mode);
<<<<<<< HEAD
    let ref mut fresh116 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh116 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh116 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSetDocCompressMode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut mode: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlSetDocCompressMode\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut mode as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    xmlSetDocCompressMode(doc, mode);
<<<<<<< HEAD
    let ref mut fresh117 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh117 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh117 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSetListDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut list: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_list: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut list: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_list: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlSetListDoc\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_list as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    list = if pyobj_list == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_list as *mut PyxmlNode_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    xmlSetListDoc(list, doc);
<<<<<<< HEAD
    let ref mut fresh118 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh118 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh118 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSetNs(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut ns: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut pyobj_ns: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlSetNs\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut pyobj_ns as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    ns = (if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_ns as *mut PyxmlNode_Object)).obj
    }) as xmlNsPtr;
    xmlSetNs(node, ns);
<<<<<<< HEAD
    let ref mut fresh119 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh119 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh119 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSetNsProp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut ns: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut pyobj_ns: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOzz:xmlSetNsProp\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut pyobj_ns as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    ns = (if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_ns as *mut PyxmlNode_Object)).obj
    }) as xmlNsPtr;
    c_retval = xmlSetNsProp(node, ns, name, value);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSetProp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozz:xmlSetProp\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlSetProp(node, name, value);
    py_retval = libxml_xmlNodePtrWrap(c_retval as xmlNodePtr);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSetTreeDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut tree: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_tree: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut tree: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_tree: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlSetTreeDoc\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_tree as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    tree = if pyobj_tree == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_tree as *mut PyxmlNode_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    xmlSetTreeDoc(tree, doc);
<<<<<<< HEAD
    let ref mut fresh120 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh120 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh120 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSetupParserForBuffer(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut buffer: *mut xmlChar = 0 as *mut xmlChar;
    let mut filename: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut buffer: * mut u8 = 0 as *mut xmlChar;
    let mut filename: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozz:xmlSetupParserForBuffer\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut buffer as *mut *mut xmlChar,
        &mut filename as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlSetupParserForBuffer(ctxt, buffer, filename);
<<<<<<< HEAD
    let ref mut fresh121 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh121 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh121 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlShellPrintNode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlShellPrintNode\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    xmlShellPrintNode(node);
<<<<<<< HEAD
    let ref mut fresh122 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh122 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh122 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlShellPrintXPathError(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut errorType: i32 = 0;
    let mut arg: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut errorType: i32 = 0;
    let mut arg: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"iz:xmlShellPrintXPathError\0" as *const u8 as *const i8
            as *mut i8,
        &mut errorType as *mut i32,
        &mut arg as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    xmlShellPrintXPathError(errorType, arg);
<<<<<<< HEAD
    let ref mut fresh123 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh123 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh123 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSkipBlankChars(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlSkipBlankChars\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlSkipBlankChars(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStopParser(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlStopParser\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    xmlStopParser(ctxt);
<<<<<<< HEAD
    let ref mut fresh124 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh124 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh124 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrEqual(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut str1: *mut xmlChar = 0 as *mut xmlChar;
    let mut str2: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut str1: * mut u8 = 0 as *mut xmlChar;
    let mut str2: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:xmlStrEqual\0" as *const u8 as *const i8 as *mut i8,
        &mut str1 as *mut *mut xmlChar,
        &mut str2 as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlStrEqual(str1, str2);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrQEqual(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut pref: *mut xmlChar = 0 as *mut xmlChar;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut pref: * mut u8 = 0 as *mut xmlChar;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut str: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zzz:xmlStrQEqual\0" as *const u8 as *const i8 as *mut i8,
        &mut pref as *mut *mut xmlChar,
        &mut name as *mut *mut xmlChar,
        &mut str as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlStrQEqual(pref, name, str);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrcasecmp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut str1: *mut xmlChar = 0 as *mut xmlChar;
    let mut str2: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut str1: * mut u8 = 0 as *mut xmlChar;
    let mut str2: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:xmlStrcasecmp\0" as *const u8 as *const i8 as *mut i8,
        &mut str1 as *mut *mut xmlChar,
        &mut str2 as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlStrcasecmp(str1, str2);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrcasestr(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut str: * mut u8 = 0 as *mut xmlChar;
    let mut val: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:xmlStrcasestr\0" as *const u8 as *const i8 as *mut i8,
        &mut str as *mut *mut xmlChar,
        &mut val as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlStrcasestr(str, val);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrcat(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut add: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut cur: * mut u8 = 0 as *mut xmlChar;
    let mut add: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:xmlStrcat\0" as *const u8 as *const i8 as *mut i8,
        &mut cur as *mut *mut xmlChar,
        &mut add as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlStrcat(cur, add);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrchr(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut val: xmlChar = 0;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut str: * mut u8 = 0 as *mut xmlChar;
    let mut val: u8 = 0;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zc:xmlStrchr\0" as *const u8 as *const i8 as *mut i8,
        &mut str as *mut *mut xmlChar,
        &mut val as *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlStrchr(str, val);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrcmp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut str1: *mut xmlChar = 0 as *mut xmlChar;
    let mut str2: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut str1: * mut u8 = 0 as *mut xmlChar;
    let mut str2: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:xmlStrcmp\0" as *const u8 as *const i8 as *mut i8,
        &mut str1 as *mut *mut xmlChar,
        &mut str2 as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlStrcmp(str1, str2);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrdup(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut cur: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlStrdup\0" as *const u8 as *const i8 as *mut i8,
        &mut cur as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlStrdup(cur);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStringDecodeEntities(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut what: i32 = 0;
    let mut end: xmlChar = 0;
    let mut end2: xmlChar = 0;
    let mut end3: xmlChar = 0;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut str: * mut u8 = 0 as *mut xmlChar;
    let mut what: i32 = 0;
    let mut end: u8 = 0;
    let mut end2: u8 = 0;
    let mut end3: u8 = 0;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oziccc:xmlStringDecodeEntities\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut str as *mut *mut xmlChar,
        &mut what as *mut i32,
        &mut end as *mut xmlChar,
        &mut end2 as *mut xmlChar,
        &mut end3 as *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlStringDecodeEntities(ctxt, str, what, end, end2, end3);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStringGetNodeList(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlStringGetNodeList\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as *mut xmlDoc;
    c_retval = xmlStringGetNodeList(doc, value);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStringLenDecodeEntities(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut len: i32 = 0;
    let mut what: i32 = 0;
    let mut end: xmlChar = 0;
    let mut end2: xmlChar = 0;
    let mut end3: xmlChar = 0;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut str: * mut u8 = 0 as *mut xmlChar;
    let mut len: i32 = 0;
    let mut what: i32 = 0;
    let mut end: u8 = 0;
    let mut end2: u8 = 0;
    let mut end3: u8 = 0;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oziiccc:xmlStringLenDecodeEntities\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut str as *mut *mut xmlChar,
        &mut len as *mut i32,
        &mut what as *mut i32,
        &mut end as *mut xmlChar,
        &mut end2 as *mut xmlChar,
        &mut end3 as *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyparserCtxt_Object)).obj
    };
    c_retval = xmlStringLenDecodeEntities(ctxt, str, len, what, end, end2, end3);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStringLenGetNodeList(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut doc: *mut xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozi:xmlStringLenGetNodeList\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut value as *mut *mut xmlChar,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as *mut xmlDoc;
    c_retval = xmlStringLenGetNodeList(doc, value, len);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrlen(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut str: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlStrlen\0" as *const u8 as *const i8 as *mut i8,
        &mut str as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlStrlen(str);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrncasecmp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut str1: *mut xmlChar = 0 as *mut xmlChar;
    let mut str2: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut str1: * mut u8 = 0 as *mut xmlChar;
    let mut str2: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zzi:xmlStrncasecmp\0" as *const u8 as *const i8 as *mut i8,
        &mut str1 as *mut *mut xmlChar,
        &mut str2 as *mut *mut xmlChar,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlStrncasecmp(str1, str2, len);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrncat(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
    let mut add: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut cur: * mut u8 = 0 as *mut xmlChar;
    let mut add: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zzi:xmlStrncat\0" as *const u8 as *const i8 as *mut i8,
        &mut cur as *mut *mut xmlChar,
        &mut add as *mut *mut xmlChar,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlStrncat(cur, add, len);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrncatNew(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut str1: *mut xmlChar = 0 as *mut xmlChar;
    let mut str2: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut str1: * mut u8 = 0 as *mut xmlChar;
    let mut str2: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zzi:xmlStrncatNew\0" as *const u8 as *const i8 as *mut i8,
        &mut str1 as *mut *mut xmlChar,
        &mut str2 as *mut *mut xmlChar,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlStrncatNew(str1, str2, len);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrncmp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut str1: *mut xmlChar = 0 as *mut xmlChar;
    let mut str2: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut str1: * mut u8 = 0 as *mut xmlChar;
    let mut str2: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zzi:xmlStrncmp\0" as *const u8 as *const i8 as *mut i8,
        &mut str1 as *mut *mut xmlChar,
        &mut str2 as *mut *mut xmlChar,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlStrncmp(str1, str2, len);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrndup(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut cur: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zi:xmlStrndup\0" as *const u8 as *const i8 as *mut i8,
        &mut cur as *mut *mut xmlChar,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlStrndup(cur, len);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrstr(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut str: * mut u8 = 0 as *mut xmlChar;
    let mut val: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:xmlStrstr\0" as *const u8 as *const i8 as *mut i8,
        &mut str as *mut *mut xmlChar,
        &mut val as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlStrstr(str, val);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlStrsub(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut str: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut start: i32 = 0;
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zii:xmlStrsub\0" as *const u8 as *const i8 as *mut i8,
        &mut str as *mut *mut xmlChar,
        &mut start as *mut i32,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlStrsub(str, start, len);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlSubstituteEntitiesDefault(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut val: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlSubstituteEntitiesDefault\0" as *const u8 as *const i8
            as *mut i8,
        &mut val as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlSubstituteEntitiesDefault(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextConcat(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut content: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozi:xmlTextConcat\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut content as *mut *mut xmlChar,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlTextConcat(node, content, len);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextMerge(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut first: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_first: *mut PyObject = 0 as *mut PyObject;
    let mut second: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_second: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut first: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_first: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut second: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_second: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlTextMerge\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_first as *mut *mut PyObject,
        &mut pyobj_second as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    first = if pyobj_first == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_first as *mut PyxmlNode_Object)).obj
    };
    second = if pyobj_second == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_second as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlTextMerge(first, second);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderAttributeCount(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderAttributeCount\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderAttributeCount(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderByteConsumed(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i64 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i64 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderByteConsumed\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderByteConsumed(reader);
    py_retval = libxml_longWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderClose(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderClose\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderClose(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstBaseUri(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderConstBaseUri\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderConstBaseUri(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstEncoding(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderConstEncoding\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderConstEncoding(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstLocalName(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderConstLocalName\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderConstLocalName(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstName(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderConstName\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderConstName(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstNamespaceUri(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderConstNamespaceUri\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderConstNamespaceUri(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstPrefix(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderConstPrefix\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderConstPrefix(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstString(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut str: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlTextReaderConstString\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut str as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderConstString(reader, str);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstValue(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderConstValue\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderConstValue(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstXmlLang(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderConstXmlLang\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderConstXmlLang(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderConstXmlVersion(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderConstXmlVersion\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderConstXmlVersion(reader);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderCurrentDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderCurrentDoc\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderCurrentDoc(reader);
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderCurrentNode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderCurrentNode\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderCurrentNode(reader);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderDepth(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderDepth\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderDepth(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderExpand(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderExpand\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderExpand(reader);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderGetAttribute(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlTextReaderGetAttribute\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderGetAttribute(reader, name);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderGetAttributeNo(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut no: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlTextReaderGetAttributeNo\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut no as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderGetAttributeNo(reader, no);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderGetAttributeNs(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut localName: *mut xmlChar = 0 as *mut xmlChar;
    let mut namespaceURI: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut localName: * mut u8 = 0 as *mut xmlChar;
    let mut namespaceURI: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozz:xmlTextReaderGetAttributeNs\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut localName as *mut *mut xmlChar,
        &mut namespaceURI as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderGetAttributeNs(reader, localName, namespaceURI);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderGetParserColumnNumber(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderGetParserColumnNumber\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderGetParserColumnNumber(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderGetParserLineNumber(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderGetParserLineNumber\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderGetParserLineNumber(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderGetParserProp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut prop: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlTextReaderGetParserProp\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut prop as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderGetParserProp(reader, prop);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderGetRemainder(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlParserInputBuffer = 0 as *mut xmlParserInputBuffer;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderGetRemainder\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderGetRemainder(reader);
    py_retval = libxml_xmlParserInputBufferPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderHasAttributes(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderHasAttributes\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderHasAttributes(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderHasValue(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderHasValue\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderHasValue(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderIsDefault(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderIsDefault\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderIsDefault(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderIsEmptyElement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderIsEmptyElement\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderIsEmptyElement(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderIsNamespaceDecl(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderIsNamespaceDecl\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderIsNamespaceDecl(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderIsValid(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderIsValid\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderIsValid(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderLocatorBaseURI(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut locator: xmlTextReaderLocatorPtr = 0 as *mut libc::c_void;
    let mut pyobj_locator: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut locator: * mut core::ffi::c_void = 0 as *mut libc::c_void;
    let mut pyobj_locator: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderLocatorBaseURI\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_locator as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    locator = if pyobj_locator == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut libc::c_void
    } else {
        (*(pyobj_locator as *mut PyxmlTextReaderLocator_Object)).obj
    };
    c_retval = xmlTextReaderLocatorBaseURI(locator);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderLocatorLineNumber(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut locator: xmlTextReaderLocatorPtr = 0 as *mut libc::c_void;
    let mut pyobj_locator: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut locator: * mut core::ffi::c_void = 0 as *mut libc::c_void;
    let mut pyobj_locator: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderLocatorLineNumber\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_locator as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    locator = if pyobj_locator == &mut _Py_NoneStruct as *mut PyObject {
        0 as *mut libc::c_void
    } else {
        (*(pyobj_locator as *mut PyxmlTextReaderLocator_Object)).obj
    };
    c_retval = xmlTextReaderLocatorLineNumber(locator);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderLookupNamespace(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut prefix: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlTextReaderLookupNamespace\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut prefix as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderLookupNamespace(reader, prefix);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderMoveToAttribute(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlTextReaderMoveToAttribute\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderMoveToAttribute(reader, name);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderMoveToAttributeNo(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut no: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlTextReaderMoveToAttributeNo\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut no as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderMoveToAttributeNo(reader, no);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderMoveToAttributeNs(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut localName: *mut xmlChar = 0 as *mut xmlChar;
    let mut namespaceURI: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut localName: * mut u8 = 0 as *mut xmlChar;
    let mut namespaceURI: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozz:xmlTextReaderMoveToAttributeNs\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut localName as *mut *mut xmlChar,
        &mut namespaceURI as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderMoveToAttributeNs(reader, localName, namespaceURI);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderMoveToElement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderMoveToElement\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderMoveToElement(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderMoveToFirstAttribute(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderMoveToFirstAttribute\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderMoveToFirstAttribute(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderMoveToNextAttribute(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderMoveToNextAttribute\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderMoveToNextAttribute(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderNext(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderNext\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderNext(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderNextSibling(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderNextSibling\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderNextSibling(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderNodeType(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderNodeType\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderNodeType(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderNormalization(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderNormalization\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderNormalization(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderPreserve(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderPreserve\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderPreserve(reader);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderQuoteChar(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderQuoteChar\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderQuoteChar(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderRead(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderRead\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderRead(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderReadAttributeValue(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderReadAttributeValue\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderReadAttributeValue(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderReadInnerXml(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderReadInnerXml\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderReadInnerXml(reader);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderReadOuterXml(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderReadOuterXml\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderReadOuterXml(reader);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderReadState(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderReadState\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderReadState(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderReadString(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderReadString\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderReadString(reader);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderRelaxNGSetSchema(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut schema: xmlRelaxNGPtr = 0 as *mut xmlRelaxNG;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut schema: * mut crate::src::python::types::_xmlRelaxNG = 0 as *mut xmlRelaxNG;
    let mut pyobj_schema: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlTextReaderRelaxNGSetSchema\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut pyobj_schema as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    schema = if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRelaxNGPtr
    } else {
        (*(pyobj_schema as *mut PyrelaxNgSchema_Object)).obj
    };
    c_retval = xmlTextReaderRelaxNGSetSchema(reader, schema);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderRelaxNGValidate(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut rng: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut rng: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlTextReaderRelaxNGValidate\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut rng as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderRelaxNGValidate(reader, rng);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderRelaxNGValidateCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut ctxt: xmlRelaxNGValidCtxtPtr = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut ctxt: * mut crate::src::python::types::_xmlRelaxNGValidCtxt = 0 as *mut xmlRelaxNGValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOi:xmlTextReaderRelaxNGValidateCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlRelaxNGValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyrelaxNgValidCtxt_Object)).obj
    };
    c_retval = xmlTextReaderRelaxNGValidateCtxt(reader, ctxt, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderSchemaValidate(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut xsd: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut xsd: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlTextReaderSchemaValidate\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut xsd as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderSchemaValidate(reader, xsd);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderSchemaValidateCtxt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut ctxt: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut ctxt: * mut crate::src::python::types::_xmlSchemaValidCtxt = 0 as *mut xmlSchemaValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOi:xmlTextReaderSchemaValidateCtxt\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlSchemaValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PySchemaValidCtxt_Object)).obj
    };
    c_retval = xmlTextReaderSchemaValidateCtxt(reader, ctxt, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderSetParserProp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut prop: i32 = 0;
    let mut value: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oii:xmlTextReaderSetParserProp\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut prop as *mut i32,
        &mut value as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderSetParserProp(reader, prop, value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderSetSchema(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut schema: xmlSchemaPtr = 0 as *mut xmlSchema;
    let mut pyobj_schema: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut schema: * mut crate::src::python::libxml2_py::_xmlSchema = 0 as *mut xmlSchema;
    let mut pyobj_schema: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlTextReaderSetSchema\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut pyobj_schema as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    schema = if pyobj_schema == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlSchemaPtr
    } else {
        (*(pyobj_schema as *mut PySchema_Object)).obj
    };
    c_retval = xmlTextReaderSetSchema(reader, schema);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderSetup(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_input: *mut PyObject = 0 as *mut PyObject;
    let mut URL: *mut i8 = 0 as *mut i8;
    let mut encoding: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut input: * mut crate::src::python::libxml::_xmlParserInputBuffer = 0 as *mut xmlParserInputBuffer;
    let mut pyobj_input: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut URL: * mut i8 = 0 as *mut i8;
    let mut encoding: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOzzi:xmlTextReaderSetup\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
        &mut pyobj_input as *mut *mut PyObject,
        &mut URL as *mut *mut i8,
        &mut encoding as *mut *mut i8,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    input = if pyobj_input == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlParserInputBufferPtr
    } else {
        (*(pyobj_input as *mut PyinputBuffer_Object)).obj
    };
    c_retval = xmlTextReaderSetup(reader, input, URL, encoding, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlTextReaderStandalone(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: xmlTextReaderPtr = 0 as *mut xmlTextReader;
    let mut pyobj_reader: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut reader: * mut crate::src::python::types::_xmlTextReader = 0 as *mut xmlTextReader;
    let mut pyobj_reader: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlTextReaderStandalone\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_reader as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    reader = if pyobj_reader == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlTextReaderPtr
    } else {
        (*(pyobj_reader as *mut PyxmlTextReader_Object)).obj
    };
    c_retval = xmlTextReaderStandalone(reader);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefDefaultBufferSize(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut v: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlThrDefDefaultBufferSize\0" as *const u8 as *const i8
            as *mut i8,
        &mut v as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlThrDefDefaultBufferSize(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefDoValidityCheckingDefaultValue(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut v: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlThrDefDoValidityCheckingDefaultValue\0" as *const u8
            as *const i8 as *mut i8,
        &mut v as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlThrDefDoValidityCheckingDefaultValue(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefGetWarningsDefaultValue(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut v: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlThrDefGetWarningsDefaultValue\0" as *const u8 as *const i8
            as *mut i8,
        &mut v as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlThrDefGetWarningsDefaultValue(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefIndentTreeOutput(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut v: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlThrDefIndentTreeOutput\0" as *const u8 as *const i8
            as *mut i8,
        &mut v as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlThrDefIndentTreeOutput(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefKeepBlanksDefaultValue(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut v: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlThrDefKeepBlanksDefaultValue\0" as *const u8 as *const i8
            as *mut i8,
        &mut v as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlThrDefKeepBlanksDefaultValue(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefLineNumbersDefaultValue(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut v: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlThrDefLineNumbersDefaultValue\0" as *const u8 as *const i8
            as *mut i8,
        &mut v as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlThrDefLineNumbersDefaultValue(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefLoadExtDtdDefaultValue(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut v: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlThrDefLoadExtDtdDefaultValue\0" as *const u8 as *const i8
            as *mut i8,
        &mut v as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlThrDefLoadExtDtdDefaultValue(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefParserDebugEntities(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut v: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlThrDefParserDebugEntities\0" as *const u8 as *const i8
            as *mut i8,
        &mut v as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlThrDefParserDebugEntities(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefPedanticParserDefaultValue(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut v: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlThrDefPedanticParserDefaultValue\0" as *const u8 as *const i8
            as *mut i8,
        &mut v as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlThrDefPedanticParserDefaultValue(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefSaveNoEmptyTags(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut v: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlThrDefSaveNoEmptyTags\0" as *const u8 as *const i8
            as *mut i8,
        &mut v as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlThrDefSaveNoEmptyTags(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefSubstituteEntitiesDefaultValue(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut v: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlThrDefSubstituteEntitiesDefaultValue\0" as *const u8
            as *const i8 as *mut i8,
        &mut v as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlThrDefSubstituteEntitiesDefaultValue(v);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlThrDefTreeIndentString(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const i8 = 0 as *const i8;
    let mut v: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const i8 = 0 as *const i8;
    let mut v: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlThrDefTreeIndentString\0" as *const u8 as *const i8
            as *mut i8,
        &mut v as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlThrDefTreeIndentString(v);
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsAegeanNumbers(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsAegeanNumbers\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsAegeanNumbers(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsAlphabeticPresentationForms(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsAlphabeticPresentationForms\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsAlphabeticPresentationForms(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsArabic(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsArabic\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsArabic(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsArabicPresentationFormsA(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsArabicPresentationFormsA\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsArabicPresentationFormsA(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsArabicPresentationFormsB(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsArabicPresentationFormsB\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsArabicPresentationFormsB(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsArmenian(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsArmenian\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsArmenian(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsArrows(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsArrows\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsArrows(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBasicLatin(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsBasicLatin\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsBasicLatin(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBengali(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsBengali\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsBengali(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBlock(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    let mut block: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    let mut block: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"iz:xmlUCSIsBlock\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
        &mut block as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsBlock(code, block);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBlockElements(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsBlockElements\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsBlockElements(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBopomofo(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsBopomofo\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsBopomofo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBopomofoExtended(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsBopomofoExtended\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsBopomofoExtended(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBoxDrawing(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsBoxDrawing\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsBoxDrawing(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBraillePatterns(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsBraillePatterns\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsBraillePatterns(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsBuhid(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsBuhid\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsBuhid(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsByzantineMusicalSymbols(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsByzantineMusicalSymbols\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsByzantineMusicalSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKCompatibility(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCJKCompatibility\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCJKCompatibility(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKCompatibilityForms(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCJKCompatibilityForms\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCJKCompatibilityForms(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKCompatibilityIdeographs(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCJKCompatibilityIdeographs\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCJKCompatibilityIdeographs(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKCompatibilityIdeographsSupplement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCJKCompatibilityIdeographsSupplement\0" as *const u8
            as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCJKCompatibilityIdeographsSupplement(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKRadicalsSupplement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCJKRadicalsSupplement\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCJKRadicalsSupplement(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKSymbolsandPunctuation(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCJKSymbolsandPunctuation\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCJKSymbolsandPunctuation(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKUnifiedIdeographs(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCJKUnifiedIdeographs\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCJKUnifiedIdeographs(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKUnifiedIdeographsExtensionA(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCJKUnifiedIdeographsExtensionA\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCJKUnifiedIdeographsExtensionA(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCJKUnifiedIdeographsExtensionB(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCJKUnifiedIdeographsExtensionB\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCJKUnifiedIdeographsExtensionB(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCat(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    let mut cat: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    let mut cat: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"iz:xmlUCSIsCat\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
        &mut cat as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCat(code, cat);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatC(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatC\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatC(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatCc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatCc\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatCc(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatCf(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatCf\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatCf(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatCo(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatCo\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatCo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatCs(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatCs\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatCs(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatL(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatL\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatL(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatLl(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatLl\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatLl(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatLm(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatLm\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatLm(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatLo(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatLo\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatLo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatLt(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatLt\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatLt(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatLu(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatLu\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatLu(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatM(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatM\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatM(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatMc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatMc\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatMc(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatMe(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatMe\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatMe(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatMn(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatMn\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatMn(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatN(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatN\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatN(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatNd(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatNd\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatNd(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatNl(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatNl\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatNl(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatNo(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatNo\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatNo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatP(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatP\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatP(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatPc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatPc\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatPc(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatPd(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatPd\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatPd(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatPe(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatPe\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatPe(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatPf(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatPf\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatPf(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatPi(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatPi\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatPi(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatPo(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatPo\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatPo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatPs(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatPs\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatPs(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatS(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatS\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatS(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatSc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatSc\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatSc(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatSk(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatSk\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatSk(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatSm(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatSm\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatSm(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatSo(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatSo\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatSo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatZ(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatZ\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatZ(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatZl(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatZl\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatZl(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatZp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatZp\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatZp(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCatZs(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCatZs\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCatZs(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCherokee(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCherokee\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCherokee(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCombiningDiacriticalMarks(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCombiningDiacriticalMarks\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCombiningDiacriticalMarks(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCombiningDiacriticalMarksforSymbols(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCombiningDiacriticalMarksforSymbols\0" as *const u8
            as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCombiningDiacriticalMarksforSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCombiningHalfMarks(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCombiningHalfMarks\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCombiningHalfMarks(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCombiningMarksforSymbols(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCombiningMarksforSymbols\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCombiningMarksforSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsControlPictures(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsControlPictures\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsControlPictures(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCurrencySymbols(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCurrencySymbols\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCurrencySymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCypriotSyllabary(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCypriotSyllabary\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCypriotSyllabary(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCyrillic(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCyrillic\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCyrillic(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsCyrillicSupplement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsCyrillicSupplement\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsCyrillicSupplement(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsDeseret(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsDeseret\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsDeseret(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsDevanagari(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsDevanagari\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsDevanagari(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsDingbats(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsDingbats\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsDingbats(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsEnclosedAlphanumerics(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsEnclosedAlphanumerics\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsEnclosedAlphanumerics(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsEnclosedCJKLettersandMonths(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsEnclosedCJKLettersandMonths\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsEnclosedCJKLettersandMonths(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsEthiopic(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsEthiopic\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsEthiopic(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGeneralPunctuation(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsGeneralPunctuation\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsGeneralPunctuation(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGeometricShapes(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsGeometricShapes\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsGeometricShapes(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGeorgian(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsGeorgian\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsGeorgian(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGothic(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsGothic\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsGothic(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGreek(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsGreek\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsGreek(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGreekExtended(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsGreekExtended\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsGreekExtended(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGreekandCoptic(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsGreekandCoptic\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsGreekandCoptic(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGujarati(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsGujarati\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsGujarati(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsGurmukhi(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsGurmukhi\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsGurmukhi(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHalfwidthandFullwidthForms(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsHalfwidthandFullwidthForms\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsHalfwidthandFullwidthForms(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHangulCompatibilityJamo(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsHangulCompatibilityJamo\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsHangulCompatibilityJamo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHangulJamo(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsHangulJamo\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsHangulJamo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHangulSyllables(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsHangulSyllables\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsHangulSyllables(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHanunoo(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsHanunoo\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsHanunoo(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHebrew(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsHebrew\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsHebrew(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHighPrivateUseSurrogates(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsHighPrivateUseSurrogates\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsHighPrivateUseSurrogates(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHighSurrogates(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsHighSurrogates\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsHighSurrogates(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsHiragana(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsHiragana\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsHiragana(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsIPAExtensions(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsIPAExtensions\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsIPAExtensions(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsIdeographicDescriptionCharacters(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsIdeographicDescriptionCharacters\0" as *const u8
            as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsIdeographicDescriptionCharacters(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsKanbun(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsKanbun\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsKanbun(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsKangxiRadicals(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsKangxiRadicals\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsKangxiRadicals(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsKannada(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsKannada\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsKannada(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsKatakana(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsKatakana\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsKatakana(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsKatakanaPhoneticExtensions(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsKatakanaPhoneticExtensions\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsKatakanaPhoneticExtensions(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsKhmer(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsKhmer\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsKhmer(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsKhmerSymbols(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsKhmerSymbols\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsKhmerSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLao(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsLao\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsLao(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLatin1Supplement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsLatin1Supplement\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsLatin1Supplement(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLatinExtendedA(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsLatinExtendedA\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsLatinExtendedA(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLatinExtendedAdditional(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsLatinExtendedAdditional\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsLatinExtendedAdditional(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLatinExtendedB(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsLatinExtendedB\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsLatinExtendedB(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLetterlikeSymbols(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsLetterlikeSymbols\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsLetterlikeSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLimbu(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsLimbu\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsLimbu(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLinearBIdeograms(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsLinearBIdeograms\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsLinearBIdeograms(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLinearBSyllabary(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsLinearBSyllabary\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsLinearBSyllabary(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsLowSurrogates(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsLowSurrogates\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsLowSurrogates(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMalayalam(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsMalayalam\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsMalayalam(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMathematicalAlphanumericSymbols(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsMathematicalAlphanumericSymbols\0" as *const u8
            as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsMathematicalAlphanumericSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMathematicalOperators(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsMathematicalOperators\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsMathematicalOperators(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMiscellaneousMathematicalSymbolsA(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsMiscellaneousMathematicalSymbolsA\0" as *const u8
            as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsMiscellaneousMathematicalSymbolsA(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMiscellaneousMathematicalSymbolsB(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsMiscellaneousMathematicalSymbolsB\0" as *const u8
            as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsMiscellaneousMathematicalSymbolsB(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMiscellaneousSymbols(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsMiscellaneousSymbols\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsMiscellaneousSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMiscellaneousSymbolsandArrows(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsMiscellaneousSymbolsandArrows\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsMiscellaneousSymbolsandArrows(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMiscellaneousTechnical(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsMiscellaneousTechnical\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsMiscellaneousTechnical(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMongolian(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsMongolian\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsMongolian(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMusicalSymbols(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsMusicalSymbols\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsMusicalSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsMyanmar(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsMyanmar\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsMyanmar(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsNumberForms(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsNumberForms\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsNumberForms(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsOgham(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsOgham\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsOgham(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsOldItalic(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsOldItalic\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsOldItalic(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsOpticalCharacterRecognition(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsOpticalCharacterRecognition\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsOpticalCharacterRecognition(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsOriya(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsOriya\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsOriya(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsOsmanya(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsOsmanya\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsOsmanya(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsPhoneticExtensions(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsPhoneticExtensions\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsPhoneticExtensions(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsPrivateUse(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsPrivateUse\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsPrivateUse(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsPrivateUseArea(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsPrivateUseArea\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsPrivateUseArea(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsRunic(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsRunic\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsRunic(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsShavian(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsShavian\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsShavian(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSinhala(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsSinhala\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsSinhala(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSmallFormVariants(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsSmallFormVariants\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsSmallFormVariants(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSpacingModifierLetters(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsSpacingModifierLetters\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsSpacingModifierLetters(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSpecials(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsSpecials\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsSpecials(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSuperscriptsandSubscripts(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsSuperscriptsandSubscripts\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsSuperscriptsandSubscripts(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSupplementalArrowsA(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsSupplementalArrowsA\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsSupplementalArrowsA(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSupplementalArrowsB(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsSupplementalArrowsB\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsSupplementalArrowsB(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSupplementalMathematicalOperators(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsSupplementalMathematicalOperators\0" as *const u8
            as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsSupplementalMathematicalOperators(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSupplementaryPrivateUseAreaA(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsSupplementaryPrivateUseAreaA\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsSupplementaryPrivateUseAreaA(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSupplementaryPrivateUseAreaB(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsSupplementaryPrivateUseAreaB\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsSupplementaryPrivateUseAreaB(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsSyriac(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsSyriac\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsSyriac(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsTagalog(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsTagalog\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsTagalog(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsTagbanwa(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsTagbanwa\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsTagbanwa(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsTags(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsTags\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsTags(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsTaiLe(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsTaiLe\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsTaiLe(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsTaiXuanJingSymbols(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsTaiXuanJingSymbols\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsTaiXuanJingSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsTamil(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsTamil\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsTamil(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsTelugu(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsTelugu\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsTelugu(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsThaana(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsThaana\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsThaana(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsThai(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsThai\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsThai(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsTibetan(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsTibetan\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsTibetan(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsUgaritic(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsUgaritic\0" as *const u8 as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsUgaritic(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsUnifiedCanadianAboriginalSyllabics(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsUnifiedCanadianAboriginalSyllabics\0" as *const u8
            as *const i8 as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsUnifiedCanadianAboriginalSyllabics(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsVariationSelectors(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsVariationSelectors\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsVariationSelectors(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsVariationSelectorsSupplement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsVariationSelectorsSupplement\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsVariationSelectorsSupplement(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsYiRadicals(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsYiRadicals\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsYiRadicals(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsYiSyllables(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsYiSyllables\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsYiSyllables(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUCSIsYijingHexagramSymbols(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut code: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlUCSIsYijingHexagramSymbols\0" as *const u8 as *const i8
            as *mut i8,
        &mut code as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUCSIsYijingHexagramSymbols(code);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIEscape(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut str: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlURIEscape\0" as *const u8 as *const i8 as *mut i8,
        &mut str as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlURIEscape(str);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIEscapeStr(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut list: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut str: * mut u8 = 0 as *mut xmlChar;
    let mut list: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:xmlURIEscapeStr\0" as *const u8 as *const i8 as *mut i8,
        &mut str as *mut *mut xmlChar,
        &mut list as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlURIEscapeStr(str, list);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetAuthority(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const i8 = 0 as *const i8;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const i8 = 0 as *const i8;
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlURIGetAuthority\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    c_retval = (*URI).authority;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetFragment(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const i8 = 0 as *const i8;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const i8 = 0 as *const i8;
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlURIGetFragment\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    c_retval = (*URI).fragment;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetOpaque(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const i8 = 0 as *const i8;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const i8 = 0 as *const i8;
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlURIGetOpaque\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    c_retval = (*URI).opaque;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetPath(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const i8 = 0 as *const i8;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const i8 = 0 as *const i8;
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlURIGetPath\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    c_retval = (*URI).path;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetPort(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlURIGetPort\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    c_retval = (*URI).port;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetQuery(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const i8 = 0 as *const i8;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const i8 = 0 as *const i8;
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlURIGetQuery\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    c_retval = (*URI).query;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetQueryRaw(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const i8 = 0 as *const i8;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const i8 = 0 as *const i8;
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlURIGetQueryRaw\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    c_retval = (*URI).query_raw;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetScheme(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const i8 = 0 as *const i8;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const i8 = 0 as *const i8;
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlURIGetScheme\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    c_retval = (*URI).scheme;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetServer(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const i8 = 0 as *const i8;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const i8 = 0 as *const i8;
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlURIGetServer\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    c_retval = (*URI).server;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIGetUser(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const i8 = 0 as *const i8;
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const i8 = 0 as *const i8;
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlURIGetUser\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    c_retval = (*URI).user;
    py_retval = libxml_charPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetAuthority(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut authority: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut authority: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlURISetAuthority\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
        &mut authority as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    if !((*URI).authority).is_null() {
        xmlFree
            .expect("non-null function pointer")((*URI).authority as *mut libc::c_void);
    }
    let ref mut fresh125 = (*URI).authority;
    *fresh125 = xmlStrdup(authority as *const xmlChar) as *mut i8;
<<<<<<< HEAD
    let ref mut fresh126 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh126 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh126 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetFragment(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut fragment: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut fragment: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlURISetFragment\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
        &mut fragment as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    if !((*URI).fragment).is_null() {
        xmlFree
            .expect("non-null function pointer")((*URI).fragment as *mut libc::c_void);
    }
    let ref mut fresh127 = (*URI).fragment;
    *fresh127 = xmlStrdup(fragment as *const xmlChar) as *mut i8;
<<<<<<< HEAD
    let ref mut fresh128 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh128 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh128 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetOpaque(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut opaque: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut opaque: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlURISetOpaque\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
        &mut opaque as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    if !((*URI).opaque).is_null() {
        xmlFree.expect("non-null function pointer")((*URI).opaque as *mut libc::c_void);
    }
    let ref mut fresh129 = (*URI).opaque;
    *fresh129 = xmlStrdup(opaque as *const xmlChar) as *mut i8;
<<<<<<< HEAD
    let ref mut fresh130 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh130 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh130 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetPath(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut path: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut path: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlURISetPath\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
        &mut path as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    if !((*URI).path).is_null() {
        xmlFree.expect("non-null function pointer")((*URI).path as *mut libc::c_void);
    }
    let ref mut fresh131 = (*URI).path;
    *fresh131 = xmlStrdup(path as *const xmlChar) as *mut i8;
<<<<<<< HEAD
    let ref mut fresh132 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh132 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh132 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetPort(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut port: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlURISetPort\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
        &mut port as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    (*URI).port = port;
<<<<<<< HEAD
    let ref mut fresh133 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh133 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh133 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetQuery(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut query: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut query: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlURISetQuery\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
        &mut query as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    if !((*URI).query).is_null() {
        xmlFree.expect("non-null function pointer")((*URI).query as *mut libc::c_void);
    }
    let ref mut fresh134 = (*URI).query;
    *fresh134 = xmlStrdup(query as *const xmlChar) as *mut i8;
<<<<<<< HEAD
    let ref mut fresh135 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh135 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh135 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetQueryRaw(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut query_raw: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut query_raw: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlURISetQueryRaw\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
        &mut query_raw as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    if !((*URI).query_raw).is_null() {
        xmlFree
            .expect("non-null function pointer")((*URI).query_raw as *mut libc::c_void);
    }
    let ref mut fresh136 = (*URI).query_raw;
    *fresh136 = xmlStrdup(query_raw as *const xmlChar) as *mut i8;
<<<<<<< HEAD
    let ref mut fresh137 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh137 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh137 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetScheme(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut scheme: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut scheme: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlURISetScheme\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
        &mut scheme as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    if !((*URI).scheme).is_null() {
        xmlFree.expect("non-null function pointer")((*URI).scheme as *mut libc::c_void);
    }
    let ref mut fresh138 = (*URI).scheme;
    *fresh138 = xmlStrdup(scheme as *const xmlChar) as *mut i8;
<<<<<<< HEAD
    let ref mut fresh139 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh139 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh139 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetServer(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut server: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut server: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlURISetServer\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
        &mut server as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    if !((*URI).server).is_null() {
        xmlFree.expect("non-null function pointer")((*URI).server as *mut libc::c_void);
    }
    let ref mut fresh140 = (*URI).server;
    *fresh140 = xmlStrdup(server as *const xmlChar) as *mut i8;
<<<<<<< HEAD
    let ref mut fresh141 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh141 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh141 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURISetUser(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut URI: xmlURIPtr = 0 as *mut xmlURI;
    let mut pyobj_URI: *mut PyObject = 0 as *mut PyObject;
    let mut user: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut URI: * mut crate::src::python::libxml2_py::_xmlURI = 0 as *mut xmlURI;
    let mut pyobj_URI: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut user: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlURISetUser\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_URI as *mut *mut PyObject,
        &mut user as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    URI = if pyobj_URI == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlURIPtr
    } else {
        (*(pyobj_URI as *mut PyURI_Object)).obj
    };
    if !((*URI).user).is_null() {
        xmlFree.expect("non-null function pointer")((*URI).user as *mut libc::c_void);
    }
    let ref mut fresh142 = (*URI).user;
    *fresh142 = xmlStrdup(user as *const xmlChar) as *mut i8;
<<<<<<< HEAD
    let ref mut fresh143 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh143 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh143 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlURIUnescapeString(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut i8 = 0 as *mut i8;
    let mut str: *mut i8 = 0 as *mut i8;
    let mut len: i32 = 0;
    let mut target: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut i8 = 0 as *mut i8;
    let mut str: * mut i8 = 0 as *mut i8;
    let mut len: i32 = 0;
    let mut target: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"ziz:xmlURIUnescapeString\0" as *const u8 as *const i8
            as *mut i8,
        &mut str as *mut *mut i8,
        &mut len as *mut i32,
        &mut target as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlURIUnescapeString(str, len, target);
    py_retval = libxml_charPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUTF8Charcmp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut utf1: *mut xmlChar = 0 as *mut xmlChar;
    let mut utf2: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut utf1: * mut u8 = 0 as *mut xmlChar;
    let mut utf2: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:xmlUTF8Charcmp\0" as *const u8 as *const i8 as *mut i8,
        &mut utf1 as *mut *mut xmlChar,
        &mut utf2 as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUTF8Charcmp(utf1, utf2);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUTF8Size(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut utf: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlUTF8Size\0" as *const u8 as *const i8 as *mut i8,
        &mut utf as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUTF8Size(utf);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUTF8Strlen(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut utf: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlUTF8Strlen\0" as *const u8 as *const i8 as *mut i8,
        &mut utf as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUTF8Strlen(utf);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUTF8Strloc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
    let mut utfchar: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut utf: * mut u8 = 0 as *mut xmlChar;
    let mut utfchar: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zz:xmlUTF8Strloc\0" as *const u8 as *const i8 as *mut i8,
        &mut utf as *mut *mut xmlChar,
        &mut utfchar as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUTF8Strloc(utf, utfchar);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUTF8Strndup(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut utf: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zi:xmlUTF8Strndup\0" as *const u8 as *const i8 as *mut i8,
        &mut utf as *mut *mut xmlChar,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUTF8Strndup(utf, len);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUTF8Strpos(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut utf: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut pos: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zi:xmlUTF8Strpos\0" as *const u8 as *const i8 as *mut i8,
        &mut utf as *mut *mut xmlChar,
        &mut pos as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUTF8Strpos(utf, pos);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUTF8Strsize(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut utf: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zi:xmlUTF8Strsize\0" as *const u8 as *const i8 as *mut i8,
        &mut utf as *mut *mut xmlChar,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUTF8Strsize(utf, len);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUTF8Strsub(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut utf: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut utf: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut start: i32 = 0;
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zii:xmlUTF8Strsub\0" as *const u8 as *const i8 as *mut i8,
        &mut utf as *mut *mut xmlChar,
        &mut start as *mut i32,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlUTF8Strsub(utf, start, len);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUnlinkNode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlUnlinkNode\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    xmlUnlinkNode(cur);
<<<<<<< HEAD
    let ref mut fresh144 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh144 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh144 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUnsetNsProp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut ns: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut pyobj_ns: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOz:xmlUnsetNsProp\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut pyobj_ns as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    ns = (if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_ns as *mut PyxmlNode_Object)).obj
    }) as xmlNsPtr;
    c_retval = xmlUnsetNsProp(node, ns, name);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlUnsetProp(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlUnsetProp\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlUnsetProp(node, name);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidCtxtNormalizeAttributeValue(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlValidCtxt = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOOzz:xmlValidCtxtNormalizeAttributeValue\0" as *const u8
            as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlValidCtxtNormalizeAttributeValue(ctxt, doc, elem, name, value);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidNormalizeAttributeValue(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOzz:xmlValidNormalizeAttributeValue\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlValidNormalizeAttributeValue(doc, elem, name, value);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateDocument(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlValidCtxt = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlValidateDocument\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlValidateDocument(ctxt, doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateDocumentFinal(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlValidCtxt = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlValidateDocumentFinal\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlValidateDocumentFinal(ctxt, doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateDtd(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut dtd: xmlDtdPtr = 0 as *mut xmlDtd;
    let mut pyobj_dtd: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlValidCtxt = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut dtd: * mut crate::src::python::libxml::_xmlDtd = 0 as *mut xmlDtd;
    let mut pyobj_dtd: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOO:xmlValidateDtd\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_dtd as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    dtd = (if pyobj_dtd == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_dtd as *mut PyxmlNode_Object)).obj
    }) as xmlDtdPtr;
    c_retval = xmlValidateDtd(ctxt, doc, dtd);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateDtdFinal(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlValidCtxt = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlValidateDtdFinal\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlValidateDtdFinal(ctxt, doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateElement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlValidCtxt = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOO:xmlValidateElement\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlValidateElement(ctxt, doc, elem);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateNCName(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut space: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zi:xmlValidateNCName\0" as *const u8 as *const i8
            as *mut i8,
        &mut value as *mut *mut xmlChar,
        &mut space as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlValidateNCName(value, space);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateNMToken(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut space: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zi:xmlValidateNMToken\0" as *const u8 as *const i8
            as *mut i8,
        &mut value as *mut *mut xmlChar,
        &mut space as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlValidateNMToken(value, space);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateName(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut space: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zi:xmlValidateName\0" as *const u8 as *const i8 as *mut i8,
        &mut value as *mut *mut xmlChar,
        &mut space as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlValidateName(value, space);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateNameValue(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlValidateNameValue\0" as *const u8 as *const i8
            as *mut i8,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlValidateNameValue(value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateNamesValue(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlValidateNamesValue\0" as *const u8 as *const i8
            as *mut i8,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlValidateNamesValue(value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateNmtokenValue(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlValidateNmtokenValue\0" as *const u8 as *const i8
            as *mut i8,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlValidateNmtokenValue(value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateNmtokensValue(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlValidateNmtokensValue\0" as *const u8 as *const i8
            as *mut i8,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlValidateNmtokensValue(value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateNotationUse(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut notationName: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlValidCtxt = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut notationName: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOz:xmlValidateNotationUse\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut notationName as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlValidateNotationUse(ctxt, doc, notationName);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateOneAttribute(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut pyobj_attr: *mut PyObject = 0 as *mut PyObject;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlValidCtxt = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut attr: * mut crate::src::python::libxml::_xmlAttr = 0 as *mut xmlAttr;
    let mut pyobj_attr: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOOOz:xmlValidateOneAttribute\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
        &mut pyobj_attr as *mut *mut PyObject,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    attr = (if pyobj_attr == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_attr as *mut PyxmlNode_Object)).obj
    }) as xmlAttrPtr;
    c_retval = xmlValidateOneAttribute(ctxt, doc, elem, attr, value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateOneElement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlValidCtxt = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOO:xmlValidateOneElement\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlValidateOneElement(ctxt, doc, elem);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateOneNamespace(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlValidCtxt = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut prefix: * mut u8 = 0 as *mut xmlChar;
    let mut ns: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut pyobj_ns: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOOzOz:xmlValidateOneNamespace\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
        &mut prefix as *mut *mut xmlChar,
        &mut pyobj_ns as *mut *mut PyObject,
        &mut value as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    ns = (if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_ns as *mut PyxmlNode_Object)).obj
    }) as xmlNsPtr;
    c_retval = xmlValidateOneNamespace(ctxt, doc, elem, prefix, ns, value);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidatePopElement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    let mut qname: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlValidCtxt = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut qname: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOOz:xmlValidatePopElement\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
        &mut qname as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlValidatePopElement(ctxt, doc, elem, qname);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidatePushCData(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut data: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlValidCtxt = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut data: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut len: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozi:xmlValidatePushCData\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut data as *mut *mut xmlChar,
        &mut len as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj
    };
    c_retval = xmlValidatePushCData(ctxt, data, len);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidatePushElement(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut elem: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_elem: *mut PyObject = 0 as *mut PyObject;
    let mut qname: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlValidCtxt = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut elem: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_elem: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut qname: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOOz:xmlValidatePushElement\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_elem as *mut *mut PyObject,
        &mut qname as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    elem = if pyobj_elem == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_elem as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlValidatePushElement(ctxt, doc, elem, qname);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateQName(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut value: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut space: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zi:xmlValidateQName\0" as *const u8 as *const i8
            as *mut i8,
        &mut value as *mut *mut xmlChar,
        &mut space as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlValidateQName(value, space);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlValidateRoot(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlValidCtxtPtr = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlValidCtxt = 0 as *mut xmlValidCtxt;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlValidateRoot\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlValidCtxtPtr
    } else {
        (*(pyobj_ctxt as *mut PyValidCtxt_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlValidateRoot(ctxt, doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXIncludeProcess(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXIncludeProcess\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlXIncludeProcess(doc);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXIncludeProcessFlags(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut flags: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXIncludeProcessFlags\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut flags as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlXIncludeProcessFlags(doc, flags);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXIncludeProcessTree(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut tree: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_tree: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut tree: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_tree: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXIncludeProcessTree\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_tree as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    tree = if pyobj_tree == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_tree as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXIncludeProcessTree(tree);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXIncludeProcessTreeFlags(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut tree: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_tree: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut tree: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_tree: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut flags: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXIncludeProcessTreeFlags\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_tree as *mut *mut PyObject,
        &mut flags as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    tree = if pyobj_tree == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_tree as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXIncludeProcessTreeFlags(tree, flags);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathAddValues(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathAddValues\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathAddValues(ctxt);
<<<<<<< HEAD
    let ref mut fresh145 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh145 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh145 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathBooleanFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathBooleanFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathBooleanFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh146 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh146 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh146 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCastBooleanToNumber(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: f64 = 0.;
    let mut val: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlXPathCastBooleanToNumber\0" as *const u8 as *const i8
            as *mut i8,
        &mut val as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlXPathCastBooleanToNumber(val);
    py_retval = libxml_doubleWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCastBooleanToString(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut val: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlXPathCastBooleanToString\0" as *const u8 as *const i8
            as *mut i8,
        &mut val as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlXPathCastBooleanToString(val);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCastNodeToNumber(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: f64 = 0.;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: f64 = 0.;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathCastNodeToNumber\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathCastNodeToNumber(node);
    py_retval = libxml_doubleWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCastNodeToString(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathCastNodeToString\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathCastNodeToString(node);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCastNumberToBoolean(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut val: f64 = 0.;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"d:xmlXPathCastNumberToBoolean\0" as *const u8 as *const i8
            as *mut i8,
        &mut val as *mut f64,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlXPathCastNumberToBoolean(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCastNumberToString(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut val: f64 = 0.;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"d:xmlXPathCastNumberToString\0" as *const u8 as *const i8
            as *mut i8,
        &mut val as *mut f64,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlXPathCastNumberToString(val);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCastStringToBoolean(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut val: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlXPathCastStringToBoolean\0" as *const u8 as *const i8
            as *mut i8,
        &mut val as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlXPathCastStringToBoolean(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCastStringToNumber(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: f64 = 0.;
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: f64 = 0.;
    let mut val: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlXPathCastStringToNumber\0" as *const u8 as *const i8
            as *mut i8,
        &mut val as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlXPathCastStringToNumber(val);
    py_retval = libxml_doubleWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCeilingFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathCeilingFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathCeilingFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh147 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh147 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh147 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCmpNodes(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut node1: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node1: *mut PyObject = 0 as *mut PyObject;
    let mut node2: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node2: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut node1: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node1: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut node2: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node2: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlXPathCmpNodes\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_node1 as *mut *mut PyObject,
        &mut pyobj_node2 as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node1 = if pyobj_node1 == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node1 as *mut PyxmlNode_Object)).obj
    };
    node2 = if pyobj_node2 == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node2 as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathCmpNodes(node1, node2);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCompareValues(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut inf: i32 = 0;
    let mut strict: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oii:xmlXPathCompareValues\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut inf as *mut i32,
        &mut strict as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    c_retval = xmlXPathCompareValues(ctxt, inf, strict);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathConcatFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathConcatFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathConcatFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh148 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh148 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh148 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathContainsFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathContainsFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathContainsFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh149 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh149 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh149 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathContextSetCache(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut active: i32 = 0;
    let mut value: i32 = 0;
    let mut options: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oiii:xmlXPathContextSetCache\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut active as *mut i32,
        &mut value as *mut i32,
        &mut options as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    c_retval = xmlXPathContextSetCache(ctxt, active, value, options);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathCountFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathCountFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathCountFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh150 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh150 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh150 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathDivValues(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathDivValues\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathDivValues(ctxt);
<<<<<<< HEAD
    let ref mut fresh151 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh151 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh151 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathEqualValues(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathEqualValues\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    c_retval = xmlXPathEqualValues(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathErr(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut error: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathErr\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut error as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathErr(ctxt, error);
<<<<<<< HEAD
    let ref mut fresh152 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh152 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh152 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathEval(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctx: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctx: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlXPathObject = 0 as *mut xmlXPathObject;
    let mut str: * mut u8 = 0 as *mut xmlChar;
    let mut ctx: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctx: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zO:xmlXPathEval\0" as *const u8 as *const i8 as *mut i8,
        &mut str as *mut *mut xmlChar,
        &mut pyobj_ctx as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctx = if pyobj_ctx == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctx as *mut PyxmlXPathContext_Object)).obj
    };
    c_retval = xmlXPathEval(str, ctx);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathEvalExpr(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathEvalExpr\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathEvalExpr(ctxt);
<<<<<<< HEAD
    let ref mut fresh153 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh153 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh153 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathEvalExpression(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlXPathObject = 0 as *mut xmlXPathObject;
    let mut str: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zO:xmlXPathEvalExpression\0" as *const u8 as *const i8
            as *mut i8,
        &mut str as *mut *mut xmlChar,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    c_retval = xmlXPathEvalExpression(str, ctxt);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathFalseFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathFalseFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathFalseFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh154 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh154 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh154 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathFloorFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathFloorFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathFloorFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh155 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh155 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh155 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathFreeContext(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathFreeContext\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    xmlXPathFreeContext(ctxt);
<<<<<<< HEAD
    let ref mut fresh156 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh156 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh156 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathFreeParserContext(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathFreeParserContext\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathFreeParserContext(ctxt);
<<<<<<< HEAD
    let ref mut fresh157 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh157 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh157 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathGetContextDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlDocPtr = 0 as *mut xmlDoc;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathGetContextDoc\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    c_retval = (*ctxt).doc;
    py_retval = libxml_xmlDocPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathGetContextNode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathGetContextNode\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    c_retval = (*ctxt).node;
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathGetContextPosition(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathGetContextPosition\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    c_retval = (*ctxt).proximityPosition;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathGetContextSize(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathGetContextSize\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    c_retval = (*ctxt).contextSize;
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathGetFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathGetFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    c_retval = (*ctxt).function;
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathGetFunctionURI(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathGetFunctionURI\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    c_retval = (*ctxt).functionURI;
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathIdFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathIdFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathIdFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh158 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh158 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh158 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathInit(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if libxml_deprecationWarning(b"xmlXPathInit\0" as *const u8 as *const i8)
        == -(1 as i32)
    {
        return 0 as *mut PyObject;
    }
    xmlXPathInit();
<<<<<<< HEAD
    let ref mut fresh159 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh159 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh159 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathIsInf(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut val: f64 = 0.;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"d:xmlXPathIsInf\0" as *const u8 as *const i8 as *mut i8,
        &mut val as *mut f64,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlXPathIsInf(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathIsNaN(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut c_retval: i32 = 0;
    let mut val: f64 = 0.;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"d:xmlXPathIsNaN\0" as *const u8 as *const i8 as *mut i8,
        &mut val as *mut f64,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlXPathIsNaN(val);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathIsNodeType(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlXPathIsNodeType\0" as *const u8 as *const i8
            as *mut i8,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlXPathIsNodeType(name);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathLangFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathLangFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathLangFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh160 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh160 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh160 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathLastFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathLastFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathLastFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh161 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh161 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh161 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathLocalNameFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathLocalNameFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathLocalNameFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh162 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh162 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh162 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathModValues(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathModValues\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathModValues(ctxt);
<<<<<<< HEAD
    let ref mut fresh163 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh163 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh163 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathMultValues(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathMultValues\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathMultValues(ctxt);
<<<<<<< HEAD
    let ref mut fresh164 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh164 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh164 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNamespaceURIFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathNamespaceURIFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathNamespaceURIFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh165 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh165 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh165 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNewBoolean(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlXPathObject = 0 as *mut xmlXPathObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut val: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"i:xmlXPathNewBoolean\0" as *const u8 as *const i8
            as *mut i8,
        &mut val as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlXPathNewBoolean(val);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNewCString(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlXPathObject = 0 as *mut xmlXPathObject;
    let mut val: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlXPathNewCString\0" as *const u8 as *const i8
            as *mut i8,
        &mut val as *mut *mut i8,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlXPathNewCString(val);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNewContext(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathNewContext\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlXPathNewContext(doc);
    py_retval = libxml_xmlXPathContextPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNewFloat(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlXPathObject = 0 as *mut xmlXPathObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut val: f64 = 0.;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"d:xmlXPathNewFloat\0" as *const u8 as *const i8 as *mut i8,
        &mut val as *mut f64,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlXPathNewFloat(val);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNewNodeSet(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_val: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlXPathObject = 0 as *mut xmlXPathObject;
    let mut val: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_val: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathNewNodeSet\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_val as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    val = if pyobj_val == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_val as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathNewNodeSet(val);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNewParserContext(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut str: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zO:xmlXPathNewParserContext\0" as *const u8 as *const i8
            as *mut i8,
        &mut str as *mut *mut xmlChar,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    c_retval = xmlXPathNewParserContext(str, ctxt);
    py_retval = libxml_xmlXPathParserContextPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNewString(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlXPathObject = 0 as *mut xmlXPathObject;
    let mut val: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlXPathNewString\0" as *const u8 as *const i8
            as *mut i8,
        &mut val as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlXPathNewString(val);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNewValueTree(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut val: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_val: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlXPathObject = 0 as *mut xmlXPathObject;
    let mut val: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_val: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathNewValueTree\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_val as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    val = if pyobj_val == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_val as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathNewValueTree(val);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextAncestor(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlXPathNextAncestor\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathNextAncestor(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextAncestorOrSelf(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlXPathNextAncestorOrSelf\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathNextAncestorOrSelf(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextAttribute(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlXPathNextAttribute\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathNextAttribute(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextChild(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlXPathNextChild\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathNextChild(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextDescendant(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlXPathNextDescendant\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathNextDescendant(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextDescendantOrSelf(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlXPathNextDescendantOrSelf\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathNextDescendantOrSelf(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextFollowing(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlXPathNextFollowing\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathNextFollowing(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextFollowingSibling(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlXPathNextFollowingSibling\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathNextFollowingSibling(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextNamespace(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlXPathNextNamespace\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathNextNamespace(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextParent(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlXPathNextParent\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathNextParent(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextPreceding(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlXPathNextPreceding\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathNextPreceding(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextPrecedingSibling(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlXPathNextPrecedingSibling\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathNextPrecedingSibling(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNextSelf(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlNodePtr = 0 as *mut xmlNode;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_cur: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut cur: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_cur: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlXPathNextSelf\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_cur as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    cur = if pyobj_cur == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_cur as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPathNextSelf(ctxt, cur);
    py_retval = libxml_xmlNodePtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNodeEval(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctx: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctx: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlXPathObject = 0 as *mut xmlXPathObject;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut str: * mut u8 = 0 as *mut xmlChar;
    let mut ctx: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctx: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OzO:xmlXPathNodeEval\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_node as *mut *mut PyObject,
        &mut str as *mut *mut xmlChar,
        &mut pyobj_ctx as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    ctx = if pyobj_ctx == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctx as *mut PyxmlXPathContext_Object)).obj
    };
    c_retval = xmlXPathNodeEval(node, str, ctx);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNodeSetFreeNs(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut pyobj_ns: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ns: * mut crate::src::python::libxml::_xmlNs = 0 as *mut xmlNs;
    let mut pyobj_ns: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathNodeSetFreeNs\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ns as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ns = (if pyobj_ns == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_ns as *mut PyxmlNode_Object)).obj
    }) as xmlNsPtr;
    xmlXPathNodeSetFreeNs(ns);
<<<<<<< HEAD
    let ref mut fresh166 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh166 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh166 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNormalizeFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathNormalizeFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathNormalizeFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh167 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh167 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh167 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNotEqualValues(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathNotEqualValues\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    c_retval = xmlXPathNotEqualValues(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNotFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathNotFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathNotFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh168 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh168 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh168 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNsLookup(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *const xmlChar = 0 as *const xmlChar;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * const u8 = 0 as *const xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut prefix: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlXPathNsLookup\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut prefix as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    c_retval = xmlXPathNsLookup(ctxt, prefix);
    py_retval = libxml_xmlCharPtrConstWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathNumberFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathNumberFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathNumberFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh169 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh169 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh169 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathOrderDocElems(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i64 = 0;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i64 = 0;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathOrderDocElems\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    c_retval = xmlXPathOrderDocElems(doc);
    py_retval = libxml_longWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathParseNCName(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathParseNCName\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    c_retval = xmlXPathParseNCName(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathParseName(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathParseName\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    c_retval = xmlXPathParseName(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathParserGetContext(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathParserGetContext\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    c_retval = (*ctxt).context;
    py_retval = libxml_xmlXPathContextPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathPopBoolean(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathPopBoolean\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    c_retval = xmlXPathPopBoolean(ctxt);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathPopNumber(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: f64 = 0.;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: f64 = 0.;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathPopNumber\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    c_retval = xmlXPathPopNumber(ctxt);
    py_retval = libxml_doubleWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathPopString(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut u8 = 0 as *mut xmlChar;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathPopString\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    c_retval = xmlXPathPopString(ctxt);
    py_retval = libxml_xmlCharPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathPositionFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathPositionFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathPositionFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh170 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh170 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh170 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathRegisterAllFunctions(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathRegisterAllFunctions\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    xmlXPathRegisterAllFunctions(ctxt);
<<<<<<< HEAD
    let ref mut fresh171 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh171 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh171 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathRegisterNs(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    let mut ns_uri: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: i32 = 0;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut prefix: * mut u8 = 0 as *mut xmlChar;
    let mut ns_uri: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozz:xmlXPathRegisterNs\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut prefix as *mut *mut xmlChar,
        &mut ns_uri as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    c_retval = xmlXPathRegisterNs(ctxt, prefix, ns_uri);
    py_retval = libxml_intWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathRegisteredFuncsCleanup(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathRegisteredFuncsCleanup\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    xmlXPathRegisteredFuncsCleanup(ctxt);
<<<<<<< HEAD
    let ref mut fresh172 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh172 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh172 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathRegisteredNsCleanup(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathRegisteredNsCleanup\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    xmlXPathRegisteredNsCleanup(ctxt);
<<<<<<< HEAD
    let ref mut fresh173 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh173 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh173 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathRegisteredVariablesCleanup(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathRegisteredVariablesCleanup\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    xmlXPathRegisteredVariablesCleanup(ctxt);
<<<<<<< HEAD
    let ref mut fresh174 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh174 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh174 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathRoot(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathRoot\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathRoot(ctxt);
<<<<<<< HEAD
    let ref mut fresh175 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh175 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh175 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathRoundFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathRoundFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathRoundFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh176 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh176 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh176 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathSetContextDoc(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlXPathSetContextDoc\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_doc as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    let ref mut fresh177 = (*ctxt).doc;
    *fresh177 = doc;
<<<<<<< HEAD
    let ref mut fresh178 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh178 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh178 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathSetContextNode(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_node: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut node: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_node: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OO:xmlXPathSetContextNode\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut pyobj_node as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    node = if pyobj_node == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_node as *mut PyxmlNode_Object)).obj
    };
    let ref mut fresh179 = (*ctxt).node;
    *fresh179 = node;
<<<<<<< HEAD
    let ref mut fresh180 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh180 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh180 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathStartsWithFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathStartsWithFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathStartsWithFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh181 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh181 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh181 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathStringEvalNumber(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: f64 = 0.;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: f64 = 0.;
    let mut str: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"z:xmlXPathStringEvalNumber\0" as *const u8 as *const i8
            as *mut i8,
        &mut str as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    c_retval = xmlXPathStringEvalNumber(str);
    py_retval = libxml_doubleWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathStringFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathStringFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathStringFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh182 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh182 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh182 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathStringLengthFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathStringLengthFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathStringLengthFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh183 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh183 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh183 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathSubValues(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathSubValues\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathSubValues(ctxt);
<<<<<<< HEAD
    let ref mut fresh184 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh184 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh184 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathSubstringAfterFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathSubstringAfterFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathSubstringAfterFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh185 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh185 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh185 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathSubstringBeforeFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathSubstringBeforeFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathSubstringBeforeFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh186 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh186 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh186 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathSubstringFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathSubstringFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathSubstringFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh187 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh187 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh187 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathSumFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathSumFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathSumFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh188 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh188 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh188 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathTranslateFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathTranslateFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathTranslateFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh189 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh189 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh189 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathTrueFunction(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut nargs: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oi:xmlXPathTrueFunction\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut nargs as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathTrueFunction(ctxt, nargs);
<<<<<<< HEAD
    let ref mut fresh190 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh190 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh190 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathValueFlipSign(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"O:xmlXPathValueFlipSign\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPathValueFlipSign(ctxt);
<<<<<<< HEAD
    let ref mut fresh191 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh191 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh191 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathVariableLookup(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlXPathObject = 0 as *mut xmlXPathObject;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Oz:xmlXPathVariableLookup\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    c_retval = xmlXPathVariableLookup(ctxt, name);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPathVariableLookupNS(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut ctxt: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut name: *mut xmlChar = 0 as *mut xmlChar;
    let mut ns_uri: *mut xmlChar = 0 as *mut xmlChar;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlXPathObject = 0 as *mut xmlXPathObject;
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut name: * mut u8 = 0 as *mut xmlChar;
    let mut ns_uri: * mut u8 = 0 as *mut xmlChar;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozz:xmlXPathVariableLookupNS\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut name as *mut *mut xmlChar,
        &mut ns_uri as *mut *mut xmlChar,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathContext_Object)).obj
    };
    c_retval = xmlXPathVariableLookupNS(ctxt, name, ns_uri);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPatherror(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut ctxt: xmlXPathParserContextPtr = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: *mut PyObject = 0 as *mut PyObject;
    let mut file: *mut i8 = 0 as *mut i8;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut ctxt: * mut crate::src::python::libxml::_xmlXPathParserContext = 0 as *mut xmlXPathParserContext;
    let mut pyobj_ctxt: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut file: * mut i8 = 0 as *mut i8;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    let mut line: i32 = 0;
    let mut no: i32 = 0;
    if _PyArg_ParseTuple_SizeT(
        args,
        b"Ozii:xmlXPatherror\0" as *const u8 as *const i8 as *mut i8,
        &mut pyobj_ctxt as *mut *mut PyObject,
        &mut file as *mut *mut i8,
        &mut line as *mut i32,
        &mut no as *mut i32,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctxt = if pyobj_ctxt == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathParserContextPtr
    } else {
        (*(pyobj_ctxt as *mut PyxmlXPathParserContext_Object)).obj
    };
    xmlXPatherror(ctxt, file, line, no);
<<<<<<< HEAD
    let ref mut fresh192 = (*(&mut _Py_NoneStruct as *mut PyObject)).ob_refcnt;
=======
    let ref mut fresh192 = (*((Some(&mut _Py_NoneStruct))).unwrap()).ob_refcnt;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    *fresh192 += 1;
    return &mut _Py_NoneStruct;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPtrEval(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathObjectPtr = 0 as *mut xmlXPathObject;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut ctx: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut pyobj_ctx: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlXPathObject = 0 as *mut xmlXPathObject;
    let mut str: * mut u8 = 0 as *mut xmlChar;
    let mut ctx: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut pyobj_ctx: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"zO:xmlXPtrEval\0" as *const u8 as *const i8 as *mut i8,
        &mut str as *mut *mut xmlChar,
        &mut pyobj_ctx as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    ctx = if pyobj_ctx == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlXPathContextPtr
    } else {
        (*(pyobj_ctx as *mut PyxmlXPathContext_Object)).obj
    };
    c_retval = xmlXPtrEval(str, ctx);
    py_retval = libxml_xmlXPathObjectPtrWrap(c_retval);
    return py_retval;
}
#[no_mangle]
pub unsafe extern "C" fn libxml_xmlXPtrNewContext(
<<<<<<< HEAD
    mut self_0: *mut PyObject,
    mut args: *mut PyObject,
) -> *mut PyObject {
    let mut py_retval: *mut PyObject = 0 as *mut PyObject;
    let mut c_retval: xmlXPathContextPtr = 0 as *mut xmlXPathContext;
    let mut doc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut pyobj_doc: *mut PyObject = 0 as *mut PyObject;
    let mut here: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_here: *mut PyObject = 0 as *mut PyObject;
    let mut origin: xmlNodePtr = 0 as *mut xmlNode;
    let mut pyobj_origin: *mut PyObject = 0 as *mut PyObject;
=======
    mut self_0: * mut crate::src::python::libxml::_object,
    mut args: * mut crate::src::python::libxml::_object,
) -> * mut crate::src::python::libxml::_object {
    let mut py_retval: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut c_retval: * mut crate::src::python::libxml::_xmlXPathContext = 0 as *mut xmlXPathContext;
    let mut doc: * mut crate::src::python::libxml::_xmlDoc = 0 as *mut xmlDoc;
    let mut pyobj_doc: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut here: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_here: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
    let mut origin: * mut crate::src::python::libxml::_xmlNode = 0 as *mut xmlNode;
    let mut pyobj_origin: * mut crate::src::python::libxml::_object = 0 as *mut PyObject;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe
    if _PyArg_ParseTuple_SizeT(
        args,
        b"OOO:xmlXPtrNewContext\0" as *const u8 as *const i8
            as *mut i8,
        &mut pyobj_doc as *mut *mut PyObject,
        &mut pyobj_here as *mut *mut PyObject,
        &mut pyobj_origin as *mut *mut PyObject,
    ) == 0
    {
        return 0 as *mut PyObject;
    }
    doc = (if pyobj_doc == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_doc as *mut PyxmlNode_Object)).obj
    }) as xmlDocPtr;
    here = if pyobj_here == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_here as *mut PyxmlNode_Object)).obj
    };
    origin = if pyobj_origin == &mut _Py_NoneStruct as *mut PyObject {
        0 as xmlNodePtr
    } else {
        (*(pyobj_origin as *mut PyxmlNode_Object)).obj
    };
    c_retval = xmlXPtrNewContext(doc, here, origin);
    py_retval = libxml_xmlXPathContextPtrWrap(c_retval);
    return py_retval;
}
<<<<<<< HEAD
=======
use crate::laertes_rt::*;
>>>>>>> bbfa64d0f7db1b5e94d853ac3a3845e65fc050fe

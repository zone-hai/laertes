use ::libc;
extern "C" {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    fn fprintf(_: *mut FILE, _: *const i8, _: ...) -> i32;
    fn snprintf(
        _: *mut i8,
        _: u64,
        _: *const i8,
        _: ...
    ) -> i32;
    
    
    
    
    
    
    
    
    
    fn memset(
        _: *mut libc::c_void,
        _: i32,
        _: u64,
    ) -> *mut libc::c_void;
    fn strchr(_: *const i8, _: i32) -> *mut i8;
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: u64,
    ) -> *mut libc::c_void;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}
pub use crate::src::SAX2::xmlSAX2GetLineNumber;
pub use crate::src::dict::xmlDictCreate;
pub use crate::src::dict::xmlDictFree;
pub use crate::src::dict::xmlDictLookup;
pub use crate::src::dict::xmlDictReference;
pub use crate::src::error::__xmlRaiseError;
pub use crate::src::error::__xmlSimpleError;
pub use crate::src::error::xmlGetLastError;
pub use crate::src::globals::__xmlGenericError;
pub use crate::src::globals::__xmlGenericErrorContext;
pub use crate::src::hash::xmlHashAddEntry;
pub use crate::src::hash::xmlHashAddEntry2;
pub use crate::src::hash::xmlHashCreate;
pub use crate::src::hash::xmlHashCreateDict;
pub use crate::src::hash::xmlHashFree;
pub use crate::src::hash::xmlHashLookup;
pub use crate::src::hash::xmlHashLookup2;
pub use crate::src::hash::xmlHashScan;
pub use crate::src::hash::xmlHashScanFull;
pub use crate::src::hash::xmlHashSize;
pub use crate::src::parser::inputPush;
pub use crate::src::parser::xmlCtxtReadFile;
pub use crate::src::parser::xmlCtxtReadMemory;
pub use crate::src::parser::xmlParseDocument;
pub use crate::src::parser::xmlStopParser;
pub use crate::src::parserInternals::xmlFreeParserCtxt;
pub use crate::src::parserInternals::xmlNewIOInputStream;
pub use crate::src::parserInternals::xmlNewParserCtxt;
pub use crate::src::pattern::xmlFreePattern;
pub use crate::src::pattern::xmlFreeStreamCtxt;
pub use crate::src::pattern::xmlPatternGetStreamCtxt;
pub use crate::src::pattern::xmlPatterncompile;
pub use crate::src::pattern::xmlStreamPop;
pub use crate::src::pattern::xmlStreamPush;
pub use crate::src::pattern::xmlStreamPushAttr;
pub use crate::src::tree::xmlAddChild;
pub use crate::src::tree::xmlDocGetRootElement;
pub use crate::src::tree::xmlFreeDoc;
pub use crate::src::tree::xmlFreeNode;
pub use crate::src::tree::xmlGetNoNsProp;
pub use crate::src::tree::xmlGetNsList;
pub use crate::src::tree::xmlHasProp;
pub use crate::src::tree::xmlNewDocText;
pub use crate::src::tree::xmlNewNs;
pub use crate::src::tree::xmlNewNsProp;
pub use crate::src::tree::xmlNewProp;
pub use crate::src::tree::xmlNodeGetBase;
pub use crate::src::tree::xmlNodeGetContent;
pub use crate::src::tree::xmlNodeGetSpacePreserve;
pub use crate::src::tree::xmlNodeListGetString;
pub use crate::src::tree::xmlSearchNs;
pub use crate::src::tree::xmlSearchNsByHref;
pub use crate::src::tree::xmlSplitQName2;
pub use crate::src::tree::xmlSplitQName3;
pub use crate::src::tree::xmlUnlinkNode;
pub use crate::src::tree::xmlValidateNCName;
pub use crate::src::tree::xmlValidateQName;
pub use crate::src::uri::xmlBuildURI;
pub use crate::src::valid::xmlAddID;
pub use crate::src::valid::xmlFreeEnumeration;
pub use crate::src::xmlIO::xmlParserInputBufferCreateFilename;
pub use crate::src::xmlreader::xmlTextReaderLookupNamespace;
pub use crate::src::xmlregexp::xmlAutomataCompile;
pub use crate::src::xmlregexp::xmlAutomataGetInitState;
pub use crate::src::xmlregexp::xmlAutomataNewAllTrans;
pub use crate::src::xmlregexp::xmlAutomataNewCountTrans2;
pub use crate::src::xmlregexp::xmlAutomataNewCountedTrans;
pub use crate::src::xmlregexp::xmlAutomataNewCounter;
pub use crate::src::xmlregexp::xmlAutomataNewCounterTrans;
pub use crate::src::xmlregexp::xmlAutomataNewEpsilon;
pub use crate::src::xmlregexp::xmlAutomataNewNegTrans;
pub use crate::src::xmlregexp::xmlAutomataNewOnceTrans2;
pub use crate::src::xmlregexp::xmlAutomataNewState;
pub use crate::src::xmlregexp::xmlAutomataNewTransition2;
pub use crate::src::xmlregexp::xmlAutomataSetFinalState;
pub use crate::src::xmlregexp::xmlFreeAutomata;
pub use crate::src::xmlregexp::xmlNewAutomata;
pub use crate::src::xmlregexp::xmlRegExecErrInfo;
pub use crate::src::xmlregexp::xmlRegExecNextValues;
pub use crate::src::xmlregexp::xmlRegExecPushString;
pub use crate::src::xmlregexp::xmlRegExecPushString2;
pub use crate::src::xmlregexp::xmlRegFreeExecCtxt;
pub use crate::src::xmlregexp::xmlRegFreeRegexp;
pub use crate::src::xmlregexp::xmlRegNewExecCtxt;
pub use crate::src::xmlregexp::xmlRegexpCompile;
pub use crate::src::xmlregexp::xmlRegexpExec;
pub use crate::src::xmlregexp::xmlRegexpIsDeterminist;
pub use crate::src::xmlschemastypes::xmlSchemaCollapseString;
pub use crate::src::xmlschemastypes::xmlSchemaCompareValues;
pub use crate::src::xmlschemastypes::xmlSchemaCompareValuesWhtsp;
pub use crate::src::xmlschemastypes::xmlSchemaCopyValue;
pub use crate::src::xmlschemastypes::xmlSchemaFreeValue;
pub use crate::src::xmlschemastypes::xmlSchemaGetBuiltInType;
pub use crate::src::xmlschemastypes::xmlSchemaGetCanonValue;
pub use crate::src::xmlschemastypes::xmlSchemaGetFacetValueAsULong;
pub use crate::src::xmlschemastypes::xmlSchemaGetPredefinedType;
pub use crate::src::xmlschemastypes::xmlSchemaGetValType;
pub use crate::src::xmlschemastypes::xmlSchemaInitTypes;
pub use crate::src::xmlschemastypes::xmlSchemaIsBuiltInTypeFacet;
pub use crate::src::xmlschemastypes::xmlSchemaNewNOTATIONValue;
pub use crate::src::xmlschemastypes::xmlSchemaNewQNameValue;
pub use crate::src::xmlschemastypes::xmlSchemaValPredefTypeNode;
pub use crate::src::xmlschemastypes::xmlSchemaValPredefTypeNodeNoNorm;
pub use crate::src::xmlschemastypes::xmlSchemaValidateFacetWhtsp;
pub use crate::src::xmlschemastypes::xmlSchemaValidateLengthFacetWhtsp;
pub use crate::src::xmlschemastypes::xmlSchemaValidateListSimpleTypeFacet;
pub use crate::src::xmlschemastypes::xmlSchemaValidatePredefinedType;
pub use crate::src::xmlschemastypes::xmlSchemaValueAppend;
pub use crate::src::xmlschemastypes::xmlSchemaValueGetAsBoolean;
pub use crate::src::xmlschemastypes::xmlSchemaValueGetAsString;
pub use crate::src::xmlschemastypes::xmlSchemaValueGetNext;
pub use crate::src::xmlschemastypes::xmlSchemaWhiteSpaceReplace;
pub use crate::src::xmlstring::xmlCharStrdup;
pub use crate::src::xmlstring::xmlEscapeFormatString;
pub use crate::src::xmlstring::xmlStrEqual;
pub use crate::src::xmlstring::xmlStrcat;
pub use crate::src::xmlstring::xmlStrdup;
pub use crate::src::xmlstring::xmlStrlen;
pub use crate::src::xmlstring::xmlStrncat;
pub use crate::src::xmlstring::xmlStrncatNew;
pub use crate::src::xmlstring::xmlStrndup;
pub use crate::src::buf::_xmlBuf;
pub use crate::src::dict::_xmlDict;
pub use crate::src::hash::_xmlHashTable;
pub use crate::src::parser::_xmlStartTag;
pub use crate::src::pattern::_xmlPattern;
pub use crate::src::pattern::_xmlStreamCtxt;
pub use crate::src::valid::_xmlValidState;
pub use crate::src::xmlreader::_xmlTextReader;
pub use crate::src::xmlregexp::_xmlAutomata;
pub use crate::src::xmlregexp::_xmlAutomataState;
pub use crate::src::xmlregexp::_xmlRegExecCtxt;
pub use crate::src::xmlregexp::_xmlRegexp;
pub use crate::src::globals::xmlFree;
pub use crate::src::globals::xmlMalloc;
pub use crate::src::globals::xmlMallocAtomic;
pub use crate::src::globals::xmlRealloc;
pub use crate::src::parserInternals::_IO_wide_data;
pub use crate::src::relaxng::_IO_codecvt;
pub use crate::src::uri::_IO_marker;
pub use crate::src::xmlschemastypes::_xmlSchemaVal;
pub type xmlChar = crate::src::HTMLparser::xmlChar;
pub type size_t = crate::src::HTMLparser::size_t;
pub type __off_t = crate::src::HTMLtree::__off_t;
pub type __off64_t = crate::src::HTMLtree::__off64_t;
// #[derive(Copy, Clone)]

pub type _IO_FILE = crate::src::HTMLtree::_IO_FILE;
pub type _IO_lock_t = crate::src::HTMLtree::_IO_lock_t;
pub type FILE = crate::src::HTMLtree::FILE;
pub type xmlFreeFunc = crate::src::HTMLparser::xmlFreeFunc;
pub type xmlMallocFunc = crate::src::HTMLparser::xmlMallocFunc;
pub type xmlReallocFunc = crate::src::HTMLparser::xmlReallocFunc;
// #[derive(Copy, Clone)]

pub type _xmlParserInputBuffer = crate::src::HTMLparser::_xmlParserInputBuffer;
pub type xmlBufPtr = crate::src::HTMLparser::xmlBufPtr;
pub type xmlBuf = crate::src::HTMLparser::xmlBuf;
pub type xmlCharEncodingHandlerPtr = crate::src::HTMLparser::xmlCharEncodingHandlerPtr;
pub type xmlCharEncodingHandler = crate::src::HTMLparser::xmlCharEncodingHandler;
// #[derive(Copy, Clone)]

pub type _xmlCharEncodingHandler = crate::src::HTMLparser::_xmlCharEncodingHandler;
pub type iconv_t = crate::src::HTMLparser::iconv_t;
pub type xmlCharEncodingOutputFunc = crate::src::HTMLparser::xmlCharEncodingOutputFunc;
pub type xmlCharEncodingInputFunc = crate::src::HTMLparser::xmlCharEncodingInputFunc;
pub type xmlInputCloseCallback = crate::src::HTMLparser::xmlInputCloseCallback;
pub type xmlInputReadCallback = crate::src::HTMLparser::xmlInputReadCallback;
pub type xmlParserInputBuffer = crate::src::HTMLparser::xmlParserInputBuffer;
pub type xmlParserInputBufferPtr = crate::src::HTMLparser::xmlParserInputBufferPtr;
// #[derive(Copy, Clone)]

pub type _xmlParserInput = crate::src::HTMLparser::_xmlParserInput;
pub type xmlParserInputDeallocate = crate::src::HTMLparser::xmlParserInputDeallocate;
pub type xmlParserInput = crate::src::HTMLparser::xmlParserInput;
pub type xmlParserInputPtr = crate::src::HTMLparser::xmlParserInputPtr;
// #[derive(Copy, Clone)]

pub type _xmlParserCtxt = crate::src::HTMLparser::_xmlParserCtxt;
pub type xmlParserNodeInfo = crate::src::HTMLparser::xmlParserNodeInfo;
// #[derive(Copy, Clone)]

pub type _xmlParserNodeInfo = crate::src::HTMLparser::_xmlParserNodeInfo;
// #[derive(Copy, Clone)]

pub type _xmlNode = crate::src::HTMLparser::_xmlNode;
pub type xmlNs = crate::src::HTMLparser::xmlNs;
// #[derive(Copy, Clone)]

pub type _xmlNs = crate::src::HTMLparser::_xmlNs;
// #[derive(Copy, Clone)]

pub type _xmlDoc = crate::src::HTMLparser::_xmlDoc;
// #[derive(Copy, Clone)]

pub type _xmlDtd = crate::src::HTMLparser::_xmlDtd;
pub type xmlElementType = crate::src::HTMLparser::xmlElementType;
pub const XML_XINCLUDE_END: xmlElementType = 20;
pub const XML_XINCLUDE_START: xmlElementType = 19;
pub const XML_NAMESPACE_DECL: xmlElementType = 18;
pub const XML_ENTITY_DECL: xmlElementType = 17;
pub const XML_ATTRIBUTE_DECL: xmlElementType = 16;
pub const XML_ELEMENT_DECL: xmlElementType = 15;
pub const XML_DTD_NODE: xmlElementType = 14;
pub const XML_HTML_DOCUMENT_NODE: xmlElementType = 13;
pub const XML_NOTATION_NODE: xmlElementType = 12;
pub const XML_DOCUMENT_FRAG_NODE: xmlElementType = 11;
pub const XML_DOCUMENT_TYPE_NODE: xmlElementType = 10;
pub const XML_DOCUMENT_NODE: xmlElementType = 9;
pub const XML_COMMENT_NODE: xmlElementType = 8;
pub const XML_PI_NODE: xmlElementType = 7;
pub const XML_ENTITY_NODE: xmlElementType = 6;
pub const XML_ENTITY_REF_NODE: xmlElementType = 5;
pub const XML_CDATA_SECTION_NODE: xmlElementType = 4;
pub const XML_TEXT_NODE: xmlElementType = 3;
pub const XML_ATTRIBUTE_NODE: xmlElementType = 2;
pub const XML_ELEMENT_NODE: xmlElementType = 1;
pub type xmlNsType = crate::src::HTMLparser::xmlNsType;
// #[derive(Copy, Clone)]

pub type _xmlAttr = crate::src::HTMLparser::_xmlAttr;
pub type xmlAttributeType = crate::src::HTMLparser::xmlAttributeType;
pub const XML_ATTRIBUTE_NOTATION: xmlAttributeType = 10;
pub const XML_ATTRIBUTE_ENUMERATION: xmlAttributeType = 9;
pub const XML_ATTRIBUTE_NMTOKENS: xmlAttributeType = 8;
pub const XML_ATTRIBUTE_NMTOKEN: xmlAttributeType = 7;
pub const XML_ATTRIBUTE_ENTITIES: xmlAttributeType = 6;
pub const XML_ATTRIBUTE_ENTITY: xmlAttributeType = 5;
pub const XML_ATTRIBUTE_IDREFS: xmlAttributeType = 4;
pub const XML_ATTRIBUTE_IDREF: xmlAttributeType = 3;
pub const XML_ATTRIBUTE_ID: xmlAttributeType = 2;
pub const XML_ATTRIBUTE_CDATA: xmlAttributeType = 1;
pub type xmlParserMode = crate::src::HTMLparser::xmlParserMode;
pub const XML_PARSE_READER: xmlParserMode = 5;
pub const XML_PARSE_PUSH_SAX: xmlParserMode = 4;
pub const XML_PARSE_PUSH_DOM: xmlParserMode = 3;
pub const XML_PARSE_SAX: xmlParserMode = 2;
pub const XML_PARSE_DOM: xmlParserMode = 1;
pub const XML_PARSE_UNKNOWN: xmlParserMode = 0;
pub type xmlError = crate::src::HTMLparser::xmlError;
// #[derive(Copy, Clone)]

pub type _xmlError = crate::src::HTMLparser::_xmlError;
pub type xmlErrorLevel = crate::src::HTMLparser::xmlErrorLevel;
pub const XML_ERR_FATAL: xmlErrorLevel = 3;
pub const XML_ERR_ERROR: xmlErrorLevel = 2;
pub const XML_ERR_WARNING: xmlErrorLevel = 1;
pub const XML_ERR_NONE: xmlErrorLevel = 0;
pub type xmlAttrPtr = crate::src::HTMLparser::xmlAttrPtr;
pub type xmlAttr = crate::src::HTMLparser::xmlAttr;
pub type xmlNodePtr = crate::src::HTMLparser::xmlNodePtr;
pub type xmlNode = crate::src::HTMLparser::xmlNode;
pub type xmlHashTablePtr = crate::src::HTMLparser::xmlHashTablePtr;
pub type xmlHashTable = crate::src::HTMLparser::xmlHashTable;
pub type xmlStartTag = crate::src::HTMLparser::xmlStartTag;
pub type xmlDictPtr = crate::src::HTMLparser::xmlDictPtr;
pub type xmlDict = crate::src::HTMLparser::xmlDict;
pub type xmlParserInputState = crate::src::HTMLparser::xmlParserInputState;
pub const XML_PARSER_PUBLIC_LITERAL: xmlParserInputState = 16;
pub const XML_PARSER_IGNORE: xmlParserInputState = 15;
pub const XML_PARSER_EPILOG: xmlParserInputState = 14;
pub const XML_PARSER_SYSTEM_LITERAL: xmlParserInputState = 13;
pub const XML_PARSER_ATTRIBUTE_VALUE: xmlParserInputState = 12;
pub const XML_PARSER_ENTITY_VALUE: xmlParserInputState = 11;
pub const XML_PARSER_ENTITY_DECL: xmlParserInputState = 10;
pub const XML_PARSER_END_TAG: xmlParserInputState = 9;
pub const XML_PARSER_CDATA_SECTION: xmlParserInputState = 8;
pub const XML_PARSER_CONTENT: xmlParserInputState = 7;
pub const XML_PARSER_START_TAG: xmlParserInputState = 6;
pub const XML_PARSER_COMMENT: xmlParserInputState = 5;
pub const XML_PARSER_PROLOG: xmlParserInputState = 4;
pub const XML_PARSER_DTD: xmlParserInputState = 3;
pub const XML_PARSER_PI: xmlParserInputState = 2;
pub const XML_PARSER_MISC: xmlParserInputState = 1;
pub const XML_PARSER_START: xmlParserInputState = 0;
pub const XML_PARSER_EOF: xmlParserInputState = -1;
pub type xmlValidCtxt = crate::src::HTMLparser::xmlValidCtxt;
// #[derive(Copy, Clone)]

pub type _xmlValidCtxt = crate::src::HTMLparser::_xmlValidCtxt;
pub type xmlAutomataStatePtr = crate::src::HTMLparser::xmlAutomataStatePtr;
pub type xmlAutomataState = crate::src::HTMLparser::xmlAutomataState;
pub type xmlAutomataPtr = crate::src::HTMLparser::xmlAutomataPtr;
pub type xmlAutomata = crate::src::HTMLparser::xmlAutomata;
pub type xmlValidState = crate::src::HTMLparser::xmlValidState;
pub type xmlDocPtr = crate::src::HTMLparser::xmlDocPtr;
pub type xmlDoc = crate::src::HTMLparser::xmlDoc;
pub type xmlValidityWarningFunc = crate::src::HTMLparser::xmlValidityWarningFunc;
pub type xmlValidityErrorFunc = crate::src::HTMLparser::xmlValidityErrorFunc;
pub type xmlParserNodeInfoSeq = crate::src::HTMLparser::xmlParserNodeInfoSeq;
// #[derive(Copy, Clone)]

pub type _xmlParserNodeInfoSeq = crate::src::HTMLparser::_xmlParserNodeInfoSeq;
// #[derive(Copy, Clone)]

pub type _xmlSAXHandler = crate::src::HTMLparser::_xmlSAXHandler;
pub type xmlStructuredErrorFunc = crate::src::HTMLparser::xmlStructuredErrorFunc;
pub type xmlErrorPtr = crate::src::HTMLparser::xmlErrorPtr;
pub type endElementNsSAX2Func = crate::src::HTMLparser::endElementNsSAX2Func;
pub type startElementNsSAX2Func = crate::src::HTMLparser::startElementNsSAX2Func;
pub type externalSubsetSAXFunc = crate::src::HTMLparser::externalSubsetSAXFunc;
pub type cdataBlockSAXFunc = crate::src::HTMLparser::cdataBlockSAXFunc;
pub type getParameterEntitySAXFunc = crate::src::HTMLparser::getParameterEntitySAXFunc;
pub type xmlEntityPtr = crate::src::HTMLparser::xmlEntityPtr;
pub type xmlEntity = crate::src::HTMLparser::xmlEntity;
// #[derive(Copy, Clone)]

pub type _xmlEntity = crate::src::HTMLparser::_xmlEntity;
pub type xmlEntityType = crate::src::HTMLparser::xmlEntityType;
pub const XML_INTERNAL_PREDEFINED_ENTITY: xmlEntityType = 6;
pub const XML_EXTERNAL_PARAMETER_ENTITY: xmlEntityType = 5;
pub const XML_INTERNAL_PARAMETER_ENTITY: xmlEntityType = 4;
pub const XML_EXTERNAL_GENERAL_UNPARSED_ENTITY: xmlEntityType = 3;
pub const XML_EXTERNAL_GENERAL_PARSED_ENTITY: xmlEntityType = 2;
pub const XML_INTERNAL_GENERAL_ENTITY: xmlEntityType = 1;
pub type fatalErrorSAXFunc = crate::src::HTMLparser::fatalErrorSAXFunc;
pub type errorSAXFunc = crate::src::HTMLparser::errorSAXFunc;
pub type warningSAXFunc = crate::src::HTMLparser::warningSAXFunc;
pub type commentSAXFunc = crate::src::HTMLparser::commentSAXFunc;
pub type processingInstructionSAXFunc = crate::src::HTMLparser::processingInstructionSAXFunc;
pub type ignorableWhitespaceSAXFunc = crate::src::HTMLparser::ignorableWhitespaceSAXFunc;
pub type charactersSAXFunc = crate::src::HTMLparser::charactersSAXFunc;
pub type referenceSAXFunc = crate::src::HTMLparser::referenceSAXFunc;
pub type endElementSAXFunc = crate::src::HTMLparser::endElementSAXFunc;
pub type startElementSAXFunc = crate::src::HTMLparser::startElementSAXFunc;
pub type endDocumentSAXFunc = crate::src::HTMLparser::endDocumentSAXFunc;
pub type startDocumentSAXFunc = crate::src::HTMLparser::startDocumentSAXFunc;
pub type setDocumentLocatorSAXFunc = crate::src::HTMLparser::setDocumentLocatorSAXFunc;
pub type xmlSAXLocatorPtr = crate::src::HTMLparser::xmlSAXLocatorPtr;
pub type xmlSAXLocator = crate::src::HTMLparser::xmlSAXLocator;
// #[derive(Copy, Clone)]

pub type _xmlSAXLocator = crate::src::HTMLparser::_xmlSAXLocator;
pub type unparsedEntityDeclSAXFunc = crate::src::HTMLparser::unparsedEntityDeclSAXFunc;
pub type elementDeclSAXFunc = crate::src::HTMLparser::elementDeclSAXFunc;
pub type xmlElementContentPtr = crate::src::HTMLparser::xmlElementContentPtr;
pub type xmlElementContent = crate::src::HTMLparser::xmlElementContent;
// #[derive(Copy, Clone)]

pub type _xmlElementContent = crate::src::HTMLparser::_xmlElementContent;
pub type xmlElementContentOccur = crate::src::HTMLparser::xmlElementContentOccur;
pub const XML_ELEMENT_CONTENT_PLUS: xmlElementContentOccur = 4;
pub const XML_ELEMENT_CONTENT_MULT: xmlElementContentOccur = 3;
pub const XML_ELEMENT_CONTENT_OPT: xmlElementContentOccur = 2;
pub const XML_ELEMENT_CONTENT_ONCE: xmlElementContentOccur = 1;
pub type xmlElementContentType = crate::src::HTMLparser::xmlElementContentType;
pub const XML_ELEMENT_CONTENT_OR: xmlElementContentType = 4;
pub const XML_ELEMENT_CONTENT_SEQ: xmlElementContentType = 3;
pub const XML_ELEMENT_CONTENT_ELEMENT: xmlElementContentType = 2;
pub const XML_ELEMENT_CONTENT_PCDATA: xmlElementContentType = 1;
pub type attributeDeclSAXFunc = crate::src::HTMLparser::attributeDeclSAXFunc;
pub type xmlEnumerationPtr = crate::src::HTMLparser::xmlEnumerationPtr;
pub type xmlEnumeration = crate::src::HTMLparser::xmlEnumeration;
// #[derive(Copy, Clone)]

pub type _xmlEnumeration = crate::src::HTMLparser::_xmlEnumeration;
pub type notationDeclSAXFunc = crate::src::HTMLparser::notationDeclSAXFunc;
pub type entityDeclSAXFunc = crate::src::HTMLparser::entityDeclSAXFunc;
pub type getEntitySAXFunc = crate::src::HTMLparser::getEntitySAXFunc;
pub type resolveEntitySAXFunc = crate::src::HTMLparser::resolveEntitySAXFunc;
pub type hasExternalSubsetSAXFunc = crate::src::HTMLparser::hasExternalSubsetSAXFunc;
pub type hasInternalSubsetSAXFunc = crate::src::HTMLparser::hasInternalSubsetSAXFunc;
pub type isStandaloneSAXFunc = crate::src::HTMLparser::isStandaloneSAXFunc;
pub type internalSubsetSAXFunc = crate::src::HTMLparser::internalSubsetSAXFunc;
pub type xmlParserCtxt = crate::src::HTMLparser::xmlParserCtxt;
pub type xmlParserCtxtPtr = crate::src::HTMLparser::xmlParserCtxtPtr;
pub type xmlSAXHandler = crate::src::HTMLparser::xmlSAXHandler;
pub type xmlSAXHandlerPtr = crate::src::HTMLparser::xmlSAXHandlerPtr;
pub type xmlRegexp = crate::src::SAX2::xmlRegexp;
pub type xmlRegexpPtr = crate::src::SAX2::xmlRegexpPtr;
pub type xmlRegExecCtxt = crate::src::relaxng::xmlRegExecCtxt;
pub type xmlRegExecCtxtPtr = crate::src::relaxng::xmlRegExecCtxtPtr;
pub type xmlRegExecCallbacks = crate::src::relaxng::xmlRegExecCallbacks;
pub type xmlNsPtr = crate::src::HTMLtree::xmlNsPtr;
// #[derive(Copy, Clone)]

pub type _xmlID = crate::src::SAX2::_xmlID;
pub type xmlID = crate::src::SAX2::xmlID;
pub type xmlIDPtr = crate::src::SAX2::xmlIDPtr;
pub type xmlHashDeallocator = crate::src::HTMLparser::xmlHashDeallocator;
pub type xmlHashScanner = crate::src::catalog::xmlHashScanner;
pub type xmlHashScannerFull = crate::src::hash::xmlHashScannerFull;
pub type C2RustUnnamed = u32;
pub const XML_FROM_URI: C2RustUnnamed = 30;
pub const XML_FROM_BUFFER: C2RustUnnamed = 29;
pub const XML_FROM_SCHEMATRONV: C2RustUnnamed = 28;
pub const XML_FROM_I18N: C2RustUnnamed = 27;
pub const XML_FROM_MODULE: C2RustUnnamed = 26;
pub const XML_FROM_WRITER: C2RustUnnamed = 25;
pub const XML_FROM_CHECK: C2RustUnnamed = 24;
pub const XML_FROM_VALID: C2RustUnnamed = 23;
pub const XML_FROM_XSLT: C2RustUnnamed = 22;
pub const XML_FROM_C14N: C2RustUnnamed = 21;
pub const XML_FROM_CATALOG: C2RustUnnamed = 20;
pub const XML_FROM_RELAXNGV: C2RustUnnamed = 19;
pub const XML_FROM_RELAXNGP: C2RustUnnamed = 18;
pub const XML_FROM_SCHEMASV: C2RustUnnamed = 17;
pub const XML_FROM_SCHEMASP: C2RustUnnamed = 16;
pub const XML_FROM_DATATYPE: C2RustUnnamed = 15;
pub const XML_FROM_REGEXP: C2RustUnnamed = 14;
pub const XML_FROM_XPOINTER: C2RustUnnamed = 13;
pub const XML_FROM_XPATH: C2RustUnnamed = 12;
pub const XML_FROM_XINCLUDE: C2RustUnnamed = 11;
pub const XML_FROM_HTTP: C2RustUnnamed = 10;
pub const XML_FROM_FTP: C2RustUnnamed = 9;
pub const XML_FROM_IO: C2RustUnnamed = 8;
pub const XML_FROM_OUTPUT: C2RustUnnamed = 7;
pub const XML_FROM_MEMORY: C2RustUnnamed = 6;
pub const XML_FROM_HTML: C2RustUnnamed = 5;
pub const XML_FROM_DTD: C2RustUnnamed = 4;
pub const XML_FROM_NAMESPACE: C2RustUnnamed = 3;
pub const XML_FROM_TREE: C2RustUnnamed = 2;
pub const XML_FROM_PARSER: C2RustUnnamed = 1;
pub const XML_FROM_NONE: C2RustUnnamed = 0;
pub type xmlParserErrors = crate::src::HTMLparser::xmlParserErrors;
pub const XML_BUF_OVERFLOW: xmlParserErrors = 7000;
pub const XML_I18N_NO_OUTPUT: xmlParserErrors = 6004;
pub const XML_I18N_CONV_FAILED: xmlParserErrors = 6003;
pub const XML_I18N_EXCESS_HANDLER: xmlParserErrors = 6002;
pub const XML_I18N_NO_HANDLER: xmlParserErrors = 6001;
pub const XML_I18N_NO_NAME: xmlParserErrors = 6000;
pub const XML_CHECK_NAME_NOT_NULL: xmlParserErrors = 5037;
pub const XML_CHECK_WRONG_NAME: xmlParserErrors = 5036;
pub const XML_CHECK_OUTSIDE_DICT: xmlParserErrors = 5035;
pub const XML_CHECK_NOT_NCNAME: xmlParserErrors = 5034;
pub const XML_CHECK_NO_DICT: xmlParserErrors = 5033;
pub const XML_CHECK_NOT_UTF8: xmlParserErrors = 5032;
pub const XML_CHECK_NS_ANCESTOR: xmlParserErrors = 5031;
pub const XML_CHECK_NS_SCOPE: xmlParserErrors = 5030;
pub const XML_CHECK_WRONG_PARENT: xmlParserErrors = 5029;
pub const XML_CHECK_NO_HREF: xmlParserErrors = 5028;
pub const XML_CHECK_NOT_NS_DECL: xmlParserErrors = 5027;
pub const XML_CHECK_NOT_ENTITY_DECL: xmlParserErrors = 5026;
pub const XML_CHECK_NOT_ELEM_DECL: xmlParserErrors = 5025;
pub const XML_CHECK_NOT_ATTR_DECL: xmlParserErrors = 5024;
pub const XML_CHECK_NOT_ATTR: xmlParserErrors = 5023;
pub const XML_CHECK_NOT_DTD: xmlParserErrors = 5022;
pub const XML_CHECK_WRONG_NEXT: xmlParserErrors = 5021;
pub const XML_CHECK_NO_NEXT: xmlParserErrors = 5020;
pub const XML_CHECK_WRONG_PREV: xmlParserErrors = 5019;
pub const XML_CHECK_NO_PREV: xmlParserErrors = 5018;
pub const XML_CHECK_WRONG_DOC: xmlParserErrors = 5017;
pub const XML_CHECK_NO_ELEM: xmlParserErrors = 5016;
pub const XML_CHECK_NO_NAME: xmlParserErrors = 5015;
pub const XML_CHECK_NO_DOC: xmlParserErrors = 5014;
pub const XML_CHECK_NO_PARENT: xmlParserErrors = 5013;
pub const XML_CHECK_ENTITY_TYPE: xmlParserErrors = 5012;
pub const XML_CHECK_UNKNOWN_NODE: xmlParserErrors = 5011;
pub const XML_CHECK_FOUND_NOTATION: xmlParserErrors = 5010;
pub const XML_CHECK_FOUND_FRAGMENT: xmlParserErrors = 5009;
pub const XML_CHECK_FOUND_DOCTYPE: xmlParserErrors = 5008;
pub const XML_CHECK_FOUND_COMMENT: xmlParserErrors = 5007;
pub const XML_CHECK_FOUND_PI: xmlParserErrors = 5006;
pub const XML_CHECK_FOUND_ENTITY: xmlParserErrors = 5005;
pub const XML_CHECK_FOUND_ENTITYREF: xmlParserErrors = 5004;
pub const XML_CHECK_FOUND_CDATA: xmlParserErrors = 5003;
pub const XML_CHECK_FOUND_TEXT: xmlParserErrors = 5002;
pub const XML_CHECK_FOUND_ATTRIBUTE: xmlParserErrors = 5001;
pub const XML_CHECK_FOUND_ELEMENT: xmlParserErrors = 5000;
pub const XML_MODULE_CLOSE: xmlParserErrors = 4901;
pub const XML_MODULE_OPEN: xmlParserErrors = 4900;
pub const XML_SCHEMATRONV_REPORT: xmlParserErrors = 4001;
pub const XML_SCHEMATRONV_ASSERT: xmlParserErrors = 4000;
pub const XML_SCHEMAP_COS_ALL_LIMITED: xmlParserErrors = 3091;
pub const XML_SCHEMAP_A_PROPS_CORRECT_3: xmlParserErrors = 3090;
pub const XML_SCHEMAP_AU_PROPS_CORRECT: xmlParserErrors = 3089;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_2: xmlParserErrors = 3088;
pub const XML_SCHEMAP_AG_PROPS_CORRECT: xmlParserErrors = 3087;
pub const XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH: xmlParserErrors = 3086;
pub const XML_SCHEMAP_WARN_ATTR_REDECL_PROH: xmlParserErrors = 3085;
pub const XML_SCHEMAP_WARN_UNLOCATED_SCHEMA: xmlParserErrors = 3084;
pub const XML_SCHEMAP_WARN_SKIP_SCHEMA: xmlParserErrors = 3083;
pub const XML_SCHEMAP_SRC_IMPORT: xmlParserErrors = 3082;
pub const XML_SCHEMAP_SRC_REDEFINE: xmlParserErrors = 3081;
pub const XML_SCHEMAP_C_PROPS_CORRECT: xmlParserErrors = 3080;
pub const XML_SCHEMAP_A_PROPS_CORRECT_2: xmlParserErrors = 3079;
pub const XML_SCHEMAP_AU_PROPS_CORRECT_2: xmlParserErrors = 3078;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3: xmlParserErrors = 3077;
pub const XML_SCHEMAP_SRC_CT_1: xmlParserErrors = 3076;
pub const XML_SCHEMAP_MG_PROPS_CORRECT_2: xmlParserErrors = 3075;
pub const XML_SCHEMAP_MG_PROPS_CORRECT_1: xmlParserErrors = 3074;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3: xmlParserErrors = 3073;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2: xmlParserErrors = 3072;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1: xmlParserErrors = 3071;
pub const XML_SCHEMAP_NOT_DETERMINISTIC: xmlParserErrors = 3070;
pub const XML_SCHEMAP_INTERNAL: xmlParserErrors = 3069;
pub const XML_SCHEMAP_SRC_IMPORT_2_2: xmlParserErrors = 3068;
pub const XML_SCHEMAP_SRC_IMPORT_2_1: xmlParserErrors = 3067;
pub const XML_SCHEMAP_SRC_IMPORT_2: xmlParserErrors = 3066;
pub const XML_SCHEMAP_SRC_IMPORT_1_2: xmlParserErrors = 3065;
pub const XML_SCHEMAP_SRC_IMPORT_1_1: xmlParserErrors = 3064;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_1: xmlParserErrors = 3063;
pub const XML_SCHEMAP_CVC_SIMPLE_TYPE: xmlParserErrors = 3062;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2: xmlParserErrors = 3061;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1: xmlParserErrors = 3060;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_1: xmlParserErrors = 3059;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_1: xmlParserErrors = 3058;
pub const XML_SCHEMAP_NO_XSI: xmlParserErrors = 3057;
pub const XML_SCHEMAP_NO_XMLNS: xmlParserErrors = 3056;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_4: xmlParserErrors = 3055;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_3_2: xmlParserErrors = 3054;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_3_1: xmlParserErrors = 3053;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_2: xmlParserErrors = 3052;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_1: xmlParserErrors = 3051;
pub const XML_SCHEMAP_SRC_INCLUDE: xmlParserErrors = 3050;
pub const XML_SCHEMAP_E_PROPS_CORRECT_6: xmlParserErrors = 3049;
pub const XML_SCHEMAP_E_PROPS_CORRECT_5: xmlParserErrors = 3048;
pub const XML_SCHEMAP_E_PROPS_CORRECT_4: xmlParserErrors = 3047;
pub const XML_SCHEMAP_E_PROPS_CORRECT_3: xmlParserErrors = 3046;
pub const XML_SCHEMAP_E_PROPS_CORRECT_2: xmlParserErrors = 3045;
pub const XML_SCHEMAP_P_PROPS_CORRECT_2_2: xmlParserErrors = 3044;
pub const XML_SCHEMAP_P_PROPS_CORRECT_2_1: xmlParserErrors = 3043;
pub const XML_SCHEMAP_P_PROPS_CORRECT_1: xmlParserErrors = 3042;
pub const XML_SCHEMAP_SRC_ELEMENT_3: xmlParserErrors = 3041;
pub const XML_SCHEMAP_SRC_ELEMENT_2_2: xmlParserErrors = 3040;
pub const XML_SCHEMAP_SRC_ELEMENT_2_1: xmlParserErrors = 3039;
pub const XML_SCHEMAP_SRC_ELEMENT_1: xmlParserErrors = 3038;
pub const XML_SCHEMAP_S4S_ATTR_INVALID_VALUE: xmlParserErrors = 3037;
pub const XML_SCHEMAP_S4S_ATTR_MISSING: xmlParserErrors = 3036;
pub const XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED: xmlParserErrors = 3035;
pub const XML_SCHEMAP_S4S_ELEM_MISSING: xmlParserErrors = 3034;
pub const XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED: xmlParserErrors = 3033;
pub const XML_SCHEMAP_COS_ST_DERIVED_OK_2_2: xmlParserErrors = 3032;
pub const XML_SCHEMAP_COS_ST_DERIVED_OK_2_1: xmlParserErrors = 3031;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5: xmlParserErrors = 3030;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4: xmlParserErrors = 3029;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3: xmlParserErrors = 3028;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1: xmlParserErrors = 3027;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2: xmlParserErrors = 3026;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2: xmlParserErrors = 3025;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1: xmlParserErrors = 3024;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_1: xmlParserErrors = 3023;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5: xmlParserErrors = 3022;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4: xmlParserErrors = 3021;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3: xmlParserErrors = 3020;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2: xmlParserErrors = 3019;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1: xmlParserErrors = 3018;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2: xmlParserErrors = 3017;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1: xmlParserErrors = 3016;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_1: xmlParserErrors = 3015;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2: xmlParserErrors = 3014;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1: xmlParserErrors = 3013;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_2: xmlParserErrors = 3012;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_1: xmlParserErrors = 3011;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_3: xmlParserErrors = 3010;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_2: xmlParserErrors = 3009;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_1: xmlParserErrors = 3008;
pub const XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES: xmlParserErrors = 3007;
pub const XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE: xmlParserErrors = 3006;
pub const XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE: xmlParserErrors = 3005;
pub const XML_SCHEMAP_SRC_RESOLVE: xmlParserErrors = 3004;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_4: xmlParserErrors = 3003;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_3: xmlParserErrors = 3002;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_2: xmlParserErrors = 3001;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_1: xmlParserErrors = 3000;
pub const XML_HTTP_UNKNOWN_HOST: xmlParserErrors = 2022;
pub const XML_HTTP_USE_IP: xmlParserErrors = 2021;
pub const XML_HTTP_URL_SYNTAX: xmlParserErrors = 2020;
pub const XML_FTP_URL_SYNTAX: xmlParserErrors = 2003;
pub const XML_FTP_ACCNT: xmlParserErrors = 2002;
pub const XML_FTP_EPSV_ANSWER: xmlParserErrors = 2001;
pub const XML_FTP_PASV_ANSWER: xmlParserErrors = 2000;
pub const XML_C14N_RELATIVE_NAMESPACE: xmlParserErrors = 1955;
pub const XML_C14N_UNKNOW_NODE: xmlParserErrors = 1954;
pub const XML_C14N_INVALID_NODE: xmlParserErrors = 1953;
pub const XML_C14N_CREATE_STACK: xmlParserErrors = 1952;
pub const XML_C14N_REQUIRES_UTF8: xmlParserErrors = 1951;
pub const XML_C14N_CREATE_CTXT: xmlParserErrors = 1950;
pub const XML_XPTR_EXTRA_OBJECTS: xmlParserErrors = 1903;
pub const XML_XPTR_EVAL_FAILED: xmlParserErrors = 1902;
pub const XML_XPTR_CHILDSEQ_START: xmlParserErrors = 1901;
pub const XML_XPTR_UNKNOWN_SCHEME: xmlParserErrors = 1900;
pub const XML_SCHEMAV_MISC: xmlParserErrors = 1879;
pub const XML_SCHEMAV_CVC_WILDCARD: xmlParserErrors = 1878;
pub const XML_SCHEMAV_CVC_IDC: xmlParserErrors = 1877;
pub const XML_SCHEMAV_CVC_TYPE_2: xmlParserErrors = 1876;
pub const XML_SCHEMAV_CVC_TYPE_1: xmlParserErrors = 1875;
pub const XML_SCHEMAV_CVC_AU: xmlParserErrors = 1874;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_1: xmlParserErrors = 1873;
pub const XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING: xmlParserErrors = 1872;
pub const XML_SCHEMAV_ELEMENT_CONTENT: xmlParserErrors = 1871;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2: xmlParserErrors = 1870;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1: xmlParserErrors = 1869;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_4: xmlParserErrors = 1868;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2: xmlParserErrors = 1867;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1: xmlParserErrors = 1866;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1: xmlParserErrors = 1865;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_4: xmlParserErrors = 1864;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_3: xmlParserErrors = 1863;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_2: xmlParserErrors = 1862;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_1: xmlParserErrors = 1861;
pub const XML_SCHEMAV_CVC_ELT_7: xmlParserErrors = 1860;
pub const XML_SCHEMAV_CVC_ELT_6: xmlParserErrors = 1859;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_2_2: xmlParserErrors = 1858;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_2_1: xmlParserErrors = 1857;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_1: xmlParserErrors = 1856;
pub const XML_SCHEMAV_CVC_ELT_5_2_1: xmlParserErrors = 1855;
pub const XML_SCHEMAV_CVC_ELT_5_1_2: xmlParserErrors = 1854;
pub const XML_SCHEMAV_CVC_ELT_5_1_1: xmlParserErrors = 1853;
pub const XML_SCHEMAV_CVC_ELT_4_3: xmlParserErrors = 1852;
pub const XML_SCHEMAV_CVC_ELT_4_2: xmlParserErrors = 1851;
pub const XML_SCHEMAV_CVC_ELT_4_1: xmlParserErrors = 1850;
pub const XML_SCHEMAV_CVC_ELT_3_2_2: xmlParserErrors = 1849;
pub const XML_SCHEMAV_CVC_ELT_3_2_1: xmlParserErrors = 1848;
pub const XML_SCHEMAV_CVC_ELT_3_1: xmlParserErrors = 1847;
pub const XML_SCHEMAV_CVC_ELT_2: xmlParserErrors = 1846;
pub const XML_SCHEMAV_CVC_ELT_1: xmlParserErrors = 1845;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4: xmlParserErrors = 1844;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3: xmlParserErrors = 1843;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2: xmlParserErrors = 1842;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1: xmlParserErrors = 1841;
pub const XML_SCHEMAV_CVC_ENUMERATION_VALID: xmlParserErrors = 1840;
pub const XML_SCHEMAV_CVC_PATTERN_VALID: xmlParserErrors = 1839;
pub const XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID: xmlParserErrors = 1838;
pub const XML_SCHEMAV_CVC_TOTALDIGITS_VALID: xmlParserErrors = 1837;
pub const XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID: xmlParserErrors = 1836;
pub const XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID: xmlParserErrors = 1835;
pub const XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID: xmlParserErrors = 1834;
pub const XML_SCHEMAV_CVC_MININCLUSIVE_VALID: xmlParserErrors = 1833;
pub const XML_SCHEMAV_CVC_MAXLENGTH_VALID: xmlParserErrors = 1832;
pub const XML_SCHEMAV_CVC_MINLENGTH_VALID: xmlParserErrors = 1831;
pub const XML_SCHEMAV_CVC_LENGTH_VALID: xmlParserErrors = 1830;
pub const XML_SCHEMAV_CVC_FACET_VALID: xmlParserErrors = 1829;
pub const XML_SCHEMAV_CVC_TYPE_3_1_2: xmlParserErrors = 1828;
pub const XML_SCHEMAV_CVC_TYPE_3_1_1: xmlParserErrors = 1827;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3: xmlParserErrors = 1826;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2: xmlParserErrors = 1825;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1: xmlParserErrors = 1824;
pub const XML_SCHEMAV_FACET: xmlParserErrors = 1823;
pub const XML_SCHEMAV_VALUE: xmlParserErrors = 1822;
pub const XML_SCHEMAV_ATTRINVALID: xmlParserErrors = 1821;
pub const XML_SCHEMAV_ATTRUNKNOWN: xmlParserErrors = 1820;
pub const XML_SCHEMAV_NOTSIMPLE: xmlParserErrors = 1819;
pub const XML_SCHEMAV_INTERNAL: xmlParserErrors = 1818;
pub const XML_SCHEMAV_CONSTRUCT: xmlParserErrors = 1817;
pub const XML_SCHEMAV_NOTDETERMINIST: xmlParserErrors = 1816;
pub const XML_SCHEMAV_INVALIDELEM: xmlParserErrors = 1815;
pub const XML_SCHEMAV_INVALIDATTR: xmlParserErrors = 1814;
pub const XML_SCHEMAV_EXTRACONTENT: xmlParserErrors = 1813;
pub const XML_SCHEMAV_NOTNILLABLE: xmlParserErrors = 1812;
pub const XML_SCHEMAV_HAVEDEFAULT: xmlParserErrors = 1811;
pub const XML_SCHEMAV_ELEMCONT: xmlParserErrors = 1810;
pub const XML_SCHEMAV_NOTEMPTY: xmlParserErrors = 1809;
pub const XML_SCHEMAV_ISABSTRACT: xmlParserErrors = 1808;
pub const XML_SCHEMAV_NOROLLBACK: xmlParserErrors = 1807;
pub const XML_SCHEMAV_NOTYPE: xmlParserErrors = 1806;
pub const XML_SCHEMAV_WRONGELEM: xmlParserErrors = 1805;
pub const XML_SCHEMAV_MISSING: xmlParserErrors = 1804;
pub const XML_SCHEMAV_NOTTOPLEVEL: xmlParserErrors = 1803;
pub const XML_SCHEMAV_UNDECLAREDELEM: xmlParserErrors = 1802;
pub const XML_SCHEMAV_NOROOT: xmlParserErrors = 1801;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_3: xmlParserErrors = 1800;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3: xmlParserErrors = 1799;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2: xmlParserErrors = 1798;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1: xmlParserErrors = 1797;
pub const XML_SCHEMAP_SRC_IMPORT_3_2: xmlParserErrors = 1796;
pub const XML_SCHEMAP_SRC_IMPORT_3_1: xmlParserErrors = 1795;
pub const XML_SCHEMAP_UNION_NOT_EXPRESSIBLE: xmlParserErrors = 1794;
pub const XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE: xmlParserErrors = 1793;
pub const XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER: xmlParserErrors = 1792;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3: xmlParserErrors = 1791;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2: xmlParserErrors = 1790;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2: xmlParserErrors = 1789;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1: xmlParserErrors = 1788;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1: xmlParserErrors = 1787;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_5: xmlParserErrors = 1786;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_4: xmlParserErrors = 1785;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_3: xmlParserErrors = 1784;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_2: xmlParserErrors = 1783;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_1: xmlParserErrors = 1782;
pub const XML_SCHEMAP_REF_AND_CONTENT: xmlParserErrors = 1781;
pub const XML_SCHEMAP_INVALID_ATTR_NAME: xmlParserErrors = 1780;
pub const XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD: xmlParserErrors = 1779;
pub const XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION: xmlParserErrors = 1778;
pub const XML_SCHEMAP_INVALID_ATTR_COMBINATION: xmlParserErrors = 1777;
pub const XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE: xmlParserErrors = 1776;
pub const XML_SCHEMAP_RECURSIVE: xmlParserErrors = 1775;
pub const XML_SCHEMAP_INVALID_ATTR_USE: xmlParserErrors = 1774;
pub const XML_SCHEMAP_UNKNOWN_MEMBER_TYPE: xmlParserErrors = 1773;
pub const XML_SCHEMAP_NOT_SCHEMA: xmlParserErrors = 1772;
pub const XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI: xmlParserErrors = 1771;
pub const XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI: xmlParserErrors = 1770;
pub const XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD: xmlParserErrors = 1769;
pub const XML_SCHEMAP_DEF_AND_PREFIX: xmlParserErrors = 1768;
pub const XML_SCHEMAP_UNKNOWN_PREFIX: xmlParserErrors = 1767;
pub const XML_SCHEMAP_FAILED_PARSE: xmlParserErrors = 1766;
pub const XML_SCHEMAP_REDEFINED_NOTATION: xmlParserErrors = 1765;
pub const XML_SCHEMAP_REDEFINED_ATTR: xmlParserErrors = 1764;
pub const XML_SCHEMAP_REDEFINED_ATTRGROUP: xmlParserErrors = 1763;
pub const XML_SCHEMAP_REDEFINED_ELEMENT: xmlParserErrors = 1762;
pub const XML_SCHEMAP_REDEFINED_TYPE: xmlParserErrors = 1761;
pub const XML_SCHEMAP_REDEFINED_GROUP: xmlParserErrors = 1760;
pub const XML_SCHEMAP_NOROOT: xmlParserErrors = 1759;
pub const XML_SCHEMAP_NOTHING_TO_PARSE: xmlParserErrors = 1758;
pub const XML_SCHEMAP_FAILED_LOAD: xmlParserErrors = 1757;
pub const XML_SCHEMAP_REGEXP_INVALID: xmlParserErrors = 1756;
pub const XML_SCHEMAP_ELEM_DEFAULT_FIXED: xmlParserErrors = 1755;
pub const XML_SCHEMAP_UNKNOWN_UNION_CHILD: xmlParserErrors = 1754;
pub const XML_SCHEMAP_UNKNOWN_TYPE: xmlParserErrors = 1753;
pub const XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD: xmlParserErrors = 1752;
pub const XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD: xmlParserErrors = 1751;
pub const XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD: xmlParserErrors = 1750;
pub const XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD: xmlParserErrors = 1749;
pub const XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD: xmlParserErrors = 1748;
pub const XML_SCHEMAP_UNKNOWN_REF: xmlParserErrors = 1747;
pub const XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD: xmlParserErrors = 1746;
pub const XML_SCHEMAP_UNKNOWN_NOTATION_CHILD: xmlParserErrors = 1745;
pub const XML_SCHEMAP_UNKNOWN_LIST_CHILD: xmlParserErrors = 1744;
pub const XML_SCHEMAP_UNKNOWN_IMPORT_CHILD: xmlParserErrors = 1743;
pub const XML_SCHEMAP_UNKNOWN_GROUP_CHILD: xmlParserErrors = 1742;
pub const XML_SCHEMAP_UNKNOWN_FACET_TYPE: xmlParserErrors = 1741;
pub const XML_SCHEMAP_UNKNOWN_FACET_CHILD: xmlParserErrors = 1740;
pub const XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD: xmlParserErrors = 1739;
pub const XML_SCHEMAP_UNKNOWN_ELEM_CHILD: xmlParserErrors = 1738;
pub const XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD: xmlParserErrors = 1737;
pub const XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD: xmlParserErrors = 1736;
pub const XML_SCHEMAP_UNKNOWN_CHOICE_CHILD: xmlParserErrors = 1735;
pub const XML_SCHEMAP_UNKNOWN_BASE_TYPE: xmlParserErrors = 1734;
pub const XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP: xmlParserErrors = 1733;
pub const XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD: xmlParserErrors = 1732;
pub const XML_SCHEMAP_UNKNOWN_ATTR_CHILD: xmlParserErrors = 1731;
pub const XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD: xmlParserErrors = 1730;
pub const XML_SCHEMAP_UNKNOWN_ALL_CHILD: xmlParserErrors = 1729;
pub const XML_SCHEMAP_TYPE_AND_SUBTYPE: xmlParserErrors = 1728;
pub const XML_SCHEMAP_SIMPLETYPE_NONAME: xmlParserErrors = 1727;
pub const XML_SCHEMAP_RESTRICTION_NONAME_NOREF: xmlParserErrors = 1726;
pub const XML_SCHEMAP_REF_AND_SUBTYPE: xmlParserErrors = 1725;
pub const XML_SCHEMAP_NOTYPE_NOREF: xmlParserErrors = 1724;
pub const XML_SCHEMAP_NOTATION_NO_NAME: xmlParserErrors = 1723;
pub const XML_SCHEMAP_NOATTR_NOREF: xmlParserErrors = 1722;
pub const XML_SCHEMAP_INVALID_WHITE_SPACE: xmlParserErrors = 1721;
pub const XML_SCHEMAP_INVALID_REF_AND_SUBTYPE: xmlParserErrors = 1720;
pub const XML_SCHEMAP_INVALID_MINOCCURS: xmlParserErrors = 1719;
pub const XML_SCHEMAP_INVALID_MAXOCCURS: xmlParserErrors = 1718;
pub const XML_SCHEMAP_INVALID_FACET_VALUE: xmlParserErrors = 1717;
pub const XML_SCHEMAP_INVALID_FACET: xmlParserErrors = 1716;
pub const XML_SCHEMAP_INVALID_ENUM: xmlParserErrors = 1715;
pub const XML_SCHEMAP_INVALID_BOOLEAN: xmlParserErrors = 1714;
pub const XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI: xmlParserErrors = 1713;
pub const XML_SCHEMAP_IMPORT_REDEFINE_NSNAME: xmlParserErrors = 1712;
pub const XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI: xmlParserErrors = 1711;
pub const XML_SCHEMAP_GROUP_NONAME_NOREF: xmlParserErrors = 1710;
pub const XML_SCHEMAP_FAILED_BUILD_IMPORT: xmlParserErrors = 1709;
pub const XML_SCHEMAP_FACET_NO_VALUE: xmlParserErrors = 1708;
pub const XML_SCHEMAP_EXTENSION_NO_BASE: xmlParserErrors = 1707;
pub const XML_SCHEMAP_ELEM_NONAME_NOREF: xmlParserErrors = 1706;
pub const XML_SCHEMAP_ELEMFORMDEFAULT_VALUE: xmlParserErrors = 1705;
pub const XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF: xmlParserErrors = 1704;
pub const XML_SCHEMAP_ATTR_NONAME_NOREF: xmlParserErrors = 1703;
pub const XML_SCHEMAP_ATTRGRP_NONAME_NOREF: xmlParserErrors = 1702;
pub const XML_SCHEMAP_ATTRFORMDEFAULT_VALUE: xmlParserErrors = 1701;
pub const XML_SCHEMAP_PREFIX_UNDEFINED: xmlParserErrors = 1700;
pub const XML_CATALOG_RECURSION: xmlParserErrors = 1654;
pub const XML_CATALOG_NOT_CATALOG: xmlParserErrors = 1653;
pub const XML_CATALOG_PREFER_VALUE: xmlParserErrors = 1652;
pub const XML_CATALOG_ENTRY_BROKEN: xmlParserErrors = 1651;
pub const XML_CATALOG_MISSING_ATTR: xmlParserErrors = 1650;
pub const XML_XINCLUDE_FRAGMENT_ID: xmlParserErrors = 1618;
pub const XML_XINCLUDE_DEPRECATED_NS: xmlParserErrors = 1617;
pub const XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE: xmlParserErrors = 1616;
pub const XML_XINCLUDE_FALLBACKS_IN_INCLUDE: xmlParserErrors = 1615;
pub const XML_XINCLUDE_INCLUDE_IN_INCLUDE: xmlParserErrors = 1614;
pub const XML_XINCLUDE_XPTR_RESULT: xmlParserErrors = 1613;
pub const XML_XINCLUDE_XPTR_FAILED: xmlParserErrors = 1612;
pub const XML_XINCLUDE_MULTIPLE_ROOT: xmlParserErrors = 1611;
pub const XML_XINCLUDE_UNKNOWN_ENCODING: xmlParserErrors = 1610;
pub const XML_XINCLUDE_BUILD_FAILED: xmlParserErrors = 1609;
pub const XML_XINCLUDE_INVALID_CHAR: xmlParserErrors = 1608;
pub const XML_XINCLUDE_TEXT_DOCUMENT: xmlParserErrors = 1607;
pub const XML_XINCLUDE_TEXT_FRAGMENT: xmlParserErrors = 1606;
pub const XML_XINCLUDE_HREF_URI: xmlParserErrors = 1605;
pub const XML_XINCLUDE_NO_FALLBACK: xmlParserErrors = 1604;
pub const XML_XINCLUDE_NO_HREF: xmlParserErrors = 1603;
pub const XML_XINCLUDE_ENTITY_DEF_MISMATCH: xmlParserErrors = 1602;
pub const XML_XINCLUDE_PARSE_VALUE: xmlParserErrors = 1601;
pub const XML_XINCLUDE_RECURSION: xmlParserErrors = 1600;
pub const XML_IO_EAFNOSUPPORT: xmlParserErrors = 1556;
pub const XML_IO_EALREADY: xmlParserErrors = 1555;
pub const XML_IO_EADDRINUSE: xmlParserErrors = 1554;
pub const XML_IO_ENETUNREACH: xmlParserErrors = 1553;
pub const XML_IO_ECONNREFUSED: xmlParserErrors = 1552;
pub const XML_IO_EISCONN: xmlParserErrors = 1551;
pub const XML_IO_ENOTSOCK: xmlParserErrors = 1550;
pub const XML_IO_LOAD_ERROR: xmlParserErrors = 1549;
pub const XML_IO_BUFFER_FULL: xmlParserErrors = 1548;
pub const XML_IO_NO_INPUT: xmlParserErrors = 1547;
pub const XML_IO_WRITE: xmlParserErrors = 1546;
pub const XML_IO_FLUSH: xmlParserErrors = 1545;
pub const XML_IO_ENCODER: xmlParserErrors = 1544;
pub const XML_IO_NETWORK_ATTEMPT: xmlParserErrors = 1543;
pub const XML_IO_EXDEV: xmlParserErrors = 1542;
pub const XML_IO_ETIMEDOUT: xmlParserErrors = 1541;
pub const XML_IO_ESRCH: xmlParserErrors = 1540;
pub const XML_IO_ESPIPE: xmlParserErrors = 1539;
pub const XML_IO_EROFS: xmlParserErrors = 1538;
pub const XML_IO_ERANGE: xmlParserErrors = 1537;
pub const XML_IO_EPIPE: xmlParserErrors = 1536;
pub const XML_IO_EPERM: xmlParserErrors = 1535;
pub const XML_IO_ENXIO: xmlParserErrors = 1534;
pub const XML_IO_ENOTTY: xmlParserErrors = 1533;
pub const XML_IO_ENOTSUP: xmlParserErrors = 1532;
pub const XML_IO_ENOTEMPTY: xmlParserErrors = 1531;
pub const XML_IO_ENOTDIR: xmlParserErrors = 1530;
pub const XML_IO_ENOSYS: xmlParserErrors = 1529;
pub const XML_IO_ENOSPC: xmlParserErrors = 1528;
pub const XML_IO_ENOMEM: xmlParserErrors = 1527;
pub const XML_IO_ENOLCK: xmlParserErrors = 1526;
pub const XML_IO_ENOEXEC: xmlParserErrors = 1525;
pub const XML_IO_ENOENT: xmlParserErrors = 1524;
pub const XML_IO_ENODEV: xmlParserErrors = 1523;
pub const XML_IO_ENFILE: xmlParserErrors = 1522;
pub const XML_IO_ENAMETOOLONG: xmlParserErrors = 1521;
pub const XML_IO_EMSGSIZE: xmlParserErrors = 1520;
pub const XML_IO_EMLINK: xmlParserErrors = 1519;
pub const XML_IO_EMFILE: xmlParserErrors = 1518;
pub const XML_IO_EISDIR: xmlParserErrors = 1517;
pub const XML_IO_EIO: xmlParserErrors = 1516;
pub const XML_IO_EINVAL: xmlParserErrors = 1515;
pub const XML_IO_EINTR: xmlParserErrors = 1514;
pub const XML_IO_EINPROGRESS: xmlParserErrors = 1513;
pub const XML_IO_EFBIG: xmlParserErrors = 1512;
pub const XML_IO_EFAULT: xmlParserErrors = 1511;
pub const XML_IO_EEXIST: xmlParserErrors = 1510;
pub const XML_IO_EDOM: xmlParserErrors = 1509;
pub const XML_IO_EDEADLK: xmlParserErrors = 1508;
pub const XML_IO_ECHILD: xmlParserErrors = 1507;
pub const XML_IO_ECANCELED: xmlParserErrors = 1506;
pub const XML_IO_EBUSY: xmlParserErrors = 1505;
pub const XML_IO_EBADMSG: xmlParserErrors = 1504;
pub const XML_IO_EBADF: xmlParserErrors = 1503;
pub const XML_IO_EAGAIN: xmlParserErrors = 1502;
pub const XML_IO_EACCES: xmlParserErrors = 1501;
pub const XML_IO_UNKNOWN: xmlParserErrors = 1500;
pub const XML_REGEXP_COMPILE_ERROR: xmlParserErrors = 1450;
pub const XML_SAVE_UNKNOWN_ENCODING: xmlParserErrors = 1403;
pub const XML_SAVE_NO_DOCTYPE: xmlParserErrors = 1402;
pub const XML_SAVE_CHAR_INVALID: xmlParserErrors = 1401;
pub const XML_SAVE_NOT_UTF8: xmlParserErrors = 1400;
pub const XML_TREE_NOT_UTF8: xmlParserErrors = 1303;
pub const XML_TREE_UNTERMINATED_ENTITY: xmlParserErrors = 1302;
pub const XML_TREE_INVALID_DEC: xmlParserErrors = 1301;
pub const XML_TREE_INVALID_HEX: xmlParserErrors = 1300;
pub const XML_XPATH_INVALID_CHAR_ERROR: xmlParserErrors = 1221;
pub const XML_XPATH_ENCODING_ERROR: xmlParserErrors = 1220;
pub const XML_XPATH_UNDEF_PREFIX_ERROR: xmlParserErrors = 1219;
pub const XML_XPTR_SUB_RESOURCE_ERROR: xmlParserErrors = 1218;
pub const XML_XPTR_RESOURCE_ERROR: xmlParserErrors = 1217;
pub const XML_XPTR_SYNTAX_ERROR: xmlParserErrors = 1216;
pub const XML_XPATH_MEMORY_ERROR: xmlParserErrors = 1215;
pub const XML_XPATH_INVALID_CTXT_POSITION: xmlParserErrors = 1214;
pub const XML_XPATH_INVALID_CTXT_SIZE: xmlParserErrors = 1213;
pub const XML_XPATH_INVALID_ARITY: xmlParserErrors = 1212;
pub const XML_XPATH_INVALID_TYPE: xmlParserErrors = 1211;
pub const XML_XPATH_INVALID_OPERAND: xmlParserErrors = 1210;
pub const XML_XPATH_UNKNOWN_FUNC_ERROR: xmlParserErrors = 1209;
pub const XML_XPATH_UNCLOSED_ERROR: xmlParserErrors = 1208;
pub const XML_XPATH_EXPR_ERROR: xmlParserErrors = 1207;
pub const XML_XPATH_INVALID_PREDICATE_ERROR: xmlParserErrors = 1206;
pub const XML_XPATH_UNDEF_VARIABLE_ERROR: xmlParserErrors = 1205;
pub const XML_XPATH_VARIABLE_REF_ERROR: xmlParserErrors = 1204;
pub const XML_XPATH_START_LITERAL_ERROR: xmlParserErrors = 1203;
pub const XML_XPATH_UNFINISHED_LITERAL_ERROR: xmlParserErrors = 1202;
pub const XML_XPATH_NUMBER_ERROR: xmlParserErrors = 1201;
pub const XML_XPATH_EXPRESSION_OK: xmlParserErrors = 1200;
pub const XML_RNGP_XML_NS: xmlParserErrors = 1122;
pub const XML_RNGP_XMLNS_NAME: xmlParserErrors = 1121;
pub const XML_RNGP_VALUE_NO_CONTENT: xmlParserErrors = 1120;
pub const XML_RNGP_VALUE_EMPTY: xmlParserErrors = 1119;
pub const XML_RNGP_URI_NOT_ABSOLUTE: xmlParserErrors = 1118;
pub const XML_RNGP_URI_FRAGMENT: xmlParserErrors = 1117;
pub const XML_RNGP_UNKNOWN_TYPE_LIB: xmlParserErrors = 1116;
pub const XML_RNGP_UNKNOWN_CONSTRUCT: xmlParserErrors = 1115;
pub const XML_RNGP_UNKNOWN_COMBINE: xmlParserErrors = 1114;
pub const XML_RNGP_UNKNOWN_ATTRIBUTE: xmlParserErrors = 1113;
pub const XML_RNGP_TYPE_VALUE: xmlParserErrors = 1112;
pub const XML_RNGP_TYPE_NOT_FOUND: xmlParserErrors = 1111;
pub const XML_RNGP_TYPE_MISSING: xmlParserErrors = 1110;
pub const XML_RNGP_TEXT_HAS_CHILD: xmlParserErrors = 1109;
pub const XML_RNGP_TEXT_EXPECTED: xmlParserErrors = 1108;
pub const XML_RNGP_START_MISSING: xmlParserErrors = 1107;
pub const XML_RNGP_START_EMPTY: xmlParserErrors = 1106;
pub const XML_RNGP_START_CONTENT: xmlParserErrors = 1105;
pub const XML_RNGP_START_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1104;
pub const XML_RNGP_REF_NOT_EMPTY: xmlParserErrors = 1103;
pub const XML_RNGP_REF_NO_NAME: xmlParserErrors = 1102;
pub const XML_RNGP_REF_NO_DEF: xmlParserErrors = 1101;
pub const XML_RNGP_REF_NAME_INVALID: xmlParserErrors = 1100;
pub const XML_RNGP_REF_CYCLE: xmlParserErrors = 1099;
pub const XML_RNGP_REF_CREATE_FAILED: xmlParserErrors = 1098;
pub const XML_RNGP_PREFIX_UNDEFINED: xmlParserErrors = 1097;
pub const XML_RNGP_PAT_START_VALUE: xmlParserErrors = 1096;
pub const XML_RNGP_PAT_START_TEXT: xmlParserErrors = 1095;
pub const XML_RNGP_PAT_START_ONEMORE: xmlParserErrors = 1094;
pub const XML_RNGP_PAT_START_LIST: xmlParserErrors = 1093;
pub const XML_RNGP_PAT_START_INTERLEAVE: xmlParserErrors = 1092;
pub const XML_RNGP_PAT_START_GROUP: xmlParserErrors = 1091;
pub const XML_RNGP_PAT_START_EMPTY: xmlParserErrors = 1090;
pub const XML_RNGP_PAT_START_DATA: xmlParserErrors = 1089;
pub const XML_RNGP_PAT_START_ATTR: xmlParserErrors = 1088;
pub const XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR: xmlParserErrors = 1087;
pub const XML_RNGP_PAT_ONEMORE_GROUP_ATTR: xmlParserErrors = 1086;
pub const XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME: xmlParserErrors = 1085;
pub const XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME: xmlParserErrors = 1084;
pub const XML_RNGP_PAT_LIST_TEXT: xmlParserErrors = 1083;
pub const XML_RNGP_PAT_LIST_REF: xmlParserErrors = 1082;
pub const XML_RNGP_PAT_LIST_LIST: xmlParserErrors = 1081;
pub const XML_RNGP_PAT_LIST_INTERLEAVE: xmlParserErrors = 1080;
pub const XML_RNGP_PAT_LIST_ELEM: xmlParserErrors = 1079;
pub const XML_RNGP_PAT_LIST_ATTR: xmlParserErrors = 1078;
pub const XML_RNGP_PAT_DATA_EXCEPT_TEXT: xmlParserErrors = 1077;
pub const XML_RNGP_PAT_DATA_EXCEPT_REF: xmlParserErrors = 1076;
pub const XML_RNGP_PAT_DATA_EXCEPT_ONEMORE: xmlParserErrors = 1075;
pub const XML_RNGP_PAT_DATA_EXCEPT_LIST: xmlParserErrors = 1074;
pub const XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE: xmlParserErrors = 1073;
pub const XML_RNGP_PAT_DATA_EXCEPT_GROUP: xmlParserErrors = 1072;
pub const XML_RNGP_PAT_DATA_EXCEPT_EMPTY: xmlParserErrors = 1071;
pub const XML_RNGP_PAT_DATA_EXCEPT_ELEM: xmlParserErrors = 1070;
pub const XML_RNGP_PAT_DATA_EXCEPT_ATTR: xmlParserErrors = 1069;
pub const XML_RNGP_PAT_ATTR_ELEM: xmlParserErrors = 1068;
pub const XML_RNGP_PAT_ATTR_ATTR: xmlParserErrors = 1067;
pub const XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME: xmlParserErrors = 1066;
pub const XML_RNGP_PARSE_ERROR: xmlParserErrors = 1065;
pub const XML_RNGP_PARENTREF_NOT_EMPTY: xmlParserErrors = 1064;
pub const XML_RNGP_PARENTREF_NO_PARENT: xmlParserErrors = 1063;
pub const XML_RNGP_PARENTREF_NO_NAME: xmlParserErrors = 1062;
pub const XML_RNGP_PARENTREF_NAME_INVALID: xmlParserErrors = 1061;
pub const XML_RNGP_PARENTREF_CREATE_FAILED: xmlParserErrors = 1060;
pub const XML_RNGP_PARAM_NAME_MISSING: xmlParserErrors = 1059;
pub const XML_RNGP_PARAM_FORBIDDEN: xmlParserErrors = 1058;
pub const XML_RNGP_NSNAME_NO_NS: xmlParserErrors = 1057;
pub const XML_RNGP_NSNAME_ATTR_ANCESTOR: xmlParserErrors = 1056;
pub const XML_RNGP_NOTALLOWED_NOT_EMPTY: xmlParserErrors = 1055;
pub const XML_RNGP_NEED_COMBINE: xmlParserErrors = 1054;
pub const XML_RNGP_NAME_MISSING: xmlParserErrors = 1053;
pub const XML_RNGP_MISSING_HREF: xmlParserErrors = 1052;
pub const XML_RNGP_INVALID_VALUE: xmlParserErrors = 1051;
pub const XML_RNGP_INVALID_URI: xmlParserErrors = 1050;
pub const XML_RNGP_INVALID_DEFINE_NAME: xmlParserErrors = 1049;
pub const XML_RNGP_INTERLEAVE_NO_CONTENT: xmlParserErrors = 1048;
pub const XML_RNGP_INTERLEAVE_EMPTY: xmlParserErrors = 1047;
pub const XML_RNGP_INTERLEAVE_CREATE_FAILED: xmlParserErrors = 1046;
pub const XML_RNGP_INTERLEAVE_ADD: xmlParserErrors = 1045;
pub const XML_RNGP_INCLUDE_RECURSE: xmlParserErrors = 1044;
pub const XML_RNGP_INCLUDE_FAILURE: xmlParserErrors = 1043;
pub const XML_RNGP_INCLUDE_EMPTY: xmlParserErrors = 1042;
pub const XML_RNGP_HREF_ERROR: xmlParserErrors = 1041;
pub const XML_RNGP_GROUP_ATTR_CONFLICT: xmlParserErrors = 1040;
pub const XML_RNGP_GRAMMAR_NO_START: xmlParserErrors = 1039;
pub const XML_RNGP_GRAMMAR_MISSING: xmlParserErrors = 1038;
pub const XML_RNGP_GRAMMAR_EMPTY: xmlParserErrors = 1037;
pub const XML_RNGP_GRAMMAR_CONTENT: xmlParserErrors = 1036;
pub const XML_RNGP_FOREIGN_ELEMENT: xmlParserErrors = 1035;
pub const XML_RNGP_FORBIDDEN_ATTRIBUTE: xmlParserErrors = 1034;
pub const XML_RNGP_EXTERNALREF_RECURSE: xmlParserErrors = 1033;
pub const XML_RNGP_EXTERNAL_REF_FAILURE: xmlParserErrors = 1032;
pub const XML_RNGP_EXTERNALREF_EMTPY: xmlParserErrors = 1031;
pub const XML_RNGP_EXCEPT_NO_CONTENT: xmlParserErrors = 1030;
pub const XML_RNGP_EXCEPT_MULTIPLE: xmlParserErrors = 1029;
pub const XML_RNGP_EXCEPT_MISSING: xmlParserErrors = 1028;
pub const XML_RNGP_EXCEPT_EMPTY: xmlParserErrors = 1027;
pub const XML_RNGP_ERROR_TYPE_LIB: xmlParserErrors = 1026;
pub const XML_RNGP_EMPTY_NOT_EMPTY: xmlParserErrors = 1025;
pub const XML_RNGP_EMPTY_CONTENT: xmlParserErrors = 1024;
pub const XML_RNGP_EMPTY_CONSTRUCT: xmlParserErrors = 1023;
pub const XML_RNGP_EMPTY: xmlParserErrors = 1022;
pub const XML_RNGP_ELEM_TEXT_CONFLICT: xmlParserErrors = 1021;
pub const XML_RNGP_ELEMENT_NO_CONTENT: xmlParserErrors = 1020;
pub const XML_RNGP_ELEMENT_NAME: xmlParserErrors = 1019;
pub const XML_RNGP_ELEMENT_CONTENT: xmlParserErrors = 1018;
pub const XML_RNGP_ELEMENT_EMPTY: xmlParserErrors = 1017;
pub const XML_RNGP_ELEM_CONTENT_ERROR: xmlParserErrors = 1016;
pub const XML_RNGP_ELEM_CONTENT_EMPTY: xmlParserErrors = 1015;
pub const XML_RNGP_DEFINE_NAME_MISSING: xmlParserErrors = 1014;
pub const XML_RNGP_DEFINE_MISSING: xmlParserErrors = 1013;
pub const XML_RNGP_DEFINE_EMPTY: xmlParserErrors = 1012;
pub const XML_RNGP_DEFINE_CREATE_FAILED: xmlParserErrors = 1011;
pub const XML_RNGP_DEF_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1010;
pub const XML_RNGP_DATA_CONTENT: xmlParserErrors = 1009;
pub const XML_RNGP_CREATE_FAILURE: xmlParserErrors = 1008;
pub const XML_RNGP_CHOICE_EMPTY: xmlParserErrors = 1007;
pub const XML_RNGP_CHOICE_CONTENT: xmlParserErrors = 1006;
pub const XML_RNGP_ATTRIBUTE_NOOP: xmlParserErrors = 1005;
pub const XML_RNGP_ATTRIBUTE_EMPTY: xmlParserErrors = 1004;
pub const XML_RNGP_ATTRIBUTE_CONTENT: xmlParserErrors = 1003;
pub const XML_RNGP_ATTRIBUTE_CHILDREN: xmlParserErrors = 1002;
pub const XML_RNGP_ATTR_CONFLICT: xmlParserErrors = 1001;
pub const XML_RNGP_ANYNAME_ATTR_ANCESTOR: xmlParserErrors = 1000;
pub const XML_HTML_INCORRECTLY_OPENED_COMMENT: xmlParserErrors = 802;
pub const XML_HTML_UNKNOWN_TAG: xmlParserErrors = 801;
pub const XML_HTML_STRUCURE_ERROR: xmlParserErrors = 800;
pub const XML_DTD_DUP_TOKEN: xmlParserErrors = 541;
pub const XML_DTD_XMLID_TYPE: xmlParserErrors = 540;
pub const XML_DTD_XMLID_VALUE: xmlParserErrors = 539;
pub const XML_DTD_STANDALONE_DEFAULTED: xmlParserErrors = 538;
pub const XML_DTD_UNKNOWN_NOTATION: xmlParserErrors = 537;
pub const XML_DTD_UNKNOWN_ID: xmlParserErrors = 536;
pub const XML_DTD_UNKNOWN_ENTITY: xmlParserErrors = 535;
pub const XML_DTD_UNKNOWN_ELEM: xmlParserErrors = 534;
pub const XML_DTD_UNKNOWN_ATTRIBUTE: xmlParserErrors = 533;
pub const XML_DTD_STANDALONE_WHITE_SPACE: xmlParserErrors = 532;
pub const XML_DTD_ROOT_NAME: xmlParserErrors = 531;
pub const XML_DTD_NOT_STANDALONE: xmlParserErrors = 530;
pub const XML_DTD_NOT_PCDATA: xmlParserErrors = 529;
pub const XML_DTD_NOT_EMPTY: xmlParserErrors = 528;
pub const XML_DTD_NOTATION_VALUE: xmlParserErrors = 527;
pub const XML_DTD_NOTATION_REDEFINED: xmlParserErrors = 526;
pub const XML_DTD_NO_ROOT: xmlParserErrors = 525;
pub const XML_DTD_NO_PREFIX: xmlParserErrors = 524;
pub const XML_DTD_NO_ELEM_NAME: xmlParserErrors = 523;
pub const XML_DTD_NO_DTD: xmlParserErrors = 522;
pub const XML_DTD_NO_DOC: xmlParserErrors = 521;
pub const XML_DTD_MULTIPLE_ID: xmlParserErrors = 520;
pub const XML_DTD_MIXED_CORRUPT: xmlParserErrors = 519;
pub const XML_DTD_MISSING_ATTRIBUTE: xmlParserErrors = 518;
pub const XML_DTD_LOAD_ERROR: xmlParserErrors = 517;
pub const XML_DTD_INVALID_DEFAULT: xmlParserErrors = 516;
pub const XML_DTD_INVALID_CHILD: xmlParserErrors = 515;
pub const XML_DTD_ID_SUBSET: xmlParserErrors = 514;
pub const XML_DTD_ID_REDEFINED: xmlParserErrors = 513;
pub const XML_DTD_ID_FIXED: xmlParserErrors = 512;
pub const XML_DTD_ENTITY_TYPE: xmlParserErrors = 511;
pub const XML_DTD_EMPTY_NOTATION: xmlParserErrors = 510;
pub const XML_DTD_ELEM_REDEFINED: xmlParserErrors = 509;
pub const XML_DTD_ELEM_NAMESPACE: xmlParserErrors = 508;
pub const XML_DTD_ELEM_DEFAULT_NAMESPACE: xmlParserErrors = 507;
pub const XML_DTD_DIFFERENT_PREFIX: xmlParserErrors = 506;
pub const XML_DTD_CONTENT_NOT_DETERMINIST: xmlParserErrors = 505;
pub const XML_DTD_CONTENT_MODEL: xmlParserErrors = 504;
pub const XML_DTD_CONTENT_ERROR: xmlParserErrors = 503;
pub const XML_DTD_ATTRIBUTE_VALUE: xmlParserErrors = 502;
pub const XML_DTD_ATTRIBUTE_REDEFINED: xmlParserErrors = 501;
pub const XML_DTD_ATTRIBUTE_DEFAULT: xmlParserErrors = 500;
pub const XML_NS_ERR_COLON: xmlParserErrors = 205;
pub const XML_NS_ERR_EMPTY: xmlParserErrors = 204;
pub const XML_NS_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 203;
pub const XML_NS_ERR_QNAME: xmlParserErrors = 202;
pub const XML_NS_ERR_UNDEFINED_NAMESPACE: xmlParserErrors = 201;
pub const XML_NS_ERR_XML_NAMESPACE: xmlParserErrors = 200;
pub const XML_ERR_COMMENT_ABRUPTLY_ENDED: xmlParserErrors = 112;
pub const XML_ERR_USER_STOP: xmlParserErrors = 111;
pub const XML_ERR_NAME_TOO_LONG: xmlParserErrors = 110;
pub const XML_ERR_VERSION_MISMATCH: xmlParserErrors = 109;
pub const XML_ERR_UNKNOWN_VERSION: xmlParserErrors = 108;
pub const XML_WAR_ENTITY_REDEFINED: xmlParserErrors = 107;
pub const XML_WAR_NS_COLUMN: xmlParserErrors = 106;
pub const XML_ERR_NOTATION_PROCESSING: xmlParserErrors = 105;
pub const XML_ERR_ENTITY_PROCESSING: xmlParserErrors = 104;
pub const XML_ERR_NOT_STANDALONE: xmlParserErrors = 103;
pub const XML_WAR_SPACE_VALUE: xmlParserErrors = 102;
pub const XML_ERR_MISSING_ENCODING: xmlParserErrors = 101;
pub const XML_WAR_NS_URI_RELATIVE: xmlParserErrors = 100;
pub const XML_WAR_NS_URI: xmlParserErrors = 99;
pub const XML_WAR_LANG_VALUE: xmlParserErrors = 98;
pub const XML_WAR_UNKNOWN_VERSION: xmlParserErrors = 97;
pub const XML_ERR_VERSION_MISSING: xmlParserErrors = 96;
pub const XML_ERR_CONDSEC_INVALID_KEYWORD: xmlParserErrors = 95;
pub const XML_ERR_NO_DTD: xmlParserErrors = 94;
pub const XML_WAR_CATALOG_PI: xmlParserErrors = 93;
pub const XML_ERR_URI_FRAGMENT: xmlParserErrors = 92;
pub const XML_ERR_INVALID_URI: xmlParserErrors = 91;
pub const XML_ERR_ENTITY_BOUNDARY: xmlParserErrors = 90;
pub const XML_ERR_ENTITY_LOOP: xmlParserErrors = 89;
pub const XML_ERR_ENTITY_PE_INTERNAL: xmlParserErrors = 88;
pub const XML_ERR_ENTITY_CHAR_ERROR: xmlParserErrors = 87;
pub const XML_ERR_EXTRA_CONTENT: xmlParserErrors = 86;
pub const XML_ERR_NOT_WELL_BALANCED: xmlParserErrors = 85;
pub const XML_ERR_VALUE_REQUIRED: xmlParserErrors = 84;
pub const XML_ERR_CONDSEC_INVALID: xmlParserErrors = 83;
pub const XML_ERR_EXT_ENTITY_STANDALONE: xmlParserErrors = 82;
pub const XML_ERR_INVALID_ENCODING: xmlParserErrors = 81;
pub const XML_ERR_HYPHEN_IN_COMMENT: xmlParserErrors = 80;
pub const XML_ERR_ENCODING_NAME: xmlParserErrors = 79;
pub const XML_ERR_STANDALONE_VALUE: xmlParserErrors = 78;
pub const XML_ERR_TAG_NOT_FINISHED: xmlParserErrors = 77;
pub const XML_ERR_TAG_NAME_MISMATCH: xmlParserErrors = 76;
pub const XML_ERR_EQUAL_REQUIRED: xmlParserErrors = 75;
pub const XML_ERR_LTSLASH_REQUIRED: xmlParserErrors = 74;
pub const XML_ERR_GT_REQUIRED: xmlParserErrors = 73;
pub const XML_ERR_LT_REQUIRED: xmlParserErrors = 72;
pub const XML_ERR_PUBID_REQUIRED: xmlParserErrors = 71;
pub const XML_ERR_URI_REQUIRED: xmlParserErrors = 70;
pub const XML_ERR_PCDATA_REQUIRED: xmlParserErrors = 69;
pub const XML_ERR_NAME_REQUIRED: xmlParserErrors = 68;
pub const XML_ERR_NMTOKEN_REQUIRED: xmlParserErrors = 67;
pub const XML_ERR_SEPARATOR_REQUIRED: xmlParserErrors = 66;
pub const XML_ERR_SPACE_REQUIRED: xmlParserErrors = 65;
pub const XML_ERR_RESERVED_XML_NAME: xmlParserErrors = 64;
pub const XML_ERR_CDATA_NOT_FINISHED: xmlParserErrors = 63;
pub const XML_ERR_MISPLACED_CDATA_END: xmlParserErrors = 62;
pub const XML_ERR_DOCTYPE_NOT_FINISHED: xmlParserErrors = 61;
pub const XML_ERR_EXT_SUBSET_NOT_FINISHED: xmlParserErrors = 60;
pub const XML_ERR_CONDSEC_NOT_FINISHED: xmlParserErrors = 59;
pub const XML_ERR_CONDSEC_NOT_STARTED: xmlParserErrors = 58;
pub const XML_ERR_XMLDECL_NOT_FINISHED: xmlParserErrors = 57;
pub const XML_ERR_XMLDECL_NOT_STARTED: xmlParserErrors = 56;
pub const XML_ERR_ELEMCONTENT_NOT_FINISHED: xmlParserErrors = 55;
pub const XML_ERR_ELEMCONTENT_NOT_STARTED: xmlParserErrors = 54;
pub const XML_ERR_MIXED_NOT_FINISHED: xmlParserErrors = 53;
pub const XML_ERR_MIXED_NOT_STARTED: xmlParserErrors = 52;
pub const XML_ERR_ATTLIST_NOT_FINISHED: xmlParserErrors = 51;
pub const XML_ERR_ATTLIST_NOT_STARTED: xmlParserErrors = 50;
pub const XML_ERR_NOTATION_NOT_FINISHED: xmlParserErrors = 49;
pub const XML_ERR_NOTATION_NOT_STARTED: xmlParserErrors = 48;
pub const XML_ERR_PI_NOT_FINISHED: xmlParserErrors = 47;
pub const XML_ERR_PI_NOT_STARTED: xmlParserErrors = 46;
pub const XML_ERR_COMMENT_NOT_FINISHED: xmlParserErrors = 45;
pub const XML_ERR_LITERAL_NOT_FINISHED: xmlParserErrors = 44;
pub const XML_ERR_LITERAL_NOT_STARTED: xmlParserErrors = 43;
pub const XML_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 42;
pub const XML_ERR_ATTRIBUTE_WITHOUT_VALUE: xmlParserErrors = 41;
pub const XML_ERR_ATTRIBUTE_NOT_FINISHED: xmlParserErrors = 40;
pub const XML_ERR_ATTRIBUTE_NOT_STARTED: xmlParserErrors = 39;
pub const XML_ERR_LT_IN_ATTRIBUTE: xmlParserErrors = 38;
pub const XML_ERR_ENTITY_NOT_FINISHED: xmlParserErrors = 37;
pub const XML_ERR_ENTITY_NOT_STARTED: xmlParserErrors = 36;
pub const XML_ERR_NS_DECL_ERROR: xmlParserErrors = 35;
pub const XML_ERR_STRING_NOT_CLOSED: xmlParserErrors = 34;
pub const XML_ERR_STRING_NOT_STARTED: xmlParserErrors = 33;
pub const XML_ERR_UNSUPPORTED_ENCODING: xmlParserErrors = 32;
pub const XML_ERR_UNKNOWN_ENCODING: xmlParserErrors = 31;
pub const XML_ERR_ENTITY_IS_PARAMETER: xmlParserErrors = 30;
pub const XML_ERR_ENTITY_IS_EXTERNAL: xmlParserErrors = 29;
pub const XML_ERR_UNPARSED_ENTITY: xmlParserErrors = 28;
pub const XML_WAR_UNDECLARED_ENTITY: xmlParserErrors = 27;
pub const XML_ERR_UNDECLARED_ENTITY: xmlParserErrors = 26;
pub const XML_ERR_PEREF_SEMICOL_MISSING: xmlParserErrors = 25;
pub const XML_ERR_PEREF_NO_NAME: xmlParserErrors = 24;
pub const XML_ERR_ENTITYREF_SEMICOL_MISSING: xmlParserErrors = 23;
pub const XML_ERR_ENTITYREF_NO_NAME: xmlParserErrors = 22;
pub const XML_ERR_PEREF_IN_INT_SUBSET: xmlParserErrors = 21;
pub const XML_ERR_PEREF_IN_EPILOG: xmlParserErrors = 20;
pub const XML_ERR_PEREF_IN_PROLOG: xmlParserErrors = 19;
pub const XML_ERR_PEREF_AT_EOF: xmlParserErrors = 18;
pub const XML_ERR_ENTITYREF_IN_DTD: xmlParserErrors = 17;
pub const XML_ERR_ENTITYREF_IN_EPILOG: xmlParserErrors = 16;
pub const XML_ERR_ENTITYREF_IN_PROLOG: xmlParserErrors = 15;
pub const XML_ERR_ENTITYREF_AT_EOF: xmlParserErrors = 14;
pub const XML_ERR_CHARREF_IN_DTD: xmlParserErrors = 13;
pub const XML_ERR_CHARREF_IN_EPILOG: xmlParserErrors = 12;
pub const XML_ERR_CHARREF_IN_PROLOG: xmlParserErrors = 11;
pub const XML_ERR_CHARREF_AT_EOF: xmlParserErrors = 10;
pub const XML_ERR_INVALID_CHAR: xmlParserErrors = 9;
pub const XML_ERR_INVALID_CHARREF: xmlParserErrors = 8;
pub const XML_ERR_INVALID_DEC_CHARREF: xmlParserErrors = 7;
pub const XML_ERR_INVALID_HEX_CHARREF: xmlParserErrors = 6;
pub const XML_ERR_DOCUMENT_END: xmlParserErrors = 5;
pub const XML_ERR_DOCUMENT_EMPTY: xmlParserErrors = 4;
pub const XML_ERR_DOCUMENT_START: xmlParserErrors = 3;
pub const XML_ERR_NO_MEMORY: xmlParserErrors = 2;
pub const XML_ERR_INTERNAL_ERROR: xmlParserErrors = 1;
pub const XML_ERR_OK: xmlParserErrors = 0;
pub type xmlGenericErrorFunc = crate::src::HTMLparser::xmlGenericErrorFunc;
pub type xmlValidCtxtPtr = crate::src::SAX2::xmlValidCtxtPtr;
pub type xmlCharEncoding = crate::src::HTMLparser::xmlCharEncoding;
pub const XML_CHAR_ENCODING_ASCII: xmlCharEncoding = 22;
pub const XML_CHAR_ENCODING_EUC_JP: xmlCharEncoding = 21;
pub const XML_CHAR_ENCODING_SHIFT_JIS: xmlCharEncoding = 20;
pub const XML_CHAR_ENCODING_2022_JP: xmlCharEncoding = 19;
pub const XML_CHAR_ENCODING_8859_9: xmlCharEncoding = 18;
pub const XML_CHAR_ENCODING_8859_8: xmlCharEncoding = 17;
pub const XML_CHAR_ENCODING_8859_7: xmlCharEncoding = 16;
pub const XML_CHAR_ENCODING_8859_6: xmlCharEncoding = 15;
pub const XML_CHAR_ENCODING_8859_5: xmlCharEncoding = 14;
pub const XML_CHAR_ENCODING_8859_4: xmlCharEncoding = 13;
pub const XML_CHAR_ENCODING_8859_3: xmlCharEncoding = 12;
pub const XML_CHAR_ENCODING_8859_2: xmlCharEncoding = 11;
pub const XML_CHAR_ENCODING_8859_1: xmlCharEncoding = 10;
pub const XML_CHAR_ENCODING_UCS2: xmlCharEncoding = 9;
pub const XML_CHAR_ENCODING_UCS4_3412: xmlCharEncoding = 8;
pub const XML_CHAR_ENCODING_UCS4_2143: xmlCharEncoding = 7;
pub const XML_CHAR_ENCODING_EBCDIC: xmlCharEncoding = 6;
pub const XML_CHAR_ENCODING_UCS4BE: xmlCharEncoding = 5;
pub const XML_CHAR_ENCODING_UCS4LE: xmlCharEncoding = 4;
pub const XML_CHAR_ENCODING_UTF16BE: xmlCharEncoding = 3;
pub const XML_CHAR_ENCODING_UTF16LE: xmlCharEncoding = 2;
pub const XML_CHAR_ENCODING_UTF8: xmlCharEncoding = 1;
pub const XML_CHAR_ENCODING_NONE: xmlCharEncoding = 0;
pub const XML_CHAR_ENCODING_ERROR: xmlCharEncoding = -1;
pub type C2RustUnnamed_0 = u32;
pub const XML_PARSE_BIG_LINES: C2RustUnnamed_0 = 4194304;
pub const XML_PARSE_IGNORE_ENC: C2RustUnnamed_0 = 2097152;
pub const XML_PARSE_OLDSAX: C2RustUnnamed_0 = 1048576;
pub const XML_PARSE_HUGE: C2RustUnnamed_0 = 524288;
pub const XML_PARSE_NOBASEFIX: C2RustUnnamed_0 = 262144;
pub const XML_PARSE_OLD10: C2RustUnnamed_0 = 131072;
pub const XML_PARSE_COMPACT: C2RustUnnamed_0 = 65536;
pub const XML_PARSE_NOXINCNODE: C2RustUnnamed_0 = 32768;
pub const XML_PARSE_NOCDATA: C2RustUnnamed_0 = 16384;
pub const XML_PARSE_NSCLEAN: C2RustUnnamed_0 = 8192;
pub const XML_PARSE_NODICT: C2RustUnnamed_0 = 4096;
pub const XML_PARSE_NONET: C2RustUnnamed_0 = 2048;
pub const XML_PARSE_XINCLUDE: C2RustUnnamed_0 = 1024;
pub const XML_PARSE_SAX1: C2RustUnnamed_0 = 512;
pub const XML_PARSE_NOBLANKS: C2RustUnnamed_0 = 256;
pub const XML_PARSE_PEDANTIC: C2RustUnnamed_0 = 128;
pub const XML_PARSE_NOWARNING: C2RustUnnamed_0 = 64;
pub const XML_PARSE_NOERROR: C2RustUnnamed_0 = 32;
pub const XML_PARSE_DTDVALID: C2RustUnnamed_0 = 16;
pub const XML_PARSE_DTDATTR: C2RustUnnamed_0 = 8;
pub const XML_PARSE_DTDLOAD: C2RustUnnamed_0 = 4;
pub const XML_PARSE_NOENT: C2RustUnnamed_0 = 2;
pub const XML_PARSE_RECOVER: C2RustUnnamed_0 = 1;
pub type C2RustUnnamed_1 = u32;
pub const XML_SCHEMA_VAL_VC_I_CREATE: C2RustUnnamed_1 = 1;
// #[derive(Copy, Clone)]

pub type _xmlSchema = crate::src::python::libxml2_py::_xmlSchema;
pub type xmlSchemaAnnotPtr = crate::src::python::libxml2_py::xmlSchemaAnnotPtr;
pub type xmlSchemaAnnot = crate::src::python::libxml2_py::xmlSchemaAnnot;
// #[derive(Copy, Clone)]

pub type _xmlSchemaAnnot = crate::src::python::libxml2_py::_xmlSchemaAnnot;
pub type xmlSchema = crate::src::python::libxml2_py::xmlSchema;
pub type xmlSchemaPtr = crate::src::python::libxml2_py::xmlSchemaPtr;
pub type xmlSchemaValidityErrorFunc = crate::src::python::libxml::xmlSchemaValidityErrorFunc;
pub type xmlSchemaValidityWarningFunc = crate::src::python::libxml::xmlSchemaValidityWarningFunc;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaParserCtxt {
    pub type_0: i32,
    pub errCtxt: *mut libc::c_void,
    pub error: xmlSchemaValidityErrorFunc,
    pub warning: xmlSchemaValidityWarningFunc,
    pub err: i32,
    pub nberrors: i32,
    pub serror: xmlStructuredErrorFunc,
    pub constructor: xmlSchemaConstructionCtxtPtr,
    pub ownsConstructor: i32,
    pub schema: xmlSchemaPtr,
    pub counter: i32,
    pub URL: *const xmlChar,
    pub doc: xmlDocPtr,
    pub preserve: i32,
    pub buffer: *const i8,
    pub size: i32,
    pub am: xmlAutomataPtr,
    pub start: xmlAutomataStatePtr,
    pub end: xmlAutomataStatePtr,
    pub state: xmlAutomataStatePtr,
    pub dict: xmlDictPtr,
    pub ctxtType: xmlSchemaTypePtr,
    pub options: i32,
    pub vctxt: xmlSchemaValidCtxtPtr,
    pub isS4S: i32,
    pub isRedefine: i32,
    pub xsiAssemble: i32,
    pub stop: i32,
    pub targetNamespace: *const xmlChar,
    pub redefined: xmlSchemaBucketPtr,
    pub redef: xmlSchemaRedefPtr,
    pub redefCounter: i32,
    pub attrProhibs: xmlSchemaItemListPtr,
}
pub type xmlSchemaItemListPtr = *mut xmlSchemaItemList;
pub type xmlSchemaItemList = _xmlSchemaItemList;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaItemList {
    pub items: *mut *mut libc::c_void,
    pub nbItems: i32,
    pub sizeItems: i32,
}
pub type xmlSchemaRedefPtr = *mut xmlSchemaRedef;
pub type xmlSchemaRedef = _xmlSchemaRedef;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaRedef {
    pub next: xmlSchemaRedefPtr,
    pub item: xmlSchemaBasicItemPtr,
    pub reference: xmlSchemaBasicItemPtr,
    pub target: xmlSchemaBasicItemPtr,
    pub refName: *const xmlChar,
    pub refTargetNs: *const xmlChar,
    pub targetBucket: xmlSchemaBucketPtr,
}
pub type xmlSchemaBucketPtr = *mut xmlSchemaBucket;
pub type xmlSchemaBucket = _xmlSchemaBucket;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaBucket {
    pub type_0: i32,
    pub flags: i32,
    pub schemaLocation: *const xmlChar,
    pub origTargetNamespace: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub doc: xmlDocPtr,
    pub relations: xmlSchemaSchemaRelationPtr,
    pub located: i32,
    pub parsed: i32,
    pub imported: i32,
    pub preserveDoc: i32,
    pub globals: xmlSchemaItemListPtr,
    pub locals: xmlSchemaItemListPtr,
}
pub type xmlSchemaSchemaRelationPtr = *mut xmlSchemaSchemaRelation;
pub type xmlSchemaSchemaRelation = _xmlSchemaSchemaRelation;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaSchemaRelation {
    pub next: xmlSchemaSchemaRelationPtr,
    pub type_0: i32,
    pub importNamespace: *const xmlChar,
    pub bucket: xmlSchemaBucketPtr,
}
pub type xmlSchemaBasicItemPtr = *mut xmlSchemaBasicItem;
pub type xmlSchemaBasicItem = _xmlSchemaBasicItem;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaBasicItem {
    pub type_0: xmlSchemaTypeType,
    pub dummy: *mut libc::c_void,
}
pub type xmlSchemaTypeType = crate::src::relaxng::xmlSchemaTypeType;
pub const XML_SCHEMA_EXTRA_ATTR_USE_PROHIB: xmlSchemaTypeType = 2001;
pub const XML_SCHEMA_EXTRA_QNAMEREF: xmlSchemaTypeType = 2000;
pub const XML_SCHEMA_FACET_MINLENGTH: xmlSchemaTypeType = 1011;
pub const XML_SCHEMA_FACET_MAXLENGTH: xmlSchemaTypeType = 1010;
pub const XML_SCHEMA_FACET_LENGTH: xmlSchemaTypeType = 1009;
pub const XML_SCHEMA_FACET_WHITESPACE: xmlSchemaTypeType = 1008;
pub const XML_SCHEMA_FACET_ENUMERATION: xmlSchemaTypeType = 1007;
pub const XML_SCHEMA_FACET_PATTERN: xmlSchemaTypeType = 1006;
pub const XML_SCHEMA_FACET_FRACTIONDIGITS: xmlSchemaTypeType = 1005;
pub const XML_SCHEMA_FACET_TOTALDIGITS: xmlSchemaTypeType = 1004;
pub const XML_SCHEMA_FACET_MAXEXCLUSIVE: xmlSchemaTypeType = 1003;
pub const XML_SCHEMA_FACET_MAXINCLUSIVE: xmlSchemaTypeType = 1002;
pub const XML_SCHEMA_FACET_MINEXCLUSIVE: xmlSchemaTypeType = 1001;
pub const XML_SCHEMA_FACET_MININCLUSIVE: xmlSchemaTypeType = 1000;
pub const XML_SCHEMA_TYPE_ATTRIBUTE_USE: xmlSchemaTypeType = 26;
pub const XML_SCHEMA_TYPE_PARTICLE: xmlSchemaTypeType = 25;
pub const XML_SCHEMA_TYPE_IDC_KEYREF: xmlSchemaTypeType = 24;
pub const XML_SCHEMA_TYPE_IDC_KEY: xmlSchemaTypeType = 23;
pub const XML_SCHEMA_TYPE_IDC_UNIQUE: xmlSchemaTypeType = 22;
pub const XML_SCHEMA_TYPE_ANY_ATTRIBUTE: xmlSchemaTypeType = 21;
pub const XML_SCHEMA_TYPE_UNION: xmlSchemaTypeType = 20;
pub const XML_SCHEMA_TYPE_LIST: xmlSchemaTypeType = 19;
pub const XML_SCHEMA_TYPE_NOTATION: xmlSchemaTypeType = 18;
pub const XML_SCHEMA_TYPE_GROUP: xmlSchemaTypeType = 17;
pub const XML_SCHEMA_TYPE_ATTRIBUTEGROUP: xmlSchemaTypeType = 16;
pub const XML_SCHEMA_TYPE_ATTRIBUTE: xmlSchemaTypeType = 15;
pub const XML_SCHEMA_TYPE_ELEMENT: xmlSchemaTypeType = 14;
pub const XML_SCHEMA_TYPE_EXTENSION: xmlSchemaTypeType = 13;
pub const XML_SCHEMA_TYPE_RESTRICTION: xmlSchemaTypeType = 12;
pub const XML_SCHEMA_TYPE_UR: xmlSchemaTypeType = 11;
pub const XML_SCHEMA_TYPE_COMPLEX_CONTENT: xmlSchemaTypeType = 10;
pub const XML_SCHEMA_TYPE_SIMPLE_CONTENT: xmlSchemaTypeType = 9;
pub const XML_SCHEMA_TYPE_ALL: xmlSchemaTypeType = 8;
pub const XML_SCHEMA_TYPE_CHOICE: xmlSchemaTypeType = 7;
pub const XML_SCHEMA_TYPE_SEQUENCE: xmlSchemaTypeType = 6;
pub const XML_SCHEMA_TYPE_COMPLEX: xmlSchemaTypeType = 5;
pub const XML_SCHEMA_TYPE_SIMPLE: xmlSchemaTypeType = 4;
pub const XML_SCHEMA_TYPE_FACET: xmlSchemaTypeType = 3;
pub const XML_SCHEMA_TYPE_ANY: xmlSchemaTypeType = 2;
pub const XML_SCHEMA_TYPE_BASIC: xmlSchemaTypeType = 1;
pub type xmlSchemaValidCtxtPtr = crate::src::python::libxml::xmlSchemaValidCtxtPtr;
pub type xmlSchemaValidCtxt = crate::src::python::libxml::xmlSchemaValidCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaValidCtxt {
    pub type_0: i32,
    pub errCtxt: *mut libc::c_void,
    pub error: xmlSchemaValidityErrorFunc,
    pub warning: xmlSchemaValidityWarningFunc,
    pub serror: xmlStructuredErrorFunc,
    pub schema: xmlSchemaPtr,
    pub doc: xmlDocPtr,
    pub input: xmlParserInputBufferPtr,
    pub enc: xmlCharEncoding,
    pub sax: xmlSAXHandlerPtr,
    pub parserCtxt: xmlParserCtxtPtr,
    pub user_data: *mut libc::c_void,
    pub filename: *mut i8,
    pub err: i32,
    pub nberrors: i32,
    pub node: xmlNodePtr,
    pub cur: xmlNodePtr,
    pub regexp: xmlRegExecCtxtPtr,
    pub value: xmlSchemaValPtr,
    pub valueWS: i32,
    pub options: i32,
    pub validationRoot: xmlNodePtr,
    pub pctxt: xmlSchemaParserCtxtPtr,
    pub xsiAssemble: i32,
    pub depth: i32,
    pub elemInfos: *mut xmlSchemaNodeInfoPtr,
    pub sizeElemInfos: i32,
    pub inode: xmlSchemaNodeInfoPtr,
    pub aidcs: xmlSchemaIDCAugPtr,
    pub xpathStates: xmlSchemaIDCStateObjPtr,
    pub xpathStatePool: xmlSchemaIDCStateObjPtr,
    pub idcMatcherCache: xmlSchemaIDCMatcherPtr,
    pub idcNodes: *mut xmlSchemaPSVIIDCNodePtr,
    pub nbIdcNodes: i32,
    pub sizeIdcNodes: i32,
    pub idcKeys: *mut xmlSchemaPSVIIDCKeyPtr,
    pub nbIdcKeys: i32,
    pub sizeIdcKeys: i32,
    pub flags: i32,
    pub dict: xmlDictPtr,
    pub reader: xmlTextReaderPtr,
    pub attrInfos: *mut xmlSchemaAttrInfoPtr,
    pub nbAttrInfos: i32,
    pub sizeAttrInfos: i32,
    pub skipDepth: i32,
    pub nodeQNames: xmlSchemaItemListPtr,
    pub hasKeyrefs: i32,
    pub createIDCNodeTables: i32,
    pub psviExposeIDCNodeTables: i32,
    pub locFunc: xmlSchemaValidityLocatorFunc,
    pub locCtxt: *mut libc::c_void,
}
pub type xmlSchemaValidityLocatorFunc = crate::src::xmlreader::xmlSchemaValidityLocatorFunc;
pub type xmlSchemaAttrInfoPtr = *mut xmlSchemaAttrInfo;
pub type xmlSchemaAttrInfo = _xmlSchemaAttrInfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttrInfo {
    pub nodeType: i32,
    pub node: xmlNodePtr,
    pub nodeLine: i32,
    pub localName: *const xmlChar,
    pub nsName: *const xmlChar,
    pub value: *const xmlChar,
    pub val: xmlSchemaValPtr,
    pub typeDef: xmlSchemaTypePtr,
    pub flags: i32,
    pub decl: xmlSchemaAttributePtr,
    pub use_0: xmlSchemaAttributeUsePtr,
    pub state: i32,
    pub metaType: i32,
    pub vcValue: *const xmlChar,
    pub parent: xmlSchemaNodeInfoPtr,
}
pub type xmlSchemaNodeInfoPtr = *mut xmlSchemaNodeInfo;
pub type xmlSchemaNodeInfo = _xmlSchemaNodeInfo;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaNodeInfo {
    pub nodeType: i32,
    pub node: xmlNodePtr,
    pub nodeLine: i32,
    pub localName: *const xmlChar,
    pub nsName: *const xmlChar,
    pub value: *const xmlChar,
    pub val: xmlSchemaValPtr,
    pub typeDef: xmlSchemaTypePtr,
    pub flags: i32,
    pub valNeeded: i32,
    pub normVal: i32,
    pub decl: xmlSchemaElementPtr,
    pub depth: i32,
    pub idcTable: xmlSchemaPSVIIDCBindingPtr,
    pub idcMatchers: xmlSchemaIDCMatcherPtr,
    pub regexCtxt: xmlRegExecCtxtPtr,
    pub nsBindings: *mut *const xmlChar,
    pub nbNsBindings: i32,
    pub sizeNsBindings: i32,
    pub hasKeyrefs: i32,
    pub appliedXPath: i32,
}
pub type xmlSchemaIDCMatcherPtr = *mut xmlSchemaIDCMatcher;
pub type xmlSchemaIDCMatcher = _xmlSchemaIDCMatcher;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDCMatcher {
    pub type_0: i32,
    pub depth: i32,
    pub next: xmlSchemaIDCMatcherPtr,
    pub nextCached: xmlSchemaIDCMatcherPtr,
    pub aidc: xmlSchemaIDCAugPtr,
    pub idcType: i32,
    pub keySeqs: *mut *mut xmlSchemaPSVIIDCKeyPtr,
    pub sizeKeySeqs: i32,
    pub targets: xmlSchemaItemListPtr,
    pub htab: xmlHashTablePtr,
}
pub type xmlSchemaPSVIIDCKeyPtr = *mut xmlSchemaPSVIIDCKey;
pub type xmlSchemaPSVIIDCKey = _xmlSchemaPSVIIDCKey;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaPSVIIDCKey {
    pub type_0: xmlSchemaTypePtr,
    pub val: xmlSchemaValPtr,
}
pub type xmlSchemaValPtr = crate::src::relaxng::xmlSchemaValPtr;
pub type xmlSchemaVal = crate::src::relaxng::xmlSchemaVal;
pub type xmlSchemaTypePtr = crate::src::relaxng::xmlSchemaTypePtr;
pub type xmlSchemaType = crate::src::relaxng::xmlSchemaType;
// #[derive(Copy, Clone)]

pub type _xmlSchemaType = crate::src::relaxng::_xmlSchemaType;
pub type xmlSchemaFacetLinkPtr = crate::src::relaxng::xmlSchemaFacetLinkPtr;
pub type xmlSchemaFacetLink = crate::src::relaxng::xmlSchemaFacetLink;
// #[derive(Copy, Clone)]

pub type _xmlSchemaFacetLink = crate::src::relaxng::_xmlSchemaFacetLink;
pub type xmlSchemaFacetPtr = crate::src::relaxng::xmlSchemaFacetPtr;
pub type xmlSchemaFacet = crate::src::relaxng::xmlSchemaFacet;
// #[derive(Copy, Clone)]

pub type _xmlSchemaFacet = crate::src::relaxng::_xmlSchemaFacet;
pub type xmlSchemaTypeLinkPtr = crate::src::relaxng::xmlSchemaTypeLinkPtr;
pub type xmlSchemaTypeLink = crate::src::relaxng::xmlSchemaTypeLink;
// #[derive(Copy, Clone)]

pub type _xmlSchemaTypeLink = crate::src::relaxng::_xmlSchemaTypeLink;
pub type xmlSchemaWildcardPtr = crate::src::relaxng::xmlSchemaWildcardPtr;
pub type xmlSchemaWildcard = crate::src::relaxng::xmlSchemaWildcard;
// #[derive(Copy, Clone)]

pub type _xmlSchemaWildcard = crate::src::relaxng::_xmlSchemaWildcard;
pub type xmlSchemaWildcardNsPtr = crate::src::relaxng::xmlSchemaWildcardNsPtr;
pub type xmlSchemaWildcardNs = crate::src::relaxng::xmlSchemaWildcardNs;
// #[derive(Copy, Clone)]

pub type _xmlSchemaWildcardNs = crate::src::relaxng::_xmlSchemaWildcardNs;
pub type xmlSchemaAttributeLinkPtr = crate::src::relaxng::xmlSchemaAttributeLinkPtr;
pub type xmlSchemaAttributeLink = crate::src::relaxng::xmlSchemaAttributeLink;
// #[derive(Copy, Clone)]

pub type _xmlSchemaAttributeLink = crate::src::relaxng::_xmlSchemaAttributeLink;
// #[derive(Copy, Clone)]

pub type _xmlSchemaAttribute = crate::src::relaxng::_xmlSchemaAttribute;
pub type xmlSchemaAttributePtr = crate::src::relaxng::xmlSchemaAttributePtr;
pub type xmlSchemaAttribute = crate::src::relaxng::xmlSchemaAttribute;
pub type xmlSchemaContentType = crate::src::relaxng::xmlSchemaContentType;
pub const XML_SCHEMA_CONTENT_ANY: xmlSchemaContentType = 7;
pub const XML_SCHEMA_CONTENT_BASIC: xmlSchemaContentType = 6;
pub const XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS: xmlSchemaContentType = 5;
pub const XML_SCHEMA_CONTENT_SIMPLE: xmlSchemaContentType = 4;
pub const XML_SCHEMA_CONTENT_MIXED: xmlSchemaContentType = 3;
pub const XML_SCHEMA_CONTENT_ELEMENTS: xmlSchemaContentType = 2;
pub const XML_SCHEMA_CONTENT_EMPTY: xmlSchemaContentType = 1;
pub const XML_SCHEMA_CONTENT_UNKNOWN: xmlSchemaContentType = 0;
pub type xmlSchemaIDCAugPtr = *mut xmlSchemaIDCAug;
pub type xmlSchemaIDCAug = _xmlSchemaIDCAug;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDCAug {
    pub next: xmlSchemaIDCAugPtr,
    pub def: xmlSchemaIDCPtr,
    pub keyrefDepth: i32,
}
pub type xmlSchemaIDCPtr = *mut xmlSchemaIDC;
pub type xmlSchemaIDC = _xmlSchemaIDC;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDC {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaIDCPtr,
    pub node: xmlNodePtr,
    pub name: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub selector: xmlSchemaIDCSelectPtr,
    pub fields: xmlSchemaIDCSelectPtr,
    pub nbFields: i32,
    pub ref_0: xmlSchemaQNameRefPtr,
}
pub type xmlSchemaQNameRefPtr = *mut xmlSchemaQNameRef;
pub type xmlSchemaQNameRef = _xmlSchemaQNameRef;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaQNameRef {
    pub type_0: xmlSchemaTypeType,
    pub item: xmlSchemaBasicItemPtr,
    pub itemType: xmlSchemaTypeType,
    pub name: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub node: xmlNodePtr,
}
pub type xmlSchemaIDCSelectPtr = *mut xmlSchemaIDCSelect;
pub type xmlSchemaIDCSelect = _xmlSchemaIDCSelect;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDCSelect {
    pub next: xmlSchemaIDCSelectPtr,
    pub idc: xmlSchemaIDCPtr,
    pub index: i32,
    pub xpath: *const xmlChar,
    pub xpathComp: *mut libc::c_void,
}
pub type xmlSchemaPSVIIDCBindingPtr = *mut xmlSchemaPSVIIDCBinding;
pub type xmlSchemaPSVIIDCBinding = _xmlSchemaPSVIIDCBinding;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaPSVIIDCBinding {
    pub next: xmlSchemaPSVIIDCBindingPtr,
    pub definition: xmlSchemaIDCPtr,
    pub nodeTable: *mut xmlSchemaPSVIIDCNodePtr,
    pub nbNodes: i32,
    pub sizeNodes: i32,
    pub dupls: xmlSchemaItemListPtr,
}
pub type xmlSchemaPSVIIDCNodePtr = *mut xmlSchemaPSVIIDCNode;
pub type xmlSchemaPSVIIDCNode = _xmlSchemaPSVIIDCNode;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaPSVIIDCNode {
    pub node: xmlNodePtr,
    pub keys: *mut xmlSchemaPSVIIDCKeyPtr,
    pub nodeLine: i32,
    pub nodeQNameID: i32,
}
pub type xmlSchemaElementPtr = *mut xmlSchemaElement;
pub type xmlSchemaElement = _xmlSchemaElement;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaElement {
    pub type_0: xmlSchemaTypeType,
    pub next: *mut _xmlSchemaType,
    pub name: *const xmlChar,
    pub id: *const xmlChar,
    pub ref_0: *const xmlChar,
    pub refNs: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub subtypes: xmlSchemaTypePtr,
    pub attributes: xmlSchemaAttributePtr,
    pub node: xmlNodePtr,
    pub minOccurs: i32,
    pub maxOccurs: i32,
    pub flags: i32,
    pub targetNamespace: *const xmlChar,
    pub namedType: *const xmlChar,
    pub namedTypeNs: *const xmlChar,
    pub substGroup: *const xmlChar,
    pub substGroupNs: *const xmlChar,
    pub scope: *const xmlChar,
    pub value: *const xmlChar,
    pub refDecl: *mut _xmlSchemaElement,
    pub contModel: xmlRegexpPtr,
    pub contentType: xmlSchemaContentType,
    pub refPrefix: *const xmlChar,
    pub defVal: xmlSchemaValPtr,
    pub idcs: *mut libc::c_void,
}
pub type xmlSchemaAttributeUsePtr = *mut xmlSchemaAttributeUse;
pub type xmlSchemaAttributeUse = _xmlSchemaAttributeUse;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttributeUse {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaAttributeUsePtr,
    pub attrDecl: xmlSchemaAttributePtr,
    pub flags: i32,
    pub node: xmlNodePtr,
    pub occurs: i32,
    pub defValue: *const xmlChar,
    pub defVal: xmlSchemaValPtr,
}
pub type xmlTextReaderPtr = crate::src::python::libxml::xmlTextReaderPtr;
pub type xmlTextReader = crate::src::python::libxml::xmlTextReader;
pub type xmlSchemaIDCStateObjPtr = *mut xmlSchemaIDCStateObj;
pub type xmlSchemaIDCStateObj = _xmlSchemaIDCStateObj;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDCStateObj {
    pub type_0: i32,
    pub next: xmlSchemaIDCStateObjPtr,
    pub depth: i32,
    pub history: *mut i32,
    pub nbHistory: i32,
    pub sizeHistory: i32,
    pub matcher: xmlSchemaIDCMatcherPtr,
    pub sel: xmlSchemaIDCSelectPtr,
    pub xpathCtxt: *mut libc::c_void,
}
pub type xmlSchemaParserCtxtPtr = crate::src::python::libxml2_py::xmlSchemaParserCtxtPtr;
pub type xmlSchemaParserCtxt = crate::src::python::libxml2_py::xmlSchemaParserCtxt;
pub type xmlSchemaConstructionCtxtPtr = *mut xmlSchemaConstructionCtxt;
pub type xmlSchemaConstructionCtxt = _xmlSchemaConstructionCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaConstructionCtxt {
    pub mainSchema: xmlSchemaPtr,
    pub mainBucket: xmlSchemaBucketPtr,
    pub dict: xmlDictPtr,
    pub buckets: xmlSchemaItemListPtr,
    pub bucket: xmlSchemaBucketPtr,
    pub pending: xmlSchemaItemListPtr,
    pub substGroups: xmlHashTablePtr,
    pub redefs: xmlSchemaRedefPtr,
    pub lastRedef: xmlSchemaRedefPtr,
}
pub type xmlSchemaSubstGroupPtr = *mut xmlSchemaSubstGroup;
pub type xmlSchemaSubstGroup = _xmlSchemaSubstGroup;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaSubstGroup {
    pub head: xmlSchemaElementPtr,
    pub members: xmlSchemaItemListPtr,
}
pub type xmlIDCHashEntryPtr = *mut xmlIDCHashEntry;
pub type xmlIDCHashEntry = _xmlIDCHashEntry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlIDCHashEntry {
    pub next: xmlIDCHashEntryPtr,
    pub index: i32,
}
pub type xmlStreamCtxtPtr = crate::src::pattern::xmlStreamCtxtPtr;
pub type xmlStreamCtxt = crate::src::pattern::xmlStreamCtxt;
pub type xmlSchemaAbstractCtxtPtr = *mut xmlSchemaAbstractCtxt;
pub type xmlSchemaAbstractCtxt = _xmlSchemaAbstractCtxt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAbstractCtxt {
    pub type_0: i32,
    pub dummy: *mut libc::c_void,
}
pub type xmlSchemaImportPtr = *mut xmlSchemaImport;
pub type xmlSchemaImport = _xmlSchemaImport;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaImport {
    pub type_0: i32,
    pub flags: i32,
    pub schemaLocation: *const xmlChar,
    pub origTargetNamespace: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub doc: xmlDocPtr,
    pub relations: xmlSchemaSchemaRelationPtr,
    pub located: i32,
    pub parsed: i32,
    pub imported: i32,
    pub preserveDoc: i32,
    pub globals: xmlSchemaItemListPtr,
    pub locals: xmlSchemaItemListPtr,
    pub schema: xmlSchemaPtr,
}
pub type xmlSchemaTreeItemPtr = *mut xmlSchemaTreeItem;
pub type xmlSchemaTreeItem = _xmlSchemaTreeItem;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaTreeItem {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaTreeItemPtr,
    pub children: xmlSchemaTreeItemPtr,
}
pub const XML_SCHEMAS_ANYTYPE: xmlSchemaValType = 45;
pub type xmlSchemaNotationPtr = *mut xmlSchemaNotation;
pub type xmlSchemaNotation = _xmlSchemaNotation;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaNotation {
    pub type_0: xmlSchemaTypeType,
    pub name: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub identifier: *const xmlChar,
    pub targetNamespace: *const xmlChar,
}
pub type xmlPatternPtr = crate::src::pattern::xmlPatternPtr;
pub type xmlPattern = crate::src::pattern::xmlPattern;
pub type xmlSchemaModelGroupDefPtr = *mut xmlSchemaModelGroupDef;
pub type xmlSchemaModelGroupDef = _xmlSchemaModelGroupDef;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaModelGroupDef {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaTreeItemPtr,
    pub children: xmlSchemaTreeItemPtr,
    pub name: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub node: xmlNodePtr,
    pub flags: i32,
}
pub type xmlSchemaAttributeGroupPtr = *mut xmlSchemaAttributeGroup;
pub type xmlSchemaAttributeGroup = _xmlSchemaAttributeGroup;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttributeGroup {
    pub type_0: xmlSchemaTypeType,
    pub next: *mut _xmlSchemaAttribute,
    pub name: *const xmlChar,
    pub id: *const xmlChar,
    pub ref_0: *const xmlChar,
    pub refNs: *const xmlChar,
    pub annot: xmlSchemaAnnotPtr,
    pub attributes: xmlSchemaAttributePtr,
    pub node: xmlNodePtr,
    pub flags: i32,
    pub attributeWildcard: xmlSchemaWildcardPtr,
    pub refPrefix: *const xmlChar,
    pub refItem: xmlSchemaAttributeGroupPtr,
    pub targetNamespace: *const xmlChar,
    pub attrUses: *mut libc::c_void,
}
pub type xmlSchemaModelGroupPtr = *mut xmlSchemaModelGroup;
pub type xmlSchemaModelGroup = _xmlSchemaModelGroup;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaModelGroup {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaTreeItemPtr,
    pub children: xmlSchemaTreeItemPtr,
    pub node: xmlNodePtr,
}
pub type xmlSchemaAttributeUseProhibPtr = *mut xmlSchemaAttributeUseProhib;
pub type xmlSchemaAttributeUseProhib = _xmlSchemaAttributeUseProhib;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttributeUseProhib {
    pub type_0: xmlSchemaTypeType,
    pub node: xmlNodePtr,
    pub name: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub isRef: i32,
}
pub type xmlSchemaParticlePtr = *mut xmlSchemaParticle;
pub type xmlSchemaParticle = _xmlSchemaParticle;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaParticle {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
    pub next: xmlSchemaTreeItemPtr,
    pub children: xmlSchemaTreeItemPtr,
    pub minOccurs: i32,
    pub maxOccurs: i32,
    pub node: xmlNodePtr,
}
pub type xmlSchemaValType = u32;
pub const XML_SCHEMAS_ANYSIMPLETYPE: xmlSchemaValType = 46;
pub const XML_SCHEMAS_BASE64BINARY: xmlSchemaValType = 44;
pub const XML_SCHEMAS_HEXBINARY: xmlSchemaValType = 43;
pub const XML_SCHEMAS_UBYTE: xmlSchemaValType = 42;
pub const XML_SCHEMAS_BYTE: xmlSchemaValType = 41;
pub const XML_SCHEMAS_USHORT: xmlSchemaValType = 40;
pub const XML_SCHEMAS_SHORT: xmlSchemaValType = 39;
pub const XML_SCHEMAS_ULONG: xmlSchemaValType = 38;
pub const XML_SCHEMAS_LONG: xmlSchemaValType = 37;
pub const XML_SCHEMAS_UINT: xmlSchemaValType = 36;
pub const XML_SCHEMAS_INT: xmlSchemaValType = 35;
pub const XML_SCHEMAS_PINTEGER: xmlSchemaValType = 34;
pub const XML_SCHEMAS_NNINTEGER: xmlSchemaValType = 33;
pub const XML_SCHEMAS_NINTEGER: xmlSchemaValType = 32;
pub const XML_SCHEMAS_NPINTEGER: xmlSchemaValType = 31;
pub const XML_SCHEMAS_INTEGER: xmlSchemaValType = 30;
pub const XML_SCHEMAS_ANYURI: xmlSchemaValType = 29;
pub const XML_SCHEMAS_NOTATION: xmlSchemaValType = 28;
pub const XML_SCHEMAS_ENTITIES: xmlSchemaValType = 27;
pub const XML_SCHEMAS_ENTITY: xmlSchemaValType = 26;
pub const XML_SCHEMAS_IDREFS: xmlSchemaValType = 25;
pub const XML_SCHEMAS_IDREF: xmlSchemaValType = 24;
pub const XML_SCHEMAS_ID: xmlSchemaValType = 23;
pub const XML_SCHEMAS_NCNAME: xmlSchemaValType = 22;
pub const XML_SCHEMAS_QNAME: xmlSchemaValType = 21;
pub const XML_SCHEMAS_NAME: xmlSchemaValType = 20;
pub const XML_SCHEMAS_NMTOKENS: xmlSchemaValType = 19;
pub const XML_SCHEMAS_NMTOKEN: xmlSchemaValType = 18;
pub const XML_SCHEMAS_LANGUAGE: xmlSchemaValType = 17;
pub const XML_SCHEMAS_TOKEN: xmlSchemaValType = 16;
pub const XML_SCHEMAS_BOOLEAN: xmlSchemaValType = 15;
pub const XML_SCHEMAS_DOUBLE: xmlSchemaValType = 14;
pub const XML_SCHEMAS_FLOAT: xmlSchemaValType = 13;
pub const XML_SCHEMAS_DURATION: xmlSchemaValType = 12;
pub const XML_SCHEMAS_DATETIME: xmlSchemaValType = 11;
pub const XML_SCHEMAS_DATE: xmlSchemaValType = 10;
pub const XML_SCHEMAS_GYEARMONTH: xmlSchemaValType = 9;
pub const XML_SCHEMAS_GYEAR: xmlSchemaValType = 8;
pub const XML_SCHEMAS_GMONTHDAY: xmlSchemaValType = 7;
pub const XML_SCHEMAS_GMONTH: xmlSchemaValType = 6;
pub const XML_SCHEMAS_GDAY: xmlSchemaValType = 5;
pub const XML_SCHEMAS_TIME: xmlSchemaValType = 4;
pub const XML_SCHEMAS_DECIMAL: xmlSchemaValType = 3;
pub const XML_SCHEMAS_NORMSTRING: xmlSchemaValType = 2;
pub const XML_SCHEMAS_STRING: xmlSchemaValType = 1;
pub const XML_SCHEMAS_UNKNOWN: xmlSchemaValType = 0;
pub type xmlSchemaWhitespaceValueType = u32;
pub const XML_SCHEMA_WHITESPACE_COLLAPSE: xmlSchemaWhitespaceValueType = 3;
pub const XML_SCHEMA_WHITESPACE_REPLACE: xmlSchemaWhitespaceValueType = 2;
pub const XML_SCHEMA_WHITESPACE_PRESERVE: xmlSchemaWhitespaceValueType = 1;
pub const XML_SCHEMA_WHITESPACE_UNKNOWN: xmlSchemaWhitespaceValueType = 0;
pub type xmlSchemaIncludePtr = *mut xmlSchemaInclude;
pub type xmlSchemaInclude = _xmlSchemaInclude;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaInclude {
    pub type_0: i32,
    pub flags: i32,
    pub schemaLocation: *const xmlChar,
    pub origTargetNamespace: *const xmlChar,
    pub targetNamespace: *const xmlChar,
    pub doc: xmlDocPtr,
    pub relations: xmlSchemaSchemaRelationPtr,
    pub located: i32,
    pub parsed: i32,
    pub imported: i32,
    pub preserveDoc: i32,
    pub globals: xmlSchemaItemListPtr,
    pub locals: xmlSchemaItemListPtr,
    pub ownerImport: xmlSchemaImportPtr,
}
pub type xmlSchemaAnnotItemPtr = *mut xmlSchemaAnnotItem;
pub type xmlSchemaAnnotItem = _xmlSchemaAnnotItem;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAnnotItem {
    pub type_0: xmlSchemaTypeType,
    pub annot: xmlSchemaAnnotPtr,
}
pub const XML_PATTERN_XSSEL: C2RustUnnamed_2 = 2;
pub const XML_PATTERN_XSFIELD: C2RustUnnamed_2 = 4;
pub type xmlSchemaSAXPlugPtr = crate::src::xmlreader::xmlSchemaSAXPlugPtr;
pub type xmlSchemaSAXPlugStruct = crate::src::xmlreader::xmlSchemaSAXPlugStruct;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaSAXPlug {
    pub magic: u32,
    pub user_sax_ptr: *mut xmlSAXHandlerPtr,
    pub user_sax: xmlSAXHandlerPtr,
    pub user_data_ptr: *mut *mut libc::c_void,
    pub user_data: *mut libc::c_void,
    pub schemas_sax: xmlSAXHandler,
    pub ctxt: xmlSchemaValidCtxtPtr,
}
pub type C2RustUnnamed_2 = u32;
pub const XML_PATTERN_XPATH: C2RustUnnamed_2 = 1;
pub const XML_PATTERN_DEFAULT: C2RustUnnamed_2 = 0;
static mut xmlSchemaNs: *const xmlChar = b"http://www.w3.org/2001/XMLSchema\0"
    as *const u8 as *const i8 as *const xmlChar;
static mut xmlSchemaInstanceNs: *const xmlChar = b"http://www.w3.org/2001/XMLSchema-instance\0"
    as *const u8 as *const i8 as *const xmlChar;
static mut xmlNamespaceNs: *const xmlChar = b"http://www.w3.org/2000/xmlns/\0"
    as *const u8 as *const i8 as *const xmlChar;
 extern "C" fn xmlSchemaItemTypeToStr(
    mut type_0: xmlSchemaTypeType,
) -> *const xmlChar {
    match type_0 as u32 {
        1 => {
            return b"simple type definition\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
        4 => {
            return b"simple type definition\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
        5 => {
            return b"complex type definition\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
        14 => {
            return b"element declaration\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
        26 => {
            return b"attribute use\0" as *const u8 as *const i8 as *mut xmlChar;
        }
        15 => {
            return b"attribute declaration\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
        17 => {
            return b"model group definition\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
        16 => {
            return b"attribute group definition\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
        18 => {
            return b"notation declaration\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
        6 => {
            return b"model group (sequence)\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
        7 => {
            return b"model group (choice)\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
        8 => {
            return b"model group (all)\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
        25 => return b"particle\0" as *const u8 as *const i8 as *mut xmlChar,
        22 => {
            return b"unique identity-constraint\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
        23 => {
            return b"key identity-constraint\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
        24 => {
            return b"keyref identity-constraint\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
        2 => {
            return b"wildcard (any)\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
        2000 => {
            return b"[helper component] QName reference\0" as *const u8
                as *const i8 as *mut xmlChar;
        }
        2001 => {
            return b"[helper component] attribute use prohibition\0" as *const u8
                as *const i8 as *mut xmlChar;
        }
        _ => {
            return b"Not a schema component\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
    };
}
unsafe extern "C" fn xmlSchemaGetComponentTypeStr(
    mut item: xmlSchemaBasicItemPtr,
) -> *const xmlChar {
    match (*item).type_0 as u32 {
        1 => {
            if (*(item as xmlSchemaTypePtr)).type_0 as u32
                == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                || (*(item as xmlSchemaTypePtr)).builtInType
                    == XML_SCHEMAS_ANYTYPE as i32
            {
                return b"complex type definition\0" as *const u8 as *const i8
                    as *mut xmlChar
            } else {
                return b"simple type definition\0" as *const u8 as *const i8
                    as *mut xmlChar
            }
        }
        _ => return xmlSchemaItemTypeToStr((*item).type_0),
    };
}
unsafe extern "C" fn xmlSchemaGetComponentNode(
    mut item: xmlSchemaBasicItemPtr,
) -> xmlNodePtr {
    match (*item).type_0 as u32 {
        14 => return (*(item as xmlSchemaElementPtr)).node,
        15 => return (*(item as xmlSchemaAttributePtr)).node,
        5 | 4 => return (*(item as xmlSchemaTypePtr)).node,
        2 | 21 => return (*(item as xmlSchemaWildcardPtr)).node,
        25 => return (*(item as xmlSchemaParticlePtr)).node,
        6 | 7 | 8 => return (*(item as xmlSchemaModelGroupPtr)).node,
        17 => return (*(item as xmlSchemaModelGroupDefPtr)).node,
        16 => return (*(item as xmlSchemaAttributeGroupPtr)).node,
        22 | 23 | 24 => return (*(item as xmlSchemaIDCPtr)).node,
        2000 => return (*(item as xmlSchemaQNameRefPtr)).node,
        26 => return (*(item as xmlSchemaAttributeUsePtr)).node,
        _ => return 0 as xmlNodePtr,
    };
}
unsafe extern "C" fn xmlSchemaFormatQName(
    mut buf: *mut *mut xmlChar,
    mut namespaceName: *const xmlChar,
    mut localName: *const xmlChar,
) -> *const xmlChar {
    if !(*buf).is_null() {
        xmlFree.expect("non-null function pointer")(*buf as *mut libc::c_void);
        *buf = 0 as *mut xmlChar;
    }
    if !namespaceName.is_null() {
        *buf = xmlStrdup(b"{\0" as *const u8 as *const i8 as *mut xmlChar);
        *buf = xmlStrcat(*buf, namespaceName);
        *buf = xmlStrcat(
            *buf,
            b"}\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    if !localName.is_null() {
        if namespaceName.is_null() {
            return localName;
        }
        *buf = xmlStrcat(*buf, localName);
    } else {
        *buf = xmlStrcat(
            *buf,
            b"(NULL)\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    return *buf as *const xmlChar;
}
unsafe extern "C" fn xmlSchemaFormatQNameNs(
    mut buf: *mut *mut xmlChar,
    mut ns: xmlNsPtr,
    mut localName: *const xmlChar,
) -> *const xmlChar {
    if !ns.is_null() {
        return xmlSchemaFormatQName(buf, (*ns).href, localName)
    } else {
        return xmlSchemaFormatQName(buf, 0 as *const xmlChar, localName)
    };
}
unsafe extern "C" fn xmlSchemaGetComponentName(
    mut item: xmlSchemaBasicItemPtr,
) -> *const xmlChar {
    if item.is_null() {
        return 0 as *const xmlChar;
    }
    match (*item).type_0 as u32 {
        14 => return (*(item as xmlSchemaElementPtr)).name,
        15 => return (*(item as xmlSchemaAttributePtr)).name,
        16 => return (*(item as xmlSchemaAttributeGroupPtr)).name,
        1 | 4 | 5 => return (*(item as xmlSchemaTypePtr)).name,
        17 => return (*(item as xmlSchemaModelGroupDefPtr)).name,
        23 | 22 | 24 => return (*(item as xmlSchemaIDCPtr)).name,
        26 => {
            if !((*(item as xmlSchemaAttributeUsePtr)).attrDecl).is_null() {
                return xmlSchemaGetComponentName(
                    (*(item as xmlSchemaAttributeUsePtr)).attrDecl
                        as xmlSchemaBasicItemPtr,
                )
            } else {
                return 0 as *const xmlChar
            }
        }
        2000 => return (*(item as xmlSchemaQNameRefPtr)).name,
        18 => return (*(item as xmlSchemaNotationPtr)).name,
        _ => {}
    }
    return 0 as *const xmlChar;
}
unsafe extern "C" fn xmlSchemaGetComponentTargetNs(
    mut item: xmlSchemaBasicItemPtr,
) -> *const xmlChar {
    if item.is_null() {
        return 0 as *const xmlChar;
    }
    match (*item).type_0 as u32 {
        14 => return (*(item as xmlSchemaElementPtr)).targetNamespace,
        15 => return (*(item as xmlSchemaAttributePtr)).targetNamespace,
        16 => return (*(item as xmlSchemaAttributeGroupPtr)).targetNamespace,
        1 => {
            return b"http://www.w3.org/2001/XMLSchema\0" as *const u8
                as *const i8 as *mut xmlChar;
        }
        4 | 5 => return (*(item as xmlSchemaTypePtr)).targetNamespace,
        17 => return (*(item as xmlSchemaModelGroupDefPtr)).targetNamespace,
        23 | 22 | 24 => return (*(item as xmlSchemaIDCPtr)).targetNamespace,
        26 => {
            if !((*(item as xmlSchemaAttributeUsePtr)).attrDecl).is_null() {
                return xmlSchemaGetComponentTargetNs(
                    (*(item as xmlSchemaAttributeUsePtr)).attrDecl
                        as xmlSchemaBasicItemPtr,
                );
            }
        }
        2000 => return (*(item as xmlSchemaQNameRefPtr)).targetNamespace,
        18 => return (*(item as xmlSchemaNotationPtr)).targetNamespace,
        _ => {}
    }
    return 0 as *const xmlChar;
}
unsafe extern "C" fn xmlSchemaGetComponentQName(
    mut buf: *mut *mut xmlChar,
    mut item: *mut libc::c_void,
) -> *const xmlChar {
    return xmlSchemaFormatQName(
        buf,
        xmlSchemaGetComponentTargetNs(item as xmlSchemaBasicItemPtr),
        xmlSchemaGetComponentName(item as xmlSchemaBasicItemPtr),
    );
}
unsafe extern "C" fn xmlSchemaGetComponentDesignation(
    mut buf: *mut *mut xmlChar,
    mut item: *mut libc::c_void,
) -> *const xmlChar {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    *buf = xmlStrcat(*buf, xmlSchemaGetComponentTypeStr(item as xmlSchemaBasicItemPtr));
    *buf = xmlStrcat(*buf, b" '\0" as *const u8 as *const i8 as *mut xmlChar);
    *buf = xmlStrcat(
        *buf,
        xmlSchemaGetComponentQName(
            &mut str,
            item as xmlSchemaBasicItemPtr as *mut libc::c_void,
        ),
    );
    *buf = xmlStrcat(*buf, b"'\0" as *const u8 as *const i8 as *mut xmlChar);
    if !str.is_null() {
        xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
        str = 0 as *mut xmlChar;
    }
    return *buf;
}
unsafe extern "C" fn xmlSchemaGetIDCDesignation(
    mut buf: *mut *mut xmlChar,
    mut idc: xmlSchemaIDCPtr,
) -> *const xmlChar {
    return xmlSchemaGetComponentDesignation(buf, idc as *mut libc::c_void);
}
 extern "C" fn xmlSchemaWildcardPCToString(mut pc: i32) -> *const xmlChar {
    match pc {
        1 => return b"skip\0" as *const u8 as *const i8 as *mut xmlChar,
        2 => return b"lax\0" as *const u8 as *const i8 as *mut xmlChar,
        3 => return b"strict\0" as *const u8 as *const i8 as *mut xmlChar,
        _ => {
            return b"invalid process contents\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
    };
}
unsafe extern "C" fn xmlSchemaGetCanonValueWhtspExt_1(
    mut val: xmlSchemaValPtr,
    mut ws: xmlSchemaWhitespaceValueType,
    mut retValue: *mut *mut xmlChar,
    mut for_hash: i32,
) -> i32 {
    let mut current_block: u64;
    let mut list: i32 = 0;
    let mut valType: xmlSchemaValType = XML_SCHEMAS_UNKNOWN;
    let mut value: *const xmlChar = 0 as *const xmlChar;
    let mut value2: *const xmlChar = 0 as *const xmlChar;
    if retValue.is_null() || val.is_null() {
        return -(1 as i32);
    }
    list = if !(xmlSchemaValueGetNext(val)).is_null() {
        1 as i32
    } else {
        0 as i32
    };
    *retValue = 0 as *mut xmlChar;
    loop {
        value = 0 as *const xmlChar;
        valType = xmlSchemaGetValType(val);
        match valType as u32 {
            1 | 2 | 46 => {
                value = xmlSchemaValueGetAsString(val);
                if !value.is_null() {
                    if ws as u32
                        == XML_SCHEMA_WHITESPACE_COLLAPSE as i32 as u32
                    {
                        value2 = xmlSchemaCollapseString(value);
                    } else if ws as u32
                            == XML_SCHEMA_WHITESPACE_REPLACE as i32
                                as u32
                        {
                        value2 = xmlSchemaWhiteSpaceReplace(value);
                    }
                    if !value2.is_null() {
                        value = value2;
                    }
                }
            }
            _ => {
                if xmlSchemaGetCanonValue(val, &mut value2) == -(1 as i32) {
                    if !value2.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(value2 as *mut xmlChar as *mut libc::c_void);
                    }
                    current_block = 11962130098811163542;
                    break;
                } else {
                    if for_hash != 0
                        && valType as u32
                            == XML_SCHEMAS_DECIMAL as i32 as u32
                    {
                        let mut len: i32 = xmlStrlen(value2);
                        if len > 2 as i32
                            && *value2.offset((len - 1 as i32) as isize)
                                as i32 == '0' as i32
                            && *value2.offset((len - 2 as i32) as isize)
                                as i32 == '.' as i32
                        {
                            *(value2 as *mut xmlChar)
                                .offset(
                                    (len - 2 as i32) as isize,
                                ) = 0 as i32 as xmlChar;
                        }
                    }
                    value = value2;
                }
            }
        }
        if (*retValue).is_null() {
            if value.is_null() {
                if list == 0 {
                    *retValue = xmlStrdup(
                        b"\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                }
            } else {
                *retValue = xmlStrdup(value);
            }
        } else if !value.is_null() {
            *retValue = xmlStrcat(
                *retValue,
                b" \0" as *const u8 as *const i8 as *mut xmlChar,
            );
            *retValue = xmlStrcat(*retValue, value);
        }
        if !value2.is_null() {
            xmlFree
                .expect(
                    "non-null function pointer",
                )(value2 as *mut xmlChar as *mut libc::c_void);
            value2 = 0 as *const xmlChar;
        }
        val = xmlSchemaValueGetNext(val);
        if val.is_null() {
            current_block = 3222590281903869779;
            break;
        }
    }
    match current_block {
        3222590281903869779 => return 0 as i32,
        _ => {
            if !(*retValue).is_null() {
                xmlFree
                    .expect("non-null function pointer")(*retValue as *mut libc::c_void);
            }
            if !value2.is_null() {
                xmlFree
                    .expect(
                        "non-null function pointer",
                    )(value2 as *mut xmlChar as *mut libc::c_void);
            }
            return -(1 as i32);
        }
    };
}
unsafe extern "C" fn xmlSchemaGetCanonValueWhtspExt(
    mut val: xmlSchemaValPtr,
    mut ws: xmlSchemaWhitespaceValueType,
    mut retValue: *mut *mut xmlChar,
) -> i32 {
    return xmlSchemaGetCanonValueWhtspExt_1(val, ws, retValue, 0 as i32);
}
unsafe extern "C" fn xmlSchemaGetCanonValueHash(
    mut val: xmlSchemaValPtr,
    mut retValue: *mut *mut xmlChar,
) -> i32 {
    return xmlSchemaGetCanonValueWhtspExt_1(
        val,
        XML_SCHEMA_WHITESPACE_COLLAPSE,
        retValue,
        1 as i32,
    );
}
unsafe extern "C" fn xmlSchemaFormatItemForReport(
    mut buf: *mut *mut xmlChar,
    mut itemDes: *const xmlChar,
    mut item: xmlSchemaBasicItemPtr,
    mut itemNode: xmlNodePtr,
) -> *mut xmlChar {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut named: i32 = 1 as i32;
    if !(*buf).is_null() {
        xmlFree.expect("non-null function pointer")(*buf as *mut libc::c_void);
        *buf = 0 as *mut xmlChar;
    }
    if !itemDes.is_null() {
        *buf = xmlStrdup(itemDes);
    } else if !item.is_null() {
        let mut current_block_107: u64;
        match (*item).type_0 as u32 {
            1 => {
                let mut type_0: xmlSchemaTypePtr = item as xmlSchemaTypePtr;
                if (*type_0).flags & (1 as i32) << 8 as i32 != 0 {
                    *buf = xmlStrdup(
                        b"atomic type 'xs:\0" as *const u8 as *const i8
                            as *mut xmlChar,
                    );
                } else if (*type_0).flags & (1 as i32) << 6 as i32 != 0 {
                    *buf = xmlStrdup(
                        b"list type 'xs:\0" as *const u8 as *const i8
                            as *mut xmlChar,
                    );
                } else if (*type_0).flags & (1 as i32) << 7 as i32 != 0 {
                    *buf = xmlStrdup(
                        b"union type 'xs:\0" as *const u8 as *const i8
                            as *mut xmlChar,
                    );
                } else {
                    *buf = xmlStrdup(
                        b"simple type 'xs:\0" as *const u8 as *const i8
                            as *mut xmlChar,
                    );
                }
                *buf = xmlStrcat(*buf, (*type_0).name);
                *buf = xmlStrcat(
                    *buf,
                    b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            }
            4 => {
                let mut type_1: xmlSchemaTypePtr = item as xmlSchemaTypePtr;
                if (*type_1).flags & (1 as i32) << 3 as i32 != 0 {
                    *buf = xmlStrdup(
                        b"\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                } else {
                    *buf = xmlStrdup(
                        b"local \0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                }
                if (*type_1).flags & (1 as i32) << 8 as i32 != 0 {
                    *buf = xmlStrcat(
                        *buf,
                        b"atomic type\0" as *const u8 as *const i8
                            as *mut xmlChar,
                    );
                } else if (*type_1).flags & (1 as i32) << 6 as i32 != 0 {
                    *buf = xmlStrcat(
                        *buf,
                        b"list type\0" as *const u8 as *const i8
                            as *mut xmlChar,
                    );
                } else if (*type_1).flags & (1 as i32) << 7 as i32 != 0 {
                    *buf = xmlStrcat(
                        *buf,
                        b"union type\0" as *const u8 as *const i8
                            as *mut xmlChar,
                    );
                } else {
                    *buf = xmlStrcat(
                        *buf,
                        b"simple type\0" as *const u8 as *const i8
                            as *mut xmlChar,
                    );
                }
                if (*type_1).flags & (1 as i32) << 3 as i32 != 0 {
                    *buf = xmlStrcat(
                        *buf,
                        b" '\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                    *buf = xmlStrcat(*buf, (*type_1).name);
                    *buf = xmlStrcat(
                        *buf,
                        b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                }
                current_block_107 = 13253659531982233645;
            }
            5 => {
                let mut type_2: xmlSchemaTypePtr = item as xmlSchemaTypePtr;
                if (*type_2).flags & (1 as i32) << 3 as i32 != 0 {
                    *buf = xmlStrdup(
                        b"\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                } else {
                    *buf = xmlStrdup(
                        b"local \0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                }
                *buf = xmlStrcat(
                    *buf,
                    b"complex type\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                if (*type_2).flags & (1 as i32) << 3 as i32 != 0 {
                    *buf = xmlStrcat(
                        *buf,
                        b" '\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                    *buf = xmlStrcat(*buf, (*type_2).name);
                    *buf = xmlStrcat(
                        *buf,
                        b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                }
                current_block_107 = 13253659531982233645;
            }
            26 => {
                let mut ause: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
                ause = item as xmlSchemaAttributeUsePtr;
                *buf = xmlStrdup(
                    b"attribute use \0" as *const u8 as *const i8
                        as *mut xmlChar,
                );
                if !((*ause).attrDecl).is_null() {
                    *buf = xmlStrcat(
                        *buf,
                        b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                    *buf = xmlStrcat(
                        *buf,
                        xmlSchemaGetComponentQName(
                            &mut str,
                            (*ause).attrDecl as *mut libc::c_void,
                        ),
                    );
                    if !str.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str as *mut libc::c_void);
                        str = 0 as *mut xmlChar;
                    }
                    *buf = xmlStrcat(
                        *buf,
                        b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                } else {
                    *buf = xmlStrcat(
                        *buf,
                        b"(unknown)\0" as *const u8 as *const i8
                            as *mut xmlChar,
                    );
                }
                current_block_107 = 13253659531982233645;
            }
            15 => {
                let mut attr: xmlSchemaAttributePtr = 0 as *mut xmlSchemaAttribute;
                attr = item as xmlSchemaAttributePtr;
                *buf = xmlStrdup(
                    b"attribute decl.\0" as *const u8 as *const i8
                        as *mut xmlChar,
                );
                *buf = xmlStrcat(
                    *buf,
                    b" '\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                *buf = xmlStrcat(
                    *buf,
                    xmlSchemaFormatQName(&mut str, (*attr).targetNamespace, (*attr).name),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                *buf = xmlStrcat(
                    *buf,
                    b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            }
            16 => {
                xmlSchemaGetComponentDesignation(buf, item as *mut libc::c_void);
                current_block_107 = 13253659531982233645;
            }
            14 => {
                let mut elem: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
                elem = item as xmlSchemaElementPtr;
                *buf = xmlStrdup(
                    b"element decl.\0" as *const u8 as *const i8
                        as *mut xmlChar,
                );
                *buf = xmlStrcat(
                    *buf,
                    b" '\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                *buf = xmlStrcat(
                    *buf,
                    xmlSchemaFormatQName(&mut str, (*elem).targetNamespace, (*elem).name),
                );
                *buf = xmlStrcat(
                    *buf,
                    b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            }
            22 | 23 | 24 => {
                if (*item).type_0 as u32
                    == XML_SCHEMA_TYPE_IDC_UNIQUE as i32 as u32
                {
                    *buf = xmlStrdup(
                        b"unique '\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                } else if (*item).type_0 as u32
                        == XML_SCHEMA_TYPE_IDC_KEY as i32 as u32
                    {
                    *buf = xmlStrdup(
                        b"key '\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                } else {
                    *buf = xmlStrdup(
                        b"keyRef '\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                }
                *buf = xmlStrcat(*buf, (*(item as xmlSchemaIDCPtr)).name);
                *buf = xmlStrcat(
                    *buf,
                    b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            }
            2 | 21 => {
                *buf = xmlStrdup(
                    xmlSchemaWildcardPCToString(
                        (*(item as xmlSchemaWildcardPtr)).processContents,
                    ),
                );
                *buf = xmlStrcat(
                    *buf,
                    b" wildcard\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            }
            1000 | 1001 | 1002 | 1003 | 1004 | 1005 | 1006 | 1007 | 1008 | 1009 | 1010
            | 1011 => {
                *buf = xmlStrdup(
                    b"facet '\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                *buf = xmlStrcat(*buf, xmlSchemaFacetTypeToString((*item).type_0));
                *buf = xmlStrcat(
                    *buf,
                    b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            }
            17 => {
                *buf = xmlStrdup(
                    b"model group def.\0" as *const u8 as *const i8
                        as *mut xmlChar,
                );
                *buf = xmlStrcat(
                    *buf,
                    b" '\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                *buf = xmlStrcat(
                    *buf,
                    xmlSchemaGetComponentQName(&mut str, item as *mut libc::c_void),
                );
                *buf = xmlStrcat(
                    *buf,
                    b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                current_block_107 = 13253659531982233645;
            }
            6 | 7 | 8 | 25 => {
                *buf = xmlStrdup(xmlSchemaGetComponentTypeStr(item));
                current_block_107 = 13253659531982233645;
            }
            18 => {
                *buf = xmlStrdup(xmlSchemaGetComponentTypeStr(item));
                *buf = xmlStrcat(
                    *buf,
                    b" '\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                *buf = xmlStrcat(
                    *buf,
                    xmlSchemaGetComponentQName(&mut str, item as *mut libc::c_void),
                );
                *buf = xmlStrcat(
                    *buf,
                    b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                current_block_107 = 2993333835388634117;
            }
            _ => {
                current_block_107 = 2993333835388634117;
            }
        }
        match current_block_107 {
            2993333835388634117 => {
                named = 0 as i32;
            }
            _ => {}
        }
    } else {
        named = 0 as i32;
    }
    if named == 0 as i32 && !itemNode.is_null() {
        let mut elem_0: xmlNodePtr = 0 as *mut xmlNode;
        if (*itemNode).type_0 as u32
            == XML_ATTRIBUTE_NODE as i32 as u32
        {
            elem_0 = (*itemNode).parent;
        } else {
            elem_0 = itemNode;
        }
        *buf = xmlStrdup(
            b"Element '\0" as *const u8 as *const i8 as *mut xmlChar,
        );
        if !((*elem_0).ns).is_null() {
            *buf = xmlStrcat(
                *buf,
                xmlSchemaFormatQName(&mut str, (*(*elem_0).ns).href, (*elem_0).name),
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
        } else {
            *buf = xmlStrcat(*buf, (*elem_0).name);
        }
        *buf = xmlStrcat(
            *buf,
            b"'\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    if !itemNode.is_null()
        && (*itemNode).type_0 as u32
            == XML_ATTRIBUTE_NODE as i32 as u32
    {
        *buf = xmlStrcat(
            *buf,
            b", attribute '\0" as *const u8 as *const i8 as *mut xmlChar,
        );
        if !((*itemNode).ns).is_null() {
            *buf = xmlStrcat(
                *buf,
                xmlSchemaFormatQName(&mut str, (*(*itemNode).ns).href, (*itemNode).name),
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
        } else {
            *buf = xmlStrcat(*buf, (*itemNode).name);
        }
        *buf = xmlStrcat(
            *buf,
            b"'\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    if !str.is_null() {
        xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
        str = 0 as *mut xmlChar;
    }
    return xmlEscapeFormatString(buf);
}
unsafe extern "C" fn xmlSchemaFormatFacetEnumSet(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut buf: *mut *mut xmlChar,
    mut type_0: xmlSchemaTypePtr,
) -> *const xmlChar {
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut ws: xmlSchemaWhitespaceValueType = XML_SCHEMA_WHITESPACE_UNKNOWN;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut res: i32 = 0;
    let mut found: i32 = 0 as i32;
    if !(*buf).is_null() {
        xmlFree.expect("non-null function pointer")(*buf as *mut libc::c_void);
    }
    *buf = 0 as *mut xmlChar;
    loop {
        ws = xmlSchemaGetWhiteSpaceFacetValue((*type_0).baseType);
        facet = (*type_0).facets;
        while !facet.is_null() {
            if !((*facet).type_0 as u32
                != XML_SCHEMA_FACET_ENUMERATION as i32 as u32)
            {
                found = 1 as i32;
                res = xmlSchemaGetCanonValueWhtspExt((*facet).val, ws, &mut value);
                if res == -(1 as i32) {
                    xmlSchemaInternalErr(
                        actxt,
                        b"xmlSchemaFormatFacetEnumSet\0" as *const u8
                            as *const i8,
                        b"compute the canonical lexical representation\0" as *const u8
                            as *const i8,
                    );
                    if !(*buf).is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(*buf as *mut libc::c_void);
                    }
                    *buf = 0 as *mut xmlChar;
                    return 0 as *const xmlChar;
                }
                if (*buf).is_null() {
                    *buf = xmlStrdup(
                        b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                } else {
                    *buf = xmlStrcat(
                        *buf,
                        b", '\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                }
                *buf = xmlStrcat(*buf, value);
                *buf = xmlStrcat(
                    *buf,
                    b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                if !value.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(value as *mut libc::c_void);
                    value = 0 as *mut xmlChar;
                }
            }
            facet = (*facet).next;
        }
        if found != 0 {
            break;
        }
        type_0 = (*type_0).baseType;
        if !(!type_0.is_null()
            && (*type_0).type_0 as u32
                != XML_SCHEMA_TYPE_BASIC as i32 as u32)
        {
            break;
        }
    }
    return *buf as *const xmlChar;
}
unsafe extern "C" fn xmlSchemaPSimpleErr(mut msg: *const i8) {
    __xmlSimpleError(
        XML_FROM_SCHEMASP as i32,
        XML_ERR_NO_MEMORY as i32,
        0 as xmlNodePtr,
        0 as *const i8,
        msg,
    );
}
unsafe extern "C" fn xmlSchemaPErrMemory(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut extra: *const i8,
    mut node: xmlNodePtr,
) {
    if !ctxt.is_null() {
        let fresh0 = &mut ((*ctxt).nberrors);
        *fresh0 += 1;
    }
    __xmlSimpleError(
        XML_FROM_SCHEMASP as i32,
        XML_ERR_NO_MEMORY as i32,
        node,
        0 as *const i8,
        extra,
    );
}
unsafe extern "C" fn xmlSchemaPErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut error: i32,
    mut msg: *const i8,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
) {
    let mut channel: xmlGenericErrorFunc = None;
    let mut schannel: xmlStructuredErrorFunc = None;
    let mut data: *mut libc::c_void = 0 as *mut libc::c_void;
    if !ctxt.is_null() {
        let fresh1 = &mut ((*ctxt).nberrors);
        *fresh1 += 1;
        (*ctxt).err = error;
        channel = (*ctxt).error;
        data = (*ctxt).errCtxt;
        schannel = (*ctxt).serror;
    }
    __xmlRaiseError(
        schannel,
        channel,
        data,
        ctxt as *mut libc::c_void,
        node as *mut libc::c_void,
        XML_FROM_SCHEMASP as i32,
        error,
        XML_ERR_ERROR,
        0 as *const i8,
        0 as i32,
        str1 as *const i8,
        str2 as *const i8,
        0 as *const i8,
        0 as i32,
        0 as i32,
        msg,
        str1,
        str2,
    );
}
unsafe extern "C" fn xmlSchemaPErr2(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut child: xmlNodePtr,
    mut error: i32,
    mut msg: *const i8,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
) {
    if !child.is_null() {
        xmlSchemaPErr(ctxt, child, error, msg, str1, str2);
    } else {
        xmlSchemaPErr(ctxt, node, error, msg, str1, str2);
    };
}
unsafe extern "C" fn xmlSchemaPErrExt(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut error: i32,
    mut strData1: *const xmlChar,
    mut strData2: *const xmlChar,
    mut strData3: *const xmlChar,
    mut msg: *const i8,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
    mut str3: *const xmlChar,
    mut str4: *const xmlChar,
    mut str5: *const xmlChar,
) {
    let mut channel: xmlGenericErrorFunc = None;
    let mut schannel: xmlStructuredErrorFunc = None;
    let mut data: *mut libc::c_void = 0 as *mut libc::c_void;
    if !ctxt.is_null() {
        let fresh2 = &mut ((*ctxt).nberrors);
        *fresh2 += 1;
        (*ctxt).err = error;
        channel = (*ctxt).error;
        data = (*ctxt).errCtxt;
        schannel = (*ctxt).serror;
    }
    __xmlRaiseError(
        schannel,
        channel,
        data,
        ctxt as *mut libc::c_void,
        node as *mut libc::c_void,
        XML_FROM_SCHEMASP as i32,
        error,
        XML_ERR_ERROR,
        0 as *const i8,
        0 as i32,
        strData1 as *const i8,
        strData2 as *const i8,
        strData3 as *const i8,
        0 as i32,
        0 as i32,
        msg,
        str1,
        str2,
        str3,
        str4,
        str5,
    );
}
unsafe extern "C" fn xmlSchemaVErrMemory(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut extra: *const i8,
    mut node: xmlNodePtr,
) {
    if !ctxt.is_null() {
        let fresh3 = &mut ((*ctxt).nberrors);
        *fresh3 += 1;
        (*ctxt).err = XML_SCHEMAV_INTERNAL as i32;
    }
    __xmlSimpleError(
        XML_FROM_SCHEMASV as i32,
        XML_ERR_NO_MEMORY as i32,
        node,
        0 as *const i8,
        extra,
    );
}
unsafe extern "C" fn xmlSchemaPSimpleInternalErr(
    mut node: xmlNodePtr,
    mut msg: *const i8,
    mut str: *const xmlChar,
) {
    __xmlSimpleError(
        XML_FROM_SCHEMASP as i32,
        XML_SCHEMAP_INTERNAL as i32,
        node,
        msg,
        str as *const i8,
    );
}
unsafe extern "C" fn xmlSchemaErr4Line(
    mut ctxt: xmlSchemaAbstractCtxtPtr,
    mut errorLevel: xmlErrorLevel,
    mut error: i32,
    mut node: xmlNodePtr,
    mut line: i32,
    mut msg: *const i8,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
    mut str3: *const xmlChar,
    mut str4: *const xmlChar,
) {
    let mut schannel: xmlStructuredErrorFunc = None;
    let mut channel: xmlGenericErrorFunc = None;
    let mut data: *mut libc::c_void = 0 as *mut libc::c_void;
    if !ctxt.is_null() {
        if (*ctxt).type_0 == 2 as i32 {
            let mut vctxt: xmlSchemaValidCtxtPtr = ctxt as xmlSchemaValidCtxtPtr;
            let mut file: *const i8 = 0 as *const i8;
            let mut col: i32 = 0 as i32;
            if errorLevel as u32
                != XML_ERR_WARNING as i32 as u32
            {
                let fresh4 = &mut ((*vctxt).nberrors);
                *fresh4 += 1;
                (*vctxt).err = error;
                channel = (*vctxt).error;
            } else {
                channel = (*vctxt).warning;
            }
            schannel = (*vctxt).serror;
            data = (*vctxt).errCtxt;
            if line == 0 as i32 {
                if node.is_null() && (*vctxt).depth >= 0 as i32
                    && !((*vctxt).inode).is_null()
                {
                    node = (*(*vctxt).inode).node;
                }
                if node.is_null() && !((*vctxt).parserCtxt).is_null()
                    && !((*(*vctxt).parserCtxt).input).is_null()
                {
                    file = (*(*(*vctxt).parserCtxt).input).filename;
                    line = (*(*(*vctxt).parserCtxt).input).line;
                    col = (*(*(*vctxt).parserCtxt).input).col;
                }
            } else {
                node = 0 as xmlNodePtr;
                if !((*vctxt).doc).is_null() {
                    file = (*(*vctxt).doc).URL as *const i8;
                } else if !((*vctxt).parserCtxt).is_null()
                        && !((*(*vctxt).parserCtxt).input).is_null()
                    {
                    file = (*(*(*vctxt).parserCtxt).input).filename;
                }
            }
            if ((*vctxt).locFunc).is_some() {
                if file.is_null() || line == 0 as i32 {
                    let mut l: u64 = 0;
                    let mut f: *const i8 = 0 as *const i8;
                    ((*vctxt).locFunc)
                        .expect(
                            "non-null function pointer",
                        )((*vctxt).locCtxt, &mut f, &mut l);
                    if file.is_null() {
                        file = f;
                    }
                    if line == 0 as i32 {
                        line = l as i32;
                    }
                }
            }
            if file.is_null() && !((*vctxt).filename).is_null() {
                file = (*vctxt).filename;
            }
            __xmlRaiseError(
                schannel,
                channel,
                data,
                ctxt as *mut libc::c_void,
                node as *mut libc::c_void,
                XML_FROM_SCHEMASV as i32,
                error,
                errorLevel,
                file,
                line,
                str1 as *const i8,
                str2 as *const i8,
                str3 as *const i8,
                0 as i32,
                col,
                msg,
                str1,
                str2,
                str3,
                str4,
            );
        } else if (*ctxt).type_0 == 1 as i32 {
            let mut pctxt: xmlSchemaParserCtxtPtr = ctxt as xmlSchemaParserCtxtPtr;
            if errorLevel as u32
                != XML_ERR_WARNING as i32 as u32
            {
                let fresh5 = &mut ((*pctxt).nberrors);
                *fresh5 += 1;
                (*pctxt).err = error;
                channel = (*pctxt).error;
            } else {
                channel = (*pctxt).warning;
            }
            schannel = (*pctxt).serror;
            data = (*pctxt).errCtxt;
            __xmlRaiseError(
                schannel,
                channel,
                data,
                ctxt as *mut libc::c_void,
                node as *mut libc::c_void,
                XML_FROM_SCHEMASP as i32,
                error,
                errorLevel,
                0 as *const i8,
                0 as i32,
                str1 as *const i8,
                str2 as *const i8,
                str3 as *const i8,
                0 as i32,
                0 as i32,
                msg,
                str1,
                str2,
                str3,
                str4,
            );
        } else {
            (*__xmlGenericError())
                .expect(
                    "non-null function pointer",
                )(
                *__xmlGenericErrorContext(),
                b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
                b"xmlschemas.c\0" as *const u8 as *const i8,
                2188 as i32,
            );
        }
    }
}
unsafe extern "C" fn xmlSchemaErr3(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: i32,
    mut node: xmlNodePtr,
    mut msg: *const i8,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
    mut str3: *const xmlChar,
) {
    xmlSchemaErr4Line(
        actxt,
        XML_ERR_ERROR,
        error,
        node,
        0 as i32,
        msg,
        str1,
        str2,
        str3,
        0 as *const xmlChar,
    );
}
unsafe extern "C" fn xmlSchemaErr4(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: i32,
    mut node: xmlNodePtr,
    mut msg: *const i8,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
    mut str3: *const xmlChar,
    mut str4: *const xmlChar,
) {
    xmlSchemaErr4Line(
        actxt,
        XML_ERR_ERROR,
        error,
        node,
        0 as i32,
        msg,
        str1,
        str2,
        str3,
        str4,
    );
}
unsafe extern "C" fn xmlSchemaErr(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: i32,
    mut node: xmlNodePtr,
    mut msg: *const i8,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
) {
    xmlSchemaErr4(
        actxt,
        error,
        node,
        msg,
        str1,
        str2,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
}
unsafe extern "C" fn xmlSchemaFormatNodeForError(
    mut msg: *mut *mut xmlChar,
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut node: xmlNodePtr,
) -> *mut xmlChar {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    *msg = 0 as *mut xmlChar;
    if !node.is_null()
        && (*node).type_0 as u32
            != XML_ELEMENT_NODE as i32 as u32
        && (*node).type_0 as u32
            != XML_ATTRIBUTE_NODE as i32 as u32
    {
        *msg = xmlStrdup(b"\0" as *const u8 as *const i8 as *mut xmlChar);
        return *msg;
    }
    if !node.is_null() {
        if (*node).type_0 as u32
            == XML_ATTRIBUTE_NODE as i32 as u32
        {
            let mut elem: xmlNodePtr = (*node).parent;
            *msg = xmlStrdup(
                b"Element '\0" as *const u8 as *const i8 as *mut xmlChar,
            );
            if !((*elem).ns).is_null() {
                *msg = xmlStrcat(
                    *msg,
                    xmlSchemaFormatQName(&mut str, (*(*elem).ns).href, (*elem).name),
                );
            } else {
                *msg = xmlStrcat(
                    *msg,
                    xmlSchemaFormatQName(&mut str, 0 as *const xmlChar, (*elem).name),
                );
            }
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
            *msg = xmlStrcat(
                *msg,
                b"', \0" as *const u8 as *const i8 as *mut xmlChar,
            );
            *msg = xmlStrcat(
                *msg,
                b"attribute '\0" as *const u8 as *const i8 as *mut xmlChar,
            );
        } else {
            *msg = xmlStrdup(
                b"Element '\0" as *const u8 as *const i8 as *mut xmlChar,
            );
        }
        if !((*node).ns).is_null() {
            *msg = xmlStrcat(
                *msg,
                xmlSchemaFormatQName(&mut str, (*(*node).ns).href, (*node).name),
            );
        } else {
            *msg = xmlStrcat(
                *msg,
                xmlSchemaFormatQName(&mut str, 0 as *const xmlChar, (*node).name),
            );
        }
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
        *msg = xmlStrcat(
            *msg,
            b"': \0" as *const u8 as *const i8 as *mut xmlChar,
        );
    } else if (*actxt).type_0 == 2 as i32 {
        let mut vctxt: xmlSchemaValidCtxtPtr = actxt as xmlSchemaValidCtxtPtr;
        if (*(*vctxt).inode).nodeType == XML_ATTRIBUTE_NODE as i32 {
            let mut ielem: xmlSchemaNodeInfoPtr = *((*vctxt).elemInfos)
                .offset((*vctxt).depth as isize);
            *msg = xmlStrdup(
                b"Element '\0" as *const u8 as *const i8 as *mut xmlChar,
            );
            *msg = xmlStrcat(
                *msg,
                xmlSchemaFormatQName(&mut str, (*ielem).nsName, (*ielem).localName),
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
            *msg = xmlStrcat(
                *msg,
                b"', \0" as *const u8 as *const i8 as *mut xmlChar,
            );
            *msg = xmlStrcat(
                *msg,
                b"attribute '\0" as *const u8 as *const i8 as *mut xmlChar,
            );
        } else {
            *msg = xmlStrdup(
                b"Element '\0" as *const u8 as *const i8 as *mut xmlChar,
            );
        }
        *msg = xmlStrcat(
            *msg,
            xmlSchemaFormatQName(
                &mut str,
                (*(*vctxt).inode).nsName,
                (*(*vctxt).inode).localName,
            ),
        );
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
        *msg = xmlStrcat(
            *msg,
            b"': \0" as *const u8 as *const i8 as *mut xmlChar,
        );
    } else if (*actxt).type_0 == 1 as i32 {
        *msg = xmlStrdup(b"\0" as *const u8 as *const i8 as *mut xmlChar);
    } else {
        (*__xmlGenericError())
            .expect(
                "non-null function pointer",
            )(
            *__xmlGenericErrorContext(),
            b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
            b"xmlschemas.c\0" as *const u8 as *const i8,
            2309 as i32,
        );
        return 0 as *mut xmlChar;
    }
    xmlEscapeFormatString(msg);
    return *msg;
}
unsafe extern "C" fn xmlSchemaInternalErr2(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut funcName: *const i8,
    mut message: *const i8,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    if actxt.is_null() {
        return;
    }
    msg = xmlStrdup(
        b"Internal error: %s, \0" as *const u8 as *const i8 as *mut xmlChar,
    );
    msg = xmlStrcat(msg, message as *mut xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const i8 as *mut xmlChar);
    if (*actxt).type_0 == 2 as i32 {
        xmlSchemaErr3(
            actxt,
            XML_SCHEMAV_INTERNAL as i32,
            0 as xmlNodePtr,
            msg as *const i8,
            funcName as *const xmlChar,
            str1,
            str2,
        );
    } else if (*actxt).type_0 == 1 as i32 {
        xmlSchemaErr3(
            actxt,
            XML_SCHEMAP_INTERNAL as i32,
            0 as xmlNodePtr,
            msg as *const i8,
            funcName as *const xmlChar,
            str1,
            str2,
        );
    }
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
        msg = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaInternalErr(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut funcName: *const i8,
    mut message: *const i8,
) {
    xmlSchemaInternalErr2(
        actxt,
        funcName,
        message,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
}
unsafe extern "C" fn xmlSchemaCustomErr4(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: xmlParserErrors,
    mut node: xmlNodePtr,
    mut item: xmlSchemaBasicItemPtr,
    mut message: *const i8,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
    mut str3: *const xmlChar,
    mut str4: *const xmlChar,
) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    if node.is_null() && !item.is_null() && (*actxt).type_0 == 1 as i32 {
        node = xmlSchemaGetComponentNode(item);
        xmlSchemaFormatItemForReport(
            &mut msg,
            0 as *const xmlChar,
            item,
            0 as xmlNodePtr,
        );
        msg = xmlStrcat(
            msg,
            b": \0" as *const u8 as *const i8 as *mut xmlChar,
        );
    } else {
        xmlSchemaFormatNodeForError(&mut msg, actxt, node);
    }
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const i8 as *mut xmlChar);
    xmlSchemaErr4(
        actxt,
        error as i32,
        node,
        msg as *const i8,
        str1,
        str2,
        str3,
        str4,
    );
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
        msg = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaCustomErr(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: xmlParserErrors,
    mut node: xmlNodePtr,
    mut item: xmlSchemaBasicItemPtr,
    mut message: *const i8,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
) {
    xmlSchemaCustomErr4(
        actxt,
        error,
        node,
        item,
        message,
        str1,
        str2,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
}
unsafe extern "C" fn xmlSchemaCustomWarning(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: xmlParserErrors,
    mut node: xmlNodePtr,
    mut type_0: xmlSchemaTypePtr,
    mut message: *const i8,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
    mut str3: *const xmlChar,
) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(&mut msg, actxt, node);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const i8 as *mut xmlChar);
    xmlSchemaErr4Line(
        actxt,
        XML_ERR_WARNING,
        error as i32,
        node,
        0 as i32,
        msg as *const i8,
        str1,
        str2,
        str3,
        0 as *const xmlChar,
    );
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
        msg = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaKeyrefErr(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut error: xmlParserErrors,
    mut idcNode: xmlSchemaPSVIIDCNodePtr,
    mut type_0: xmlSchemaTypePtr,
    mut message: *const i8,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    let mut qname: *mut xmlChar = 0 as *mut xmlChar;
    msg = xmlStrdup(
        b"Element '%s': \0" as *const u8 as *const i8 as *mut xmlChar,
    );
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const i8 as *mut xmlChar);
    xmlSchemaErr4Line(
        vctxt as xmlSchemaAbstractCtxtPtr,
        XML_ERR_ERROR,
        error as i32,
        0 as xmlNodePtr,
        (*idcNode).nodeLine,
        msg as *const i8,
        xmlSchemaFormatQName(
            &mut qname,
            *((*(*vctxt).nodeQNames).items)
                .offset(((*idcNode).nodeQNameID + 1 as i32) as isize)
                as *const xmlChar,
            *((*(*vctxt).nodeQNames).items).offset((*idcNode).nodeQNameID as isize)
                as *const xmlChar,
        ),
        str1,
        str2,
        0 as *const xmlChar,
    );
    if !qname.is_null() {
        xmlFree.expect("non-null function pointer")(qname as *mut libc::c_void);
        qname = 0 as *mut xmlChar;
    }
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
        msg = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaEvalErrorNodeType(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut node: xmlNodePtr,
) -> i32 {
    if !node.is_null() {
        return (*node).type_0 as i32;
    }
    if (*actxt).type_0 == 2 as i32
        && !((*(actxt as xmlSchemaValidCtxtPtr)).inode).is_null()
    {
        return (*(*(actxt as xmlSchemaValidCtxtPtr)).inode).nodeType;
    }
    return -(1 as i32);
}
unsafe extern "C" fn xmlSchemaIsGlobalItem(mut item: xmlSchemaTypePtr) -> i32 {
    match (*item).type_0 as u32 {
        5 | 4 => {
            if (*item).flags & (1 as i32) << 3 as i32 != 0 {
                return 1 as i32;
            }
        }
        17 => return 1 as i32,
        14 => {
            if (*(item as xmlSchemaElementPtr)).flags
                & (1 as i32) << 1 as i32 != 0
            {
                return 1 as i32;
            }
        }
        15 => {
            if (*(item as xmlSchemaAttributePtr)).flags
                & (1 as i32) << 0 as i32 != 0
            {
                return 1 as i32;
            }
        }
        _ => return 1 as i32,
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaSimpleTypeErr(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: xmlParserErrors,
    mut node: xmlNodePtr,
    mut value: *const xmlChar,
    mut type_0: xmlSchemaTypePtr,
    mut displayValue: i32,
) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(&mut msg, actxt, node);
    if displayValue != 0
        || xmlSchemaEvalErrorNodeType(actxt, node) == XML_ATTRIBUTE_NODE as i32
    {
        msg = xmlStrcat(
            msg,
            b"'%s' is not a valid value of \0" as *const u8 as *const i8
                as *mut xmlChar,
        );
    } else {
        msg = xmlStrcat(
            msg,
            b"The character content is not a valid value of \0" as *const u8
                as *const i8 as *mut xmlChar,
        );
    }
    if xmlSchemaIsGlobalItem(type_0) == 0 {
        msg = xmlStrcat(
            msg,
            b"the local \0" as *const u8 as *const i8 as *mut xmlChar,
        );
    } else {
        msg = xmlStrcat(
            msg,
            b"the \0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    if (*type_0).flags & (1 as i32) << 8 as i32 != 0 {
        msg = xmlStrcat(
            msg,
            b"atomic type\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    } else if (*type_0).flags & (1 as i32) << 6 as i32 != 0 {
        msg = xmlStrcat(
            msg,
            b"list type\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    } else if (*type_0).flags & (1 as i32) << 7 as i32 != 0 {
        msg = xmlStrcat(
            msg,
            b"union type\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    if xmlSchemaIsGlobalItem(type_0) != 0 {
        let mut str: *mut xmlChar = 0 as *mut xmlChar;
        msg = xmlStrcat(
            msg,
            b" '\0" as *const u8 as *const i8 as *mut xmlChar,
        );
        if (*type_0).builtInType != 0 as i32 {
            msg = xmlStrcat(
                msg,
                b"xs:\0" as *const u8 as *const i8 as *mut xmlChar,
            );
            str = xmlStrdup((*type_0).name);
        } else {
            let mut qName: *const xmlChar = xmlSchemaFormatQName(
                &mut str,
                (*type_0).targetNamespace,
                (*type_0).name,
            );
            if str.is_null() {
                str = xmlStrdup(qName);
            }
        }
        msg = xmlStrcat(msg, xmlEscapeFormatString(&mut str));
        msg = xmlStrcat(msg, b"'\0" as *const u8 as *const i8 as *mut xmlChar);
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
    }
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const i8 as *mut xmlChar);
    if displayValue != 0
        || xmlSchemaEvalErrorNodeType(actxt, node) == XML_ATTRIBUTE_NODE as i32
    {
        xmlSchemaErr(
            actxt,
            error as i32,
            node,
            msg as *const i8,
            value,
            0 as *const xmlChar,
        );
    } else {
        xmlSchemaErr(
            actxt,
            error as i32,
            node,
            msg as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
        msg = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaFormatErrorNodeQName(
    mut str: *mut *mut xmlChar,
    mut ni: xmlSchemaNodeInfoPtr,
    mut node: xmlNodePtr,
) -> *const xmlChar {
    if !node.is_null() {
        if !((*node).ns).is_null() {
            return xmlSchemaFormatQName(str, (*(*node).ns).href, (*node).name)
        } else {
            return xmlSchemaFormatQName(str, 0 as *const xmlChar, (*node).name)
        }
    } else {
        if !ni.is_null() {
            return xmlSchemaFormatQName(str, (*ni).nsName, (*ni).localName);
        }
    }
    return 0 as *const xmlChar;
}
unsafe extern "C" fn xmlSchemaIllegalAttrErr(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: xmlParserErrors,
    mut ni: xmlSchemaAttrInfoPtr,
    mut node: xmlNodePtr,
) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(&mut msg, actxt, node);
    msg = xmlStrcat(
        msg,
        b"The attribute '%s' is not allowed.\n\0" as *const u8 as *const i8
            as *mut xmlChar,
    );
    xmlSchemaErr(
        actxt,
        error as i32,
        node,
        msg as *const i8,
        xmlSchemaFormatErrorNodeQName(&mut str, ni as xmlSchemaNodeInfoPtr, node),
        0 as *const xmlChar,
    );
    if !str.is_null() {
        xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
        str = 0 as *mut xmlChar;
    }
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
        msg = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaComplexTypeErr(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: xmlParserErrors,
    mut node: xmlNodePtr,
    mut type_0: xmlSchemaTypePtr,
    mut message: *const i8,
    mut nbval: i32,
    mut nbneg: i32,
    mut values: *mut *mut xmlChar,
) {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    let mut localName: *mut xmlChar = 0 as *mut xmlChar;
    let mut nsName: *mut xmlChar = 0 as *mut xmlChar;
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    let mut end: *const xmlChar = 0 as *const xmlChar;
    let mut i: i32 = 0;
    xmlSchemaFormatNodeForError(&mut msg, actxt, node);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\0" as *const u8 as *const i8 as *mut xmlChar);
    if nbval + nbneg > 0 as i32 {
        if nbval + nbneg > 1 as i32 {
            str = xmlStrdup(
                b" Expected is one of ( \0" as *const u8 as *const i8
                    as *mut xmlChar,
            );
        } else {
            str = xmlStrdup(
                b" Expected is ( \0" as *const u8 as *const i8 as *mut xmlChar,
            );
        }
        nsName = 0 as *mut xmlChar;
        let mut current_block_55: u64;
        i = 0 as i32;
        while i < nbval + nbneg {
            cur = *values.offset(i as isize);
            if !cur.is_null() {
                if *cur.offset(0 as i32 as isize) as i32 == 'n' as i32
                    && *cur.offset(1 as i32 as isize) as i32
                        == 'o' as i32
                    && *cur.offset(2 as i32 as isize) as i32
                        == 't' as i32
                    && *cur.offset(3 as i32 as isize) as i32
                        == ' ' as i32
                {
                    cur = cur.offset(4 as i32 as isize);
                    str = xmlStrcat(
                        str,
                        b"##other\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                }
                localName = 0 as *mut xmlChar;
                end = cur;
                if *end as i32 == '*' as i32 {
                    localName = xmlStrdup(
                        b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                    end = end.offset(1);
                } else {
                    while *end as i32 != 0 as i32
                        && *end as i32 != '|' as i32
                    {
                        end = end.offset(1);
                    }
                    localName = xmlStrncat(
                        localName,
                        cur as *mut xmlChar,
                        end.offset_from(cur) as i64 as i32,
                    );
                }
                if *end as i32 != 0 as i32 {
                    end = end.offset(1);
                    if nbneg == 0 as i32 || *end as i32 != '*' as i32
                        || *localName as i32 != '*' as i32
                    {
                        cur = end;
                        if *end as i32 == '*' as i32 {
                            nsName = xmlStrdup(
                                b"{*}\0" as *const u8 as *const i8 as *mut xmlChar,
                            );
                        } else {
                            while *end as i32 != 0 as i32 {
                                end = end.offset(1);
                            }
                            if i >= nbval {
                                nsName = xmlStrdup(
                                    b"{##other:\0" as *const u8 as *const i8
                                        as *mut xmlChar,
                                );
                            } else {
                                nsName = xmlStrdup(
                                    b"{\0" as *const u8 as *const i8 as *mut xmlChar,
                                );
                            }
                            nsName = xmlStrncat(
                                nsName,
                                cur as *mut xmlChar,
                                end.offset_from(cur) as i64 as i32,
                            );
                            nsName = xmlStrcat(
                                nsName,
                                b"}\0" as *const u8 as *const i8 as *mut xmlChar,
                            );
                        }
                        str = xmlStrcat(str, nsName);
                        if !nsName.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(nsName as *mut libc::c_void);
                            nsName = 0 as *mut xmlChar;
                        }
                        current_block_55 = 7990025728955927862;
                    } else {
                        if !localName.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(localName as *mut libc::c_void);
                            localName = 0 as *mut xmlChar;
                        }
                        current_block_55 = 13536709405535804910;
                    }
                } else {
                    current_block_55 = 7990025728955927862;
                }
                match current_block_55 {
                    13536709405535804910 => {}
                    _ => {
                        str = xmlStrcat(str, localName);
                        if !localName.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(localName as *mut libc::c_void);
                            localName = 0 as *mut xmlChar;
                        }
                        if i < nbval + nbneg - 1 as i32 {
                            str = xmlStrcat(
                                str,
                                b", \0" as *const u8 as *const i8 as *mut xmlChar,
                            );
                        }
                    }
                }
            }
            i += 1;
        }
        str = xmlStrcat(
            str,
            b" ).\n\0" as *const u8 as *const i8 as *mut xmlChar,
        );
        msg = xmlStrcat(msg, xmlEscapeFormatString(&mut str));
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
    } else {
        msg = xmlStrcat(
            msg,
            b"\n\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    xmlSchemaErr(
        actxt,
        error as i32,
        node,
        msg as *const i8,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
    xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFacetErr(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut error: xmlParserErrors,
    mut node: xmlNodePtr,
    mut value: *const xmlChar,
    mut length: u64,
    mut type_0: xmlSchemaTypePtr,
    mut facet: xmlSchemaFacetPtr,
    mut message: *const i8,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
) {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    let mut facetType: xmlSchemaTypeType = 0 as xmlSchemaTypeType;
    let mut nodeType: i32 = xmlSchemaEvalErrorNodeType(actxt, node);
    xmlSchemaFormatNodeForError(&mut msg, actxt, node);
    if error as u32
        == XML_SCHEMAV_CVC_ENUMERATION_VALID as i32 as u32
    {
        facetType = XML_SCHEMA_FACET_ENUMERATION;
    } else {
        facetType = (*facet).type_0;
    }
    msg = xmlStrcat(msg, b"[\0" as *const u8 as *const i8 as *mut xmlChar);
    msg = xmlStrcat(
        msg,
        b"facet '\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facetType));
    msg = xmlStrcat(msg, b"'] \0" as *const u8 as *const i8 as *mut xmlChar);
    if message.is_null() {
        if facetType as u32
            == XML_SCHEMA_FACET_LENGTH as i32 as u32
            || facetType as u32
                == XML_SCHEMA_FACET_MINLENGTH as i32 as u32
            || facetType as u32
                == XML_SCHEMA_FACET_MAXLENGTH as i32 as u32
        {
            let mut len: [i8; 25] = [0; 25];
            let mut actLen: [i8; 25] = [0; 25];
            if nodeType == XML_ATTRIBUTE_NODE as i32 {
                msg = xmlStrcat(
                    msg,
                    b"The value '%s' has a length of '%s'; \0" as *const u8
                        as *const i8 as *mut xmlChar,
                );
            } else {
                msg = xmlStrcat(
                    msg,
                    b"The value has a length of '%s'; \0" as *const u8
                        as *const i8 as *mut xmlChar,
                );
            }
            snprintf(
                len.as_mut_ptr(),
                24 as i32 as u64,
                b"%lu\0" as *const u8 as *const i8,
                xmlSchemaGetFacetValueAsULong(facet),
            );
            snprintf(
                actLen.as_mut_ptr(),
                24 as i32 as u64,
                b"%lu\0" as *const u8 as *const i8,
                length,
            );
            if facetType as u32
                == XML_SCHEMA_FACET_LENGTH as i32 as u32
            {
                msg = xmlStrcat(
                    msg,
                    b"this differs from the allowed length of '%s'.\n\0" as *const u8
                        as *const i8 as *mut xmlChar,
                );
            } else if facetType as u32
                    == XML_SCHEMA_FACET_MAXLENGTH as i32 as u32
                {
                msg = xmlStrcat(
                    msg,
                    b"this exceeds the allowed maximum length of '%s'.\n\0" as *const u8
                        as *const i8 as *mut xmlChar,
                );
            } else if facetType as u32
                    == XML_SCHEMA_FACET_MINLENGTH as i32 as u32
                {
                msg = xmlStrcat(
                    msg,
                    b"this underruns the allowed minimum length of '%s'.\n\0"
                        as *const u8 as *const i8 as *mut xmlChar,
                );
            }
            if nodeType == XML_ATTRIBUTE_NODE as i32 {
                xmlSchemaErr3(
                    actxt,
                    error as i32,
                    node,
                    msg as *const i8,
                    value,
                    actLen.as_mut_ptr() as *const xmlChar,
                    len.as_mut_ptr() as *const xmlChar,
                );
            } else {
                xmlSchemaErr(
                    actxt,
                    error as i32,
                    node,
                    msg as *const i8,
                    actLen.as_mut_ptr() as *const xmlChar,
                    len.as_mut_ptr() as *const xmlChar,
                );
            }
        } else if facetType as u32
                == XML_SCHEMA_FACET_ENUMERATION as i32 as u32
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is not an element of the set {%s}.\n\0" as *const u8
                    as *const i8 as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                xmlSchemaFormatFacetEnumSet(actxt, &mut str, type_0),
            );
        } else if facetType as u32
                == XML_SCHEMA_FACET_PATTERN as i32 as u32
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is not accepted by the pattern '%s'.\n\0" as *const u8
                    as *const i8 as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                (*facet).value,
            );
        } else if facetType as u32
                == XML_SCHEMA_FACET_MININCLUSIVE as i32 as u32
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is less than the minimum value allowed ('%s').\n\0"
                    as *const u8 as *const i8 as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                (*facet).value,
            );
        } else if facetType as u32
                == XML_SCHEMA_FACET_MAXINCLUSIVE as i32 as u32
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is greater than the maximum value allowed ('%s').\n\0"
                    as *const u8 as *const i8 as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                (*facet).value,
            );
        } else if facetType as u32
                == XML_SCHEMA_FACET_MINEXCLUSIVE as i32 as u32
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' must be greater than '%s'.\n\0" as *const u8
                    as *const i8 as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                (*facet).value,
            );
        } else if facetType as u32
                == XML_SCHEMA_FACET_MAXEXCLUSIVE as i32 as u32
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' must be less than '%s'.\n\0" as *const u8
                    as *const i8 as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                (*facet).value,
            );
        } else if facetType as u32
                == XML_SCHEMA_FACET_TOTALDIGITS as i32 as u32
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' has more digits than are allowed ('%s').\n\0"
                    as *const u8 as *const i8 as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                (*facet).value,
            );
        } else if facetType as u32
                == XML_SCHEMA_FACET_FRACTIONDIGITS as i32 as u32
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' has more fractional digits than are allowed ('%s').\n\0"
                    as *const u8 as *const i8 as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                (*facet).value,
            );
        } else if nodeType == XML_ATTRIBUTE_NODE as i32 {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is not facet-valid.\n\0" as *const u8
                    as *const i8 as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                0 as *const xmlChar,
            );
        } else {
            msg = xmlStrcat(
                msg,
                b"The value is not facet-valid.\n\0" as *const u8 as *const i8
                    as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
        }
    } else {
        msg = xmlStrcat(msg, message as *const xmlChar);
        msg = xmlStrcat(
            msg,
            b".\n\0" as *const u8 as *const i8 as *mut xmlChar,
        );
        xmlSchemaErr(
            actxt,
            error as i32,
            node,
            msg as *const i8,
            str1,
            str2,
        );
    }
    if !str.is_null() {
        xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
        str = 0 as *mut xmlChar;
    }
    xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaPMissingAttrErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut ownerElem: xmlNodePtr,
    mut name: *const i8,
    mut message: *const i8,
) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(&mut des, 0 as *const xmlChar, ownerItem, ownerElem);
    if !message.is_null() {
        xmlSchemaPErr(
            ctxt,
            ownerElem,
            error as i32,
            b"%s: %s.\n\0" as *const u8 as *const i8,
            des,
            message as *mut xmlChar,
        );
    } else {
        xmlSchemaPErr(
            ctxt,
            ownerElem,
            error as i32,
            b"%s: The attribute '%s' is required but missing.\n\0" as *const u8
                as *const i8,
            des,
            name as *mut xmlChar,
        );
    }
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
        des = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaPResCompAttrErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut ownerElem: xmlNodePtr,
    mut name: *const i8,
    mut refName: *const xmlChar,
    mut refURI: *const xmlChar,
    mut refType: xmlSchemaTypeType,
    mut refTypeStr: *const i8,
) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    let mut strA: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(&mut des, 0 as *const xmlChar, ownerItem, ownerElem);
    if refTypeStr.is_null() {
        refTypeStr = xmlSchemaItemTypeToStr(refType) as *const i8;
    }
    xmlSchemaPErrExt(
        ctxt,
        ownerElem,
        error as i32,
        0 as *const xmlChar,
        0 as *const xmlChar,
        0 as *const xmlChar,
        b"%s, attribute '%s': The QName value '%s' does not resolve to a(n) %s.\n\0"
            as *const u8 as *const i8,
        des,
        name as *mut xmlChar,
        xmlSchemaFormatQName(&mut strA, refURI, refName),
        refTypeStr as *mut xmlChar,
        0 as *const xmlChar,
    );
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
        des = 0 as *mut xmlChar;
    }
    if !strA.is_null() {
        xmlFree.expect("non-null function pointer")(strA as *mut libc::c_void);
        strA = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaPCustomAttrErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut ownerDes: *mut *mut xmlChar,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut attr: xmlAttrPtr,
    mut msg: *const i8,
) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    if ownerDes.is_null() {
        xmlSchemaFormatItemForReport(
            &mut des,
            0 as *const xmlChar,
            ownerItem,
            (*attr).parent,
        );
    } else if (*ownerDes).is_null() {
        xmlSchemaFormatItemForReport(
            ownerDes,
            0 as *const xmlChar,
            ownerItem,
            (*attr).parent,
        );
        des = *ownerDes;
    } else {
        des = *ownerDes;
    }
    if attr.is_null() {
        xmlSchemaPErrExt(
            ctxt,
            0 as xmlNodePtr,
            error as i32,
            0 as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
            b"%s, attribute '%s': %s.\n\0" as *const u8 as *const i8,
            des,
            b"Unknown\0" as *const u8 as *const i8 as *const xmlChar,
            msg as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    } else {
        xmlSchemaPErrExt(
            ctxt,
            attr as xmlNodePtr,
            error as i32,
            0 as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
            b"%s, attribute '%s': %s.\n\0" as *const u8 as *const i8,
            des,
            (*attr).name,
            msg as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    if ownerDes.is_null() {
        if !des.is_null() {
            xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
            des = 0 as *mut xmlChar;
        }
    }
}
unsafe extern "C" fn xmlSchemaPIllegalAttrErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut ownerComp: xmlSchemaBasicItemPtr,
    mut attr: xmlAttrPtr,
) {
    let mut strA: *mut xmlChar = 0 as *mut xmlChar;
    let mut strB: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(
        &mut strA,
        ctxt as xmlSchemaAbstractCtxtPtr,
        (*attr).parent,
    );
    xmlSchemaErr4(
        ctxt as xmlSchemaAbstractCtxtPtr,
        error as i32,
        attr as xmlNodePtr,
        b"%sThe attribute '%s' is not allowed.\n\0" as *const u8 as *const i8,
        strA,
        xmlSchemaFormatQNameNs(&mut strB, (*attr).ns, (*attr).name),
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
    if !strA.is_null() {
        xmlFree.expect("non-null function pointer")(strA as *mut libc::c_void);
        strA = 0 as *mut xmlChar;
    }
    if !strB.is_null() {
        xmlFree.expect("non-null function pointer")(strB as *mut libc::c_void);
        strB = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaPCustomErrExt(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut item: xmlSchemaBasicItemPtr,
    mut itemElem: xmlNodePtr,
    mut message: *const i8,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
    mut str3: *const xmlChar,
) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(&mut des, 0 as *const xmlChar, item, itemElem);
    msg = xmlStrdup(b"%s: \0" as *const u8 as *const i8 as *mut xmlChar);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const i8 as *mut xmlChar);
    if itemElem.is_null() && !item.is_null() {
        itemElem = xmlSchemaGetComponentNode(item);
    }
    xmlSchemaPErrExt(
        ctxt,
        itemElem,
        error as i32,
        0 as *const xmlChar,
        0 as *const xmlChar,
        0 as *const xmlChar,
        msg as *const i8,
        des,
        str1,
        str2,
        str3,
        0 as *const xmlChar,
    );
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
        des = 0 as *mut xmlChar;
    }
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
        msg = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaPCustomErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut item: xmlSchemaBasicItemPtr,
    mut itemElem: xmlNodePtr,
    mut message: *const i8,
    mut str1: *const xmlChar,
) {
    xmlSchemaPCustomErrExt(
        ctxt,
        error,
        item,
        itemElem,
        message,
        str1,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
}
unsafe extern "C" fn xmlSchemaPAttrUseErr4(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut node: xmlNodePtr,
    mut ownerItem: xmlSchemaBasicItemPtr,
    attruse: xmlSchemaAttributeUsePtr,
    mut message: *const i8,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
    mut str3: *const xmlChar,
    mut str4: *const xmlChar,
) {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(
        &mut msg,
        0 as *const xmlChar,
        ownerItem,
        0 as xmlNodePtr,
    );
    msg = xmlStrcat(msg, b", \0" as *const u8 as *const i8 as *mut xmlChar);
    msg = xmlStrcat(
        msg,
        xmlSchemaFormatItemForReport(
            &mut str,
            0 as *const xmlChar,
            attruse as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
        ),
    );
    if !str.is_null() {
        xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
        str = 0 as *mut xmlChar;
    }
    msg = xmlStrcat(msg, b": \0" as *const u8 as *const i8 as *mut xmlChar);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const i8 as *mut xmlChar);
    xmlSchemaErr4(
        ctxt as xmlSchemaAbstractCtxtPtr,
        error as i32,
        node,
        msg as *const i8,
        str1,
        str2,
        str3,
        str4,
    );
    xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaPIllegalFacetAtomicErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut type_0: xmlSchemaTypePtr,
    mut baseType: xmlSchemaTypePtr,
    mut facet: xmlSchemaFacetPtr,
) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    let mut strT: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(
        &mut des,
        0 as *const xmlChar,
        type_0 as xmlSchemaBasicItemPtr,
        (*type_0).node,
    );
    xmlSchemaPErrExt(
        ctxt,
        (*type_0).node,
        error as i32,
        0 as *const xmlChar,
        0 as *const xmlChar,
        0 as *const xmlChar,
        b"%s: The facet '%s' is not allowed on types derived from the type %s.\n\0"
            as *const u8 as *const i8,
        des,
        xmlSchemaFacetTypeToString((*facet).type_0),
        xmlSchemaFormatItemForReport(
            &mut strT,
            0 as *const xmlChar,
            baseType as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
        ),
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
        des = 0 as *mut xmlChar;
    }
    if !strT.is_null() {
        xmlFree.expect("non-null function pointer")(strT as *mut libc::c_void);
        strT = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaPIllegalFacetListUnionErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut type_0: xmlSchemaTypePtr,
    mut facet: xmlSchemaFacetPtr,
) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(
        &mut des,
        0 as *const xmlChar,
        type_0 as xmlSchemaBasicItemPtr,
        (*type_0).node,
    );
    xmlSchemaPErr(
        ctxt,
        (*type_0).node,
        error as i32,
        b"%s: The facet '%s' is not allowed.\n\0" as *const u8 as *const i8,
        des,
        xmlSchemaFacetTypeToString((*facet).type_0),
    );
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
        des = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaPMutualExclAttrErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut attr: xmlAttrPtr,
    mut name1: *const i8,
    mut name2: *const i8,
) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(
        &mut des,
        0 as *const xmlChar,
        ownerItem,
        (*attr).parent,
    );
    xmlSchemaPErrExt(
        ctxt,
        attr as xmlNodePtr,
        error as i32,
        0 as *const xmlChar,
        0 as *const xmlChar,
        0 as *const xmlChar,
        b"%s: The attributes '%s' and '%s' are mutually exclusive.\n\0" as *const u8
            as *const i8,
        des,
        name1 as *mut xmlChar,
        name2 as *mut xmlChar,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
        des = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaPSimpleTypeErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut node: xmlNodePtr,
    mut type_0: xmlSchemaTypePtr,
    mut expected: *const i8,
    mut value: *const xmlChar,
    mut message: *const i8,
    mut str1: *const xmlChar,
    mut str2: *const xmlChar,
) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(&mut msg, ctxt as xmlSchemaAbstractCtxtPtr, node);
    if message.is_null() {
        if !type_0.is_null() {
            if (*node).type_0 as u32
                == XML_ATTRIBUTE_NODE as i32 as u32
            {
                msg = xmlStrcat(
                    msg,
                    b"'%s' is not a valid value of \0" as *const u8
                        as *const i8 as *mut xmlChar,
                );
            } else {
                msg = xmlStrcat(
                    msg,
                    b"The character content is not a valid value of \0" as *const u8
                        as *const i8 as *mut xmlChar,
                );
            }
            if xmlSchemaIsGlobalItem(type_0) == 0 {
                msg = xmlStrcat(
                    msg,
                    b"the local \0" as *const u8 as *const i8 as *mut xmlChar,
                );
            } else {
                msg = xmlStrcat(
                    msg,
                    b"the \0" as *const u8 as *const i8 as *mut xmlChar,
                );
            }
            if (*type_0).flags & (1 as i32) << 8 as i32 != 0 {
                msg = xmlStrcat(
                    msg,
                    b"atomic type\0" as *const u8 as *const i8 as *mut xmlChar,
                );
            } else if (*type_0).flags & (1 as i32) << 6 as i32 != 0 {
                msg = xmlStrcat(
                    msg,
                    b"list type\0" as *const u8 as *const i8 as *mut xmlChar,
                );
            } else if (*type_0).flags & (1 as i32) << 7 as i32 != 0 {
                msg = xmlStrcat(
                    msg,
                    b"union type\0" as *const u8 as *const i8 as *mut xmlChar,
                );
            }
            if xmlSchemaIsGlobalItem(type_0) != 0 {
                let mut str: *mut xmlChar = 0 as *mut xmlChar;
                msg = xmlStrcat(
                    msg,
                    b" '\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                if (*type_0).builtInType != 0 as i32 {
                    msg = xmlStrcat(
                        msg,
                        b"xs:\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                    str = xmlStrdup((*type_0).name);
                } else {
                    let mut qName: *const xmlChar = xmlSchemaFormatQName(
                        &mut str,
                        (*type_0).targetNamespace,
                        (*type_0).name,
                    );
                    if str.is_null() {
                        str = xmlStrdup(qName);
                    }
                }
                msg = xmlStrcat(msg, xmlEscapeFormatString(&mut str));
                msg = xmlStrcat(
                    msg,
                    b"'.\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
            }
        } else if (*node).type_0 as u32
                == XML_ATTRIBUTE_NODE as i32 as u32
            {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is not valid.\0" as *const u8 as *const i8
                    as *mut xmlChar,
            );
        } else {
            msg = xmlStrcat(
                msg,
                b"The character content is not valid.\0" as *const u8
                    as *const i8 as *mut xmlChar,
            );
        }
        if !expected.is_null() {
            let mut expectedEscaped: *mut xmlChar = xmlCharStrdup(expected);
            msg = xmlStrcat(
                msg,
                b" Expected is '\0" as *const u8 as *const i8 as *mut xmlChar,
            );
            msg = xmlStrcat(msg, xmlEscapeFormatString(&mut expectedEscaped));
            if !expectedEscaped.is_null() {
                xmlFree
                    .expect(
                        "non-null function pointer",
                    )(expectedEscaped as *mut libc::c_void);
                expectedEscaped = 0 as *mut xmlChar;
            }
            msg = xmlStrcat(
                msg,
                b"'.\n\0" as *const u8 as *const i8 as *mut xmlChar,
            );
        } else {
            msg = xmlStrcat(
                msg,
                b"\n\0" as *const u8 as *const i8 as *mut xmlChar,
            );
        }
        if (*node).type_0 as u32
            == XML_ATTRIBUTE_NODE as i32 as u32
        {
            xmlSchemaPErr(
                ctxt,
                node,
                error as i32,
                msg as *const i8,
                value,
                0 as *const xmlChar,
            );
        } else {
            xmlSchemaPErr(
                ctxt,
                node,
                error as i32,
                msg as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
        }
    } else {
        msg = xmlStrcat(msg, message as *mut xmlChar);
        msg = xmlStrcat(
            msg,
            b".\n\0" as *const u8 as *const i8 as *mut xmlChar,
        );
        xmlSchemaPErrExt(
            ctxt,
            node,
            error as i32,
            0 as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
            msg as *const i8,
            str1,
            str2,
            0 as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
        msg = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaPContentErr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut error: xmlParserErrors,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut ownerElem: xmlNodePtr,
    mut child: xmlNodePtr,
    mut message: *const i8,
    mut content: *const i8,
) {
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(&mut des, 0 as *const xmlChar, ownerItem, ownerElem);
    if !message.is_null() {
        xmlSchemaPErr2(
            ctxt,
            ownerElem,
            child,
            error as i32,
            b"%s: %s.\n\0" as *const u8 as *const i8,
            des,
            message as *mut xmlChar,
        );
    } else if !content.is_null() {
        xmlSchemaPErr2(
            ctxt,
            ownerElem,
            child,
            error as i32,
            b"%s: The content is not valid. Expected is %s.\n\0" as *const u8
                as *const i8,
            des,
            content as *mut xmlChar,
        );
    } else {
        xmlSchemaPErr2(
            ctxt,
            ownerElem,
            child,
            error as i32,
            b"%s: The content is not valid.\n\0" as *const u8 as *const i8,
            des,
            0 as *const xmlChar,
        );
    }
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
        des = 0 as *mut xmlChar;
    }
}
unsafe extern "C" fn xmlSchemaNewSchema(
    mut ctxt: xmlSchemaParserCtxtPtr,
) -> xmlSchemaPtr {
    let mut ret: xmlSchemaPtr = 0 as *mut xmlSchema;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchema>() as u64) as xmlSchemaPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating schema\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchema>() as u64,
    );
    let fresh6 = &mut ((*ret).dict);
    *fresh6 = (*ctxt).dict;
    xmlDictReference((*ret).dict);
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaNewFacet() -> xmlSchemaFacetPtr {
    let mut ret: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaFacet>() as u64) as xmlSchemaFacetPtr;
    if ret.is_null() {
        return 0 as xmlSchemaFacetPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaFacet>() as u64,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaNewAnnot(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaAnnotPtr {
    let mut ret: xmlSchemaAnnotPtr = 0 as *mut xmlSchemaAnnot;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaAnnot>() as u64) as xmlSchemaAnnotPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating annotation\0" as *const u8 as *const i8,
            node,
        );
        return 0 as xmlSchemaAnnotPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaAnnot>() as u64,
    );
    let fresh7 = &mut ((*ret).content);
    *fresh7 = node;
    return ret;
}
unsafe extern "C" fn xmlSchemaItemListCreate() -> xmlSchemaItemListPtr {
    let mut ret: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaItemList>() as u64)
        as xmlSchemaItemListPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating an item list structure\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaItemListPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaItemList>() as u64,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaItemListClear(mut list: xmlSchemaItemListPtr) {
    if !((*list).items).is_null() {
        xmlFree.expect("non-null function pointer")((*list).items as *mut libc::c_void);
        let fresh8 = &mut ((*list).items);
        *fresh8 = 0 as *mut *mut libc::c_void;
    }
    (*list).nbItems = 0 as i32;
    (*list).sizeItems = 0 as i32;
}
unsafe extern "C" fn xmlSchemaItemListAdd(
    mut list: xmlSchemaItemListPtr,
    mut item: *mut libc::c_void,
) -> i32 {
    if ((*list).items).is_null() {
        let fresh9 = &mut ((*list).items);
        *fresh9 = xmlMalloc
            .expect(
                "non-null function pointer",
            )(
            (20 as i32 as u64)
                .wrapping_mul(
                    ::std::mem::size_of::<*mut libc::c_void>() as u64,
                ),
        ) as *mut *mut libc::c_void;
        if ((*list).items).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"allocating new item list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
        (*list).sizeItems = 20 as i32;
    } else if (*list).sizeItems <= (*list).nbItems {
        (*list).sizeItems *= 2 as i32;
        let fresh10 = &mut ((*list).items);
        *fresh10 = xmlRealloc
            .expect(
                "non-null function pointer",
            )(
            (*list).items as *mut libc::c_void,
            ((*list).sizeItems as u64)
                .wrapping_mul(
                    ::std::mem::size_of::<*mut libc::c_void>() as u64,
                ),
        ) as *mut *mut libc::c_void;
        if ((*list).items).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"growing item list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            (*list).sizeItems = 0 as i32;
            return -(1 as i32);
        }
    }
    let fresh11 = &mut ((*list).nbItems);
    let fresh12 = *fresh11;
    *fresh11 = *fresh11 + 1;
    let fresh13 = &mut (*((*list).items).offset(fresh12 as isize));
    *fresh13 = item;
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaItemListAddSize(
    mut list: xmlSchemaItemListPtr,
    mut initialSize: i32,
    mut item: *mut libc::c_void,
) -> i32 {
    if ((*list).items).is_null() {
        if initialSize <= 0 as i32 {
            initialSize = 1 as i32;
        }
        let fresh14 = &mut ((*list).items);
        *fresh14 = xmlMalloc
            .expect(
                "non-null function pointer",
            )(
            (initialSize as u64)
                .wrapping_mul(
                    ::std::mem::size_of::<*mut libc::c_void>() as u64,
                ),
        ) as *mut *mut libc::c_void;
        if ((*list).items).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"allocating new item list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
        (*list).sizeItems = initialSize;
    } else if (*list).sizeItems <= (*list).nbItems {
        (*list).sizeItems *= 2 as i32;
        let fresh15 = &mut ((*list).items);
        *fresh15 = xmlRealloc
            .expect(
                "non-null function pointer",
            )(
            (*list).items as *mut libc::c_void,
            ((*list).sizeItems as u64)
                .wrapping_mul(
                    ::std::mem::size_of::<*mut libc::c_void>() as u64,
                ),
        ) as *mut *mut libc::c_void;
        if ((*list).items).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"growing item list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            (*list).sizeItems = 0 as i32;
            return -(1 as i32);
        }
    }
    let fresh16 = &mut ((*list).nbItems);
    let fresh17 = *fresh16;
    *fresh16 = *fresh16 + 1;
    let fresh18 = &mut (*((*list).items).offset(fresh17 as isize));
    *fresh18 = item;
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaItemListInsert(
    mut list: xmlSchemaItemListPtr,
    mut item: *mut libc::c_void,
    mut idx: i32,
) -> i32 {
    if ((*list).items).is_null() {
        let fresh19 = &mut ((*list).items);
        *fresh19 = xmlMalloc
            .expect(
                "non-null function pointer",
            )(
            (20 as i32 as u64)
                .wrapping_mul(
                    ::std::mem::size_of::<*mut libc::c_void>() as u64,
                ),
        ) as *mut *mut libc::c_void;
        if ((*list).items).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"allocating new item list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
        (*list).sizeItems = 20 as i32;
    } else if (*list).sizeItems <= (*list).nbItems {
        (*list).sizeItems *= 2 as i32;
        let fresh20 = &mut ((*list).items);
        *fresh20 = xmlRealloc
            .expect(
                "non-null function pointer",
            )(
            (*list).items as *mut libc::c_void,
            ((*list).sizeItems as u64)
                .wrapping_mul(
                    ::std::mem::size_of::<*mut libc::c_void>() as u64,
                ),
        ) as *mut *mut libc::c_void;
        if ((*list).items).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"growing item list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            (*list).sizeItems = 0 as i32;
            return -(1 as i32);
        }
    }
    if idx >= (*list).nbItems {
        let fresh21 = &mut ((*list).nbItems);
        let fresh22 = *fresh21;
        *fresh21 = *fresh21 + 1;
        let fresh23 = &mut (*((*list).items).offset(fresh22 as isize));
        *fresh23 = item;
    } else {
        let mut i: i32 = 0;
        i = (*list).nbItems;
        while i > idx {
            let fresh24 = &mut (*((*list).items).offset(i as isize));
            *fresh24 = *((*list).items).offset((i - 1 as i32) as isize);
            i -= 1;
        }
        let fresh25 = &mut (*((*list).items).offset(idx as isize));
        *fresh25 = item;
        let fresh26 = &mut ((*list).nbItems);
        *fresh26 += 1;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaItemListRemove(
    mut list: xmlSchemaItemListPtr,
    mut idx: i32,
) -> i32 {
    let mut i: i32 = 0;
    if ((*list).items).is_null() || idx >= (*list).nbItems {
        xmlSchemaPSimpleErr(
            b"Internal error: xmlSchemaItemListRemove, index error.\n\0" as *const u8
                as *const i8,
        );
        return -(1 as i32);
    }
    if (*list).nbItems == 1 as i32 {
        xmlFree.expect("non-null function pointer")((*list).items as *mut libc::c_void);
        let fresh27 = &mut ((*list).items);
        *fresh27 = 0 as *mut *mut libc::c_void;
        (*list).nbItems = 0 as i32;
        (*list).sizeItems = 0 as i32;
    } else if (*list).nbItems - 1 as i32 == idx {
        let fresh28 = &mut ((*list).nbItems);
        *fresh28 -= 1;
    } else {
        i = idx;
        while i < (*list).nbItems - 1 as i32 {
            let fresh29 = &mut (*((*list).items).offset(i as isize));
            *fresh29 = *((*list).items).offset((i + 1 as i32) as isize);
            i += 1;
        }
        let fresh30 = &mut ((*list).nbItems);
        *fresh30 -= 1;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaItemListFree(mut list: xmlSchemaItemListPtr) {
    if list.is_null() {
        return;
    }
    if !((*list).items).is_null() {
        xmlFree.expect("non-null function pointer")((*list).items as *mut libc::c_void);
    }
    xmlFree.expect("non-null function pointer")(list as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaBucketFree(mut bucket: xmlSchemaBucketPtr) {
    if bucket.is_null() {
        return;
    }
    if !((*bucket).globals).is_null() {
        xmlSchemaComponentListFree((*bucket).globals);
        xmlSchemaItemListFree((*bucket).globals);
    }
    if !((*bucket).locals).is_null() {
        xmlSchemaComponentListFree((*bucket).locals);
        xmlSchemaItemListFree((*bucket).locals);
    }
    if !((*bucket).relations).is_null() {
        let mut prev: xmlSchemaSchemaRelationPtr = 0 as *mut xmlSchemaSchemaRelation;
        let mut cur: xmlSchemaSchemaRelationPtr = (*bucket).relations;
        loop {
            prev = cur;
            cur = (*cur).next;
            xmlFree.expect("non-null function pointer")(prev as *mut libc::c_void);
            if cur.is_null() {
                break;
            }
        }
    }
    if (*bucket).preserveDoc == 0 && !((*bucket).doc).is_null() {
        xmlFreeDoc((*bucket).doc);
    }
    if (*bucket).type_0 == 1 as i32 {
        if !((*(bucket as xmlSchemaImportPtr)).schema).is_null() {
            xmlSchemaFree((*(bucket as xmlSchemaImportPtr)).schema);
        }
    }
    xmlFree.expect("non-null function pointer")(bucket as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaBucketFreeEntry(
    mut bucket: *mut libc::c_void,
    mut name: *const xmlChar,
) {
    xmlSchemaBucketFree(bucket as xmlSchemaBucketPtr);
}
unsafe extern "C" fn xmlSchemaBucketCreate(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: i32,
    mut targetNamespace: *const xmlChar,
) -> xmlSchemaBucketPtr {
    let mut ret: xmlSchemaBucketPtr = 0 as *mut xmlSchemaBucket;
    let mut size: i32 = 0;
    let mut mainSchema: xmlSchemaPtr = 0 as *mut xmlSchema;
    if ((*(*pctxt).constructor).mainSchema).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaBucketCreate\0" as *const u8 as *const i8,
            b"no main schema on constructor\0" as *const u8 as *const i8,
        );
        return 0 as xmlSchemaBucketPtr;
    }
    mainSchema = (*(*pctxt).constructor).mainSchema;
    if type_0 == 2 as i32 || type_0 == 3 as i32 {
        size = ::std::mem::size_of::<xmlSchemaInclude>() as u64 as i32;
    } else {
        size = ::std::mem::size_of::<xmlSchemaImport>() as u64 as i32;
    }
    ret = xmlMalloc.expect("non-null function pointer")(size as size_t)
        as xmlSchemaBucketPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating schema bucket\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaBucketPtr;
    }
    memset(ret as *mut libc::c_void, 0 as i32, size as u64);
    let fresh31 = &mut ((*ret).targetNamespace);
    *fresh31 = targetNamespace;
    (*ret).type_0 = type_0;
    let fresh32 = &mut ((*ret).globals);
    *fresh32 = xmlSchemaItemListCreate();
    if ((*ret).globals).is_null() {
        xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void);
        return 0 as xmlSchemaBucketPtr;
    }
    let fresh33 = &mut ((*ret).locals);
    *fresh33 = xmlSchemaItemListCreate();
    if ((*ret).locals).is_null() {
        xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void);
        return 0 as xmlSchemaBucketPtr;
    }
    if !(!((*(*pctxt).constructor).buckets).is_null()
        && (*(*(*pctxt).constructor).buckets).nbItems > 0 as i32)
    {
        if type_0 == 2 as i32 || type_0 == 3 as i32 {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaBucketCreate\0" as *const u8 as *const i8,
                b"first bucket but it's an include or redefine\0" as *const u8
                    as *const i8,
            );
            xmlSchemaBucketFree(ret);
            return 0 as xmlSchemaBucketPtr;
        }
        (*ret).type_0 = 0 as i32;
        let fresh34 = &mut ((*(*pctxt).constructor).mainBucket);
        *fresh34 = ret;
        let fresh35 = &mut ((*(ret as xmlSchemaImportPtr)).schema);
        *fresh35 = mainSchema;
        let fresh36 = &mut ((*mainSchema).targetNamespace);
        *fresh36 = targetNamespace;
    } else if type_0 == 0 as i32 {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaBucketCreate\0" as *const u8 as *const i8,
            b"main bucket but it's not the first one\0" as *const u8
                as *const i8,
        );
        xmlSchemaBucketFree(ret);
        return 0 as xmlSchemaBucketPtr;
    } else {
        if type_0 == 1 as i32 {
            let fresh37 = &mut ((*(ret as xmlSchemaImportPtr)).schema);
            *fresh37 = xmlSchemaNewSchema(pctxt);
            if ((*(ret as xmlSchemaImportPtr)).schema).is_null() {
                xmlSchemaBucketFree(ret);
                return 0 as xmlSchemaBucketPtr;
            }
            let fresh38 = &mut ((*(*(ret as xmlSchemaImportPtr)).schema)
                .targetNamespace);
            *fresh38 = targetNamespace;
        }
    }
    if type_0 == 0 as i32 || type_0 == 1 as i32 {
        let mut res: i32 = 0;
        if ((*mainSchema).schemasImports).is_null() {
            let fresh39 = &mut ((*mainSchema).schemasImports);
            *fresh39 = xmlHashCreateDict(5 as i32, (*(*pctxt).constructor).dict);
            if ((*mainSchema).schemasImports).is_null() {
                xmlSchemaBucketFree(ret);
                return 0 as xmlSchemaBucketPtr;
            }
        }
        if targetNamespace.is_null() {
            res = xmlHashAddEntry(
                (*mainSchema).schemasImports,
                b"##\0" as *const u8 as *const i8 as *const xmlChar,
                ret as *mut libc::c_void,
            );
        } else {
            res = xmlHashAddEntry(
                (*mainSchema).schemasImports,
                targetNamespace,
                ret as *mut libc::c_void,
            );
        }
        if res != 0 as i32 {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaBucketCreate\0" as *const u8 as *const i8,
                b"failed to add the schema bucket to the hash\0" as *const u8
                    as *const i8,
            );
            xmlSchemaBucketFree(ret);
            return 0 as xmlSchemaBucketPtr;
        }
    } else {
        if (*(*(*pctxt).constructor).bucket).type_0 == 0 as i32
            || (*(*(*pctxt).constructor).bucket).type_0 == 1 as i32
        {
            let fresh40 = &mut ((*(ret as xmlSchemaIncludePtr)).ownerImport);
            *fresh40 = (*(*pctxt).constructor).bucket as xmlSchemaImportPtr;
        } else {
            let fresh41 = &mut ((*(ret as xmlSchemaIncludePtr)).ownerImport);
            *fresh41 = (*((*(*pctxt).constructor).bucket as xmlSchemaIncludePtr))
                .ownerImport;
        }
        if ((*mainSchema).includes).is_null() {
            let fresh42 = &mut ((*mainSchema).includes);
            *fresh42 = xmlSchemaItemListCreate() as *mut libc::c_void;
            if ((*mainSchema).includes).is_null() {
                xmlSchemaBucketFree(ret);
                return 0 as xmlSchemaBucketPtr;
            }
        }
        xmlSchemaItemListAdd(
            (*mainSchema).includes as xmlSchemaItemListPtr,
            ret as *mut libc::c_void,
        );
    }
    if xmlSchemaItemListAdd((*(*pctxt).constructor).buckets, ret as *mut libc::c_void)
        == -(1 as i32)
    {
        return 0 as xmlSchemaBucketPtr;
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaAddItemSize(
    mut list: *mut xmlSchemaItemListPtr,
    mut initialSize: i32,
    mut item: *mut libc::c_void,
) -> i32 {
    if (*list).is_null() {
        *list = xmlSchemaItemListCreate();
        if (*list).is_null() {
            return -(1 as i32);
        }
    }
    xmlSchemaItemListAddSize(*list, initialSize, item);
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaFreeAnnot(mut annot: xmlSchemaAnnotPtr) {
    if annot.is_null() {
        return;
    }
    if ((*annot).next).is_null() {
        xmlFree.expect("non-null function pointer")(annot as *mut libc::c_void);
    } else {
        let mut prev: xmlSchemaAnnotPtr = 0 as *mut xmlSchemaAnnot;
        loop {
            prev = annot;
            annot = (*annot).next;
            xmlFree.expect("non-null function pointer")(prev as *mut libc::c_void);
            if annot.is_null() {
                break;
            }
        }
    };
}
unsafe extern "C" fn xmlSchemaFreeNotation(mut nota: xmlSchemaNotationPtr) {
    if nota.is_null() {
        return;
    }
    xmlFree.expect("non-null function pointer")(nota as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeAttribute(mut attr: xmlSchemaAttributePtr) {
    if attr.is_null() {
        return;
    }
    if !((*attr).annot).is_null() {
        xmlSchemaFreeAnnot((*attr).annot);
    }
    if !((*attr).defVal).is_null() {
        xmlSchemaFreeValue((*attr).defVal);
    }
    xmlFree.expect("non-null function pointer")(attr as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeAttributeUse(mut use_0: xmlSchemaAttributeUsePtr) {
    if use_0.is_null() {
        return;
    }
    if !((*use_0).annot).is_null() {
        xmlSchemaFreeAnnot((*use_0).annot);
    }
    if !((*use_0).defVal).is_null() {
        xmlSchemaFreeValue((*use_0).defVal);
    }
    xmlFree.expect("non-null function pointer")(use_0 as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeAttributeUseProhib(
    mut prohib: xmlSchemaAttributeUseProhibPtr,
) {
    if prohib.is_null() {
        return;
    }
    xmlFree.expect("non-null function pointer")(prohib as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeWildcardNsSet(mut set: xmlSchemaWildcardNsPtr) {
    let mut next: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    while !set.is_null() {
        next = (*set).next;
        xmlFree.expect("non-null function pointer")(set as *mut libc::c_void);
        set = next;
    }
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFreeWildcard(mut wildcard: xmlSchemaWildcardPtr) {
    if wildcard.is_null() {
        return;
    }
    if !((*wildcard).annot).is_null() {
        xmlSchemaFreeAnnot((*wildcard).annot);
    }
    if !((*wildcard).nsSet).is_null() {
        xmlSchemaFreeWildcardNsSet((*wildcard).nsSet);
    }
    if !((*wildcard).negNsSet).is_null() {
        xmlFree
            .expect(
                "non-null function pointer",
            )((*wildcard).negNsSet as *mut libc::c_void);
    }
    xmlFree.expect("non-null function pointer")(wildcard as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeAttributeGroup(
    mut attrGr: xmlSchemaAttributeGroupPtr,
) {
    if attrGr.is_null() {
        return;
    }
    if !((*attrGr).annot).is_null() {
        xmlSchemaFreeAnnot((*attrGr).annot);
    }
    if !((*attrGr).attrUses).is_null() {
        xmlSchemaItemListFree((*attrGr).attrUses as xmlSchemaItemListPtr);
    }
    xmlFree.expect("non-null function pointer")(attrGr as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeQNameRef(mut item: xmlSchemaQNameRefPtr) {
    xmlFree.expect("non-null function pointer")(item as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeTypeLinkList(mut link: xmlSchemaTypeLinkPtr) {
    let mut next: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    while !link.is_null() {
        next = (*link).next;
        xmlFree.expect("non-null function pointer")(link as *mut libc::c_void);
        link = next;
    }
}
unsafe extern "C" fn xmlSchemaFreeIDCStateObjList(mut sto: xmlSchemaIDCStateObjPtr) {
    let mut next: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    while !sto.is_null() {
        next = (*sto).next;
        if !((*sto).history).is_null() {
            xmlFree
                .expect(
                    "non-null function pointer",
                )((*sto).history as *mut libc::c_void);
        }
        if !((*sto).xpathCtxt).is_null() {
            xmlFreeStreamCtxt((*sto).xpathCtxt as xmlStreamCtxtPtr);
        }
        xmlFree.expect("non-null function pointer")(sto as *mut libc::c_void);
        sto = next;
    }
}
unsafe extern "C" fn xmlSchemaFreeIDC(mut idcDef: xmlSchemaIDCPtr) {
    let mut cur: xmlSchemaIDCSelectPtr = 0 as *mut xmlSchemaIDCSelect;
    let mut prev: xmlSchemaIDCSelectPtr = 0 as *mut xmlSchemaIDCSelect;
    if idcDef.is_null() {
        return;
    }
    if !((*idcDef).annot).is_null() {
        xmlSchemaFreeAnnot((*idcDef).annot);
    }
    if !((*idcDef).selector).is_null() {
        if !((*(*idcDef).selector).xpathComp).is_null() {
            xmlFreePattern((*(*idcDef).selector).xpathComp as xmlPatternPtr);
        }
        xmlFree
            .expect(
                "non-null function pointer",
            )((*idcDef).selector as *mut libc::c_void);
    }
    if !((*idcDef).fields).is_null() {
        cur = (*idcDef).fields;
        loop {
            prev = cur;
            cur = (*cur).next;
            if !((*prev).xpathComp).is_null() {
                xmlFreePattern((*prev).xpathComp as xmlPatternPtr);
            }
            xmlFree.expect("non-null function pointer")(prev as *mut libc::c_void);
            if cur.is_null() {
                break;
            }
        }
    }
    xmlFree.expect("non-null function pointer")(idcDef as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeElement(mut elem: xmlSchemaElementPtr) {
    if elem.is_null() {
        return;
    }
    if !((*elem).annot).is_null() {
        xmlSchemaFreeAnnot((*elem).annot);
    }
    if !((*elem).contModel).is_null() {
        xmlRegFreeRegexp((*elem).contModel);
    }
    if !((*elem).defVal).is_null() {
        xmlSchemaFreeValue((*elem).defVal);
    }
    xmlFree.expect("non-null function pointer")(elem as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFreeFacet(mut facet: xmlSchemaFacetPtr) {
    if facet.is_null() {
        return;
    }
    if !((*facet).val).is_null() {
        xmlSchemaFreeValue((*facet).val);
    }
    if !((*facet).regexp).is_null() {
        xmlRegFreeRegexp((*facet).regexp);
    }
    if !((*facet).annot).is_null() {
        xmlSchemaFreeAnnot((*facet).annot);
    }
    xmlFree.expect("non-null function pointer")(facet as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFreeType(mut type_0: xmlSchemaTypePtr) {
    if type_0.is_null() {
        return;
    }
    if !((*type_0).annot).is_null() {
        xmlSchemaFreeAnnot((*type_0).annot);
    }
    if !((*type_0).facets).is_null() {
        let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
        let mut next: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
        facet = (*type_0).facets;
        while !facet.is_null() {
            next = (*facet).next;
            xmlSchemaFreeFacet(facet);
            facet = next;
        }
    }
    if !((*type_0).attrUses).is_null() {
        xmlSchemaItemListFree((*type_0).attrUses as xmlSchemaItemListPtr);
    }
    if !((*type_0).memberTypes).is_null() {
        xmlSchemaFreeTypeLinkList((*type_0).memberTypes);
    }
    if !((*type_0).facetSet).is_null() {
        let mut next_0: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
        let mut link: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
        link = (*type_0).facetSet;
        loop {
            next_0 = (*link).next;
            xmlFree.expect("non-null function pointer")(link as *mut libc::c_void);
            link = next_0;
            if link.is_null() {
                break;
            }
        }
    }
    if !((*type_0).contModel).is_null() {
        xmlRegFreeRegexp((*type_0).contModel);
    }
    xmlFree.expect("non-null function pointer")(type_0 as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeModelGroupDef(mut item: xmlSchemaModelGroupDefPtr) {
    if !((*item).annot).is_null() {
        xmlSchemaFreeAnnot((*item).annot);
    }
    xmlFree.expect("non-null function pointer")(item as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaFreeModelGroup(mut item: xmlSchemaModelGroupPtr) {
    if !((*item).annot).is_null() {
        xmlSchemaFreeAnnot((*item).annot);
    }
    xmlFree.expect("non-null function pointer")(item as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaComponentListFree(mut list: xmlSchemaItemListPtr) {
    if list.is_null() || (*list).nbItems == 0 as i32 {
        return;
    }
    let mut item: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
    let mut items: *mut xmlSchemaTreeItemPtr = (*list).items
        as *mut xmlSchemaTreeItemPtr;
    let mut i: i32 = 0;
    i = 0 as i32;
    while i < (*list).nbItems {
        item = *items.offset(i as isize);
        if !item.is_null() {
            match (*item).type_0 as u32 {
                4 | 5 => {
                    xmlSchemaFreeType(item as xmlSchemaTypePtr);
                }
                15 => {
                    xmlSchemaFreeAttribute(item as xmlSchemaAttributePtr);
                }
                26 => {
                    xmlSchemaFreeAttributeUse(item as xmlSchemaAttributeUsePtr);
                }
                2001 => {
                    xmlSchemaFreeAttributeUseProhib(
                        item as xmlSchemaAttributeUseProhibPtr,
                    );
                }
                14 => {
                    xmlSchemaFreeElement(item as xmlSchemaElementPtr);
                }
                25 => {
                    if !((*item).annot).is_null() {
                        xmlSchemaFreeAnnot((*item).annot);
                    }
                    xmlFree
                        .expect("non-null function pointer")(item as *mut libc::c_void);
                }
                6 | 7 | 8 => {
                    xmlSchemaFreeModelGroup(item as xmlSchemaModelGroupPtr);
                }
                16 => {
                    xmlSchemaFreeAttributeGroup(item as xmlSchemaAttributeGroupPtr);
                }
                17 => {
                    xmlSchemaFreeModelGroupDef(item as xmlSchemaModelGroupDefPtr);
                }
                2 | 21 => {
                    xmlSchemaFreeWildcard(item as xmlSchemaWildcardPtr);
                }
                23 | 22 | 24 => {
                    xmlSchemaFreeIDC(item as xmlSchemaIDCPtr);
                }
                18 => {
                    xmlSchemaFreeNotation(item as xmlSchemaNotationPtr);
                }
                2000 => {
                    xmlSchemaFreeQNameRef(item as xmlSchemaQNameRefPtr);
                }
                _ => {
                    xmlSchemaPSimpleInternalErr(
                        0 as xmlNodePtr,
                        b"Internal error: xmlSchemaComponentListFree, unexpected component type '%s'\n\0"
                            as *const u8 as *const i8,
                        xmlSchemaGetComponentTypeStr(item as xmlSchemaBasicItemPtr),
                    );
                }
            }
        }
        i += 1;
    }
    (*list).nbItems = 0 as i32;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFree(mut schema: xmlSchemaPtr) {
    if schema.is_null() {
        return;
    }
    if !((*schema).volatiles).is_null() {
        (*__xmlGenericError())
            .expect(
                "non-null function pointer",
            )(
            *__xmlGenericErrorContext(),
            b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
            b"xmlschemas.c\0" as *const u8 as *const i8,
            4191 as i32,
        );
    }
    if !((*schema).notaDecl).is_null() {
        xmlHashFree((*schema).notaDecl, None);
    }
    if !((*schema).attrDecl).is_null() {
        xmlHashFree((*schema).attrDecl, None);
    }
    if !((*schema).attrgrpDecl).is_null() {
        xmlHashFree((*schema).attrgrpDecl, None);
    }
    if !((*schema).elemDecl).is_null() {
        xmlHashFree((*schema).elemDecl, None);
    }
    if !((*schema).typeDecl).is_null() {
        xmlHashFree((*schema).typeDecl, None);
    }
    if !((*schema).groupDecl).is_null() {
        xmlHashFree((*schema).groupDecl, None);
    }
    if !((*schema).idcDef).is_null() {
        xmlHashFree((*schema).idcDef, None);
    }
    if !((*schema).schemasImports).is_null() {
        xmlHashFree(
            (*schema).schemasImports,
            Some(
                xmlSchemaBucketFreeEntry
                    as unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
            ),
        );
    }
    if !((*schema).includes).is_null() {
        let mut list: xmlSchemaItemListPtr = (*schema).includes as xmlSchemaItemListPtr;
        let mut i: i32 = 0;
        i = 0 as i32;
        while i < (*list).nbItems {
            xmlSchemaBucketFree(
                *((*list).items).offset(i as isize) as xmlSchemaBucketPtr,
            );
            i += 1;
        }
        xmlSchemaItemListFree(list);
    }
    if !((*schema).annot).is_null() {
        xmlSchemaFreeAnnot((*schema).annot);
    }
    xmlDictFree((*schema).dict);
    xmlFree.expect("non-null function pointer")(schema as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaElementDump(
    mut payload: *mut libc::c_void,
    mut data: *mut libc::c_void,
    mut name: *const xmlChar,
    mut namespace: *const xmlChar,
    mut context: *const xmlChar,
) {
    let mut elem: xmlSchemaElementPtr = payload as xmlSchemaElementPtr;
    let mut output: *mut FILE = data as *mut FILE;
    if elem.is_null() {
        return;
    }
    fprintf(output, b"Element\0" as *const u8 as *const i8);
    if (*elem).flags & (1 as i32) << 1 as i32 != 0 {
        fprintf(output, b" (global)\0" as *const u8 as *const i8);
    }
    fprintf(output, b": '%s' \0" as *const u8 as *const i8, (*elem).name);
    if !namespace.is_null() {
        fprintf(output, b"ns '%s'\0" as *const u8 as *const i8, namespace);
    }
    fprintf(output, b"\n\0" as *const u8 as *const i8);
    if (*elem).flags & (1 as i32) << 0 as i32 != 0
        || (*elem).flags & (1 as i32) << 4 as i32 != 0
        || (*elem).flags & (1 as i32) << 3 as i32 != 0
        || (*elem).flags & (1 as i32) << 2 as i32 != 0
    {
        fprintf(output, b"  props: \0" as *const u8 as *const i8);
        if (*elem).flags & (1 as i32) << 3 as i32 != 0 {
            fprintf(output, b"[fixed] \0" as *const u8 as *const i8);
        }
        if (*elem).flags & (1 as i32) << 2 as i32 != 0 {
            fprintf(output, b"[default] \0" as *const u8 as *const i8);
        }
        if (*elem).flags & (1 as i32) << 4 as i32 != 0 {
            fprintf(output, b"[abstract] \0" as *const u8 as *const i8);
        }
        if (*elem).flags & (1 as i32) << 0 as i32 != 0 {
            fprintf(output, b"[nillable] \0" as *const u8 as *const i8);
        }
        fprintf(output, b"\n\0" as *const u8 as *const i8);
    }
    if !((*elem).value).is_null() {
        fprintf(
            output,
            b"  value: '%s'\n\0" as *const u8 as *const i8,
            (*elem).value,
        );
    }
    if !((*elem).namedType).is_null() {
        fprintf(
            output,
            b"  type: '%s' \0" as *const u8 as *const i8,
            (*elem).namedType,
        );
        if !((*elem).namedTypeNs).is_null() {
            fprintf(
                output,
                b"ns '%s'\n\0" as *const u8 as *const i8,
                (*elem).namedTypeNs,
            );
        } else {
            fprintf(output, b"\n\0" as *const u8 as *const i8);
        }
    } else if !((*elem).subtypes).is_null() {
        xmlSchemaTypeDump((*elem).subtypes, output);
    }
    if !((*elem).substGroup).is_null() {
        fprintf(
            output,
            b"  substitutionGroup: '%s' \0" as *const u8 as *const i8,
            (*elem).substGroup,
        );
        if !((*elem).substGroupNs).is_null() {
            fprintf(
                output,
                b"ns '%s'\n\0" as *const u8 as *const i8,
                (*elem).substGroupNs,
            );
        } else {
            fprintf(output, b"\n\0" as *const u8 as *const i8);
        }
    }
}
unsafe extern "C" fn xmlSchemaAnnotDump(
    mut output: *mut FILE,
    mut annot: xmlSchemaAnnotPtr,
) {
    let mut content: *mut xmlChar = 0 as *mut xmlChar;
    if annot.is_null() {
        return;
    }
    content = xmlNodeGetContent((*annot).content as *const xmlNode);
    if !content.is_null() {
        fprintf(output, b"  Annot: %s\n\0" as *const u8 as *const i8, content);
        xmlFree.expect("non-null function pointer")(content as *mut libc::c_void);
    } else {
        fprintf(output, b"  Annot: empty\n\0" as *const u8 as *const i8);
    };
}
unsafe extern "C" fn xmlSchemaContentModelDump(
    mut particle: xmlSchemaParticlePtr,
    mut output: *mut FILE,
    mut depth: i32,
) {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut term: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
    let mut shift: [i8; 100] = [0; 100];
    let mut i: i32 = 0;
    if particle.is_null() {
        return;
    }
    i = 0 as i32;
    while i < depth && i < 25 as i32 {
        shift[(2 as i32 * i + 1 as i32)
            as usize] = ' ' as i32 as i8;
        shift[(2 as i32 * i)
            as usize] = shift[(2 as i32 * i + 1 as i32) as usize];
        i += 1;
    }
    shift[(2 as i32 * i + 1 as i32)
        as usize] = 0 as i32 as i8;
    shift[(2 as i32 * i)
        as usize] = shift[(2 as i32 * i + 1 as i32) as usize];
    fprintf(output, b"%s\0" as *const u8 as *const i8, shift.as_mut_ptr());
    if ((*particle).children).is_null() {
        fprintf(
            output,
            b"MISSING particle term\n\0" as *const u8 as *const i8,
        );
        return;
    }
    term = (*particle).children;
    if term.is_null() {
        fprintf(output, b"(NULL)\0" as *const u8 as *const i8);
    } else {
        match (*term).type_0 as u32 {
            14 => {
                fprintf(
                    output,
                    b"ELEM '%s'\0" as *const u8 as *const i8,
                    xmlSchemaFormatQName(
                        &mut str,
                        (*(term as xmlSchemaElementPtr)).targetNamespace,
                        (*(term as xmlSchemaElementPtr)).name,
                    ),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
            }
            6 => {
                fprintf(output, b"SEQUENCE\0" as *const u8 as *const i8);
            }
            7 => {
                fprintf(output, b"CHOICE\0" as *const u8 as *const i8);
            }
            8 => {
                fprintf(output, b"ALL\0" as *const u8 as *const i8);
            }
            2 => {
                fprintf(output, b"ANY\0" as *const u8 as *const i8);
            }
            _ => {
                fprintf(output, b"UNKNOWN\n\0" as *const u8 as *const i8);
                return;
            }
        }
    }
    if (*particle).minOccurs != 1 as i32 {
        fprintf(
            output,
            b" min: %d\0" as *const u8 as *const i8,
            (*particle).minOccurs,
        );
    }
    if (*particle).maxOccurs >= (1 as i32) << 30 as i32 {
        fprintf(output, b" max: unbounded\0" as *const u8 as *const i8);
    } else if (*particle).maxOccurs != 1 as i32 {
        fprintf(
            output,
            b" max: %d\0" as *const u8 as *const i8,
            (*particle).maxOccurs,
        );
    }
    fprintf(output, b"\n\0" as *const u8 as *const i8);
    if !term.is_null()
        && ((*term).type_0 as u32
            == XML_SCHEMA_TYPE_SEQUENCE as i32 as u32
            || (*term).type_0 as u32
                == XML_SCHEMA_TYPE_CHOICE as i32 as u32
            || (*term).type_0 as u32
                == XML_SCHEMA_TYPE_ALL as i32 as u32)
        && !((*term).children).is_null()
    {
        xmlSchemaContentModelDump(
            (*term).children as xmlSchemaParticlePtr,
            output,
            depth + 1 as i32,
        );
    }
    if !((*particle).next).is_null() {
        xmlSchemaContentModelDump(
            (*particle).next as xmlSchemaParticlePtr,
            output,
            depth,
        );
    }
}
unsafe extern "C" fn xmlSchemaAttrUsesDump(
    mut uses: xmlSchemaItemListPtr,
    mut output: *mut FILE,
) {
    let mut use_0: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
    let mut prohib: xmlSchemaAttributeUseProhibPtr = 0
        as *mut xmlSchemaAttributeUseProhib;
    let mut ref_0: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut tns: *const xmlChar = 0 as *const xmlChar;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    let mut i: i32 = 0;
    if uses.is_null() || (*uses).nbItems == 0 as i32 {
        return;
    }
    fprintf(output, b"  attributes:\n\0" as *const u8 as *const i8);
    i = 0 as i32;
    while i < (*uses).nbItems {
        use_0 = *((*uses).items).offset(i as isize) as xmlSchemaAttributeUsePtr;
        if (*use_0).type_0 as u32
            == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB as i32 as u32
        {
            fprintf(output, b"  [prohibition] \0" as *const u8 as *const i8);
            prohib = use_0 as xmlSchemaAttributeUseProhibPtr;
            name = (*prohib).name;
            tns = (*prohib).targetNamespace;
        } else if (*use_0).type_0 as u32
                == XML_SCHEMA_EXTRA_QNAMEREF as i32 as u32
            {
            fprintf(output, b"  [reference] \0" as *const u8 as *const i8);
            ref_0 = use_0 as xmlSchemaQNameRefPtr;
            name = (*ref_0).name;
            tns = (*ref_0).targetNamespace;
        } else {
            fprintf(output, b"  [use] \0" as *const u8 as *const i8);
            name = (*(*use_0).attrDecl).name;
            tns = (*(*use_0).attrDecl).targetNamespace;
        }
        fprintf(
            output,
            b"'%s'\n\0" as *const u8 as *const i8,
            xmlSchemaFormatQName(&mut str, tns, name) as *const i8,
        );
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
        i += 1;
    }
}
unsafe extern "C" fn xmlSchemaTypeDump(
    mut type_0: xmlSchemaTypePtr,
    mut output: *mut FILE,
) {
    if type_0.is_null() {
        fprintf(output, b"Type: NULL\n\0" as *const u8 as *const i8);
        return;
    }
    fprintf(output, b"Type: \0" as *const u8 as *const i8);
    if !((*type_0).name).is_null() {
        fprintf(output, b"'%s' \0" as *const u8 as *const i8, (*type_0).name);
    } else {
        fprintf(output, b"(no name) \0" as *const u8 as *const i8);
    }
    if !((*type_0).targetNamespace).is_null() {
        fprintf(
            output,
            b"ns '%s' \0" as *const u8 as *const i8,
            (*type_0).targetNamespace,
        );
    }
    match (*type_0).type_0 as u32 {
        1 => {
            fprintf(output, b"[basic] \0" as *const u8 as *const i8);
        }
        4 => {
            fprintf(output, b"[simple] \0" as *const u8 as *const i8);
        }
        5 => {
            fprintf(output, b"[complex] \0" as *const u8 as *const i8);
        }
        6 => {
            fprintf(output, b"[sequence] \0" as *const u8 as *const i8);
        }
        7 => {
            fprintf(output, b"[choice] \0" as *const u8 as *const i8);
        }
        8 => {
            fprintf(output, b"[all] \0" as *const u8 as *const i8);
        }
        11 => {
            fprintf(output, b"[ur] \0" as *const u8 as *const i8);
        }
        12 => {
            fprintf(output, b"[restriction] \0" as *const u8 as *const i8);
        }
        13 => {
            fprintf(output, b"[extension] \0" as *const u8 as *const i8);
        }
        _ => {
            fprintf(
                output,
                b"[unknown type %d] \0" as *const u8 as *const i8,
                (*type_0).type_0 as u32,
            );
        }
    }
    fprintf(output, b"content: \0" as *const u8 as *const i8);
    match (*type_0).contentType as u32 {
        0 => {
            fprintf(output, b"[unknown] \0" as *const u8 as *const i8);
        }
        1 => {
            fprintf(output, b"[empty] \0" as *const u8 as *const i8);
        }
        2 => {
            fprintf(output, b"[element] \0" as *const u8 as *const i8);
        }
        3 => {
            fprintf(output, b"[mixed] \0" as *const u8 as *const i8);
        }
        6 => {
            fprintf(output, b"[basic] \0" as *const u8 as *const i8);
        }
        4 => {
            fprintf(output, b"[simple] \0" as *const u8 as *const i8);
        }
        7 => {
            fprintf(output, b"[any] \0" as *const u8 as *const i8);
        }
        5 | _ => {}
    }
    fprintf(output, b"\n\0" as *const u8 as *const i8);
    if !((*type_0).base).is_null() {
        fprintf(
            output,
            b"  base type: '%s'\0" as *const u8 as *const i8,
            (*type_0).base,
        );
        if !((*type_0).baseNs).is_null() {
            fprintf(
                output,
                b" ns '%s'\n\0" as *const u8 as *const i8,
                (*type_0).baseNs,
            );
        } else {
            fprintf(output, b"\n\0" as *const u8 as *const i8);
        }
    }
    if !((*type_0).attrUses).is_null() {
        xmlSchemaAttrUsesDump((*type_0).attrUses as xmlSchemaItemListPtr, output);
    }
    if !((*type_0).annot).is_null() {
        xmlSchemaAnnotDump(output, (*type_0).annot);
    }
    if (*type_0).type_0 as u32
        == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        && !((*type_0).subtypes).is_null()
    {
        xmlSchemaContentModelDump(
            (*type_0).subtypes as xmlSchemaParticlePtr,
            output,
            1 as i32,
        );
    }
}
unsafe extern "C" fn xmlSchemaTypeDumpEntry(
    mut type_0: *mut libc::c_void,
    mut output: *mut libc::c_void,
    mut name: *const xmlChar,
) {
    xmlSchemaTypeDump(type_0 as xmlSchemaTypePtr, output as *mut FILE);
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaDump(mut output: *mut FILE, mut schema: xmlSchemaPtr) {
    if output.is_null() {
        return;
    }
    if schema.is_null() {
        fprintf(output, b"Schemas: NULL\n\0" as *const u8 as *const i8);
        return;
    }
    fprintf(output, b"Schemas: \0" as *const u8 as *const i8);
    if !((*schema).name).is_null() {
        fprintf(output, b"%s, \0" as *const u8 as *const i8, (*schema).name);
    } else {
        fprintf(output, b"no name, \0" as *const u8 as *const i8);
    }
    if !((*schema).targetNamespace).is_null() {
        fprintf(
            output,
            b"%s\0" as *const u8 as *const i8,
            (*schema).targetNamespace as *const i8,
        );
    } else {
        fprintf(output, b"no target namespace\0" as *const u8 as *const i8);
    }
    fprintf(output, b"\n\0" as *const u8 as *const i8);
    if !((*schema).annot).is_null() {
        xmlSchemaAnnotDump(output, (*schema).annot);
    }
    xmlHashScan(
        (*schema).typeDecl,
        Some(
            xmlSchemaTypeDumpEntry
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *mut libc::c_void,
                    *const xmlChar,
                ) -> (),
        ),
        output as *mut libc::c_void,
    );
    xmlHashScanFull(
        (*schema).elemDecl,
        Some(
            xmlSchemaElementDump
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *mut libc::c_void,
                    *const xmlChar,
                    *const xmlChar,
                    *const xmlChar,
                ) -> (),
        ),
        output as *mut libc::c_void,
    );
}
unsafe extern "C" fn xmlSchemaGetPropNode(
    mut node: xmlNodePtr,
    mut name: *const i8,
) -> xmlAttrPtr {
    let mut prop: xmlAttrPtr = 0 as *mut xmlAttr;
    if node.is_null() || name.is_null() {
        return 0 as xmlAttrPtr;
    }
    prop = (*node).properties;
    while !prop.is_null() {
        if ((*prop).ns).is_null() && xmlStrEqual((*prop).name, name as *mut xmlChar) != 0
        {
            return prop;
        }
        prop = (*prop).next;
    }
    return 0 as xmlAttrPtr;
}
unsafe extern "C" fn xmlSchemaGetPropNodeNs(
    mut node: xmlNodePtr,
    mut uri: *const i8,
    mut name: *const i8,
) -> xmlAttrPtr {
    let mut prop: xmlAttrPtr = 0 as *mut xmlAttr;
    if node.is_null() || name.is_null() {
        return 0 as xmlAttrPtr;
    }
    prop = (*node).properties;
    while !prop.is_null() {
        if !((*prop).ns).is_null()
            && xmlStrEqual((*prop).name, name as *mut xmlChar) != 0
            && xmlStrEqual((*(*prop).ns).href, uri as *mut xmlChar) != 0
        {
            return prop;
        }
        prop = (*prop).next;
    }
    return 0 as xmlAttrPtr;
}
unsafe extern "C" fn xmlSchemaGetNodeContent(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
) -> *const xmlChar {
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    val = xmlNodeGetContent(node as *const xmlNode);
    if val.is_null() {
        val = xmlStrdup(b"\0" as *const u8 as *const i8 as *mut xmlChar);
    }
    ret = xmlDictLookup((*ctxt).dict, val, -(1 as i32));
    xmlFree.expect("non-null function pointer")(val as *mut libc::c_void);
    return ret;
}
unsafe extern "C" fn xmlSchemaGetNodeContentNoDict(
    mut node: xmlNodePtr,
) -> *const xmlChar {
    return xmlNodeGetContent(node as *const xmlNode) as *const xmlChar;
}
unsafe extern "C" fn xmlSchemaGetProp(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut name: *const i8,
) -> *const xmlChar {
    let mut val: *mut xmlChar = 0 as *mut xmlChar;
    let mut ret: *const xmlChar = 0 as *const xmlChar;
    val = xmlGetNoNsProp(node as *const xmlNode, name as *mut xmlChar);
    if val.is_null() {
        return 0 as *const xmlChar;
    }
    ret = xmlDictLookup((*ctxt).dict, val, -(1 as i32));
    xmlFree.expect("non-null function pointer")(val as *mut libc::c_void);
    return ret;
}
unsafe extern "C" fn xmlSchemaGetElem(
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
) -> xmlSchemaElementPtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaElementPtr = 0 as xmlSchemaElementPtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaElementPtr;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret = xmlHashLookup((*schema).elemDecl, name) as xmlSchemaElementPtr;
            if !ret.is_null() {
                current_block = 16011728522843784008;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            16011728522843784008 => {}
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as i32 {
                    let mut import: xmlSchemaImportPtr = 0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import = xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const i8 as *const xmlChar,
                        ) as xmlSchemaImportPtr;
                    } else {
                        import = xmlHashLookup((*schema).schemasImports, nsName)
                            as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = xmlHashLookup((*(*import).schema).elemDecl, name)
                            as xmlSchemaElementPtr;
                    }
                }
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaGetType(
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
) -> xmlSchemaTypePtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
    if name.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    if !nsName.is_null() && xmlStrEqual(nsName, xmlSchemaNs) != 0 {
        ret = xmlSchemaGetPredefinedType(name, nsName);
        if !ret.is_null() {
            current_block = 7386887182042359627;
        } else {
            current_block = 15427931788582360902;
        }
    } else {
        current_block = 15427931788582360902;
    }
    match current_block {
        15427931788582360902 => {
            if !schema.is_null() {
                if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
                    ret = xmlHashLookup((*schema).typeDecl, name) as xmlSchemaTypePtr;
                    if !ret.is_null() {
                        current_block = 7386887182042359627;
                    } else {
                        current_block = 11812396948646013369;
                    }
                } else {
                    current_block = 11812396948646013369;
                }
                match current_block {
                    7386887182042359627 => {}
                    _ => {
                        if xmlHashSize((*schema).schemasImports) > 1 as i32 {
                            let mut import: xmlSchemaImportPtr = 0
                                as *mut xmlSchemaImport;
                            if nsName.is_null() {
                                import = xmlHashLookup(
                                    (*schema).schemasImports,
                                    b"##\0" as *const u8 as *const i8
                                        as *const xmlChar,
                                ) as xmlSchemaImportPtr;
                            } else {
                                import = xmlHashLookup((*schema).schemasImports, nsName)
                                    as xmlSchemaImportPtr;
                            }
                            if !import.is_null() {
                                ret = xmlHashLookup((*(*import).schema).typeDecl, name)
                                    as xmlSchemaTypePtr;
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaGetAttributeDecl(
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
) -> xmlSchemaAttributePtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaAttributePtr = 0 as xmlSchemaAttributePtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaAttributePtr;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret = xmlHashLookup((*schema).attrDecl, name) as xmlSchemaAttributePtr;
            if !ret.is_null() {
                current_block = 16794065014550217599;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            16794065014550217599 => {}
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as i32 {
                    let mut import: xmlSchemaImportPtr = 0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import = xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const i8 as *const xmlChar,
                        ) as xmlSchemaImportPtr;
                    } else {
                        import = xmlHashLookup((*schema).schemasImports, nsName)
                            as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = xmlHashLookup((*(*import).schema).attrDecl, name)
                            as xmlSchemaAttributePtr;
                    }
                }
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaGetAttributeGroup(
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
) -> xmlSchemaAttributeGroupPtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaAttributeGroupPtr = 0 as xmlSchemaAttributeGroupPtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret = xmlHashLookup((*schema).attrgrpDecl, name)
                as xmlSchemaAttributeGroupPtr;
            if !ret.is_null() {
                current_block = 16237746940514357066;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            16237746940514357066 => {}
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as i32 {
                    let mut import: xmlSchemaImportPtr = 0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import = xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const i8 as *const xmlChar,
                        ) as xmlSchemaImportPtr;
                    } else {
                        import = xmlHashLookup((*schema).schemasImports, nsName)
                            as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = xmlHashLookup((*(*import).schema).attrgrpDecl, name)
                            as xmlSchemaAttributeGroupPtr;
                    }
                }
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaGetGroup(
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
) -> xmlSchemaModelGroupDefPtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaModelGroupDefPtr = 0 as xmlSchemaModelGroupDefPtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaModelGroupDefPtr;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret = xmlHashLookup((*schema).groupDecl, name) as xmlSchemaModelGroupDefPtr;
            if !ret.is_null() {
                current_block = 13643637003490791894;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            13643637003490791894 => {}
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as i32 {
                    let mut import: xmlSchemaImportPtr = 0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import = xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const i8 as *const xmlChar,
                        ) as xmlSchemaImportPtr;
                    } else {
                        import = xmlHashLookup((*schema).schemasImports, nsName)
                            as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = xmlHashLookup((*(*import).schema).groupDecl, name)
                            as xmlSchemaModelGroupDefPtr;
                    }
                }
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaGetNotation(
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
) -> xmlSchemaNotationPtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaNotationPtr = 0 as xmlSchemaNotationPtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaNotationPtr;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret = xmlHashLookup((*schema).notaDecl, name) as xmlSchemaNotationPtr;
            if !ret.is_null() {
                current_block = 16231198170495011546;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            16231198170495011546 => {}
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as i32 {
                    let mut import: xmlSchemaImportPtr = 0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import = xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const i8 as *const xmlChar,
                        ) as xmlSchemaImportPtr;
                    } else {
                        import = xmlHashLookup((*schema).schemasImports, nsName)
                            as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = xmlHashLookup((*(*import).schema).notaDecl, name)
                            as xmlSchemaNotationPtr;
                    }
                }
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaGetIDC(
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
) -> xmlSchemaIDCPtr {
    let mut current_block: u64;
    let mut ret: xmlSchemaIDCPtr = 0 as xmlSchemaIDCPtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaIDCPtr;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, (*schema).targetNamespace) != 0 {
            ret = xmlHashLookup((*schema).idcDef, name) as xmlSchemaIDCPtr;
            if !ret.is_null() {
                current_block = 6863404656786974296;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            6863404656786974296 => {}
            _ => {
                if xmlHashSize((*schema).schemasImports) > 1 as i32 {
                    let mut import: xmlSchemaImportPtr = 0 as *mut xmlSchemaImport;
                    if nsName.is_null() {
                        import = xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const i8 as *const xmlChar,
                        ) as xmlSchemaImportPtr;
                    } else {
                        import = xmlHashLookup((*schema).schemasImports, nsName)
                            as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = xmlHashLookup((*(*import).schema).idcDef, name)
                            as xmlSchemaIDCPtr;
                    }
                }
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaGetNamedComponent(
    mut schema: xmlSchemaPtr,
    mut itemType: xmlSchemaTypeType,
    mut name: *const xmlChar,
    mut targetNs: *const xmlChar,
) -> xmlSchemaBasicItemPtr {
    match itemType as u32 {
        17 => return xmlSchemaGetGroup(schema, name, targetNs) as xmlSchemaBasicItemPtr,
        14 => return xmlSchemaGetElem(schema, name, targetNs) as xmlSchemaBasicItemPtr,
        _ => {
            (*__xmlGenericError())
                .expect(
                    "non-null function pointer",
                )(
                *__xmlGenericErrorContext(),
                b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
                b"xmlschemas.c\0" as *const u8 as *const i8,
                5063 as i32,
            );
            return 0 as xmlSchemaBasicItemPtr;
        }
    };
}
unsafe extern "C" fn xmlSchemaIsBlank(
    mut str: *mut xmlChar,
    mut len: i32,
) -> i32 {
    if str.is_null() {
        return 1 as i32;
    }
    if len < 0 as i32 {
        while *str as i32 != 0 as i32 {
            if !(*str as i32 == 0x20 as i32
                || 0x9 as i32 <= *str as i32
                    && *str as i32 <= 0xa as i32
                || *str as i32 == 0xd as i32)
            {
                return 0 as i32;
            }
            str = str.offset(1);
        }
    } else {
        while *str as i32 != 0 as i32 && len != 0 as i32 {
            if !(*str as i32 == 0x20 as i32
                || 0x9 as i32 <= *str as i32
                    && *str as i32 <= 0xa as i32
                || *str as i32 == 0xd as i32)
            {
                return 0 as i32;
            }
            str = str.offset(1);
            len -= 1;
        }
    }
    return 1 as i32;
}
unsafe extern "C" fn xmlSchemaFindRedefCompInGraph(
    mut bucket: xmlSchemaBucketPtr,
    mut type_0: xmlSchemaTypeType,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
) -> xmlSchemaBasicItemPtr {
    let mut ret: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    let mut i: i32 = 0;
    if bucket.is_null() || name.is_null() {
        return 0 as xmlSchemaBasicItemPtr;
    }
    if !(((*bucket).globals).is_null()
        || (*(*bucket).globals).nbItems == 0 as i32)
    {
        i = 0 as i32;
        while i < (*(*bucket).globals).nbItems {
            ret = *((*(*bucket).globals).items).offset(i as isize)
                as xmlSchemaBasicItemPtr;
            if (*ret).type_0 as u32 == type_0 as u32 {
                match type_0 as u32 {
                    5 | 4 => {
                        if (*(ret as xmlSchemaTypePtr)).name == name
                            && (*(ret as xmlSchemaTypePtr)).targetNamespace == nsName
                        {
                            return ret;
                        }
                    }
                    17 => {
                        if (*(ret as xmlSchemaModelGroupDefPtr)).name == name
                            && (*(ret as xmlSchemaModelGroupDefPtr)).targetNamespace
                                == nsName
                        {
                            return ret;
                        }
                    }
                    16 => {
                        if (*(ret as xmlSchemaAttributeGroupPtr)).name == name
                            && (*(ret as xmlSchemaAttributeGroupPtr)).targetNamespace
                                == nsName
                        {
                            return ret;
                        }
                    }
                    _ => return 0 as xmlSchemaBasicItemPtr,
                }
            }
            i += 1;
        }
    }
    if !((*bucket).relations).is_null() {
        let mut rel: xmlSchemaSchemaRelationPtr = (*bucket).relations;
        (*bucket).flags |= (1 as i32) << 0 as i32;
        loop {
            if !((*rel).bucket).is_null()
                && (*(*rel).bucket).flags & (1 as i32) << 0 as i32
                    == 0 as i32
            {
                ret = xmlSchemaFindRedefCompInGraph((*rel).bucket, type_0, name, nsName);
                if !ret.is_null() {
                    return ret;
                }
            }
            rel = (*rel).next;
            if rel.is_null() {
                break;
            }
        }
        (*bucket).flags ^= (1 as i32) << 0 as i32;
    }
    return 0 as xmlSchemaBasicItemPtr;
}
unsafe extern "C" fn xmlSchemaAddNotation(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
    mut node: xmlNodePtr,
) -> xmlSchemaNotationPtr {
    let mut ret: xmlSchemaNotationPtr = 0 as xmlSchemaNotationPtr;
    if ctxt.is_null() || schema.is_null() || name.is_null() {
        return 0 as xmlSchemaNotationPtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaNotation>() as u64)
        as xmlSchemaNotationPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"add annotation\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaNotationPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaNotation>() as u64,
    );
    (*ret).type_0 = XML_SCHEMA_TYPE_NOTATION;
    let fresh43 = &mut ((*ret).name);
    *fresh43 = name;
    let fresh44 = &mut ((*ret).targetNamespace);
    *fresh44 = nsName;
    xmlSchemaAddItemSize(
        &mut (*(*(*ctxt).constructor).bucket).globals,
        5 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaAddAttribute(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
    mut node: xmlNodePtr,
    mut topLevel: i32,
) -> xmlSchemaAttributePtr {
    let mut ret: xmlSchemaAttributePtr = 0 as xmlSchemaAttributePtr;
    if ctxt.is_null() || schema.is_null() {
        return 0 as xmlSchemaAttributePtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaAttribute>() as u64)
        as xmlSchemaAttributePtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating attribute\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaAttributePtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaAttribute>() as u64,
    );
    (*ret).type_0 = XML_SCHEMA_TYPE_ATTRIBUTE;
    let fresh45 = &mut ((*ret).node);
    *fresh45 = node;
    let fresh46 = &mut ((*ret).name);
    *fresh46 = name;
    let fresh47 = &mut ((*ret).targetNamespace);
    *fresh47 = nsName;
    if topLevel != 0 {
        xmlSchemaAddItemSize(
            &mut (*(*(*ctxt).constructor).bucket).globals,
            5 as i32,
            ret as *mut libc::c_void,
        );
    } else {
        xmlSchemaAddItemSize(
            &mut (*(*(*ctxt).constructor).bucket).locals,
            10 as i32,
            ret as *mut libc::c_void,
        );
    }
    xmlSchemaAddItemSize(
        &mut (*(*ctxt).constructor).pending,
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaAddAttributeUse(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaAttributeUsePtr {
    let mut ret: xmlSchemaAttributeUsePtr = 0 as xmlSchemaAttributeUsePtr;
    if pctxt.is_null() {
        return 0 as xmlSchemaAttributeUsePtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaAttributeUse>() as u64)
        as xmlSchemaAttributeUsePtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            pctxt,
            b"allocating attribute\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaAttributeUsePtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaAttributeUse>() as u64,
    );
    (*ret).type_0 = XML_SCHEMA_TYPE_ATTRIBUTE_USE;
    let fresh48 = &mut ((*ret).node);
    *fresh48 = node;
    xmlSchemaAddItemSize(
        &mut (*(*(*pctxt).constructor).bucket).locals,
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaAddRedef(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut targetBucket: xmlSchemaBucketPtr,
    mut item: *mut libc::c_void,
    mut refName: *const xmlChar,
    mut refTargetNs: *const xmlChar,
) -> xmlSchemaRedefPtr {
    let mut ret: xmlSchemaRedefPtr = 0 as *mut xmlSchemaRedef;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaRedef>() as u64) as xmlSchemaRedefPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            pctxt,
            b"allocating redefinition info\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaRedefPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaRedef>() as u64,
    );
    let fresh49 = &mut ((*ret).item);
    *fresh49 = item as xmlSchemaBasicItemPtr;
    let fresh50 = &mut ((*ret).targetBucket);
    *fresh50 = targetBucket;
    let fresh51 = &mut ((*ret).refName);
    *fresh51 = refName;
    let fresh52 = &mut ((*ret).refTargetNs);
    *fresh52 = refTargetNs;
    if ((*(*pctxt).constructor).redefs).is_null() {
        let fresh53 = &mut ((*(*pctxt).constructor).redefs);
        *fresh53 = ret;
    } else {
        let fresh54 = &mut ((*(*(*pctxt).constructor).lastRedef).next);
        *fresh54 = ret;
    }
    let fresh55 = &mut ((*(*pctxt).constructor).lastRedef);
    *fresh55 = ret;
    return ret;
}
unsafe extern "C" fn xmlSchemaAddAttributeGroupDefinition(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
    mut node: xmlNodePtr,
) -> xmlSchemaAttributeGroupPtr {
    let mut ret: xmlSchemaAttributeGroupPtr = 0 as xmlSchemaAttributeGroupPtr;
    if pctxt.is_null() || name.is_null() {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaAttributeGroup>() as u64)
        as xmlSchemaAttributeGroupPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            pctxt,
            b"allocating attribute group\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaAttributeGroup>() as u64,
    );
    (*ret).type_0 = XML_SCHEMA_TYPE_ATTRIBUTEGROUP;
    let fresh56 = &mut ((*ret).name);
    *fresh56 = name;
    let fresh57 = &mut ((*ret).targetNamespace);
    *fresh57 = nsName;
    let fresh58 = &mut ((*ret).node);
    *fresh58 = node;
    (*ret).flags |= (1 as i32) << 1 as i32;
    if (*pctxt).isRedefine != 0 {
        let fresh59 = &mut ((*pctxt).redef);
        *fresh59 = xmlSchemaAddRedef(
            pctxt,
            (*pctxt).redefined,
            ret as *mut libc::c_void,
            name,
            nsName,
        );
        if ((*pctxt).redef).is_null() {
            xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void);
            return 0 as xmlSchemaAttributeGroupPtr;
        }
        (*pctxt).redefCounter = 0 as i32;
    }
    xmlSchemaAddItemSize(
        &mut (*(*(*pctxt).constructor).bucket).globals,
        5 as i32,
        ret as *mut libc::c_void,
    );
    xmlSchemaAddItemSize(
        &mut (*(*pctxt).constructor).pending,
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaAddElement(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
    mut node: xmlNodePtr,
    mut topLevel: i32,
) -> xmlSchemaElementPtr {
    let mut ret: xmlSchemaElementPtr = 0 as xmlSchemaElementPtr;
    if ctxt.is_null() || name.is_null() {
        return 0 as xmlSchemaElementPtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaElement>() as u64)
        as xmlSchemaElementPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating element\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaElementPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaElement>() as u64,
    );
    (*ret).type_0 = XML_SCHEMA_TYPE_ELEMENT;
    let fresh60 = &mut ((*ret).name);
    *fresh60 = name;
    let fresh61 = &mut ((*ret).targetNamespace);
    *fresh61 = nsName;
    let fresh62 = &mut ((*ret).node);
    *fresh62 = node;
    if topLevel != 0 {
        xmlSchemaAddItemSize(
            &mut (*(*(*ctxt).constructor).bucket).globals,
            5 as i32,
            ret as *mut libc::c_void,
        );
    } else {
        xmlSchemaAddItemSize(
            &mut (*(*(*ctxt).constructor).bucket).locals,
            10 as i32,
            ret as *mut libc::c_void,
        );
    }
    xmlSchemaAddItemSize(
        &mut (*(*ctxt).constructor).pending,
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaAddType(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut type_0: xmlSchemaTypeType,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
    mut node: xmlNodePtr,
    mut topLevel: i32,
) -> xmlSchemaTypePtr {
    let mut ret: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
    if ctxt.is_null() || schema.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaType>() as u64) as xmlSchemaTypePtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating type\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaTypePtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaType>() as u64,
    );
    (*ret).type_0 = type_0;
    let fresh63 = &mut ((*ret).name);
    *fresh63 = name;
    let fresh64 = &mut ((*ret).targetNamespace);
    *fresh64 = nsName;
    let fresh65 = &mut ((*ret).node);
    *fresh65 = node;
    if topLevel != 0 {
        if (*ctxt).isRedefine != 0 {
            let fresh66 = &mut ((*ctxt).redef);
            *fresh66 = xmlSchemaAddRedef(
                ctxt,
                (*ctxt).redefined,
                ret as *mut libc::c_void,
                name,
                nsName,
            );
            if ((*ctxt).redef).is_null() {
                xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void);
                return 0 as xmlSchemaTypePtr;
            }
            (*ctxt).redefCounter = 0 as i32;
        }
        xmlSchemaAddItemSize(
            &mut (*(*(*ctxt).constructor).bucket).globals,
            5 as i32,
            ret as *mut libc::c_void,
        );
    } else {
        xmlSchemaAddItemSize(
            &mut (*(*(*ctxt).constructor).bucket).locals,
            10 as i32,
            ret as *mut libc::c_void,
        );
    }
    xmlSchemaAddItemSize(
        &mut (*(*ctxt).constructor).pending,
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaNewQNameRef(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut refType: xmlSchemaTypeType,
    mut refName: *const xmlChar,
    mut refNs: *const xmlChar,
) -> xmlSchemaQNameRefPtr {
    let mut ret: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaQNameRef>() as u64)
        as xmlSchemaQNameRefPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            pctxt,
            b"allocating QName reference item\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaQNameRefPtr;
    }
    let fresh67 = &mut ((*ret).node);
    *fresh67 = 0 as xmlNodePtr;
    (*ret).type_0 = XML_SCHEMA_EXTRA_QNAMEREF;
    let fresh68 = &mut ((*ret).name);
    *fresh68 = refName;
    let fresh69 = &mut ((*ret).targetNamespace);
    *fresh69 = refNs;
    let fresh70 = &mut ((*ret).item);
    *fresh70 = 0 as xmlSchemaBasicItemPtr;
    (*ret).itemType = refType;
    xmlSchemaAddItemSize(
        &mut (*(*(*pctxt).constructor).bucket).locals,
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaAddAttributeUseProhib(
    mut pctxt: xmlSchemaParserCtxtPtr,
) -> xmlSchemaAttributeUseProhibPtr {
    let mut ret: xmlSchemaAttributeUseProhibPtr = 0 as *mut xmlSchemaAttributeUseProhib;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaAttributeUseProhib>() as u64)
        as xmlSchemaAttributeUseProhibPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            pctxt,
            b"allocating attribute use prohibition\0" as *const u8
                as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaAttributeUseProhibPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaAttributeUseProhib>() as u64,
    );
    (*ret).type_0 = XML_SCHEMA_EXTRA_ATTR_USE_PROHIB;
    xmlSchemaAddItemSize(
        &mut (*(*(*pctxt).constructor).bucket).locals,
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaAddModelGroup(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut type_0: xmlSchemaTypeType,
    mut node: xmlNodePtr,
) -> xmlSchemaModelGroupPtr {
    let mut ret: xmlSchemaModelGroupPtr = 0 as xmlSchemaModelGroupPtr;
    if ctxt.is_null() || schema.is_null() {
        return 0 as xmlSchemaModelGroupPtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaModelGroup>() as u64)
        as xmlSchemaModelGroupPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating model group component\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaModelGroupPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaModelGroup>() as u64,
    );
    (*ret).type_0 = type_0;
    let fresh71 = &mut ((*ret).node);
    *fresh71 = node;
    xmlSchemaAddItemSize(
        &mut (*(*(*ctxt).constructor).bucket).locals,
        10 as i32,
        ret as *mut libc::c_void,
    );
    if type_0 as u32 == XML_SCHEMA_TYPE_SEQUENCE as i32 as u32
        || type_0 as u32
            == XML_SCHEMA_TYPE_CHOICE as i32 as u32
    {
        xmlSchemaAddItemSize(
            &mut (*(*ctxt).constructor).pending,
            10 as i32,
            ret as *mut libc::c_void,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaAddParticle(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut min: i32,
    mut max: i32,
) -> xmlSchemaParticlePtr {
    let mut ret: xmlSchemaParticlePtr = 0 as xmlSchemaParticlePtr;
    if ctxt.is_null() {
        return 0 as xmlSchemaParticlePtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaParticle>() as u64)
        as xmlSchemaParticlePtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating particle component\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaParticlePtr;
    }
    (*ret).type_0 = XML_SCHEMA_TYPE_PARTICLE;
    let fresh72 = &mut ((*ret).annot);
    *fresh72 = 0 as xmlSchemaAnnotPtr;
    let fresh73 = &mut ((*ret).node);
    *fresh73 = node;
    (*ret).minOccurs = min;
    (*ret).maxOccurs = max;
    let fresh74 = &mut ((*ret).next);
    *fresh74 = 0 as xmlSchemaTreeItemPtr;
    let fresh75 = &mut ((*ret).children);
    *fresh75 = 0 as xmlSchemaTreeItemPtr;
    xmlSchemaAddItemSize(
        &mut (*(*(*ctxt).constructor).bucket).locals,
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaAddModelGroupDefinition(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
    mut node: xmlNodePtr,
) -> xmlSchemaModelGroupDefPtr {
    let mut ret: xmlSchemaModelGroupDefPtr = 0 as xmlSchemaModelGroupDefPtr;
    if ctxt.is_null() || schema.is_null() || name.is_null() {
        return 0 as xmlSchemaModelGroupDefPtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaModelGroupDef>() as u64)
        as xmlSchemaModelGroupDefPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"adding group\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaModelGroupDefPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaModelGroupDef>() as u64,
    );
    let fresh76 = &mut ((*ret).name);
    *fresh76 = name;
    (*ret).type_0 = XML_SCHEMA_TYPE_GROUP;
    let fresh77 = &mut ((*ret).node);
    *fresh77 = node;
    let fresh78 = &mut ((*ret).targetNamespace);
    *fresh78 = nsName;
    if (*ctxt).isRedefine != 0 {
        let fresh79 = &mut ((*ctxt).redef);
        *fresh79 = xmlSchemaAddRedef(
            ctxt,
            (*ctxt).redefined,
            ret as *mut libc::c_void,
            name,
            nsName,
        );
        if ((*ctxt).redef).is_null() {
            xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void);
            return 0 as xmlSchemaModelGroupDefPtr;
        }
        (*ctxt).redefCounter = 0 as i32;
    }
    xmlSchemaAddItemSize(
        &mut (*(*(*ctxt).constructor).bucket).globals,
        5 as i32,
        ret as *mut libc::c_void,
    );
    xmlSchemaAddItemSize(
        &mut (*(*ctxt).constructor).pending,
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaNewWildcardNsConstraint(
    mut ctxt: xmlSchemaParserCtxtPtr,
) -> xmlSchemaWildcardNsPtr {
    let mut ret: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaWildcardNs>() as u64)
        as xmlSchemaWildcardNsPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"creating wildcard namespace constraint\0" as *const u8
                as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaWildcardNsPtr;
    }
    let fresh80 = &mut ((*ret).value);
    *fresh80 = 0 as *const xmlChar;
    let fresh81 = &mut ((*ret).next);
    *fresh81 = 0 as *mut _xmlSchemaWildcardNs;
    return ret;
}
unsafe extern "C" fn xmlSchemaAddIDC(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut name: *const xmlChar,
    mut nsName: *const xmlChar,
    mut category: i32,
    mut node: xmlNodePtr,
) -> xmlSchemaIDCPtr {
    let mut ret: xmlSchemaIDCPtr = 0 as xmlSchemaIDCPtr;
    if ctxt.is_null() || schema.is_null() || name.is_null() {
        return 0 as xmlSchemaIDCPtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaIDC>() as u64) as xmlSchemaIDCPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating an identity-constraint definition\0" as *const u8
                as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaIDCPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaIDC>() as u64,
    );
    let fresh82 = &mut ((*ret).targetNamespace);
    *fresh82 = nsName;
    let fresh83 = &mut ((*ret).name);
    *fresh83 = name;
    (*ret).type_0 = category as xmlSchemaTypeType;
    let fresh84 = &mut ((*ret).node);
    *fresh84 = node;
    xmlSchemaAddItemSize(
        &mut (*(*(*ctxt).constructor).bucket).globals,
        5 as i32,
        ret as *mut libc::c_void,
    );
    if category == XML_SCHEMA_TYPE_IDC_KEYREF as i32 {
        xmlSchemaAddItemSize(
            &mut (*(*ctxt).constructor).pending,
            10 as i32,
            ret as *mut libc::c_void,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaAddWildcard(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut type_0: xmlSchemaTypeType,
    mut node: xmlNodePtr,
) -> xmlSchemaWildcardPtr {
    let mut ret: xmlSchemaWildcardPtr = 0 as xmlSchemaWildcardPtr;
    if ctxt.is_null() || schema.is_null() {
        return 0 as xmlSchemaWildcardPtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaWildcard>() as u64)
        as xmlSchemaWildcardPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"adding wildcard\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaWildcardPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaWildcard>() as u64,
    );
    (*ret).type_0 = type_0;
    let fresh85 = &mut ((*ret).node);
    *fresh85 = node;
    xmlSchemaAddItemSize(
        &mut (*(*(*ctxt).constructor).bucket).locals,
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaSubstGroupFree(mut group: xmlSchemaSubstGroupPtr) {
    if group.is_null() {
        return;
    }
    if !((*group).members).is_null() {
        xmlSchemaItemListFree((*group).members);
    }
    xmlFree.expect("non-null function pointer")(group as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaSubstGroupFreeEntry(
    mut group: *mut libc::c_void,
    mut name: *const xmlChar,
) {
    xmlSchemaSubstGroupFree(group as xmlSchemaSubstGroupPtr);
}
unsafe extern "C" fn xmlSchemaSubstGroupAdd(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut head: xmlSchemaElementPtr,
) -> xmlSchemaSubstGroupPtr {
    let mut ret: xmlSchemaSubstGroupPtr = 0 as *mut xmlSchemaSubstGroup;
    if ((*(*pctxt).constructor).substGroups).is_null() {
        let fresh86 = &mut ((*(*pctxt).constructor).substGroups);
        *fresh86 = xmlHashCreateDict(10 as i32, (*pctxt).dict);
        if ((*(*pctxt).constructor).substGroups).is_null() {
            return 0 as xmlSchemaSubstGroupPtr;
        }
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaSubstGroup>() as u64)
        as xmlSchemaSubstGroupPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating a substitution group container\0" as *const u8
                as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaSubstGroupPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaSubstGroup>() as u64,
    );
    let fresh87 = &mut ((*ret).head);
    *fresh87 = head;
    let fresh88 = &mut ((*ret).members);
    *fresh88 = xmlSchemaItemListCreate();
    if ((*ret).members).is_null() {
        xmlSchemaSubstGroupFree(ret);
        return 0 as xmlSchemaSubstGroupPtr;
    }
    if xmlHashAddEntry2(
        (*(*pctxt).constructor).substGroups,
        (*head).name,
        (*head).targetNamespace,
        ret as *mut libc::c_void,
    ) != 0 as i32
    {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaSubstGroupAdd\0" as *const u8 as *const i8,
            b"failed to add a new substitution container\0" as *const u8
                as *const i8,
        );
        xmlSchemaSubstGroupFree(ret);
        return 0 as xmlSchemaSubstGroupPtr;
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaSubstGroupGet(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut head: xmlSchemaElementPtr,
) -> xmlSchemaSubstGroupPtr {
    if ((*(*pctxt).constructor).substGroups).is_null() {
        return 0 as xmlSchemaSubstGroupPtr;
    }
    return xmlHashLookup2(
        (*(*pctxt).constructor).substGroups,
        (*head).name,
        (*head).targetNamespace,
    ) as xmlSchemaSubstGroupPtr;
}
unsafe extern "C" fn xmlSchemaAddElementSubstitutionMember(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut head: xmlSchemaElementPtr,
    mut member: xmlSchemaElementPtr,
) -> i32 {
    let mut substGroup: xmlSchemaSubstGroupPtr = 0 as xmlSchemaSubstGroupPtr;
    if pctxt.is_null() || head.is_null() || member.is_null() {
        return -(1 as i32);
    }
    substGroup = xmlSchemaSubstGroupGet(pctxt, head);
    if substGroup.is_null() {
        substGroup = xmlSchemaSubstGroupAdd(pctxt, head);
    }
    if substGroup.is_null() {
        return -(1 as i32);
    }
    if xmlSchemaItemListAdd((*substGroup).members, member as *mut libc::c_void)
        == -(1 as i32)
    {
        return -(1 as i32);
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaPValAttrNodeQNameValue(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut attr: xmlAttrPtr,
    mut value: *const xmlChar,
    mut uri: *mut *const xmlChar,
    mut local: *mut *const xmlChar,
) -> i32 {
    let mut pref: *const xmlChar = 0 as *const xmlChar;
    let mut ns: xmlNsPtr = 0 as *mut xmlNs;
    let mut len: i32 = 0;
    let mut ret: i32 = 0;
    *uri = 0 as *const xmlChar;
    *local = 0 as *const xmlChar;
    ret = xmlValidateQName(value, 1 as i32);
    if ret > 0 as i32 {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            ownerItem,
            attr as xmlNodePtr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),
            0 as *const i8,
            value,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        *local = value;
        return (*ctxt).err;
    } else {
        if ret < 0 as i32 {
            return -(1 as i32);
        }
    }
    if (strchr(value as *mut i8, ':' as i32)).is_null() {
        ns = xmlSearchNs((*attr).doc, (*attr).parent, 0 as *const xmlChar);
        if !ns.is_null() && !((*ns).href).is_null()
            && *((*ns).href).offset(0 as i32 as isize) as i32 != 0
        {
            *uri = xmlDictLookup((*ctxt).dict, (*ns).href, -(1 as i32));
        } else if (*schema).flags & (1 as i32) << 9 as i32 != 0 {
            *uri = (*ctxt).targetNamespace;
        }
        *local = xmlDictLookup((*ctxt).dict, value, -(1 as i32));
        return 0 as i32;
    }
    *local = xmlSplitQName3(value, &mut len);
    *local = xmlDictLookup((*ctxt).dict, *local, -(1 as i32));
    pref = xmlDictLookup((*ctxt).dict, value, len);
    ns = xmlSearchNs((*attr).doc, (*attr).parent, pref);
    if ns.is_null() {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            ownerItem,
            attr as xmlNodePtr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),
            0 as *const i8,
            value,
            b"The value '%s' of simple type 'xs:QName' has no corresponding namespace declaration in scope\0"
                as *const u8 as *const i8,
            value,
            0 as *const xmlChar,
        );
        return (*ctxt).err;
    } else {
        *uri = xmlDictLookup((*ctxt).dict, (*ns).href, -(1 as i32));
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaPValAttrNodeQName(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut attr: xmlAttrPtr,
    mut uri: *mut *const xmlChar,
    mut local: *mut *const xmlChar,
) -> i32 {
    let mut value: *const xmlChar = 0 as *const xmlChar;
    value = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    return xmlSchemaPValAttrNodeQNameValue(
        ctxt,
        schema,
        ownerItem,
        attr,
        value,
        uri,
        local,
    );
}
unsafe extern "C" fn xmlSchemaPValAttrQName(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut ownerElem: xmlNodePtr,
    mut name: *const i8,
    mut uri: *mut *const xmlChar,
    mut local: *mut *const xmlChar,
) -> i32 {
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    attr = xmlSchemaGetPropNode(ownerElem, name);
    if attr.is_null() {
        *local = 0 as *const xmlChar;
        *uri = 0 as *const xmlChar;
        return 0 as i32;
    }
    return xmlSchemaPValAttrNodeQName(ctxt, schema, ownerItem, attr, uri, local);
}
unsafe extern "C" fn xmlSchemaPValAttrNodeID(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut attr: xmlAttrPtr,
) -> i32 {
    let mut ret: i32 = 0;
    let mut value: *const xmlChar = 0 as *const xmlChar;
    if attr.is_null() {
        return 0 as i32;
    }
    value = xmlSchemaGetNodeContentNoDict(attr as xmlNodePtr);
    ret = xmlValidateNCName(value, 1 as i32);
    if ret == 0 as i32 {
        if (*attr).atype as u32
            != XML_ATTRIBUTE_ID as i32 as u32
        {
            let mut res: xmlIDPtr = 0 as *mut xmlID;
            let mut strip: *mut xmlChar = 0 as *mut xmlChar;
            strip = xmlSchemaCollapseString(value);
            if !strip.is_null() {
                xmlFree
                    .expect(
                        "non-null function pointer",
                    )(value as *mut xmlChar as *mut libc::c_void);
                value = strip;
            }
            res = xmlAddID(0 as xmlValidCtxtPtr, (*attr).doc, value, attr);
            if res.is_null() {
                ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as i32;
                xmlSchemaPSimpleTypeErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                    0 as xmlSchemaBasicItemPtr,
                    attr as xmlNodePtr,
                    xmlSchemaGetBuiltInType(XML_SCHEMAS_ID),
                    0 as *const i8,
                    0 as *const xmlChar,
                    b"Duplicate value '%s' of simple type 'xs:ID'\0" as *const u8
                        as *const i8,
                    value,
                    0 as *const xmlChar,
                );
            } else {
                (*attr).atype = XML_ATTRIBUTE_ID;
            }
        }
    } else if ret > 0 as i32 {
        ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as i32;
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_ID),
            0 as *const i8,
            0 as *const xmlChar,
            b"The value '%s' of simple type 'xs:ID' is not a valid 'xs:NCName'\0"
                as *const u8 as *const i8,
            value,
            0 as *const xmlChar,
        );
    }
    if !value.is_null() {
        xmlFree
            .expect(
                "non-null function pointer",
            )(value as *mut xmlChar as *mut libc::c_void);
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaPValAttrID(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut ownerElem: xmlNodePtr,
    mut name: *const xmlChar,
) -> i32 {
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    attr = xmlSchemaGetPropNode(ownerElem, name as *const i8);
    if attr.is_null() {
        return 0 as i32;
    }
    return xmlSchemaPValAttrNodeID(ctxt, attr);
}
unsafe extern "C" fn xmlGetMaxOccurs(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut min: i32,
    mut max: i32,
    mut def: i32,
    mut expected: *const i8,
) -> i32 {
    let mut val: *const xmlChar = 0 as *const xmlChar;
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    let mut ret: i32 = 0 as i32;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    attr = xmlSchemaGetPropNode(
        node,
        b"maxOccurs\0" as *const u8 as *const i8,
    );
    if attr.is_null() {
        return def;
    }
    val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    if xmlStrEqual(
        val,
        b"unbounded\0" as *const u8 as *const i8 as *const xmlChar,
    ) != 0
    {
        if max != (1 as i32) << 30 as i32 {
            xmlSchemaPSimpleTypeErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                0 as xmlSchemaBasicItemPtr,
                attr as xmlNodePtr,
                0 as xmlSchemaTypePtr,
                expected,
                val,
                0 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return def;
        } else {
            return (1 as i32) << 30 as i32
        }
    }
    cur = val;
    while *cur as i32 == 0x20 as i32
        || 0x9 as i32 <= *cur as i32
            && *cur as i32 <= 0xa as i32
        || *cur as i32 == 0xd as i32
    {
        cur = cur.offset(1);
    }
    if *cur as i32 == 0 as i32 {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            0 as xmlSchemaTypePtr,
            expected,
            val,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return def;
    }
    while *cur as i32 >= '0' as i32 && *cur as i32 <= '9' as i32 {
        if ret > 2147483647 as i32 / 10 as i32 {
            ret = 2147483647 as i32;
        } else {
            let mut digit: i32 = *cur as i32 - '0' as i32;
            ret *= 10 as i32;
            if ret > 2147483647 as i32 - digit {
                ret = 2147483647 as i32;
            } else {
                ret += digit;
            }
        }
        cur = cur.offset(1);
    }
    while *cur as i32 == 0x20 as i32
        || 0x9 as i32 <= *cur as i32
            && *cur as i32 <= 0xa as i32
        || *cur as i32 == 0xd as i32
    {
        cur = cur.offset(1);
    }
    if *cur as i32 != 0 as i32 || ret < min
        || max != -(1 as i32) && ret > max
    {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            0 as xmlSchemaTypePtr,
            expected,
            val,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return def;
    }
    return ret;
}
unsafe extern "C" fn xmlGetMinOccurs(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut min: i32,
    mut max: i32,
    mut def: i32,
    mut expected: *const i8,
) -> i32 {
    let mut val: *const xmlChar = 0 as *const xmlChar;
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    let mut ret: i32 = 0 as i32;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    attr = xmlSchemaGetPropNode(
        node,
        b"minOccurs\0" as *const u8 as *const i8,
    );
    if attr.is_null() {
        return def;
    }
    val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    cur = val;
    while *cur as i32 == 0x20 as i32
        || 0x9 as i32 <= *cur as i32
            && *cur as i32 <= 0xa as i32
        || *cur as i32 == 0xd as i32
    {
        cur = cur.offset(1);
    }
    if *cur as i32 == 0 as i32 {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            0 as xmlSchemaTypePtr,
            expected,
            val,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return def;
    }
    while *cur as i32 >= '0' as i32 && *cur as i32 <= '9' as i32 {
        if ret > 2147483647 as i32 / 10 as i32 {
            ret = 2147483647 as i32;
        } else {
            let mut digit: i32 = *cur as i32 - '0' as i32;
            ret *= 10 as i32;
            if ret > 2147483647 as i32 - digit {
                ret = 2147483647 as i32;
            } else {
                ret += digit;
            }
        }
        cur = cur.offset(1);
    }
    while *cur as i32 == 0x20 as i32
        || 0x9 as i32 <= *cur as i32
            && *cur as i32 <= 0xa as i32
        || *cur as i32 == 0xd as i32
    {
        cur = cur.offset(1);
    }
    if *cur as i32 != 0 as i32 || ret < min
        || max != -(1 as i32) && ret > max
    {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            0 as xmlSchemaTypePtr,
            expected,
            val,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return def;
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaPGetBoolNodeValue(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut node: xmlNodePtr,
) -> i32 {
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    let mut res: i32 = 0 as i32;
    value = xmlNodeGetContent(node as *const xmlNode);
    if xmlStrEqual(value, b"true\0" as *const u8 as *const i8 as *mut xmlChar)
        != 0
    {
        res = 1 as i32;
    } else if xmlStrEqual(
            value,
            b"false\0" as *const u8 as *const i8 as *mut xmlChar,
        ) != 0
        {
        res = 0 as i32;
    } else if xmlStrEqual(
            value,
            b"1\0" as *const u8 as *const i8 as *mut xmlChar,
        ) != 0
        {
        res = 1 as i32;
    } else if xmlStrEqual(
            value,
            b"0\0" as *const u8 as *const i8 as *mut xmlChar,
        ) != 0
        {
        res = 0 as i32;
    } else {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_INVALID_BOOLEAN,
            ownerItem,
            node,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
            0 as *const i8,
            value,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    if !value.is_null() {
        xmlFree.expect("non-null function pointer")(value as *mut libc::c_void);
    }
    return res;
}
unsafe extern "C" fn xmlGetBooleanProp(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut name: *const i8,
    mut def: i32,
) -> i32 {
    let mut val: *const xmlChar = 0 as *const xmlChar;
    val = xmlSchemaGetProp(ctxt, node, name);
    if val.is_null() {
        return def;
    }
    if xmlStrEqual(val, b"true\0" as *const u8 as *const i8 as *mut xmlChar)
        != 0
    {
        def = 1 as i32;
    } else if xmlStrEqual(
            val,
            b"false\0" as *const u8 as *const i8 as *mut xmlChar,
        ) != 0
        {
        def = 0 as i32;
    } else if xmlStrEqual(
            val,
            b"1\0" as *const u8 as *const i8 as *mut xmlChar,
        ) != 0
        {
        def = 1 as i32;
    } else if xmlStrEqual(
            val,
            b"0\0" as *const u8 as *const i8 as *mut xmlChar,
        ) != 0
        {
        def = 0 as i32;
    } else {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_INVALID_BOOLEAN,
            0 as xmlSchemaBasicItemPtr,
            xmlSchemaGetPropNode(node, name) as xmlNodePtr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
            0 as *const i8,
            val,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    return def;
}
unsafe extern "C" fn xmlSchemaPValAttrNodeValue(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut attr: xmlAttrPtr,
    mut value: *const xmlChar,
    mut type_0: xmlSchemaTypePtr,
) -> i32 {
    let mut ret: i32 = 0 as i32;
    if pctxt.is_null() || type_0.is_null() || attr.is_null() {
        return -(1 as i32);
    }
    if (*type_0).type_0 as u32
        != XML_SCHEMA_TYPE_BASIC as i32 as u32
    {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaPValAttrNodeValue\0" as *const u8 as *const i8,
            b"the given type is not a built-in type\0" as *const u8
                as *const i8,
        );
        return -(1 as i32);
    }
    match (*type_0).builtInType {
        22 | 21 | 29 | 16 | 17 => {
            ret = xmlSchemaValPredefTypeNode(
                type_0,
                value,
                0 as *mut xmlSchemaValPtr,
                attr as xmlNodePtr,
            );
        }
        _ => {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaPValAttrNodeValue\0" as *const u8 as *const i8,
                b"validation using the given type is not supported while parsing a schema\0"
                    as *const u8 as *const i8,
            );
            return -(1 as i32);
        }
    }
    if ret < 0 as i32 {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaPValAttrNodeValue\0" as *const u8 as *const i8,
            b"failed to validate a schema attribute value\0" as *const u8
                as *const i8,
        );
        return -(1 as i32);
    } else {
        if ret > 0 as i32 {
            if (*type_0).flags & (1 as i32) << 6 as i32 != 0 {
                ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as i32;
            } else {
                ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as i32;
            }
            xmlSchemaPSimpleTypeErr(
                pctxt,
                ret as xmlParserErrors,
                ownerItem,
                attr as xmlNodePtr,
                type_0,
                0 as *const i8,
                value,
                0 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaPValAttrNode(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut attr: xmlAttrPtr,
    mut type_0: xmlSchemaTypePtr,
    mut value: *mut *const xmlChar,
) -> i32 {
    let mut val: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || type_0.is_null() || attr.is_null() {
        return -(1 as i32);
    }
    val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    if !value.is_null() {
        *value = val;
    }
    return xmlSchemaPValAttrNodeValue(ctxt, ownerItem, attr, val, type_0);
}
unsafe extern "C" fn xmlSchemaPValAttr(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut ownerItem: xmlSchemaBasicItemPtr,
    mut ownerElem: xmlNodePtr,
    mut name: *const i8,
    mut type_0: xmlSchemaTypePtr,
    mut value: *mut *const xmlChar,
) -> i32 {
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || type_0.is_null() {
        if !value.is_null() {
            *value = 0 as *const xmlChar;
        }
        return -(1 as i32);
    }
    if (*type_0).type_0 as u32
        != XML_SCHEMA_TYPE_BASIC as i32 as u32
    {
        if !value.is_null() {
            *value = 0 as *const xmlChar;
        }
        xmlSchemaPErr(
            ctxt,
            ownerElem,
            XML_SCHEMAP_INTERNAL as i32,
            b"Internal error: xmlSchemaPValAttr, the given type '%s' is not a built-in type.\n\0"
                as *const u8 as *const i8,
            (*type_0).name,
            0 as *const xmlChar,
        );
        return -(1 as i32);
    }
    attr = xmlSchemaGetPropNode(ownerElem, name);
    if attr.is_null() {
        if !value.is_null() {
            *value = 0 as *const xmlChar;
        }
        return 0 as i32;
    }
    return xmlSchemaPValAttrNode(ctxt, ownerItem, attr, type_0, value);
}
unsafe extern "C" fn xmlSchemaCheckReference(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut attr: xmlAttrPtr,
    mut namespaceName: *const xmlChar,
) -> i32 {
    if xmlStrEqual((*pctxt).targetNamespace, namespaceName) != 0 {
        return 0 as i32;
    }
    if xmlStrEqual(xmlSchemaNs, namespaceName) != 0 {
        return 0 as i32;
    }
    if !((*(*(*pctxt).constructor).bucket).relations).is_null() {
        let mut rel: xmlSchemaSchemaRelationPtr = 0 as *mut xmlSchemaSchemaRelation;
        rel = (*(*(*pctxt).constructor).bucket).relations;
        loop {
            if ((*rel).type_0 == 0 as i32 || (*rel).type_0 == 1 as i32)
                && xmlStrEqual(namespaceName, (*rel).importNamespace) != 0
            {
                return 0 as i32;
            }
            rel = (*rel).next;
            if rel.is_null() {
                break;
            }
        }
    }
    let mut n: xmlNodePtr = if !attr.is_null() { attr as xmlNodePtr } else { node };
    if namespaceName.is_null() {
        xmlSchemaCustomErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_SRC_RESOLVE,
            n,
            0 as xmlSchemaBasicItemPtr,
            b"References from this schema to components in no namespace are not allowed, since not indicated by an import statement\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    } else {
        xmlSchemaCustomErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_SRC_RESOLVE,
            n,
            0 as xmlSchemaBasicItemPtr,
            b"References from this schema to components in the namespace '%s' are not allowed, since not indicated by an import statement\0"
                as *const u8 as *const i8,
            namespaceName,
            0 as *const xmlChar,
        );
    }
    return XML_SCHEMAP_SRC_RESOLVE as i32;
}
unsafe extern "C" fn xmlSchemaParseLocalAttributes(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut child: *mut xmlNodePtr,
    mut list: *mut xmlSchemaItemListPtr,
    mut parentType: i32,
    mut hasRefs: *mut i32,
) -> i32 {
    let mut item: *mut libc::c_void = 0 as *mut libc::c_void;
    while !(*child).is_null() && !((**child).ns).is_null()
        && xmlStrEqual(
            (**child).name,
            b"attribute\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(**child).ns).href, xmlSchemaNs) != 0
        || !(*child).is_null() && !((**child).ns).is_null()
            && xmlStrEqual(
                (**child).name,
                b"attributeGroup\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(**child).ns).href, xmlSchemaNs) != 0
    {
        if !(*child).is_null() && !((**child).ns).is_null()
            && xmlStrEqual(
                (**child).name,
                b"attribute\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(**child).ns).href, xmlSchemaNs) != 0
        {
            item = xmlSchemaParseLocalAttribute(ctxt, schema, *child, *list, parentType)
                as *mut libc::c_void;
        } else {
            item = xmlSchemaParseAttributeGroupRef(ctxt, schema, *child)
                as *mut libc::c_void;
            if !item.is_null() && !hasRefs.is_null() {
                *hasRefs = 1 as i32;
            }
        }
        if !item.is_null() {
            if (*list).is_null() {
                *list = xmlSchemaItemListCreate();
                if (*list).is_null() {
                    return -(1 as i32);
                }
            }
            if xmlSchemaItemListAddSize(*list, 2 as i32, item)
                == -(1 as i32)
            {
                return -(1 as i32);
            }
        }
        *child = (**child).next;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaParseAnnotation(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut needed: i32,
) -> xmlSchemaAnnotPtr {
    let mut ret: xmlSchemaAnnotPtr = 0 as *mut xmlSchemaAnnot;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut barked: i32 = 0 as i32;
    if ctxt.is_null() || node.is_null() {
        return 0 as xmlSchemaAnnotPtr;
    }
    if needed != 0 {
        ret = xmlSchemaNewAnnot(ctxt, node);
    } else {
        ret = 0 as xmlSchemaAnnotPtr;
    }
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null()
            && xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
            || !((*attr).ns).is_null()
                && xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0
        {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = (*node).children;
    while !child.is_null() {
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"appinfo\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            attr = (*child).properties;
            while !attr.is_null() {
                if ((*attr).ns).is_null()
                    && xmlStrEqual(
                        (*attr).name,
                        b"source\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) == 0
                    || !((*attr).ns).is_null()
                        && xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0
                {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        0 as xmlSchemaBasicItemPtr,
                        attr,
                    );
                }
                attr = (*attr).next;
            }
            xmlSchemaPValAttr(
                ctxt,
                0 as xmlSchemaBasicItemPtr,
                child,
                b"source\0" as *const u8 as *const i8,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
                0 as *mut *const xmlChar,
            );
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"documentation\0" as *const u8 as *const i8
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            attr = (*child).properties;
            while !attr.is_null() {
                if ((*attr).ns).is_null() {
                    if xmlStrEqual(
                        (*attr).name,
                        b"source\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) == 0
                    {
                        xmlSchemaPIllegalAttrErr(
                            ctxt,
                            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                            0 as xmlSchemaBasicItemPtr,
                            attr,
                        );
                    }
                } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0
                        || xmlStrEqual(
                            (*attr).name,
                            b"lang\0" as *const u8 as *const i8 as *mut xmlChar,
                        ) != 0
                            && xmlStrEqual(
                                (*(*attr).ns).href,
                                b"http://www.w3.org/XML/1998/namespace\0" as *const u8
                                    as *const i8 as *const xmlChar,
                            ) == 0
                    {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        0 as xmlSchemaBasicItemPtr,
                        attr,
                    );
                }
                attr = (*attr).next;
            }
            attr = xmlSchemaGetPropNodeNs(
                child,
                b"http://www.w3.org/XML/1998/namespace\0" as *const u8
                    as *const i8 as *const xmlChar as *const i8,
                b"lang\0" as *const u8 as *const i8,
            );
            if !attr.is_null() {
                xmlSchemaPValAttrNode(
                    ctxt,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                    xmlSchemaGetBuiltInType(XML_SCHEMAS_LANGUAGE),
                    0 as *mut *const xmlChar,
                );
            }
            child = (*child).next;
        } else {
            if barked == 0 {
                xmlSchemaPContentErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    child,
                    0 as *const i8,
                    b"(appinfo | documentation)*\0" as *const u8 as *const i8,
                );
            }
            barked = 1 as i32;
            child = (*child).next;
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaParseFacet(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaFacetPtr {
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut value: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaFacetPtr;
    }
    facet = xmlSchemaNewFacet();
    if facet.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating facet\0" as *const u8 as *const i8,
            node,
        );
        return 0 as xmlSchemaFacetPtr;
    }
    let fresh89 = &mut ((*facet).node);
    *fresh89 = node;
    value = xmlSchemaGetProp(ctxt, node, b"value\0" as *const u8 as *const i8);
    if value.is_null() {
        xmlSchemaPErr2(
            ctxt,
            node,
            child,
            XML_SCHEMAP_FACET_NO_VALUE as i32,
            b"Facet %s has no value\n\0" as *const u8 as *const i8,
            (*node).name,
            0 as *const xmlChar,
        );
        xmlSchemaFreeFacet(facet);
        return 0 as xmlSchemaFacetPtr;
    }
    if !node.is_null() && !((*node).ns).is_null()
        && xmlStrEqual(
            (*node).name,
            b"minInclusive\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
    {
        (*facet).type_0 = XML_SCHEMA_FACET_MININCLUSIVE;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"minExclusive\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_MINEXCLUSIVE;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"maxInclusive\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_MAXINCLUSIVE;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"maxExclusive\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_MAXEXCLUSIVE;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"totalDigits\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_TOTALDIGITS;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"fractionDigits\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_FRACTIONDIGITS;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"pattern\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_PATTERN;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"enumeration\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_ENUMERATION;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"whiteSpace\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_WHITESPACE;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"length\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_LENGTH;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"maxLength\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_MAXLENGTH;
    } else if !node.is_null() && !((*node).ns).is_null()
            && xmlStrEqual(
                (*node).name,
                b"minLength\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*node).ns).href, xmlSchemaNs) != 0
        {
        (*facet).type_0 = XML_SCHEMA_FACET_MINLENGTH;
    } else {
        xmlSchemaPErr2(
            ctxt,
            node,
            child,
            XML_SCHEMAP_UNKNOWN_FACET_TYPE as i32,
            b"Unknown facet type %s\n\0" as *const u8 as *const i8,
            (*node).name,
            0 as *const xmlChar,
        );
        xmlSchemaFreeFacet(facet);
        return 0 as xmlSchemaFacetPtr;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    let fresh90 = &mut ((*facet).value);
    *fresh90 = value;
    if (*facet).type_0 as u32
        != XML_SCHEMA_FACET_PATTERN as i32 as u32
        && (*facet).type_0 as u32
            != XML_SCHEMA_FACET_ENUMERATION as i32 as u32
    {
        let mut fixed: *const xmlChar = 0 as *const xmlChar;
        fixed = xmlSchemaGetProp(
            ctxt,
            node,
            b"fixed\0" as *const u8 as *const i8,
        );
        if !fixed.is_null() {
            if xmlStrEqual(
                fixed,
                b"true\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
                (*facet).fixed = 1 as i32;
            }
        }
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let fresh91 = &mut ((*facet).annot);
        *fresh91 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPErr2(
            ctxt,
            node,
            child,
            XML_SCHEMAP_UNKNOWN_FACET_CHILD as i32,
            b"Facet %s has unexpected child content\n\0" as *const u8
                as *const i8,
            (*node).name,
            0 as *const xmlChar,
        );
    }
    return facet;
}
unsafe extern "C" fn xmlSchemaParseWildcardNs(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut wildc: xmlSchemaWildcardPtr,
    mut node: xmlNodePtr,
) -> i32 {
    let mut pc: *const xmlChar = 0 as *const xmlChar;
    let mut ns: *const xmlChar = 0 as *const xmlChar;
    let mut dictnsItem: *const xmlChar = 0 as *const xmlChar;
    let mut ret: i32 = 0 as i32;
    let mut nsItem: *mut xmlChar = 0 as *mut xmlChar;
    let mut tmp: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut lastNs: xmlSchemaWildcardNsPtr = 0 as xmlSchemaWildcardNsPtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    pc = xmlSchemaGetProp(
        ctxt,
        node,
        b"processContents\0" as *const u8 as *const i8,
    );
    if pc.is_null()
        || xmlStrEqual(
            pc,
            b"strict\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
    {
        (*wildc).processContents = 3 as i32;
    } else if xmlStrEqual(
            pc,
            b"skip\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        {
        (*wildc).processContents = 1 as i32;
    } else if xmlStrEqual(
            pc,
            b"lax\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        {
        (*wildc).processContents = 2 as i32;
    } else {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            node,
            0 as xmlSchemaTypePtr,
            b"(strict | skip | lax)\0" as *const u8 as *const i8,
            pc,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        (*wildc).processContents = 3 as i32;
        ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as i32;
    }
    attr = xmlSchemaGetPropNode(
        node,
        b"namespace\0" as *const u8 as *const i8,
    );
    ns = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    if attr.is_null()
        || xmlStrEqual(
            ns,
            b"##any\0" as *const u8 as *const i8 as *mut xmlChar,
        ) != 0
    {
        (*wildc).any = 1 as i32;
    } else if xmlStrEqual(
            ns,
            b"##other\0" as *const u8 as *const i8 as *mut xmlChar,
        ) != 0
        {
        let fresh92 = &mut ((*wildc).negNsSet);
        *fresh92 = xmlSchemaNewWildcardNsConstraint(ctxt);
        if ((*wildc).negNsSet).is_null() {
            return -(1 as i32);
        }
        let fresh93 = &mut ((*(*wildc).negNsSet).value);
        *fresh93 = (*ctxt).targetNamespace;
    } else {
        let mut end: *const xmlChar = 0 as *const xmlChar;
        let mut cur: *const xmlChar = 0 as *const xmlChar;
        cur = ns;
        loop {
            while *cur as i32 == 0x20 as i32
                || 0x9 as i32 <= *cur as i32
                    && *cur as i32 <= 0xa as i32
                || *cur as i32 == 0xd as i32
            {
                cur = cur.offset(1);
            }
            end = cur;
            while *end as i32 != 0 as i32
                && !(*end as i32 == 0x20 as i32
                    || 0x9 as i32 <= *end as i32
                        && *end as i32 <= 0xa as i32
                    || *end as i32 == 0xd as i32)
            {
                end = end.offset(1);
            }
            if end == cur {
                break;
            }
            nsItem = xmlStrndup(
                cur,
                end.offset_from(cur) as i64 as i32,
            );
            if xmlStrEqual(
                nsItem,
                b"##other\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
                || xmlStrEqual(
                    nsItem,
                    b"##any\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
            {
                xmlSchemaPSimpleTypeErr(
                    ctxt,
                    XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER,
                    0 as xmlSchemaBasicItemPtr,
                    attr as xmlNodePtr,
                    0 as xmlSchemaTypePtr,
                    b"((##any | ##other) | List of (xs:anyURI | (##targetNamespace | ##local)))\0"
                        as *const u8 as *const i8,
                    nsItem,
                    0 as *const i8,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
                ret = XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER as i32;
            } else {
                if xmlStrEqual(
                    nsItem,
                    b"##targetNamespace\0" as *const u8 as *const i8
                        as *mut xmlChar,
                ) != 0
                {
                    dictnsItem = (*ctxt).targetNamespace;
                } else if xmlStrEqual(
                        nsItem,
                        b"##local\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) != 0
                    {
                    dictnsItem = 0 as *const xmlChar;
                } else {
                    xmlSchemaPValAttrNodeValue(
                        ctxt,
                        0 as xmlSchemaBasicItemPtr,
                        attr,
                        nsItem,
                        xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
                    );
                    dictnsItem = xmlDictLookup(
                        (*ctxt).dict,
                        nsItem,
                        -(1 as i32),
                    );
                }
                tmp = (*wildc).nsSet;
                while !tmp.is_null() {
                    if dictnsItem == (*tmp).value {
                        break;
                    }
                    tmp = (*tmp).next;
                }
                if tmp.is_null() {
                    tmp = xmlSchemaNewWildcardNsConstraint(ctxt);
                    if tmp.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(nsItem as *mut libc::c_void);
                        return -(1 as i32);
                    }
                    let fresh94 = &mut ((*tmp).value);
                    *fresh94 = dictnsItem;
                    let fresh95 = &mut ((*tmp).next);
                    *fresh95 = 0 as *mut _xmlSchemaWildcardNs;
                    if ((*wildc).nsSet).is_null() {
                        let fresh96 = &mut ((*wildc).nsSet);
                        *fresh96 = tmp;
                    } else if !lastNs.is_null() {
                        let fresh97 = &mut ((*lastNs).next);
                        *fresh97 = tmp;
                    }
                    lastNs = tmp;
                }
            }
            xmlFree.expect("non-null function pointer")(nsItem as *mut libc::c_void);
            cur = end;
            if !(*cur as i32 != 0 as i32) {
                break;
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaPCheckParticleCorrect_2(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut item: xmlSchemaParticlePtr,
    mut node: xmlNodePtr,
    mut minOccurs: i32,
    mut maxOccurs: i32,
) -> i32 {
    if maxOccurs == 0 as i32 && minOccurs == 0 as i32 {
        return 0 as i32;
    }
    if maxOccurs != (1 as i32) << 30 as i32 {
        if maxOccurs < 1 as i32 {
            xmlSchemaPCustomAttrErr(
                ctxt,
                XML_SCHEMAP_P_PROPS_CORRECT_2_2,
                0 as *mut *mut xmlChar,
                0 as xmlSchemaBasicItemPtr,
                xmlSchemaGetPropNode(
                    node,
                    b"maxOccurs\0" as *const u8 as *const i8,
                ),
                b"The value must be greater than or equal to 1\0" as *const u8
                    as *const i8,
            );
            return XML_SCHEMAP_P_PROPS_CORRECT_2_2 as i32;
        } else {
            if minOccurs > maxOccurs {
                xmlSchemaPCustomAttrErr(
                    ctxt,
                    XML_SCHEMAP_P_PROPS_CORRECT_2_1,
                    0 as *mut *mut xmlChar,
                    0 as xmlSchemaBasicItemPtr,
                    xmlSchemaGetPropNode(
                        node,
                        b"minOccurs\0" as *const u8 as *const i8,
                    ),
                    b"The value must not be greater than the value of 'maxOccurs'\0"
                        as *const u8 as *const i8,
                );
                return XML_SCHEMAP_P_PROPS_CORRECT_2_1 as i32;
            }
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaParseAny(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaParticlePtr {
    let mut particle: xmlSchemaParticlePtr = 0 as *mut xmlSchemaParticle;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut wild: xmlSchemaWildcardPtr = 0 as *mut xmlSchemaWildcard;
    let mut min: i32 = 0;
    let mut max: i32 = 0;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut annot: xmlSchemaAnnotPtr = 0 as xmlSchemaAnnotPtr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaParticlePtr;
    }
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"minOccurs\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"maxOccurs\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"namespace\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"processContents\0" as *const u8 as *const i8
                        as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    max = xmlGetMaxOccurs(
        ctxt,
        node,
        0 as i32,
        (1 as i32) << 30 as i32,
        1 as i32,
        b"(xs:nonNegativeInteger | unbounded)\0" as *const u8 as *const i8,
    );
    min = xmlGetMinOccurs(
        ctxt,
        node,
        0 as i32,
        -(1 as i32),
        1 as i32,
        b"xs:nonNegativeInteger\0" as *const u8 as *const i8,
    );
    xmlSchemaPCheckParticleCorrect_2(ctxt, 0 as xmlSchemaParticlePtr, node, min, max);
    wild = xmlSchemaAddWildcard(ctxt, schema, XML_SCHEMA_TYPE_ANY, node);
    if wild.is_null() {
        return 0 as xmlSchemaParticlePtr;
    }
    xmlSchemaParseWildcardNs(ctxt, schema, wild, node);
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        annot = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?)\0" as *const u8 as *const i8,
        );
    }
    if min == 0 as i32 && max == 0 as i32 {
        return 0 as xmlSchemaParticlePtr;
    }
    particle = xmlSchemaAddParticle(ctxt, node, min, max);
    if particle.is_null() {
        return 0 as xmlSchemaParticlePtr;
    }
    let fresh98 = &mut ((*particle).annot);
    *fresh98 = annot;
    let fresh99 = &mut ((*particle).children);
    *fresh99 = wild as xmlSchemaTreeItemPtr;
    return particle;
}
unsafe extern "C" fn xmlSchemaParseNotation(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaNotationPtr {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut ret: xmlSchemaNotationPtr = 0 as *mut xmlSchemaNotation;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaNotationPtr;
    }
    name = xmlSchemaGetProp(ctxt, node, b"name\0" as *const u8 as *const i8);
    if name.is_null() {
        xmlSchemaPErr2(
            ctxt,
            node,
            child,
            XML_SCHEMAP_NOTATION_NO_NAME as i32,
            b"Notation has no name\n\0" as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return 0 as xmlSchemaNotationPtr;
    }
    ret = xmlSchemaAddNotation(ctxt, schema, name, (*ctxt).targetNamespace, node);
    if ret.is_null() {
        return 0 as xmlSchemaNotationPtr;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let fresh100 = &mut ((*ret).annot);
        *fresh100 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?)\0" as *const u8 as *const i8,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaParseAnyAttribute(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaWildcardPtr {
    let mut ret: xmlSchemaWildcardPtr = 0 as *mut xmlSchemaWildcard;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaWildcardPtr;
    }
    ret = xmlSchemaAddWildcard(ctxt, schema, XML_SCHEMA_TYPE_ANY_ATTRIBUTE, node);
    if ret.is_null() {
        return 0 as xmlSchemaWildcardPtr;
    }
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"namespace\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"processContents\0" as *const u8 as *const i8
                        as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    if xmlSchemaParseWildcardNs(ctxt, schema, ret, node) != 0 as i32 {
        return 0 as xmlSchemaWildcardPtr;
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let fresh101 = &mut ((*ret).annot);
        *fresh101 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?)\0" as *const u8 as *const i8,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaParseLocalAttribute(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut uses: xmlSchemaItemListPtr,
    mut parentType: i32,
) -> xmlSchemaBasicItemPtr {
    let mut current_block: u64;
    let mut attrValue: *const xmlChar = 0 as *const xmlChar;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut ns: *const xmlChar = 0 as *const xmlChar;
    let mut use_0: xmlSchemaAttributeUsePtr = 0 as xmlSchemaAttributeUsePtr;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut tmpNs: *const xmlChar = 0 as *const xmlChar;
    let mut tmpName: *const xmlChar = 0 as *const xmlChar;
    let mut defValue: *const xmlChar = 0 as *const xmlChar;
    let mut isRef: i32 = 0 as i32;
    let mut occurs: i32 = 2 as i32;
    let mut nberrors: i32 = 0;
    let mut hasForm: i32 = 0 as i32;
    let mut defValueType: i32 = 0 as i32;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaBasicItemPtr;
    }
    attr = xmlSchemaGetPropNode(node, b"ref\0" as *const u8 as *const i8);
    if !attr.is_null() {
        if xmlSchemaPValAttrNodeQName(
            pctxt,
            schema,
            0 as xmlSchemaBasicItemPtr,
            attr,
            &mut tmpNs,
            &mut tmpName,
        ) != 0 as i32
        {
            return 0 as xmlSchemaBasicItemPtr;
        }
        if xmlSchemaCheckReference(pctxt, schema, node, attr, tmpNs) != 0 as i32
        {
            return 0 as xmlSchemaBasicItemPtr;
        }
        isRef = 1 as i32;
    }
    nberrors = (*pctxt).nberrors;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if isRef != 0 {
                if xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                    xmlSchemaPValAttrNodeID(pctxt, attr);
                    current_block = 7049889939919688114;
                } else if xmlStrEqual(
                        (*attr).name,
                        b"ref\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) != 0
                    {
                    current_block = 7049889939919688114;
                } else {
                    current_block = 9007357115414505193;
                }
            } else if xmlStrEqual(
                    (*attr).name,
                    b"name\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                current_block = 7049889939919688114;
            } else if xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                xmlSchemaPValAttrNodeID(pctxt, attr);
                current_block = 7049889939919688114;
            } else if xmlStrEqual(
                    (*attr).name,
                    b"type\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                xmlSchemaPValAttrNodeQName(
                    pctxt,
                    schema,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                    &mut tmpNs,
                    &mut tmpName,
                );
                current_block = 7049889939919688114;
            } else if xmlStrEqual(
                    (*attr).name,
                    b"form\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                hasForm = 1 as i32;
                attrValue = xmlSchemaGetNodeContent(pctxt, attr as xmlNodePtr);
                if xmlStrEqual(
                    attrValue,
                    b"qualified\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                    ns = (*pctxt).targetNamespace;
                } else if xmlStrEqual(
                        attrValue,
                        b"unqualified\0" as *const u8 as *const i8
                            as *mut xmlChar,
                    ) == 0
                    {
                    xmlSchemaPSimpleTypeErr(
                        pctxt,
                        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                        0 as xmlSchemaBasicItemPtr,
                        attr as xmlNodePtr,
                        0 as xmlSchemaTypePtr,
                        b"(qualified | unqualified)\0" as *const u8
                            as *const i8,
                        attrValue,
                        0 as *const i8,
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                }
                current_block = 7049889939919688114;
            } else {
                current_block = 9007357115414505193;
            }
            match current_block {
                7049889939919688114 => {}
                _ => {
                    if xmlStrEqual(
                        (*attr).name,
                        b"use\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) != 0
                    {
                        attrValue = xmlSchemaGetNodeContent(pctxt, attr as xmlNodePtr);
                        if xmlStrEqual(
                            attrValue,
                            b"optional\0" as *const u8 as *const i8
                                as *mut xmlChar,
                        ) != 0
                        {
                            occurs = 2 as i32;
                        } else if xmlStrEqual(
                                attrValue,
                                b"prohibited\0" as *const u8 as *const i8
                                    as *mut xmlChar,
                            ) != 0
                            {
                            occurs = 0 as i32;
                        } else if xmlStrEqual(
                                attrValue,
                                b"required\0" as *const u8 as *const i8
                                    as *mut xmlChar,
                            ) != 0
                            {
                            occurs = 1 as i32;
                        } else {
                            xmlSchemaPSimpleTypeErr(
                                pctxt,
                                XML_SCHEMAP_INVALID_ATTR_USE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr,
                                0 as xmlSchemaTypePtr,
                                b"(optional | prohibited | required)\0" as *const u8
                                    as *const i8,
                                attrValue,
                                0 as *const i8,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        }
                        current_block = 7049889939919688114;
                    } else if xmlStrEqual(
                            (*attr).name,
                            b"default\0" as *const u8 as *const i8
                                as *mut xmlChar,
                        ) != 0
                        {
                        if !defValue.is_null() {
                            xmlSchemaPMutualExclAttrErr(
                                pctxt,
                                XML_SCHEMAP_SRC_ATTRIBUTE_1,
                                0 as xmlSchemaBasicItemPtr,
                                attr,
                                b"default\0" as *const u8 as *const i8,
                                b"fixed\0" as *const u8 as *const i8,
                            );
                        } else {
                            defValue = xmlSchemaGetNodeContent(
                                pctxt,
                                attr as xmlNodePtr,
                            );
                            defValueType = 1 as i32;
                        }
                        current_block = 7049889939919688114;
                    } else if xmlStrEqual(
                            (*attr).name,
                            b"fixed\0" as *const u8 as *const i8
                                as *mut xmlChar,
                        ) != 0
                        {
                        if !defValue.is_null() {
                            xmlSchemaPMutualExclAttrErr(
                                pctxt,
                                XML_SCHEMAP_SRC_ATTRIBUTE_1,
                                0 as xmlSchemaBasicItemPtr,
                                attr,
                                b"default\0" as *const u8 as *const i8,
                                b"fixed\0" as *const u8 as *const i8,
                            );
                        } else {
                            defValue = xmlSchemaGetNodeContent(
                                pctxt,
                                attr as xmlNodePtr,
                            );
                            defValueType = 2 as i32;
                        }
                        current_block = 7049889939919688114;
                    } else {
                        current_block = 981995395831942902;
                    }
                }
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) == 0 {
            current_block = 7049889939919688114;
        } else {
            current_block = 981995395831942902;
        }
        match current_block {
            981995395831942902 => {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
            _ => {}
        }
        attr = (*attr).next;
    }
    if defValueType == 1 as i32 && occurs != 2 as i32 {
        xmlSchemaPSimpleTypeErr(
            pctxt,
            XML_SCHEMAP_SRC_ATTRIBUTE_2,
            0 as xmlSchemaBasicItemPtr,
            node,
            0 as xmlSchemaTypePtr,
            b"(optional | prohibited | required)\0" as *const u8 as *const i8,
            0 as *const xmlChar,
            b"The value of the attribute 'use' must be 'optional' if the attribute 'default' is present\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    if nberrors != (*pctxt).nberrors {
        return 0 as xmlSchemaBasicItemPtr;
    }
    if isRef == 0 {
        let mut attrDecl: xmlSchemaAttributePtr = 0 as *mut xmlSchemaAttribute;
        if hasForm == 0 && (*schema).flags & (1 as i32) << 1 as i32 != 0
        {
            ns = (*pctxt).targetNamespace;
        }
        if xmlStrEqual(ns, xmlSchemaInstanceNs) != 0 {
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_NO_XSI,
                node,
                0 as xmlSchemaBasicItemPtr,
                b"The target namespace must not match '%s'\0" as *const u8
                    as *const i8,
                xmlSchemaInstanceNs,
                0 as *const xmlChar,
            );
        }
        attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const i8);
        if attr.is_null() {
            xmlSchemaPMissingAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"name\0" as *const u8 as *const i8,
                0 as *const i8,
            );
            return 0 as xmlSchemaBasicItemPtr;
        }
        if xmlSchemaPValAttrNode(
            pctxt,
            0 as xmlSchemaBasicItemPtr,
            attr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
            &mut name,
        ) != 0 as i32
        {
            return 0 as xmlSchemaBasicItemPtr;
        }
        if xmlStrEqual(
            name,
            b"xmlns\0" as *const u8 as *const i8 as *mut xmlChar,
        ) != 0
        {
            xmlSchemaPSimpleTypeErr(
                pctxt,
                XML_SCHEMAP_NO_XMLNS,
                0 as xmlSchemaBasicItemPtr,
                attr as xmlNodePtr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                0 as *const i8,
                0 as *const xmlChar,
                b"The value of the attribute must not match 'xmlns'\0" as *const u8
                    as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return 0 as xmlSchemaBasicItemPtr;
        }
        if !(occurs == 0 as i32) {
            use_0 = xmlSchemaAddAttributeUse(pctxt, node);
            if use_0.is_null() {
                return 0 as xmlSchemaBasicItemPtr;
            }
            (*use_0).occurs = occurs;
            attrDecl = xmlSchemaAddAttribute(
                pctxt,
                schema,
                name,
                ns,
                node,
                0 as i32,
            );
            if attrDecl.is_null() {
                return 0 as xmlSchemaBasicItemPtr;
            }
            if !tmpName.is_null() {
                let fresh102 = &mut ((*attrDecl).typeName);
                *fresh102 = tmpName;
                let fresh103 = &mut ((*attrDecl).typeNs);
                *fresh103 = tmpNs;
            }
            let fresh104 = &mut ((*use_0).attrDecl);
            *fresh104 = attrDecl;
            if !defValue.is_null() {
                let fresh105 = &mut ((*attrDecl).defValue);
                *fresh105 = defValue;
                if defValueType == 2 as i32 {
                    (*attrDecl).flags |= (1 as i32) << 9 as i32;
                }
            }
        }
    } else if occurs != 0 as i32 {
        let mut ref_0: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
        use_0 = xmlSchemaAddAttributeUse(pctxt, node);
        if use_0.is_null() {
            return 0 as xmlSchemaBasicItemPtr;
        }
        xmlSchemaAddItemSize(
            &mut (*(*pctxt).constructor).pending,
            10 as i32,
            use_0 as *mut libc::c_void,
        );
        (*use_0).occurs = occurs;
        ref_0 = xmlSchemaNewQNameRef(pctxt, XML_SCHEMA_TYPE_ATTRIBUTE, tmpName, tmpNs);
        if ref_0.is_null() {
            return 0 as xmlSchemaBasicItemPtr;
        }
        let fresh106 = &mut ((*use_0).attrDecl);
        *fresh106 = ref_0 as xmlSchemaAttributePtr;
        if !defValue.is_null() {
            let fresh107 = &mut ((*use_0).defValue);
            *fresh107 = defValue;
        }
        if defValueType == 2 as i32 {
            (*use_0).flags |= (1 as i32) << 0 as i32;
        }
    }
    child = (*node).children;
    if occurs == 0 as i32 {
        let mut prohib: xmlSchemaAttributeUseProhibPtr = 0
            as *mut xmlSchemaAttributeUseProhib;
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            xmlSchemaParseAnnotation(pctxt, child, 0 as i32);
            child = (*child).next;
        }
        if !child.is_null() {
            xmlSchemaPContentErr(
                pctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"(annotation?)\0" as *const u8 as *const i8,
            );
        }
        if parentType == XML_SCHEMA_TYPE_ATTRIBUTEGROUP as i32 {
            xmlSchemaCustomWarning(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
                node,
                0 as xmlSchemaTypePtr,
                b"Skipping attribute use prohibition, since it is pointless inside an <attributeGroup>\0"
                    as *const u8 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return 0 as xmlSchemaBasicItemPtr;
        } else {
            if parentType == XML_SCHEMA_TYPE_EXTENSION as i32 {
                xmlSchemaCustomWarning(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
                    node,
                    0 as xmlSchemaTypePtr,
                    b"Skipping attribute use prohibition, since it is pointless when extending a type\0"
                        as *const u8 as *const i8,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
                return 0 as xmlSchemaBasicItemPtr;
            }
        }
        if isRef == 0 {
            tmpName = name;
            tmpNs = ns;
        }
        if !uses.is_null() {
            let mut i: i32 = 0;
            i = 0 as i32;
            while i < (*uses).nbItems {
                use_0 = *((*uses).items).offset(i as isize) as xmlSchemaAttributeUsePtr;
                if (*use_0).type_0 as u32
                    == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB as i32 as u32
                    && tmpName == (*(use_0 as xmlSchemaAttributeUseProhibPtr)).name
                    && tmpNs
                        == (*(use_0 as xmlSchemaAttributeUseProhibPtr)).targetNamespace
                {
                    let mut str: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaCustomWarning(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
                        node,
                        0 as xmlSchemaTypePtr,
                        b"Skipping duplicate attribute use prohibition '%s'\0"
                            as *const u8 as *const i8,
                        xmlSchemaFormatQName(&mut str, tmpNs, tmpName),
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                    if !str.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str as *mut libc::c_void);
                        str = 0 as *mut xmlChar;
                    }
                    return 0 as xmlSchemaBasicItemPtr;
                }
                i += 1;
            }
        }
        prohib = xmlSchemaAddAttributeUseProhib(pctxt);
        if prohib.is_null() {
            return 0 as xmlSchemaBasicItemPtr;
        }
        let fresh108 = &mut ((*prohib).node);
        *fresh108 = node;
        let fresh109 = &mut ((*prohib).name);
        *fresh109 = tmpName;
        let fresh110 = &mut ((*prohib).targetNamespace);
        *fresh110 = tmpNs;
        if isRef != 0 {
            xmlSchemaAddItemSize(
                &mut (*(*pctxt).constructor).pending,
                10 as i32,
                prohib as *mut libc::c_void,
            );
        }
        return prohib as xmlSchemaBasicItemPtr;
    } else {
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            let fresh111 = &mut ((*use_0).annot);
            *fresh111 = xmlSchemaParseAnnotation(pctxt, child, 1 as i32);
            child = (*child).next;
        }
        if isRef != 0 {
            if !child.is_null() {
                if !child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"simpleType\0" as *const u8 as *const i8
                            as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                {
                    xmlSchemaPContentErr(
                        pctxt,
                        XML_SCHEMAP_SRC_ATTRIBUTE_3_2,
                        0 as xmlSchemaBasicItemPtr,
                        node,
                        child,
                        0 as *const i8,
                        b"(annotation?)\0" as *const u8 as *const i8,
                    );
                } else {
                    xmlSchemaPContentErr(
                        pctxt,
                        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                        0 as xmlSchemaBasicItemPtr,
                        node,
                        child,
                        0 as *const i8,
                        b"(annotation?)\0" as *const u8 as *const i8,
                    );
                }
            }
        } else {
            if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
                if !((*(*use_0).attrDecl).typeName).is_null() {
                    xmlSchemaPContentErr(
                        pctxt,
                        XML_SCHEMAP_SRC_ATTRIBUTE_4,
                        0 as xmlSchemaBasicItemPtr,
                        node,
                        child,
                        b"The attribute 'type' and the <simpleType> child are mutually exclusive\0"
                            as *const u8 as *const i8,
                        0 as *const i8,
                    );
                } else {
                    let fresh112 = &mut ((*(*use_0).attrDecl).subtypes);
                    *fresh112 = xmlSchemaParseSimpleType(
                        pctxt,
                        schema,
                        child,
                        0 as i32,
                    );
                }
                child = (*child).next;
            }
            if !child.is_null() {
                xmlSchemaPContentErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    child,
                    0 as *const i8,
                    b"(annotation?, simpleType?)\0" as *const u8 as *const i8,
                );
            }
        }
    }
    return use_0 as xmlSchemaBasicItemPtr;
}
unsafe extern "C" fn xmlSchemaParseGlobalAttribute(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaAttributePtr {
    let mut attrValue: *const xmlChar = 0 as *const xmlChar;
    let mut ret: xmlSchemaAttributePtr = 0 as *mut xmlSchemaAttribute;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaAttributePtr;
    }
    attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const i8);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"name\0" as *const u8 as *const i8,
            0 as *const i8,
        );
        return 0 as xmlSchemaAttributePtr;
    }
    if xmlSchemaPValAttrNode(
        pctxt,
        0 as xmlSchemaBasicItemPtr,
        attr,
        xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
        &mut attrValue,
    ) != 0 as i32
    {
        return 0 as xmlSchemaAttributePtr;
    }
    if xmlStrEqual(
        attrValue,
        b"xmlns\0" as *const u8 as *const i8 as *mut xmlChar,
    ) != 0
    {
        xmlSchemaPSimpleTypeErr(
            pctxt,
            XML_SCHEMAP_NO_XMLNS,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
            0 as *const i8,
            0 as *const xmlChar,
            b"The value of the attribute must not match 'xmlns'\0" as *const u8
                as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return 0 as xmlSchemaAttributePtr;
    }
    if xmlStrEqual((*pctxt).targetNamespace, xmlSchemaInstanceNs) != 0 {
        xmlSchemaCustomErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_NO_XSI,
            node,
            0 as xmlSchemaBasicItemPtr,
            b"The target namespace must not match '%s'\0" as *const u8
                as *const i8,
            xmlSchemaInstanceNs,
            0 as *const xmlChar,
        );
    }
    ret = xmlSchemaAddAttribute(
        pctxt,
        schema,
        attrValue,
        (*pctxt).targetNamespace,
        node,
        1 as i32,
    );
    if ret.is_null() {
        return 0 as xmlSchemaAttributePtr;
    }
    (*ret).flags |= (1 as i32) << 0 as i32;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"default\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"fixed\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"name\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"type\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrQName(
        pctxt,
        schema,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"type\0" as *const u8 as *const i8,
        &mut (*ret).typeNs,
        &mut (*ret).typeName,
    );
    xmlSchemaPValAttrID(
        pctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    let fresh113 = &mut ((*ret).defValue);
    *fresh113 = xmlSchemaGetProp(
        pctxt,
        node,
        b"fixed\0" as *const u8 as *const i8,
    );
    if !((*ret).defValue).is_null() {
        (*ret).flags |= (1 as i32) << 9 as i32;
    }
    attr = xmlSchemaGetPropNode(node, b"default\0" as *const u8 as *const i8);
    if !attr.is_null() {
        if (*ret).flags & (1 as i32) << 9 as i32 != 0 {
            xmlSchemaPMutualExclAttrErr(
                pctxt,
                XML_SCHEMAP_SRC_ATTRIBUTE_1,
                ret as xmlSchemaBasicItemPtr,
                attr,
                b"default\0" as *const u8 as *const i8,
                b"fixed\0" as *const u8 as *const i8,
            );
        } else {
            let fresh114 = &mut ((*ret).defValue);
            *fresh114 = xmlSchemaGetNodeContent(pctxt, attr as xmlNodePtr);
        }
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let fresh115 = &mut ((*ret).annot);
        *fresh115 = xmlSchemaParseAnnotation(pctxt, child, 1 as i32);
        child = (*child).next;
    }
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        if !((*ret).typeName).is_null() {
            xmlSchemaPContentErr(
                pctxt,
                XML_SCHEMAP_SRC_ATTRIBUTE_4,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                b"The attribute 'type' and the <simpleType> child are mutually exclusive\0"
                    as *const u8 as *const i8,
                0 as *const i8,
            );
        } else {
            let fresh116 = &mut ((*ret).subtypes);
            *fresh116 = xmlSchemaParseSimpleType(pctxt, schema, child, 0 as i32);
        }
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            pctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, simpleType?)\0" as *const u8 as *const i8,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaParseAttributeGroupRef(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaQNameRefPtr {
    let mut ret: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut refNs: *const xmlChar = 0 as *const xmlChar;
    let mut ref_0: *const xmlChar = 0 as *const xmlChar;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaQNameRefPtr;
    }
    attr = xmlSchemaGetPropNode(node, b"ref\0" as *const u8 as *const i8);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"ref\0" as *const u8 as *const i8,
            0 as *const i8,
        );
        return 0 as xmlSchemaQNameRefPtr;
    }
    xmlSchemaPValAttrNodeQName(
        pctxt,
        schema,
        0 as xmlSchemaBasicItemPtr,
        attr,
        &mut refNs,
        &mut ref_0,
    );
    if xmlSchemaCheckReference(pctxt, schema, node, attr, refNs) != 0 as i32 {
        return 0 as xmlSchemaQNameRefPtr;
    }
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"ref\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        pctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaParseAnnotation(pctxt, child, 0 as i32);
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            pctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?)\0" as *const u8 as *const i8,
        );
    }
    if (*pctxt).isRedefine != 0 && !((*pctxt).redef).is_null()
        && (*(*(*pctxt).redef).item).type_0 as u32
            == XML_SCHEMA_TYPE_ATTRIBUTEGROUP as i32 as u32
        && ref_0 == (*(*pctxt).redef).refName && refNs == (*(*pctxt).redef).refTargetNs
    {
        if (*pctxt).redefCounter != 0 as i32 {
            let mut str: *mut xmlChar = 0 as *mut xmlChar;
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_SRC_REDEFINE,
                node,
                0 as xmlSchemaBasicItemPtr,
                b"The redefining attribute group definition '%s' must not contain more than one reference to the redefined definition\0"
                    as *const u8 as *const i8,
                xmlSchemaFormatQName(&mut str, refNs, ref_0),
                0 as *const xmlChar,
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
            return 0 as xmlSchemaQNameRefPtr;
        }
        let fresh117 = &mut ((*pctxt).redefCounter);
        *fresh117 += 1;
        ret = xmlSchemaNewQNameRef(pctxt, XML_SCHEMA_TYPE_ATTRIBUTEGROUP, ref_0, refNs);
        if ret.is_null() {
            return 0 as xmlSchemaQNameRefPtr;
        }
        let fresh118 = &mut ((*ret).node);
        *fresh118 = node;
        let fresh119 = &mut ((*(*pctxt).redef).reference);
        *fresh119 = ret as xmlSchemaBasicItemPtr;
    } else {
        ret = xmlSchemaNewQNameRef(pctxt, XML_SCHEMA_TYPE_ATTRIBUTEGROUP, ref_0, refNs);
        if ret.is_null() {
            return 0 as xmlSchemaQNameRefPtr;
        }
        let fresh120 = &mut ((*ret).node);
        *fresh120 = node;
        xmlSchemaAddItemSize(
            &mut (*(*pctxt).constructor).pending,
            10 as i32,
            ret as *mut libc::c_void,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaParseAttributeGroupDefinition(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaAttributeGroupPtr {
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut ret: xmlSchemaAttributeGroupPtr = 0 as *mut xmlSchemaAttributeGroup;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut hasRefs: i32 = 0 as i32;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const i8);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"name\0" as *const u8 as *const i8,
            0 as *const i8,
        );
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    if xmlSchemaPValAttrNode(
        pctxt,
        0 as xmlSchemaBasicItemPtr,
        attr,
        xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
        &mut name,
    ) != 0 as i32
    {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    ret = xmlSchemaAddAttributeGroupDefinition(
        pctxt,
        schema,
        name,
        (*pctxt).targetNamespace,
        node,
    );
    if ret.is_null() {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"name\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        pctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let fresh121 = &mut ((*ret).annot);
        *fresh121 = xmlSchemaParseAnnotation(pctxt, child, 1 as i32);
        child = (*child).next;
    }
    if xmlSchemaParseLocalAttributes(
        pctxt,
        schema,
        &mut child,
        &mut (*ret).attrUses as *mut *mut libc::c_void as *mut xmlSchemaItemListPtr,
        XML_SCHEMA_TYPE_ATTRIBUTEGROUP as i32,
        &mut hasRefs,
    ) == -(1 as i32)
    {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    if hasRefs != 0 {
        (*ret).flags |= (1 as i32) << 4 as i32;
    }
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"anyAttribute\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let fresh122 = &mut ((*ret).attributeWildcard);
        *fresh122 = xmlSchemaParseAnyAttribute(pctxt, schema, child);
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            pctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, ((attribute | attributeGroup)*, anyAttribute?))\0"
                as *const u8 as *const i8,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaPValAttrFormDefault(
    mut value: *const xmlChar,
    mut flags: *mut i32,
    mut flagQualified: i32,
) -> i32 {
    if xmlStrEqual(
        value,
        b"qualified\0" as *const u8 as *const i8 as *mut xmlChar,
    ) != 0
    {
        if *flags & flagQualified == 0 as i32 {
            *flags |= flagQualified;
        }
    } else if xmlStrEqual(
            value,
            b"unqualified\0" as *const u8 as *const i8 as *mut xmlChar,
        ) == 0
        {
        return 1 as i32
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaPValAttrBlockFinal(
    mut value: *const xmlChar,
    mut flags: *mut i32,
    mut flagAll: i32,
    mut flagExtension: i32,
    mut flagRestriction: i32,
    mut flagSubstitution: i32,
    mut flagList: i32,
    mut flagUnion: i32,
) -> i32 {
    let mut ret: i32 = 0 as i32;
    if flags.is_null() || value.is_null() {
        return -(1 as i32);
    }
    if *value.offset(0 as i32 as isize) as i32 == 0 as i32 {
        return 0 as i32;
    }
    if xmlStrEqual(value, b"#all\0" as *const u8 as *const i8 as *mut xmlChar)
        != 0
    {
        if flagAll != -(1 as i32) {
            *flags |= flagAll;
        } else {
            if flagExtension != -(1 as i32) {
                *flags |= flagExtension;
            }
            if flagRestriction != -(1 as i32) {
                *flags |= flagRestriction;
            }
            if flagSubstitution != -(1 as i32) {
                *flags |= flagSubstitution;
            }
            if flagList != -(1 as i32) {
                *flags |= flagList;
            }
            if flagUnion != -(1 as i32) {
                *flags |= flagUnion;
            }
        }
    } else {
        let mut end: *const xmlChar = 0 as *const xmlChar;
        let mut cur: *const xmlChar = value;
        let mut item: *mut xmlChar = 0 as *mut xmlChar;
        loop {
            while *cur as i32 == 0x20 as i32
                || 0x9 as i32 <= *cur as i32
                    && *cur as i32 <= 0xa as i32
                || *cur as i32 == 0xd as i32
            {
                cur = cur.offset(1);
            }
            end = cur;
            while *end as i32 != 0 as i32
                && !(*end as i32 == 0x20 as i32
                    || 0x9 as i32 <= *end as i32
                        && *end as i32 <= 0xa as i32
                    || *end as i32 == 0xd as i32)
            {
                end = end.offset(1);
            }
            if end == cur {
                break;
            }
            item = xmlStrndup(cur, end.offset_from(cur) as i64 as i32);
            if xmlStrEqual(
                item,
                b"extension\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
                if flagExtension != -(1 as i32) {
                    if *flags & flagExtension == 0 as i32 {
                        *flags |= flagExtension;
                    }
                } else {
                    ret = 1 as i32;
                }
            } else if xmlStrEqual(
                    item,
                    b"restriction\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                if flagRestriction != -(1 as i32) {
                    if *flags & flagRestriction == 0 as i32 {
                        *flags |= flagRestriction;
                    }
                } else {
                    ret = 1 as i32;
                }
            } else if xmlStrEqual(
                    item,
                    b"substitution\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                if flagSubstitution != -(1 as i32) {
                    if *flags & flagSubstitution == 0 as i32 {
                        *flags |= flagSubstitution;
                    }
                } else {
                    ret = 1 as i32;
                }
            } else if xmlStrEqual(
                    item,
                    b"list\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                if flagList != -(1 as i32) {
                    if *flags & flagList == 0 as i32 {
                        *flags |= flagList;
                    }
                } else {
                    ret = 1 as i32;
                }
            } else if xmlStrEqual(
                    item,
                    b"union\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                if flagUnion != -(1 as i32) {
                    if *flags & flagUnion == 0 as i32 {
                        *flags |= flagUnion;
                    }
                } else {
                    ret = 1 as i32;
                }
            } else {
                ret = 1 as i32;
            }
            if !item.is_null() {
                xmlFree.expect("non-null function pointer")(item as *mut libc::c_void);
            }
            cur = end;
            if !(ret == 0 as i32 && *cur as i32 != 0 as i32) {
                break;
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaCheckCSelectorXPath(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut idc: xmlSchemaIDCPtr,
    mut selector: xmlSchemaIDCSelectPtr,
    mut attr: xmlAttrPtr,
    mut isField: i32,
) -> i32 {
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    if selector.is_null() {
        xmlSchemaPErr(
            ctxt,
            (*idc).node,
            XML_SCHEMAP_INTERNAL as i32,
            b"Internal error: xmlSchemaCheckCSelectorXPath, the selector is not specified.\n\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return -(1 as i32);
    }
    if attr.is_null() {
        node = (*idc).node;
    } else {
        node = attr as xmlNodePtr;
    }
    if ((*selector).xpath).is_null() {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"The XPath expression of the selector is not valid\0" as *const u8
                as *const i8,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as i32;
    } else {
        let mut nsArray: *mut *const xmlChar = 0 as *mut *const xmlChar;
        let mut nsList: *mut xmlNsPtr = 0 as *mut xmlNsPtr;
        if attr.is_null() {
            nsList = 0 as *mut xmlNsPtr;
        } else {
            nsList = xmlGetNsList((*attr).doc, (*attr).parent);
        }
        if !nsList.is_null() {
            let mut i: i32 = 0;
            let mut count: i32 = 0 as i32;
            i = 0 as i32;
            while !(*nsList.offset(i as isize)).is_null() {
                count += 1;
                i += 1;
            }
            nsArray = xmlMalloc
                .expect(
                    "non-null function pointer",
                )(
                ((count * 2 as i32 + 1 as i32) as u64)
                    .wrapping_mul(
                        ::std::mem::size_of::<*const xmlChar>() as u64,
                    ),
            ) as *mut *const xmlChar;
            if nsArray.is_null() {
                xmlSchemaPErrMemory(
                    ctxt,
                    b"allocating a namespace array\0" as *const u8
                        as *const i8,
                    0 as xmlNodePtr,
                );
                xmlFree.expect("non-null function pointer")(nsList as *mut libc::c_void);
                return -(1 as i32);
            }
            i = 0 as i32;
            while i < count {
                let fresh123 = &mut (*nsArray.offset((2 as i32 * i) as isize));
                *fresh123 = (**nsList.offset(i as isize)).href;
                let fresh124 = &mut (*nsArray
                    .offset((2 as i32 * i + 1 as i32) as isize));
                *fresh124 = (**nsList.offset(i as isize)).prefix;
                i += 1;
            }
            let fresh125 = &mut (*nsArray.offset((count * 2 as i32) as isize));
            *fresh125 = 0 as *const xmlChar;
            xmlFree.expect("non-null function pointer")(nsList as *mut libc::c_void);
        }
        if isField != 0 {
            let fresh126 = &mut ((*selector).xpathComp);
            *fresh126 = xmlPatterncompile(
                (*selector).xpath,
                0 as *mut xmlDict,
                XML_PATTERN_XSFIELD as i32,
                nsArray,
            ) as *mut libc::c_void;
        } else {
            let fresh127 = &mut ((*selector).xpathComp);
            *fresh127 = xmlPatterncompile(
                (*selector).xpath,
                0 as *mut xmlDict,
                XML_PATTERN_XSSEL as i32,
                nsArray,
            ) as *mut libc::c_void;
        }
        if !nsArray.is_null() {
            xmlFree
                .expect(
                    "non-null function pointer",
                )(nsArray as *mut *mut xmlChar as *mut libc::c_void);
        }
        if ((*selector).xpathComp).is_null() {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"The XPath expression '%s' could not be compiled\0" as *const u8
                    as *const i8,
                (*selector).xpath,
            );
            return XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as i32;
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaAddAnnotation(
    mut annItem: xmlSchemaAnnotItemPtr,
    mut annot: xmlSchemaAnnotPtr,
) -> xmlSchemaAnnotPtr {
    if annItem.is_null() || annot.is_null() {
        return 0 as xmlSchemaAnnotPtr;
    }
    match (*annItem).type_0 as u32 {
        14 => {
            let mut item: xmlSchemaElementPtr = annItem as xmlSchemaElementPtr;
            let mut cur: xmlSchemaAnnotPtr = (*item).annot;
            if ((*item).annot).is_null() {
                let fresh128 = &mut ((*item).annot);
                *fresh128 = annot;
                return annot;
            }
            cur = (*item).annot;
            if !((*cur).next).is_null() {
                cur = (*cur).next;
            }
            let fresh129 = &mut ((*cur).next);
            *fresh129 = annot;
        }
        15 => {
            let mut item_0: xmlSchemaAttributePtr = annItem as xmlSchemaAttributePtr;
            let mut cur_0: xmlSchemaAnnotPtr = (*item_0).annot;
            if ((*item_0).annot).is_null() {
                let fresh130 = &mut ((*item_0).annot);
                *fresh130 = annot;
                return annot;
            }
            cur_0 = (*item_0).annot;
            if !((*cur_0).next).is_null() {
                cur_0 = (*cur_0).next;
            }
            let fresh131 = &mut ((*cur_0).next);
            *fresh131 = annot;
        }
        21 | 2 => {
            let mut item_1: xmlSchemaWildcardPtr = annItem as xmlSchemaWildcardPtr;
            let mut cur_1: xmlSchemaAnnotPtr = (*item_1).annot;
            if ((*item_1).annot).is_null() {
                let fresh132 = &mut ((*item_1).annot);
                *fresh132 = annot;
                return annot;
            }
            cur_1 = (*item_1).annot;
            if !((*cur_1).next).is_null() {
                cur_1 = (*cur_1).next;
            }
            let fresh133 = &mut ((*cur_1).next);
            *fresh133 = annot;
        }
        25 | 23 | 24 | 22 => {
            let mut item_2: xmlSchemaAnnotItemPtr = annItem;
            let mut cur_2: xmlSchemaAnnotPtr = (*item_2).annot;
            if ((*item_2).annot).is_null() {
                let fresh134 = &mut ((*item_2).annot);
                *fresh134 = annot;
                return annot;
            }
            cur_2 = (*item_2).annot;
            if !((*cur_2).next).is_null() {
                cur_2 = (*cur_2).next;
            }
            let fresh135 = &mut ((*cur_2).next);
            *fresh135 = annot;
        }
        16 => {
            let mut item_3: xmlSchemaAttributeGroupPtr = annItem
                as xmlSchemaAttributeGroupPtr;
            let mut cur_3: xmlSchemaAnnotPtr = (*item_3).annot;
            if ((*item_3).annot).is_null() {
                let fresh136 = &mut ((*item_3).annot);
                *fresh136 = annot;
                return annot;
            }
            cur_3 = (*item_3).annot;
            if !((*cur_3).next).is_null() {
                cur_3 = (*cur_3).next;
            }
            let fresh137 = &mut ((*cur_3).next);
            *fresh137 = annot;
        }
        18 => {
            let mut item_4: xmlSchemaNotationPtr = annItem as xmlSchemaNotationPtr;
            let mut cur_4: xmlSchemaAnnotPtr = (*item_4).annot;
            if ((*item_4).annot).is_null() {
                let fresh138 = &mut ((*item_4).annot);
                *fresh138 = annot;
                return annot;
            }
            cur_4 = (*item_4).annot;
            if !((*cur_4).next).is_null() {
                cur_4 = (*cur_4).next;
            }
            let fresh139 = &mut ((*cur_4).next);
            *fresh139 = annot;
        }
        1000 | 1001 | 1002 | 1003 | 1004 | 1005 | 1006 | 1007 | 1008 | 1009 | 1010
        | 1011 => {
            let mut item_5: xmlSchemaFacetPtr = annItem as xmlSchemaFacetPtr;
            let mut cur_5: xmlSchemaAnnotPtr = (*item_5).annot;
            if ((*item_5).annot).is_null() {
                let fresh140 = &mut ((*item_5).annot);
                *fresh140 = annot;
                return annot;
            }
            cur_5 = (*item_5).annot;
            if !((*cur_5).next).is_null() {
                cur_5 = (*cur_5).next;
            }
            let fresh141 = &mut ((*cur_5).next);
            *fresh141 = annot;
        }
        4 | 5 => {
            let mut item_6: xmlSchemaTypePtr = annItem as xmlSchemaTypePtr;
            let mut cur_6: xmlSchemaAnnotPtr = (*item_6).annot;
            if ((*item_6).annot).is_null() {
                let fresh142 = &mut ((*item_6).annot);
                *fresh142 = annot;
                return annot;
            }
            cur_6 = (*item_6).annot;
            if !((*cur_6).next).is_null() {
                cur_6 = (*cur_6).next;
            }
            let fresh143 = &mut ((*cur_6).next);
            *fresh143 = annot;
        }
        17 => {
            let mut item_7: xmlSchemaModelGroupDefPtr = annItem
                as xmlSchemaModelGroupDefPtr;
            let mut cur_7: xmlSchemaAnnotPtr = (*item_7).annot;
            if ((*item_7).annot).is_null() {
                let fresh144 = &mut ((*item_7).annot);
                *fresh144 = annot;
                return annot;
            }
            cur_7 = (*item_7).annot;
            if !((*cur_7).next).is_null() {
                cur_7 = (*cur_7).next;
            }
            let fresh145 = &mut ((*cur_7).next);
            *fresh145 = annot;
        }
        6 | 7 | 8 => {
            let mut item_8: xmlSchemaModelGroupPtr = annItem as xmlSchemaModelGroupPtr;
            let mut cur_8: xmlSchemaAnnotPtr = (*item_8).annot;
            if ((*item_8).annot).is_null() {
                let fresh146 = &mut ((*item_8).annot);
                *fresh146 = annot;
                return annot;
            }
            cur_8 = (*item_8).annot;
            if !((*cur_8).next).is_null() {
                cur_8 = (*cur_8).next;
            }
            let fresh147 = &mut ((*cur_8).next);
            *fresh147 = annot;
        }
        _ => {
            xmlSchemaPCustomErr(
                0 as xmlSchemaParserCtxtPtr,
                XML_SCHEMAP_INTERNAL,
                0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"Internal error: xmlSchemaAddAnnotation, The item is not a annotated schema component\0"
                    as *const u8 as *const i8,
                0 as *const xmlChar,
            );
        }
    }
    return annot;
}
unsafe extern "C" fn xmlSchemaParseIDCSelectorAndField(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut idc: xmlSchemaIDCPtr,
    mut node: xmlNodePtr,
    mut isField: i32,
) -> xmlSchemaIDCSelectPtr {
    let mut item: xmlSchemaIDCSelectPtr = 0 as *mut xmlSchemaIDCSelect;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"xpath\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    item = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaIDCSelect>() as u64)
        as xmlSchemaIDCSelectPtr;
    if item.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating a 'selector' of an identity-constraint definition\0"
                as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaIDCSelectPtr;
    }
    memset(
        item as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaIDCSelect>() as u64,
    );
    attr = xmlSchemaGetPropNode(node, b"xpath\0" as *const u8 as *const i8);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"name\0" as *const u8 as *const i8,
            0 as *const i8,
        );
    } else {
        let fresh148 = &mut ((*item).xpath);
        *fresh148 = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
        if xmlSchemaCheckCSelectorXPath(ctxt, idc, item, attr, isField)
            == -(1 as i32)
        {
            xmlSchemaPErr(
                ctxt,
                attr as xmlNodePtr,
                XML_SCHEMAP_INTERNAL as i32,
                b"Internal error: xmlSchemaParseIDCSelectorAndField, validating the XPath expression of a IDC selector.\n\0"
                    as *const u8 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
        }
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaAddAnnotation(
            idc as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as i32),
        );
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?)\0" as *const u8 as *const i8,
        );
    }
    return item;
}
unsafe extern "C" fn xmlSchemaParseIDC(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut idcCategory: xmlSchemaTypeType,
    mut targetNamespace: *const xmlChar,
) -> xmlSchemaIDCPtr {
    let mut item: xmlSchemaIDCPtr = 0 as xmlSchemaIDCPtr;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut field: xmlSchemaIDCSelectPtr = 0 as xmlSchemaIDCSelectPtr;
    let mut lastField: xmlSchemaIDCSelectPtr = 0 as xmlSchemaIDCSelectPtr;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"name\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && (idcCategory as u32
                    != XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
                    || xmlStrEqual(
                        (*attr).name,
                        b"refer\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) == 0)
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const i8);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"name\0" as *const u8 as *const i8,
            0 as *const i8,
        );
        return 0 as xmlSchemaIDCPtr;
    } else {
        if xmlSchemaPValAttrNode(
            ctxt,
            0 as xmlSchemaBasicItemPtr,
            attr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
            &mut name,
        ) != 0 as i32
        {
            return 0 as xmlSchemaIDCPtr;
        }
    }
    item = xmlSchemaAddIDC(
        ctxt,
        schema,
        name,
        targetNamespace,
        idcCategory as i32,
        node,
    );
    if item.is_null() {
        return 0 as xmlSchemaIDCPtr;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    if idcCategory as u32
        == XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
    {
        attr = xmlSchemaGetPropNode(
            node,
            b"refer\0" as *const u8 as *const i8,
        );
        if attr.is_null() {
            xmlSchemaPMissingAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"refer\0" as *const u8 as *const i8,
                0 as *const i8,
            );
        } else {
            let fresh149 = &mut ((*item).ref_0);
            *fresh149 = xmlSchemaNewQNameRef(
                ctxt,
                XML_SCHEMA_TYPE_IDC_KEY,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            if ((*item).ref_0).is_null() {
                return 0 as xmlSchemaIDCPtr;
            }
            xmlSchemaPValAttrNodeQName(
                ctxt,
                schema,
                0 as xmlSchemaBasicItemPtr,
                attr,
                &mut (*(*item).ref_0).targetNamespace,
                &mut (*(*item).ref_0).name,
            );
            xmlSchemaCheckReference(
                ctxt,
                schema,
                node,
                attr,
                (*(*item).ref_0).targetNamespace,
            );
        }
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let fresh150 = &mut ((*item).annot);
        *fresh150 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = (*child).next;
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            b"A child element is missing\0" as *const u8 as *const i8,
            b"(annotation?, (selector, field+))\0" as *const u8 as *const i8,
        );
    }
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"selector\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let fresh151 = &mut ((*item).selector);
        *fresh151 = xmlSchemaParseIDCSelectorAndField(
            ctxt,
            item,
            child,
            0 as i32,
        );
        child = (*child).next;
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"field\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            loop {
                field = xmlSchemaParseIDCSelectorAndField(
                    ctxt,
                    item,
                    child,
                    1 as i32,
                );
                if !field.is_null() {
                    (*field).index = (*item).nbFields;
                    let fresh152 = &mut ((*item).nbFields);
                    *fresh152 += 1;
                    if !lastField.is_null() {
                        let fresh153 = &mut ((*lastField).next);
                        *fresh153 = field;
                    } else {
                        let fresh154 = &mut ((*item).fields);
                        *fresh154 = field;
                    }
                    lastField = field;
                }
                child = (*child).next;
                if !(!child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"field\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0)
                {
                    break;
                }
            }
        } else {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"(annotation?, (selector, field+))\0" as *const u8
                    as *const i8,
            );
        }
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, (selector, field+))\0" as *const u8 as *const i8,
        );
    }
    return item;
}
unsafe extern "C" fn xmlSchemaParseElement(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut isElemRef: *mut i32,
    mut topLevel: i32,
) -> xmlSchemaBasicItemPtr {
    let mut current_block: u64;
    let mut decl: xmlSchemaElementPtr = 0 as xmlSchemaElementPtr;
    let mut particle: xmlSchemaParticlePtr = 0 as xmlSchemaParticlePtr;
    let mut annot: xmlSchemaAnnotPtr = 0 as xmlSchemaAnnotPtr;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut nameAttr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut min: i32 = 0;
    let mut max: i32 = 0;
    let mut isRef: i32 = 0 as i32;
    let mut des: *mut xmlChar = 0 as *mut xmlChar;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaBasicItemPtr;
    }
    if !isElemRef.is_null() {
        *isElemRef = 0 as i32;
    }
    nameAttr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const i8);
    attr = xmlSchemaGetPropNode(node, b"ref\0" as *const u8 as *const i8);
    if topLevel != 0 || attr.is_null() {
        if nameAttr.is_null() {
            xmlSchemaPMissingAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"name\0" as *const u8 as *const i8,
                0 as *const i8,
            );
            return 0 as xmlSchemaBasicItemPtr;
        }
    } else {
        isRef = 1 as i32;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        annot = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = (*child).next;
    }
    if topLevel != 0 {
        current_block = 10380409671385728102;
    } else {
        min = xmlGetMinOccurs(
            ctxt,
            node,
            0 as i32,
            -(1 as i32),
            1 as i32,
            b"xs:nonNegativeInteger\0" as *const u8 as *const i8,
        );
        max = xmlGetMaxOccurs(
            ctxt,
            node,
            0 as i32,
            (1 as i32) << 30 as i32,
            1 as i32,
            b"(xs:nonNegativeInteger | unbounded)\0" as *const u8 as *const i8,
        );
        xmlSchemaPCheckParticleCorrect_2(
            ctxt,
            0 as xmlSchemaParticlePtr,
            node,
            min,
            max,
        );
        particle = xmlSchemaAddParticle(ctxt, node, min, max);
        if particle.is_null() {
            current_block = 6846348394768048216;
        } else if isRef != 0 {
            let mut refNs: *const xmlChar = 0 as *const xmlChar;
            let mut ref_0: *const xmlChar = 0 as *const xmlChar;
            let mut refer: xmlSchemaQNameRefPtr = 0 as xmlSchemaQNameRefPtr;
            if !isElemRef.is_null() {
                *isElemRef = 1 as i32;
            }
            xmlSchemaPValAttrNodeQName(
                ctxt,
                schema,
                0 as xmlSchemaBasicItemPtr,
                attr,
                &mut refNs,
                &mut ref_0,
            );
            xmlSchemaCheckReference(ctxt, schema, node, attr, refNs);
            if !nameAttr.is_null() {
                xmlSchemaPMutualExclAttrErr(
                    ctxt,
                    XML_SCHEMAP_SRC_ELEMENT_2_1,
                    0 as xmlSchemaBasicItemPtr,
                    nameAttr,
                    b"ref\0" as *const u8 as *const i8,
                    b"name\0" as *const u8 as *const i8,
                );
            }
            attr = (*node).properties;
            while !attr.is_null() {
                if ((*attr).ns).is_null() {
                    if xmlStrEqual(
                        (*attr).name,
                        b"ref\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) != 0
                        || xmlStrEqual(
                            (*attr).name,
                            b"name\0" as *const u8 as *const i8 as *mut xmlChar,
                        ) != 0
                        || xmlStrEqual(
                            (*attr).name,
                            b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                        ) != 0
                        || xmlStrEqual(
                            (*attr).name,
                            b"maxOccurs\0" as *const u8 as *const i8
                                as *mut xmlChar,
                        ) != 0
                        || xmlStrEqual(
                            (*attr).name,
                            b"minOccurs\0" as *const u8 as *const i8
                                as *mut xmlChar,
                        ) != 0
                    {
                        attr = (*attr).next;
                    } else {
                        xmlSchemaPCustomAttrErr(
                            ctxt,
                            XML_SCHEMAP_SRC_ELEMENT_2_2,
                            0 as *mut *mut xmlChar,
                            0 as xmlSchemaBasicItemPtr,
                            attr,
                            b"Only the attributes 'minOccurs', 'maxOccurs' and 'id' are allowed in addition to 'ref'\0"
                                as *const u8 as *const i8,
                        );
                        break;
                    }
                } else {
                    if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                        xmlSchemaPIllegalAttrErr(
                            ctxt,
                            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                            0 as xmlSchemaBasicItemPtr,
                            attr,
                        );
                    }
                    attr = (*attr).next;
                }
            }
            if !child.is_null() {
                xmlSchemaPContentErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    child,
                    0 as *const i8,
                    b"(annotation?)\0" as *const u8 as *const i8,
                );
            }
            if min == 0 as i32 && max == 0 as i32 {
                current_block = 6846348394768048216;
            } else {
                refer = xmlSchemaNewQNameRef(
                    ctxt,
                    XML_SCHEMA_TYPE_ELEMENT,
                    ref_0,
                    refNs,
                );
                if refer.is_null() {
                    current_block = 6846348394768048216;
                } else {
                    let fresh155 = &mut ((*particle).children);
                    *fresh155 = refer as xmlSchemaTreeItemPtr;
                    let fresh156 = &mut ((*particle).annot);
                    *fresh156 = annot;
                    xmlSchemaAddItemSize(
                        &mut (*(*ctxt).constructor).pending,
                        10 as i32,
                        particle as *mut libc::c_void,
                    );
                    return particle as xmlSchemaBasicItemPtr;
                }
            }
        } else {
            current_block = 10380409671385728102;
        }
    }
    match current_block {
        10380409671385728102 => {
            let mut ns: *const xmlChar = 0 as *const xmlChar;
            let mut fixed: *const xmlChar = 0 as *const xmlChar;
            let mut name: *const xmlChar = 0 as *const xmlChar;
            let mut attrValue: *const xmlChar = 0 as *const xmlChar;
            let mut curIDC: xmlSchemaIDCPtr = 0 as xmlSchemaIDCPtr;
            let mut lastIDC: xmlSchemaIDCPtr = 0 as xmlSchemaIDCPtr;
            if !(xmlSchemaPValAttrNode(
                ctxt,
                0 as xmlSchemaBasicItemPtr,
                nameAttr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                &mut name,
            ) != 0 as i32)
            {
                if topLevel != 0 {
                    ns = (*ctxt).targetNamespace;
                } else {
                    attr = xmlSchemaGetPropNode(
                        node,
                        b"form\0" as *const u8 as *const i8,
                    );
                    if !attr.is_null() {
                        attrValue = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if xmlStrEqual(
                            attrValue,
                            b"qualified\0" as *const u8 as *const i8
                                as *mut xmlChar,
                        ) != 0
                        {
                            ns = (*ctxt).targetNamespace;
                        } else if xmlStrEqual(
                                attrValue,
                                b"unqualified\0" as *const u8 as *const i8
                                    as *mut xmlChar,
                            ) == 0
                            {
                            xmlSchemaPSimpleTypeErr(
                                ctxt,
                                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr,
                                0 as xmlSchemaTypePtr,
                                b"(qualified | unqualified)\0" as *const u8
                                    as *const i8,
                                attrValue,
                                0 as *const i8,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        }
                    } else if (*schema).flags & (1 as i32) << 0 as i32
                            != 0
                        {
                        ns = (*ctxt).targetNamespace;
                    }
                }
                decl = xmlSchemaAddElement(ctxt, name, ns, node, topLevel);
                if !decl.is_null() {
                    attr = (*node).properties;
                    while !attr.is_null() {
                        if ((*attr).ns).is_null() {
                            if xmlStrEqual(
                                (*attr).name,
                                b"name\0" as *const u8 as *const i8
                                    as *mut xmlChar,
                            ) == 0
                                && xmlStrEqual(
                                    (*attr).name,
                                    b"type\0" as *const u8 as *const i8
                                        as *mut xmlChar,
                                ) == 0
                                && xmlStrEqual(
                                    (*attr).name,
                                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                                ) == 0
                                && xmlStrEqual(
                                    (*attr).name,
                                    b"default\0" as *const u8 as *const i8
                                        as *mut xmlChar,
                                ) == 0
                                && xmlStrEqual(
                                    (*attr).name,
                                    b"fixed\0" as *const u8 as *const i8
                                        as *mut xmlChar,
                                ) == 0
                                && xmlStrEqual(
                                    (*attr).name,
                                    b"block\0" as *const u8 as *const i8
                                        as *mut xmlChar,
                                ) == 0
                                && xmlStrEqual(
                                    (*attr).name,
                                    b"nillable\0" as *const u8 as *const i8
                                        as *mut xmlChar,
                                ) == 0
                            {
                                if topLevel == 0 as i32 {
                                    if xmlStrEqual(
                                        (*attr).name,
                                        b"maxOccurs\0" as *const u8 as *const i8
                                            as *mut xmlChar,
                                    ) == 0
                                        && xmlStrEqual(
                                            (*attr).name,
                                            b"minOccurs\0" as *const u8 as *const i8
                                                as *mut xmlChar,
                                        ) == 0
                                        && xmlStrEqual(
                                            (*attr).name,
                                            b"form\0" as *const u8 as *const i8
                                                as *mut xmlChar,
                                        ) == 0
                                    {
                                        xmlSchemaPIllegalAttrErr(
                                            ctxt,
                                            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                            0 as xmlSchemaBasicItemPtr,
                                            attr,
                                        );
                                    }
                                } else if xmlStrEqual(
                                        (*attr).name,
                                        b"final\0" as *const u8 as *const i8
                                            as *mut xmlChar,
                                    ) == 0
                                        && xmlStrEqual(
                                            (*attr).name,
                                            b"abstract\0" as *const u8 as *const i8
                                                as *mut xmlChar,
                                        ) == 0
                                        && xmlStrEqual(
                                            (*attr).name,
                                            b"substitutionGroup\0" as *const u8 as *const i8
                                                as *mut xmlChar,
                                        ) == 0
                                    {
                                    xmlSchemaPIllegalAttrErr(
                                        ctxt,
                                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                        0 as xmlSchemaBasicItemPtr,
                                        attr,
                                    );
                                }
                            }
                        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                            xmlSchemaPIllegalAttrErr(
                                ctxt,
                                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                0 as xmlSchemaBasicItemPtr,
                                attr,
                            );
                        }
                        attr = (*attr).next;
                    }
                    if topLevel != 0 {
                        (*decl).flags |= (1 as i32) << 1 as i32;
                        (*decl).flags |= (1 as i32) << 5 as i32;
                        xmlSchemaPValAttrQName(
                            ctxt,
                            schema,
                            0 as xmlSchemaBasicItemPtr,
                            node,
                            b"substitutionGroup\0" as *const u8 as *const i8,
                            &mut (*decl).substGroupNs,
                            &mut (*decl).substGroup,
                        );
                        if xmlGetBooleanProp(
                            ctxt,
                            node,
                            b"abstract\0" as *const u8 as *const i8,
                            0 as i32,
                        ) != 0
                        {
                            (*decl).flags |= (1 as i32) << 4 as i32;
                        }
                        attr = xmlSchemaGetPropNode(
                            node,
                            b"final\0" as *const u8 as *const i8,
                        );
                        if attr.is_null() {
                            if (*schema).flags & (1 as i32) << 2 as i32
                                != 0
                            {
                                (*decl).flags |= (1 as i32) << 15 as i32;
                            }
                            if (*schema).flags & (1 as i32) << 3 as i32
                                != 0
                            {
                                (*decl).flags |= (1 as i32) << 16 as i32;
                            }
                        } else {
                            attrValue = xmlSchemaGetNodeContent(
                                ctxt,
                                attr as xmlNodePtr,
                            );
                            if xmlSchemaPValAttrBlockFinal(
                                attrValue,
                                &mut (*decl).flags,
                                -(1 as i32),
                                (1 as i32) << 15 as i32,
                                (1 as i32) << 16 as i32,
                                -(1 as i32),
                                -(1 as i32),
                                -(1 as i32),
                            ) != 0 as i32
                            {
                                xmlSchemaPSimpleTypeErr(
                                    ctxt,
                                    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                    0 as xmlSchemaBasicItemPtr,
                                    attr as xmlNodePtr,
                                    0 as xmlSchemaTypePtr,
                                    b"(#all | List of (extension | restriction))\0" as *const u8
                                        as *const i8,
                                    attrValue,
                                    0 as *const i8,
                                    0 as *const xmlChar,
                                    0 as *const xmlChar,
                                );
                            }
                        }
                    }
                    attr = xmlSchemaGetPropNode(
                        node,
                        b"block\0" as *const u8 as *const i8,
                    );
                    if attr.is_null() {
                        if (*schema).flags & (1 as i32) << 7 as i32 != 0
                        {
                            (*decl).flags |= (1 as i32) << 12 as i32;
                        }
                        if (*schema).flags & (1 as i32) << 6 as i32 != 0
                        {
                            (*decl).flags |= (1 as i32) << 11 as i32;
                        }
                        if (*schema).flags & (1 as i32) << 8 as i32 != 0
                        {
                            (*decl).flags |= (1 as i32) << 13 as i32;
                        }
                    } else {
                        attrValue = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if xmlSchemaPValAttrBlockFinal(
                            attrValue,
                            &mut (*decl).flags,
                            -(1 as i32),
                            (1 as i32) << 11 as i32,
                            (1 as i32) << 12 as i32,
                            (1 as i32) << 13 as i32,
                            -(1 as i32),
                            -(1 as i32),
                        ) != 0 as i32
                        {
                            xmlSchemaPSimpleTypeErr(
                                ctxt,
                                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr,
                                0 as xmlSchemaTypePtr,
                                b"(#all | List of (extension | restriction | substitution))\0"
                                    as *const u8 as *const i8,
                                attrValue,
                                0 as *const i8,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        }
                    }
                    if xmlGetBooleanProp(
                        ctxt,
                        node,
                        b"nillable\0" as *const u8 as *const i8,
                        0 as i32,
                    ) != 0
                    {
                        (*decl).flags |= (1 as i32) << 0 as i32;
                    }
                    attr = xmlSchemaGetPropNode(
                        node,
                        b"type\0" as *const u8 as *const i8,
                    );
                    if !attr.is_null() {
                        xmlSchemaPValAttrNodeQName(
                            ctxt,
                            schema,
                            0 as xmlSchemaBasicItemPtr,
                            attr,
                            &mut (*decl).namedTypeNs,
                            &mut (*decl).namedType,
                        );
                        xmlSchemaCheckReference(
                            ctxt,
                            schema,
                            node,
                            attr,
                            (*decl).namedTypeNs,
                        );
                    }
                    let fresh157 = &mut ((*decl).value);
                    *fresh157 = xmlSchemaGetProp(
                        ctxt,
                        node,
                        b"default\0" as *const u8 as *const i8,
                    );
                    attr = xmlSchemaGetPropNode(
                        node,
                        b"fixed\0" as *const u8 as *const i8,
                    );
                    if !attr.is_null() {
                        fixed = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if !((*decl).value).is_null() {
                            xmlSchemaPMutualExclAttrErr(
                                ctxt,
                                XML_SCHEMAP_SRC_ELEMENT_1,
                                0 as xmlSchemaBasicItemPtr,
                                attr,
                                b"default\0" as *const u8 as *const i8,
                                b"fixed\0" as *const u8 as *const i8,
                            );
                        } else {
                            (*decl).flags |= (1 as i32) << 3 as i32;
                            let fresh158 = &mut ((*decl).value);
                            *fresh158 = fixed;
                        }
                    }
                    if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"complexType\0" as *const u8 as *const i8
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                        if !((*decl).namedType).is_null() {
                            xmlSchemaPContentErr(
                                ctxt,
                                XML_SCHEMAP_SRC_ELEMENT_3,
                                0 as xmlSchemaBasicItemPtr,
                                node,
                                child,
                                b"The attribute 'type' and the <complexType> child are mutually exclusive\0"
                                    as *const u8 as *const i8,
                                0 as *const i8,
                            );
                        } else {
                            let fresh159 = &mut ((*decl).subtypes);
                            *fresh159 = xmlSchemaParseComplexType(
                                ctxt,
                                schema,
                                child,
                                0 as i32,
                            );
                        }
                        child = (*child).next;
                    } else if !child.is_null() && !((*child).ns).is_null()
                            && xmlStrEqual(
                                (*child).name,
                                b"simpleType\0" as *const u8 as *const i8
                                    as *const xmlChar,
                            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                        {
                        if !((*decl).namedType).is_null() {
                            xmlSchemaPContentErr(
                                ctxt,
                                XML_SCHEMAP_SRC_ELEMENT_3,
                                0 as xmlSchemaBasicItemPtr,
                                node,
                                child,
                                b"The attribute 'type' and the <simpleType> child are mutually exclusive\0"
                                    as *const u8 as *const i8,
                                0 as *const i8,
                            );
                        } else {
                            let fresh160 = &mut ((*decl).subtypes);
                            *fresh160 = xmlSchemaParseSimpleType(
                                ctxt,
                                schema,
                                child,
                                0 as i32,
                            );
                        }
                        child = (*child).next;
                    }
                    while !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"unique\0" as *const u8 as *const i8
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                        || !child.is_null() && !((*child).ns).is_null()
                            && xmlStrEqual(
                                (*child).name,
                                b"key\0" as *const u8 as *const i8
                                    as *const xmlChar,
                            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                        || !child.is_null() && !((*child).ns).is_null()
                            && xmlStrEqual(
                                (*child).name,
                                b"keyref\0" as *const u8 as *const i8
                                    as *const xmlChar,
                            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                        if !child.is_null() && !((*child).ns).is_null()
                            && xmlStrEqual(
                                (*child).name,
                                b"unique\0" as *const u8 as *const i8
                                    as *const xmlChar,
                            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                        {
                            curIDC = xmlSchemaParseIDC(
                                ctxt,
                                schema,
                                child,
                                XML_SCHEMA_TYPE_IDC_UNIQUE,
                                (*decl).targetNamespace,
                            );
                        } else if !child.is_null() && !((*child).ns).is_null()
                                && xmlStrEqual(
                                    (*child).name,
                                    b"key\0" as *const u8 as *const i8
                                        as *const xmlChar,
                                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                            {
                            curIDC = xmlSchemaParseIDC(
                                ctxt,
                                schema,
                                child,
                                XML_SCHEMA_TYPE_IDC_KEY,
                                (*decl).targetNamespace,
                            );
                        } else if !child.is_null() && !((*child).ns).is_null()
                                && xmlStrEqual(
                                    (*child).name,
                                    b"keyref\0" as *const u8 as *const i8
                                        as *const xmlChar,
                                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                            {
                            curIDC = xmlSchemaParseIDC(
                                ctxt,
                                schema,
                                child,
                                XML_SCHEMA_TYPE_IDC_KEYREF,
                                (*decl).targetNamespace,
                            );
                        }
                        if !lastIDC.is_null() {
                            let fresh161 = &mut ((*lastIDC).next);
                            *fresh161 = curIDC;
                        } else {
                            let fresh162 = &mut ((*decl).idcs);
                            *fresh162 = curIDC as *mut libc::c_void;
                        }
                        lastIDC = curIDC;
                        child = (*child).next;
                    }
                    if !child.is_null() {
                        xmlSchemaPContentErr(
                            ctxt,
                            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                            0 as xmlSchemaBasicItemPtr,
                            node,
                            child,
                            0 as *const i8,
                            b"(annotation?, ((simpleType | complexType)?, (unique | key | keyref)*))\0"
                                as *const u8 as *const i8,
                        );
                    }
                    let fresh163 = &mut ((*decl).annot);
                    *fresh163 = annot;
                    if !des.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(des as *mut libc::c_void);
                        des = 0 as *mut xmlChar;
                    }
                    if topLevel != 0 {
                        return decl as xmlSchemaBasicItemPtr
                    } else {
                        let fresh164 = &mut ((*particle).children);
                        *fresh164 = decl as xmlSchemaTreeItemPtr;
                        return particle as xmlSchemaBasicItemPtr;
                    }
                }
            }
        }
        _ => {}
    }
    if !des.is_null() {
        xmlFree.expect("non-null function pointer")(des as *mut libc::c_void);
        des = 0 as *mut xmlChar;
    }
    if !annot.is_null() {
        if !particle.is_null() {
            let fresh165 = &mut ((*particle).annot);
            *fresh165 = 0 as xmlSchemaAnnotPtr;
        }
        if !decl.is_null() {
            let fresh166 = &mut ((*decl).annot);
            *fresh166 = 0 as xmlSchemaAnnotPtr;
        }
        xmlSchemaFreeAnnot(annot);
    }
    return 0 as xmlSchemaBasicItemPtr;
}
unsafe extern "C" fn xmlSchemaParseUnion(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> i32 {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return -(1 as i32);
    }
    type_0 = (*ctxt).ctxtType;
    (*type_0).flags |= (1 as i32) << 7 as i32;
    let fresh167 = &mut ((*type_0).baseType);
    *fresh167 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"memberTypes\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    attr = xmlSchemaGetPropNode(
        node,
        b"memberTypes\0" as *const u8 as *const i8,
    );
    if !attr.is_null() {
        let mut end: *const xmlChar = 0 as *const xmlChar;
        let mut tmp: *mut xmlChar = 0 as *mut xmlChar;
        let mut localName: *const xmlChar = 0 as *const xmlChar;
        let mut nsName: *const xmlChar = 0 as *const xmlChar;
        let mut link: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
        let mut lastLink: xmlSchemaTypeLinkPtr = 0 as xmlSchemaTypeLinkPtr;
        let mut ref_0: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
        cur = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
        let fresh168 = &mut ((*type_0).base);
        *fresh168 = cur;
        loop {
            while *cur as i32 == 0x20 as i32
                || 0x9 as i32 <= *cur as i32
                    && *cur as i32 <= 0xa as i32
                || *cur as i32 == 0xd as i32
            {
                cur = cur.offset(1);
            }
            end = cur;
            while *end as i32 != 0 as i32
                && !(*end as i32 == 0x20 as i32
                    || 0x9 as i32 <= *end as i32
                        && *end as i32 <= 0xa as i32
                    || *end as i32 == 0xd as i32)
            {
                end = end.offset(1);
            }
            if end == cur {
                break;
            }
            tmp = xmlStrndup(cur, end.offset_from(cur) as i64 as i32);
            if xmlSchemaPValAttrNodeQNameValue(
                ctxt,
                schema,
                0 as xmlSchemaBasicItemPtr,
                attr,
                tmp,
                &mut nsName,
                &mut localName,
            ) == 0 as i32
            {
                link = xmlMalloc
                    .expect(
                        "non-null function pointer",
                    )(::std::mem::size_of::<xmlSchemaTypeLink>() as u64)
                    as xmlSchemaTypeLinkPtr;
                if link.is_null() {
                    xmlSchemaPErrMemory(
                        ctxt,
                        b"xmlSchemaParseUnion, allocating a type link\0" as *const u8
                            as *const i8,
                        0 as xmlNodePtr,
                    );
                    return -(1 as i32);
                }
                let fresh169 = &mut ((*link).type_0);
                *fresh169 = 0 as xmlSchemaTypePtr;
                let fresh170 = &mut ((*link).next);
                *fresh170 = 0 as *mut _xmlSchemaTypeLink;
                if lastLink.is_null() {
                    let fresh171 = &mut ((*type_0).memberTypes);
                    *fresh171 = link;
                } else {
                    let fresh172 = &mut ((*lastLink).next);
                    *fresh172 = link;
                }
                lastLink = link;
                ref_0 = xmlSchemaNewQNameRef(
                    ctxt,
                    XML_SCHEMA_TYPE_SIMPLE,
                    localName,
                    nsName,
                );
                if ref_0.is_null() {
                    if !tmp.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(tmp as *mut libc::c_void);
                        tmp = 0 as *mut xmlChar;
                    }
                    return -(1 as i32);
                }
                let fresh173 = &mut ((*link).type_0);
                *fresh173 = ref_0 as xmlSchemaTypePtr;
            }
            if !tmp.is_null() {
                xmlFree.expect("non-null function pointer")(tmp as *mut libc::c_void);
                tmp = 0 as *mut xmlChar;
            }
            cur = end;
            if !(*cur as i32 != 0 as i32) {
                break;
            }
        }
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as i32),
        );
        child = (*child).next;
    }
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let mut subtype: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        let mut last: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
        while !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            subtype = xmlSchemaParseSimpleType(ctxt, schema, child, 0 as i32);
            if !subtype.is_null() {
                if last.is_null() {
                    let fresh174 = &mut ((*type_0).subtypes);
                    *fresh174 = subtype;
                    last = subtype;
                } else {
                    let fresh175 = &mut ((*last).next);
                    *fresh175 = subtype;
                    last = subtype;
                }
                let fresh176 = &mut ((*last).next);
                *fresh176 = 0 as *mut _xmlSchemaType;
            }
            child = (*child).next;
        }
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, simpleType*)\0" as *const u8 as *const i8,
        );
    }
    if attr.is_null() && ((*type_0).subtypes).is_null() {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"Either the attribute 'memberTypes' or at least one <simpleType> child must be present\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
        );
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaParseList(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaTypePtr {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    type_0 = (*ctxt).ctxtType;
    (*type_0).flags |= (1 as i32) << 6 as i32;
    let fresh177 = &mut ((*type_0).baseType);
    *fresh177 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"itemType\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    xmlSchemaPValAttrQName(
        ctxt,
        schema,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"itemType\0" as *const u8 as *const i8,
        &mut (*type_0).baseNs,
        &mut (*type_0).base,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as i32),
        );
        child = (*child).next;
    }
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        if !((*type_0).base).is_null() {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"The attribute 'itemType' and the <simpleType> child are mutually exclusive\0"
                    as *const u8 as *const i8,
                0 as *const xmlChar,
            );
        } else {
            let fresh178 = &mut ((*type_0).subtypes);
            *fresh178 = xmlSchemaParseSimpleType(ctxt, schema, child, 0 as i32);
        }
        child = (*child).next;
    } else if ((*type_0).base).is_null() {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"Either the attribute 'itemType' or the <simpleType> child must be present\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
        );
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, simpleType?)\0" as *const u8 as *const i8,
        );
    }
    if ((*type_0).base).is_null() && ((*type_0).subtypes).is_null()
        && (xmlSchemaGetPropNode(
            node,
            b"itemType\0" as *const u8 as *const i8,
        ))
            .is_null()
    {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"Either the attribute 'itemType' or the <simpleType> child must be present\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
        );
    }
    return 0 as xmlSchemaTypePtr;
}
unsafe extern "C" fn xmlSchemaParseSimpleType(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut topLevel: i32,
) -> xmlSchemaTypePtr {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut oldCtxtType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attrValue: *const xmlChar = 0 as *const xmlChar;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut hasRestriction: i32 = 0 as i32;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    if topLevel != 0 {
        attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const i8);
        if attr.is_null() {
            xmlSchemaPMissingAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"name\0" as *const u8 as *const i8,
                0 as *const i8,
            );
            return 0 as xmlSchemaTypePtr;
        } else {
            if xmlSchemaPValAttrNode(
                ctxt,
                0 as xmlSchemaBasicItemPtr,
                attr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                &mut attrValue,
            ) != 0 as i32
            {
                return 0 as xmlSchemaTypePtr;
            }
            if (*ctxt).isS4S != 0 {
                let mut biType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
                if (*ctxt).isRedefine != 0 {
                    xmlSchemaPCustomErr(
                        ctxt,
                        XML_SCHEMAP_SRC_REDEFINE,
                        0 as xmlSchemaBasicItemPtr,
                        node,
                        b"Redefinition of built-in simple types is not supported\0"
                            as *const u8 as *const i8,
                        0 as *const xmlChar,
                    );
                    return 0 as xmlSchemaTypePtr;
                }
                biType = xmlSchemaGetPredefinedType(attrValue, xmlSchemaNs);
                if !biType.is_null() {
                    return biType;
                }
            }
        }
    }
    if topLevel == 0 as i32 {
        type_0 = xmlSchemaAddType(
            ctxt,
            schema,
            XML_SCHEMA_TYPE_SIMPLE,
            0 as *const xmlChar,
            (*ctxt).targetNamespace,
            node,
            0 as i32,
        );
        if type_0.is_null() {
            return 0 as xmlSchemaTypePtr;
        }
        (*type_0).type_0 = XML_SCHEMA_TYPE_SIMPLE;
        (*type_0).contentType = XML_SCHEMA_CONTENT_SIMPLE;
        attr = (*node).properties;
        while !attr.is_null() {
            if ((*attr).ns).is_null() {
                if xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        0 as xmlSchemaBasicItemPtr,
                        attr,
                    );
                }
            } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
            attr = (*attr).next;
        }
    } else {
        type_0 = xmlSchemaAddType(
            ctxt,
            schema,
            XML_SCHEMA_TYPE_SIMPLE,
            attrValue,
            (*ctxt).targetNamespace,
            node,
            1 as i32,
        );
        if type_0.is_null() {
            return 0 as xmlSchemaTypePtr;
        }
        (*type_0).type_0 = XML_SCHEMA_TYPE_SIMPLE;
        (*type_0).contentType = XML_SCHEMA_CONTENT_SIMPLE;
        (*type_0).flags |= (1 as i32) << 3 as i32;
        attr = (*node).properties;
        while !attr.is_null() {
            if ((*attr).ns).is_null() {
                if xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                    && xmlStrEqual(
                        (*attr).name,
                        b"name\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) == 0
                    && xmlStrEqual(
                        (*attr).name,
                        b"final\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) == 0
                {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        0 as xmlSchemaBasicItemPtr,
                        attr,
                    );
                }
            } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
            attr = (*attr).next;
        }
        attr = xmlSchemaGetPropNode(
            node,
            b"final\0" as *const u8 as *const i8,
        );
        if attr.is_null() {
            if (*schema).flags & (1 as i32) << 3 as i32 != 0 {
                (*type_0).flags |= (1 as i32) << 10 as i32;
            }
            if (*schema).flags & (1 as i32) << 4 as i32 != 0 {
                (*type_0).flags |= (1 as i32) << 11 as i32;
            }
            if (*schema).flags & (1 as i32) << 5 as i32 != 0 {
                (*type_0).flags |= (1 as i32) << 12 as i32;
            }
        } else {
            attrValue = xmlSchemaGetProp(
                ctxt,
                node,
                b"final\0" as *const u8 as *const i8,
            );
            if xmlSchemaPValAttrBlockFinal(
                attrValue,
                &mut (*type_0).flags,
                -(1 as i32),
                -(1 as i32),
                (1 as i32) << 10 as i32,
                -(1 as i32),
                (1 as i32) << 11 as i32,
                (1 as i32) << 12 as i32,
            ) != 0 as i32
            {
                xmlSchemaPSimpleTypeErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                    type_0 as xmlSchemaBasicItemPtr,
                    attr as xmlNodePtr,
                    0 as xmlSchemaTypePtr,
                    b"(#all | List of (list | union | restriction)\0" as *const u8
                        as *const i8,
                    attrValue,
                    0 as *const i8,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
            }
        }
    }
    let fresh179 = &mut ((*type_0).targetNamespace);
    *fresh179 = (*ctxt).targetNamespace;
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    oldCtxtType = (*ctxt).ctxtType;
    let fresh180 = &mut ((*ctxt).ctxtType);
    *fresh180 = type_0;
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let fresh181 = &mut ((*type_0).annot);
        *fresh181 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = (*child).next;
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, (restriction | list | union))\0" as *const u8
                as *const i8,
        );
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"restriction\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        xmlSchemaParseRestriction(ctxt, schema, child, XML_SCHEMA_TYPE_SIMPLE);
        hasRestriction = 1 as i32;
        child = (*child).next;
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"list\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        xmlSchemaParseList(ctxt, schema, child);
        child = (*child).next;
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"union\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        xmlSchemaParseUnion(ctxt, schema, child);
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, (restriction | list | union))\0" as *const u8
                as *const i8,
        );
    }
    if topLevel != 0 && (*ctxt).isRedefine != 0 && hasRestriction == 0 {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_SRC_REDEFINE,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"This is a redefinition, thus the <simpleType> must have a <restriction> child\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
        );
    }
    let fresh182 = &mut ((*ctxt).ctxtType);
    *fresh182 = oldCtxtType;
    return type_0;
}
unsafe extern "C" fn xmlSchemaParseModelGroupDefRef(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaTreeItemPtr {
    let mut item: xmlSchemaParticlePtr = 0 as *mut xmlSchemaParticle;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut ref_0: *const xmlChar = 0 as *const xmlChar;
    let mut refNs: *const xmlChar = 0 as *const xmlChar;
    let mut min: i32 = 0;
    let mut max: i32 = 0;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTreeItemPtr;
    }
    attr = xmlSchemaGetPropNode(node, b"ref\0" as *const u8 as *const i8);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"ref\0" as *const u8 as *const i8,
            0 as *const i8,
        );
        return 0 as xmlSchemaTreeItemPtr;
    } else {
        if xmlSchemaPValAttrNodeQName(
            ctxt,
            schema,
            0 as xmlSchemaBasicItemPtr,
            attr,
            &mut refNs,
            &mut ref_0,
        ) != 0 as i32
        {
            return 0 as xmlSchemaTreeItemPtr;
        }
    }
    xmlSchemaCheckReference(ctxt, schema, node, attr, refNs);
    min = xmlGetMinOccurs(
        ctxt,
        node,
        0 as i32,
        -(1 as i32),
        1 as i32,
        b"xs:nonNegativeInteger\0" as *const u8 as *const i8,
    );
    max = xmlGetMaxOccurs(
        ctxt,
        node,
        0 as i32,
        (1 as i32) << 30 as i32,
        1 as i32,
        b"(xs:nonNegativeInteger | unbounded)\0" as *const u8 as *const i8,
    );
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"ref\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"minOccurs\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"maxOccurs\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    item = xmlSchemaAddParticle(ctxt, node, min, max);
    if item.is_null() {
        return 0 as xmlSchemaTreeItemPtr;
    }
    let fresh183 = &mut ((*item).children);
    *fresh183 = xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_GROUP, ref_0, refNs)
        as xmlSchemaTreeItemPtr;
    xmlSchemaPCheckParticleCorrect_2(ctxt, item, node, min, max);
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let fresh184 = &mut ((*item).annot);
        *fresh184 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?)\0" as *const u8 as *const i8,
        );
    }
    if min == 0 as i32 && max == 0 as i32 {
        return 0 as xmlSchemaTreeItemPtr;
    }
    return item as xmlSchemaTreeItemPtr;
}
unsafe extern "C" fn xmlSchemaParseModelGroupDefinition(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> xmlSchemaModelGroupDefPtr {
    let mut item: xmlSchemaModelGroupDefPtr = 0 as *mut xmlSchemaModelGroupDef;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaModelGroupDefPtr;
    }
    attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const i8);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"name\0" as *const u8 as *const i8,
            0 as *const i8,
        );
        return 0 as xmlSchemaModelGroupDefPtr;
    } else {
        if xmlSchemaPValAttrNode(
            ctxt,
            0 as xmlSchemaBasicItemPtr,
            attr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
            &mut name,
        ) != 0 as i32
        {
            return 0 as xmlSchemaModelGroupDefPtr;
        }
    }
    item = xmlSchemaAddModelGroupDefinition(
        ctxt,
        schema,
        name,
        (*ctxt).targetNamespace,
        node,
    );
    if item.is_null() {
        return 0 as xmlSchemaModelGroupDefPtr;
    }
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"name\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let fresh185 = &mut ((*item).annot);
        *fresh185 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = (*child).next;
    }
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"all\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let fresh186 = &mut ((*item).children);
        *fresh186 = xmlSchemaParseModelGroup(
            ctxt,
            schema,
            child,
            XML_SCHEMA_TYPE_ALL,
            0 as i32,
        );
        child = (*child).next;
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"choice\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        let fresh187 = &mut ((*item).children);
        *fresh187 = xmlSchemaParseModelGroup(
            ctxt,
            schema,
            child,
            XML_SCHEMA_TYPE_CHOICE,
            0 as i32,
        );
        child = (*child).next;
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"sequence\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        let fresh188 = &mut ((*item).children);
        *fresh188 = xmlSchemaParseModelGroup(
            ctxt,
            schema,
            child,
            XML_SCHEMA_TYPE_SEQUENCE,
            0 as i32,
        );
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, (all | choice | sequence)?)\0" as *const u8
                as *const i8,
        );
    }
    return item;
}
unsafe extern "C" fn xmlSchemaCleanupDoc(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut root: xmlNodePtr,
) {
    let mut delete: xmlNodePtr = 0 as *mut xmlNode;
    let mut cur: xmlNodePtr = 0 as *mut xmlNode;
    if ctxt.is_null() || root.is_null() {
        return;
    }
    delete = 0 as xmlNodePtr;
    cur = root;
    let mut current_block_21: u64;
    while !cur.is_null() {
        if !delete.is_null() {
            xmlUnlinkNode(delete);
            xmlFreeNode(delete);
            delete = 0 as xmlNodePtr;
        }
        if (*cur).type_0 as u32 == XML_TEXT_NODE as i32 as u32
        {
            if (*cur).type_0 as u32
                == XML_TEXT_NODE as i32 as u32
                && xmlSchemaIsBlank((*cur).content, -(1 as i32)) != 0
            {
                if xmlNodeGetSpacePreserve(cur as *const xmlNode) != 1 as i32 {
                    delete = cur;
                }
            }
            current_block_21 = 5689001924483802034;
        } else if (*cur).type_0 as u32
                != XML_ELEMENT_NODE as i32 as u32
                && (*cur).type_0 as u32
                    != XML_CDATA_SECTION_NODE as i32 as u32
            {
            delete = cur;
            current_block_21 = 11313137364425335962;
        } else {
            current_block_21 = 5689001924483802034;
        }
        match current_block_21 {
            5689001924483802034 => {
                if !((*cur).children).is_null() {
                    if (*(*cur).children).type_0 as u32
                        != XML_ENTITY_DECL as i32 as u32
                        && (*(*cur).children).type_0 as u32
                            != XML_ENTITY_REF_NODE as i32 as u32
                        && (*(*cur).children).type_0 as u32
                            != XML_ENTITY_NODE as i32 as u32
                    {
                        cur = (*cur).children;
                        continue;
                    }
                }
            }
            _ => {}
        }
        if !((*cur).next).is_null() {
            cur = (*cur).next;
        } else {
            loop {
                cur = (*cur).parent;
                if cur.is_null() {
                    break;
                }
                if cur == root {
                    cur = 0 as xmlNodePtr;
                    break;
                } else if !((*cur).next).is_null() {
                    cur = (*cur).next;
                    break;
                } else if cur.is_null() {
                    break;
                }
            }
        }
    }
    if !delete.is_null() {
        xmlUnlinkNode(delete);
        xmlFreeNode(delete);
        delete = 0 as xmlNodePtr;
    }
}
unsafe extern "C" fn xmlSchemaClearSchemaDefaults(mut schema: xmlSchemaPtr) {
    if (*schema).flags & (1 as i32) << 0 as i32 != 0 {
        (*schema).flags ^= (1 as i32) << 0 as i32;
    }
    if (*schema).flags & (1 as i32) << 1 as i32 != 0 {
        (*schema).flags ^= (1 as i32) << 1 as i32;
    }
    if (*schema).flags & (1 as i32) << 2 as i32 != 0 {
        (*schema).flags ^= (1 as i32) << 2 as i32;
    }
    if (*schema).flags & (1 as i32) << 3 as i32 != 0 {
        (*schema).flags ^= (1 as i32) << 3 as i32;
    }
    if (*schema).flags & (1 as i32) << 4 as i32 != 0 {
        (*schema).flags ^= (1 as i32) << 4 as i32;
    }
    if (*schema).flags & (1 as i32) << 5 as i32 != 0 {
        (*schema).flags ^= (1 as i32) << 5 as i32;
    }
    if (*schema).flags & (1 as i32) << 6 as i32 != 0 {
        (*schema).flags ^= (1 as i32) << 6 as i32;
    }
    if (*schema).flags & (1 as i32) << 7 as i32 != 0 {
        (*schema).flags ^= (1 as i32) << 7 as i32;
    }
    if (*schema).flags & (1 as i32) << 8 as i32 != 0 {
        (*schema).flags ^= (1 as i32) << 8 as i32;
    }
}
unsafe extern "C" fn xmlSchemaParseSchemaElement(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> i32 {
    let mut current_block: u64;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut val: *const xmlChar = 0 as *const xmlChar;
    let mut res: i32 = 0 as i32;
    let mut oldErrs: i32 = (*ctxt).nberrors;
    res = xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    if !(res == -(1 as i32)) {
        attr = xmlSchemaGetPropNode(
            node,
            b"targetNamespace\0" as *const u8 as *const i8,
        );
        if !attr.is_null() {
            res = xmlSchemaPValAttrNode(
                ctxt,
                0 as xmlSchemaBasicItemPtr,
                attr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
                0 as *mut *const xmlChar,
            );
            if res == -(1 as i32) {
                current_block = 10376413147378688457;
            } else if res != 0 as i32 {
                (*ctxt).stop = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as i32;
                current_block = 6156756840313318511;
            } else {
                current_block = 5399440093318478209;
            }
        } else {
            current_block = 5399440093318478209;
        }
        match current_block {
            10376413147378688457 => {}
            _ => {
                match current_block {
                    5399440093318478209 => {
                        attr = xmlSchemaGetPropNode(
                            node,
                            b"elementFormDefault\0" as *const u8 as *const i8,
                        );
                        if !attr.is_null() {
                            val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                            res = xmlSchemaPValAttrFormDefault(
                                val,
                                &mut (*schema).flags,
                                (1 as i32) << 0 as i32,
                            );
                            if res == -(1 as i32) {
                                current_block = 10376413147378688457;
                            } else {
                                if res != 0 as i32 {
                                    xmlSchemaPSimpleTypeErr(
                                        ctxt,
                                        XML_SCHEMAP_ELEMFORMDEFAULT_VALUE,
                                        0 as xmlSchemaBasicItemPtr,
                                        attr as xmlNodePtr,
                                        0 as xmlSchemaTypePtr,
                                        b"(qualified | unqualified)\0" as *const u8
                                            as *const i8,
                                        val,
                                        0 as *const i8,
                                        0 as *const xmlChar,
                                        0 as *const xmlChar,
                                    );
                                }
                                current_block = 224731115979188411;
                            }
                        } else {
                            current_block = 224731115979188411;
                        }
                        match current_block {
                            10376413147378688457 => {}
                            _ => {
                                attr = xmlSchemaGetPropNode(
                                    node,
                                    b"attributeFormDefault\0" as *const u8
                                        as *const i8,
                                );
                                if !attr.is_null() {
                                    val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                                    res = xmlSchemaPValAttrFormDefault(
                                        val,
                                        &mut (*schema).flags,
                                        (1 as i32) << 1 as i32,
                                    );
                                    if res == -(1 as i32) {
                                        current_block = 10376413147378688457;
                                    } else {
                                        if res != 0 as i32 {
                                            xmlSchemaPSimpleTypeErr(
                                                ctxt,
                                                XML_SCHEMAP_ATTRFORMDEFAULT_VALUE,
                                                0 as xmlSchemaBasicItemPtr,
                                                attr as xmlNodePtr,
                                                0 as xmlSchemaTypePtr,
                                                b"(qualified | unqualified)\0" as *const u8
                                                    as *const i8,
                                                val,
                                                0 as *const i8,
                                                0 as *const xmlChar,
                                                0 as *const xmlChar,
                                            );
                                        }
                                        current_block = 5689316957504528238;
                                    }
                                } else {
                                    current_block = 5689316957504528238;
                                }
                                match current_block {
                                    10376413147378688457 => {}
                                    _ => {
                                        attr = xmlSchemaGetPropNode(
                                            node,
                                            b"finalDefault\0" as *const u8 as *const i8,
                                        );
                                        if !attr.is_null() {
                                            val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                                            res = xmlSchemaPValAttrBlockFinal(
                                                val,
                                                &mut (*schema).flags,
                                                -(1 as i32),
                                                (1 as i32) << 2 as i32,
                                                (1 as i32) << 3 as i32,
                                                -(1 as i32),
                                                (1 as i32) << 4 as i32,
                                                (1 as i32) << 5 as i32,
                                            );
                                            if res == -(1 as i32) {
                                                current_block = 10376413147378688457;
                                            } else {
                                                if res != 0 as i32 {
                                                    xmlSchemaPSimpleTypeErr(
                                                        ctxt,
                                                        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                                        0 as xmlSchemaBasicItemPtr,
                                                        attr as xmlNodePtr,
                                                        0 as xmlSchemaTypePtr,
                                                        b"(#all | List of (extension | restriction | list | union))\0"
                                                            as *const u8 as *const i8,
                                                        val,
                                                        0 as *const i8,
                                                        0 as *const xmlChar,
                                                        0 as *const xmlChar,
                                                    );
                                                }
                                                current_block = 3123434771885419771;
                                            }
                                        } else {
                                            current_block = 3123434771885419771;
                                        }
                                        match current_block {
                                            10376413147378688457 => {}
                                            _ => {
                                                attr = xmlSchemaGetPropNode(
                                                    node,
                                                    b"blockDefault\0" as *const u8 as *const i8,
                                                );
                                                if !attr.is_null() {
                                                    val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                                                    res = xmlSchemaPValAttrBlockFinal(
                                                        val,
                                                        &mut (*schema).flags,
                                                        -(1 as i32),
                                                        (1 as i32) << 6 as i32,
                                                        (1 as i32) << 7 as i32,
                                                        (1 as i32) << 8 as i32,
                                                        -(1 as i32),
                                                        -(1 as i32),
                                                    );
                                                    if res == -(1 as i32) {
                                                        current_block = 10376413147378688457;
                                                    } else {
                                                        if res != 0 as i32 {
                                                            xmlSchemaPSimpleTypeErr(
                                                                ctxt,
                                                                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                                                0 as xmlSchemaBasicItemPtr,
                                                                attr as xmlNodePtr,
                                                                0 as xmlSchemaTypePtr,
                                                                b"(#all | List of (extension | restriction | substitution))\0"
                                                                    as *const u8 as *const i8,
                                                                val,
                                                                0 as *const i8,
                                                                0 as *const xmlChar,
                                                                0 as *const xmlChar,
                                                            );
                                                        }
                                                        current_block = 6156756840313318511;
                                                    }
                                                } else {
                                                    current_block = 6156756840313318511;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
                match current_block {
                    10376413147378688457 => {}
                    _ => {
                        if oldErrs != (*ctxt).nberrors {
                            res = (*ctxt).err;
                        }
                        return res;
                    }
                }
            }
        }
    }
    return -(1 as i32);
}
unsafe extern "C" fn xmlSchemaParseSchemaTopLevel(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut nodes: xmlNodePtr,
) -> i32 {
    let mut current_block: u64;
    let mut child: xmlNodePtr = 0 as *mut xmlNode;
    let mut annot: xmlSchemaAnnotPtr = 0 as *mut xmlSchemaAnnot;
    let mut res: i32 = 0 as i32;
    let mut oldErrs: i32 = 0;
    let mut tmpOldErrs: i32 = 0;
    if ctxt.is_null() || schema.is_null() || nodes.is_null() {
        return -(1 as i32);
    }
    oldErrs = (*ctxt).nberrors;
    child = nodes;
    loop {
        if !(!child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"include\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"import\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"redefine\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0)
        {
            current_block = 14832935472441733737;
            break;
        }
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            annot = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
            if ((*schema).annot).is_null() {
                let fresh189 = &mut ((*schema).annot);
                *fresh189 = annot;
            } else {
                xmlSchemaFreeAnnot(annot);
            }
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"import\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            tmpOldErrs = (*ctxt).nberrors;
            res = xmlSchemaParseImport(ctxt, schema, child);
            if res == -(1 as i32) {
                current_block = 17833631497414332109;
                break;
            }
            if (*ctxt).stop != 0 {
                current_block = 5749571351303500870;
                break;
            }
            if tmpOldErrs != (*ctxt).nberrors {
                current_block = 5749571351303500870;
                break;
            }
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"include\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            tmpOldErrs = (*ctxt).nberrors;
            res = xmlSchemaParseInclude(ctxt, schema, child);
            if res == -(1 as i32) {
                current_block = 17833631497414332109;
                break;
            }
            if (*ctxt).stop != 0 {
                current_block = 5749571351303500870;
                break;
            }
            if tmpOldErrs != (*ctxt).nberrors {
                current_block = 5749571351303500870;
                break;
            }
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"redefine\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            tmpOldErrs = (*ctxt).nberrors;
            res = xmlSchemaParseRedefine(ctxt, schema, child);
            if res == -(1 as i32) {
                current_block = 17833631497414332109;
                break;
            }
            if (*ctxt).stop != 0 {
                current_block = 5749571351303500870;
                break;
            }
            if tmpOldErrs != (*ctxt).nberrors {
                current_block = 5749571351303500870;
                break;
            }
        }
        child = (*child).next;
    }
    match current_block {
        14832935472441733737 => {
            while !child.is_null() {
                if !child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"complexType\0" as *const u8 as *const i8
                            as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                {
                    xmlSchemaParseComplexType(ctxt, schema, child, 1 as i32);
                    child = (*child).next;
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"simpleType\0" as *const u8 as *const i8
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseSimpleType(ctxt, schema, child, 1 as i32);
                    child = (*child).next;
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"element\0" as *const u8 as *const i8
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseElement(
                        ctxt,
                        schema,
                        child,
                        0 as *mut i32,
                        1 as i32,
                    );
                    child = (*child).next;
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"attribute\0" as *const u8 as *const i8
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseGlobalAttribute(ctxt, schema, child);
                    child = (*child).next;
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"attributeGroup\0" as *const u8 as *const i8
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseAttributeGroupDefinition(ctxt, schema, child);
                    child = (*child).next;
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"group\0" as *const u8 as *const i8
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseModelGroupDefinition(ctxt, schema, child);
                    child = (*child).next;
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"notation\0" as *const u8 as *const i8
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseNotation(ctxt, schema, child);
                    child = (*child).next;
                } else {
                    xmlSchemaPContentErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                        0 as xmlSchemaBasicItemPtr,
                        (*child).parent,
                        child,
                        0 as *const i8,
                        b"((include | import | redefine | annotation)*, (((simpleType | complexType | group | attributeGroup) | element | attribute | notation), annotation*)*)\0"
                            as *const u8 as *const i8,
                    );
                    child = (*child).next;
                }
                while !child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"annotation\0" as *const u8 as *const i8
                            as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                {
                    annot = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
                    if ((*schema).annot).is_null() {
                        let fresh190 = &mut ((*schema).annot);
                        *fresh190 = annot;
                    } else {
                        xmlSchemaFreeAnnot(annot);
                    }
                    child = (*child).next;
                }
            }
        }
        17833631497414332109 => return -(1 as i32),
        _ => {}
    }
    let fresh191 = &mut ((*ctxt).ctxtType);
    *fresh191 = 0 as xmlSchemaTypePtr;
    if oldErrs != (*ctxt).nberrors {
        res = (*ctxt).err;
    }
    return res;
}
unsafe extern "C" fn xmlSchemaSchemaRelationCreate() -> xmlSchemaSchemaRelationPtr {
    let mut ret: xmlSchemaSchemaRelationPtr = 0 as *mut xmlSchemaSchemaRelation;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaSchemaRelation>() as u64)
        as xmlSchemaSchemaRelationPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating schema relation\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaSchemaRelationPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaSchemaRelation>() as u64,
    );
    return ret;
}
unsafe extern "C" fn xmlSchemaRedefListFree(mut redef: xmlSchemaRedefPtr) {
    let mut prev: xmlSchemaRedefPtr = 0 as *mut xmlSchemaRedef;
    while !redef.is_null() {
        prev = redef;
        redef = (*redef).next;
        xmlFree.expect("non-null function pointer")(prev as *mut libc::c_void);
    }
}
unsafe extern "C" fn xmlSchemaConstructionCtxtFree(
    mut con: xmlSchemaConstructionCtxtPtr,
) {
    if !((*con).buckets).is_null() {
        xmlSchemaItemListFree((*con).buckets);
    }
    if !((*con).pending).is_null() {
        xmlSchemaItemListFree((*con).pending);
    }
    if !((*con).substGroups).is_null() {
        xmlHashFree(
            (*con).substGroups,
            Some(
                xmlSchemaSubstGroupFreeEntry
                    as unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
            ),
        );
    }
    if !((*con).redefs).is_null() {
        xmlSchemaRedefListFree((*con).redefs);
    }
    if !((*con).dict).is_null() {
        xmlDictFree((*con).dict);
    }
    xmlFree.expect("non-null function pointer")(con as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaConstructionCtxtCreate(
    mut dict: xmlDictPtr,
) -> xmlSchemaConstructionCtxtPtr {
    let mut ret: xmlSchemaConstructionCtxtPtr = 0 as *mut xmlSchemaConstructionCtxt;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaConstructionCtxt>() as u64)
        as xmlSchemaConstructionCtxtPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating schema construction context\0" as *const u8
                as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaConstructionCtxtPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaConstructionCtxt>() as u64,
    );
    let fresh192 = &mut ((*ret).buckets);
    *fresh192 = xmlSchemaItemListCreate();
    if ((*ret).buckets).is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating list of schema buckets\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void);
        return 0 as xmlSchemaConstructionCtxtPtr;
    }
    let fresh193 = &mut ((*ret).pending);
    *fresh193 = xmlSchemaItemListCreate();
    if ((*ret).pending).is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating list of pending global components\0" as *const u8
                as *const i8,
            0 as xmlNodePtr,
        );
        xmlSchemaConstructionCtxtFree(ret);
        return 0 as xmlSchemaConstructionCtxtPtr;
    }
    let fresh194 = &mut ((*ret).dict);
    *fresh194 = dict;
    xmlDictReference(dict);
    return ret;
}
unsafe extern "C" fn xmlSchemaParserCtxtCreate() -> xmlSchemaParserCtxtPtr {
    let mut ret: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaParserCtxt>() as u64)
        as xmlSchemaParserCtxtPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating schema parser context\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaParserCtxtPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaParserCtxt>() as u64,
    );
    (*ret).type_0 = 1 as i32;
    let fresh195 = &mut ((*ret).attrProhibs);
    *fresh195 = xmlSchemaItemListCreate();
    if ((*ret).attrProhibs).is_null() {
        xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void);
        return 0 as xmlSchemaParserCtxtPtr;
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaNewParserCtxtUseDict(
    mut URL: *const i8,
    mut dict: xmlDictPtr,
) -> xmlSchemaParserCtxtPtr {
    let mut ret: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    ret = xmlSchemaParserCtxtCreate();
    if ret.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    let fresh196 = &mut ((*ret).dict);
    *fresh196 = dict;
    xmlDictReference(dict);
    if !URL.is_null() {
        let fresh197 = &mut ((*ret).URL);
        *fresh197 = xmlDictLookup(dict, URL as *const xmlChar, -(1 as i32));
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaCreatePCtxtOnVCtxt(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> i32 {
    if ((*vctxt).pctxt).is_null() {
        if !((*vctxt).schema).is_null() {
            let fresh198 = &mut ((*vctxt).pctxt);
            *fresh198 = xmlSchemaNewParserCtxtUseDict(
                b"*\0" as *const u8 as *const i8,
                (*(*vctxt).schema).dict,
            );
        } else {
            let fresh199 = &mut ((*vctxt).pctxt);
            *fresh199 = xmlSchemaNewParserCtxt(
                b"*\0" as *const u8 as *const i8,
            );
        }
        if ((*vctxt).pctxt).is_null() {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaCreatePCtxtOnVCtxt\0" as *const u8 as *const i8,
                b"failed to create a temp. parser context\0" as *const u8
                    as *const i8,
            );
            return -(1 as i32);
        }
        xmlSchemaSetParserErrors(
            (*vctxt).pctxt,
            (*vctxt).error,
            (*vctxt).warning,
            (*vctxt).errCtxt,
        );
        xmlSchemaSetParserStructuredErrors(
            (*vctxt).pctxt,
            (*vctxt).serror,
            (*vctxt).errCtxt,
        );
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaGetSchemaBucket(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schemaLocation: *const xmlChar,
) -> xmlSchemaBucketPtr {
    let mut cur: xmlSchemaBucketPtr = 0 as *mut xmlSchemaBucket;
    let mut list: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    list = (*(*pctxt).constructor).buckets;
    if (*list).nbItems == 0 as i32 {
        return 0 as xmlSchemaBucketPtr
    } else {
        let mut i: i32 = 0;
        i = 0 as i32;
        while i < (*list).nbItems {
            cur = *((*list).items).offset(i as isize) as xmlSchemaBucketPtr;
            if (*cur).schemaLocation == schemaLocation {
                return cur;
            }
            i += 1;
        }
    }
    return 0 as xmlSchemaBucketPtr;
}
unsafe extern "C" fn xmlSchemaGetChameleonSchemaBucket(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schemaLocation: *const xmlChar,
    mut targetNamespace: *const xmlChar,
) -> xmlSchemaBucketPtr {
    let mut cur: xmlSchemaBucketPtr = 0 as *mut xmlSchemaBucket;
    let mut list: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    list = (*(*pctxt).constructor).buckets;
    if (*list).nbItems == 0 as i32 {
        return 0 as xmlSchemaBucketPtr
    } else {
        let mut i: i32 = 0;
        i = 0 as i32;
        while i < (*list).nbItems {
            cur = *((*list).items).offset(i as isize) as xmlSchemaBucketPtr;
            if ((*cur).origTargetNamespace).is_null()
                && (*cur).schemaLocation == schemaLocation
                && (*cur).targetNamespace == targetNamespace
            {
                return cur;
            }
            i += 1;
        }
    }
    return 0 as xmlSchemaBucketPtr;
}
unsafe extern "C" fn xmlSchemaGetSchemaBucketByTNS(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut targetNamespace: *const xmlChar,
    mut imported: i32,
) -> xmlSchemaBucketPtr {
    let mut cur: xmlSchemaBucketPtr = 0 as *mut xmlSchemaBucket;
    let mut list: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    list = (*(*pctxt).constructor).buckets;
    if (*list).nbItems == 0 as i32 {
        return 0 as xmlSchemaBucketPtr
    } else {
        let mut i: i32 = 0;
        i = 0 as i32;
        while i < (*list).nbItems {
            cur = *((*list).items).offset(i as isize) as xmlSchemaBucketPtr;
            if !(((*cur).doc).is_null() && !((*cur).schemaLocation).is_null())
                && (*cur).origTargetNamespace == targetNamespace
                && (imported != 0 && (*cur).imported != 0
                    || imported == 0 && (*cur).imported == 0)
            {
                return cur;
            }
            i += 1;
        }
    }
    return 0 as xmlSchemaBucketPtr;
}
unsafe extern "C" fn xmlSchemaParseNewDocWithContext(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut bucket: xmlSchemaBucketPtr,
) -> i32 {
    let mut oldFlags: i32 = 0;
    let mut oldDoc: xmlDocPtr = 0 as *mut xmlDoc;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut ret: i32 = 0;
    let mut oldErrs: i32 = 0;
    let mut oldbucket: xmlSchemaBucketPtr = (*(*pctxt).constructor).bucket;
    oldFlags = (*schema).flags;
    oldDoc = (*schema).doc;
    if (*schema).flags != 0 as i32 {
        xmlSchemaClearSchemaDefaults(schema);
    }
    let fresh200 = &mut ((*schema).doc);
    *fresh200 = (*bucket).doc;
    let fresh201 = &mut ((*pctxt).schema);
    *fresh201 = schema;
    let fresh202 = &mut ((*pctxt).targetNamespace);
    *fresh202 = (*bucket).targetNamespace;
    let fresh203 = &mut ((*(*pctxt).constructor).bucket);
    *fresh203 = bucket;
    if !((*bucket).targetNamespace).is_null()
        && xmlStrEqual((*bucket).targetNamespace, xmlSchemaNs) != 0
    {
        (*pctxt).isS4S = 1 as i32;
    }
    let fresh204 = &mut ((*bucket).parsed);
    *fresh204 += 1;
    node = xmlDocGetRootElement((*bucket).doc as *const xmlDoc);
    ret = xmlSchemaParseSchemaElement(pctxt, schema, node);
    if !(ret != 0 as i32) {
        if !((*node).children).is_null() {
            oldErrs = (*pctxt).nberrors;
            ret = xmlSchemaParseSchemaTopLevel(pctxt, schema, (*node).children);
            if !(ret != 0 as i32) {
                if ret == 0 as i32 && oldErrs != (*pctxt).nberrors {
                    ret = (*pctxt).err;
                }
            }
        }
    }
    let fresh205 = &mut ((*(*pctxt).constructor).bucket);
    *fresh205 = oldbucket;
    let fresh206 = &mut ((*schema).doc);
    *fresh206 = oldDoc;
    (*schema).flags = oldFlags;
    return ret;
}
unsafe extern "C" fn xmlSchemaParseNewDoc(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut bucket: xmlSchemaBucketPtr,
) -> i32 {
    let mut newpctxt: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut res: i32 = 0 as i32;
    if bucket.is_null() {
        return 0 as i32;
    }
    if (*bucket).parsed != 0 {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaParseNewDoc\0" as *const u8 as *const i8,
            b"reparsing a schema doc\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    if ((*bucket).doc).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaParseNewDoc\0" as *const u8 as *const i8,
            b"parsing a schema doc, but there's no doc\0" as *const u8
                as *const i8,
        );
        return -(1 as i32);
    }
    if ((*pctxt).constructor).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaParseNewDoc\0" as *const u8 as *const i8,
            b"no constructor\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    newpctxt = xmlSchemaNewParserCtxtUseDict(
        (*bucket).schemaLocation as *const i8,
        (*pctxt).dict,
    );
    if newpctxt.is_null() {
        return -(1 as i32);
    }
    let fresh207 = &mut ((*newpctxt).constructor);
    *fresh207 = (*pctxt).constructor;
    let fresh208 = &mut ((*newpctxt).schema);
    *fresh208 = schema;
    xmlSchemaSetParserErrors(
        newpctxt,
        (*pctxt).error,
        (*pctxt).warning,
        (*pctxt).errCtxt,
    );
    xmlSchemaSetParserStructuredErrors(newpctxt, (*pctxt).serror, (*pctxt).errCtxt);
    (*newpctxt).counter = (*pctxt).counter;
    res = xmlSchemaParseNewDocWithContext(newpctxt, schema, bucket);
    if res != 0 as i32 {
        (*pctxt).err = res;
    }
    (*pctxt).nberrors += (*newpctxt).nberrors;
    (*pctxt).counter = (*newpctxt).counter;
    let fresh209 = &mut ((*newpctxt).constructor);
    *fresh209 = 0 as xmlSchemaConstructionCtxtPtr;
    xmlSchemaFreeParserCtxt(newpctxt);
    return res;
}
unsafe extern "C" fn xmlSchemaSchemaRelationAddChild(
    mut bucket: xmlSchemaBucketPtr,
    mut rel: xmlSchemaSchemaRelationPtr,
) {
    let mut cur: xmlSchemaSchemaRelationPtr = (*bucket).relations;
    if cur.is_null() {
        let fresh210 = &mut ((*bucket).relations);
        *fresh210 = rel;
        return;
    }
    while !((*cur).next).is_null() {
        cur = (*cur).next;
    }
    let fresh211 = &mut ((*cur).next);
    *fresh211 = rel;
}
unsafe extern "C" fn xmlSchemaBuildAbsoluteURI(
    mut dict: xmlDictPtr,
    mut location: *const xmlChar,
    mut ctxtNode: xmlNodePtr,
) -> *const xmlChar {
    if !location.is_null() {
        if ctxtNode.is_null() {
            return location
        } else {
            let mut base: *mut xmlChar = 0 as *mut xmlChar;
            let mut URI: *mut xmlChar = 0 as *mut xmlChar;
            let mut ret: *const xmlChar = 0 as *const xmlChar;
            base = xmlNodeGetBase((*ctxtNode).doc, ctxtNode as *const xmlNode);
            if base.is_null() {
                URI = xmlBuildURI(location, (*(*ctxtNode).doc).URL);
            } else {
                URI = xmlBuildURI(location, base);
                xmlFree.expect("non-null function pointer")(base as *mut libc::c_void);
            }
            if !URI.is_null() {
                ret = xmlDictLookup(dict, URI, -(1 as i32));
                xmlFree.expect("non-null function pointer")(URI as *mut libc::c_void);
                return ret;
            }
        }
    }
    return 0 as *const xmlChar;
}
unsafe extern "C" fn xmlSchemaAddSchemaDoc(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: i32,
    mut schemaLocation: *const xmlChar,
    mut schemaDoc: xmlDocPtr,
    mut schemaBuffer: *const i8,
    mut schemaBufferLen: i32,
    mut invokingNode: xmlNodePtr,
    mut sourceTargetNamespace: *const xmlChar,
    mut importNamespace: *const xmlChar,
    mut bucket: *mut xmlSchemaBucketPtr,
) -> i32 {
    let mut current_block: u64;
    let mut targetNamespace: *const xmlChar = 0 as *const xmlChar;
    let mut relation: xmlSchemaSchemaRelationPtr = 0 as xmlSchemaSchemaRelationPtr;
    let mut doc: xmlDocPtr = 0 as xmlDocPtr;
    let mut res: i32 = 0 as i32;
    let mut err: i32 = 0 as i32;
    let mut located: i32 = 0 as i32;
    let mut preserveDoc: i32 = 0 as i32;
    let mut bkt: xmlSchemaBucketPtr = 0 as xmlSchemaBucketPtr;
    if !bucket.is_null() {
        *bucket = 0 as xmlSchemaBucketPtr;
    }
    match type_0 {
        1 | 0 => {
            err = XML_SCHEMAP_SRC_IMPORT as i32;
        }
        2 => {
            err = XML_SCHEMAP_SRC_INCLUDE as i32;
        }
        3 => {
            err = XML_SCHEMAP_SRC_REDEFINE as i32;
        }
        _ => {}
    }
    if type_0 == 0 as i32
        || !(!((*(*pctxt).constructor).buckets).is_null()
            && (*(*(*pctxt).constructor).buckets).nbItems > 0 as i32)
    {
        current_block = 13370431095695323903;
    } else {
        if !schemaLocation.is_null() {
            bkt = xmlSchemaGetSchemaBucket(pctxt, schemaLocation);
            if !bkt.is_null() && (*(*pctxt).constructor).bucket == bkt {
                xmlSchemaCustomErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    err as xmlParserErrors,
                    invokingNode,
                    0 as xmlSchemaBasicItemPtr,
                    b"The schema must not import/include/redefine itself\0" as *const u8
                        as *const i8,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
                current_block = 16820852522665970781;
            } else {
                current_block = 17833034027772472439;
            }
        } else {
            current_block = 17833034027772472439;
        }
        match current_block {
            16820852522665970781 => {}
            _ => {
                relation = xmlSchemaSchemaRelationCreate();
                if relation.is_null() {
                    return -(1 as i32);
                }
                xmlSchemaSchemaRelationAddChild(
                    (*(*pctxt).constructor).bucket,
                    relation,
                );
                (*relation).type_0 = type_0;
                if type_0 == 0 as i32 || type_0 == 1 as i32 {
                    let fresh212 = &mut ((*relation).importNamespace);
                    *fresh212 = importNamespace;
                    if schemaLocation.is_null() {
                        current_block = 16820852522665970781;
                    } else {
                        targetNamespace = importNamespace;
                        current_block = 7056779235015430508;
                    }
                } else {
                    current_block = 7056779235015430508;
                }
                match current_block {
                    16820852522665970781 => {}
                    _ => {
                        if !bkt.is_null() {
                            if (type_0 == 0 as i32 || type_0 == 1 as i32)
                                && (*bkt).imported == 0
                            {
                                if schemaLocation.is_null() {
                                    schemaLocation = b"in_memory_buffer\0" as *const u8
                                        as *const i8 as *mut xmlChar;
                                }
                                if xmlStrEqual(schemaLocation, (*bkt).schemaLocation) == 0 {
                                    xmlSchemaCustomErr(
                                        pctxt as xmlSchemaAbstractCtxtPtr,
                                        err as xmlParserErrors,
                                        invokingNode,
                                        0 as xmlSchemaBasicItemPtr,
                                        b"The schema document '%s' cannot be imported, since it was already included or redefined\0"
                                            as *const u8 as *const i8,
                                        schemaLocation,
                                        0 as *const xmlChar,
                                    );
                                    current_block = 16820852522665970781;
                                } else {
                                    current_block = 6450597802325118133;
                                }
                            } else if !(type_0 == 0 as i32
                                    || type_0 == 1 as i32) && (*bkt).imported != 0
                                {
                                if schemaLocation.is_null() {
                                    schemaLocation = b"in_memory_buffer\0" as *const u8
                                        as *const i8 as *mut xmlChar;
                                }
                                if xmlStrEqual(schemaLocation, (*bkt).schemaLocation) == 0 {
                                    xmlSchemaCustomErr(
                                        pctxt as xmlSchemaAbstractCtxtPtr,
                                        err as xmlParserErrors,
                                        invokingNode,
                                        0 as xmlSchemaBasicItemPtr,
                                        b"The schema document '%s' cannot be included or redefined, since it was already imported\0"
                                            as *const u8 as *const i8,
                                        schemaLocation,
                                        0 as *const xmlChar,
                                    );
                                    current_block = 16820852522665970781;
                                } else {
                                    current_block = 6450597802325118133;
                                }
                            } else {
                                current_block = 6450597802325118133;
                            }
                        } else {
                            current_block = 6450597802325118133;
                        }
                        match current_block {
                            16820852522665970781 => {}
                            _ => {
                                if type_0 == 0 as i32 || type_0 == 1 as i32
                                {
                                    if !bkt.is_null() {
                                        let fresh213 = &mut ((*relation).bucket);
                                        *fresh213 = bkt;
                                        current_block = 16820852522665970781;
                                    } else {
                                        bkt = xmlSchemaGetSchemaBucketByTNS(
                                            pctxt,
                                            importNamespace,
                                            1 as i32,
                                        );
                                        if !bkt.is_null() {
                                            let fresh214 = &mut ((*relation).bucket);
                                            *fresh214 = bkt;
                                            if ((*bkt).schemaLocation).is_null() {
                                                let fresh215 = &mut ((*bkt).schemaLocation);
                                                *fresh215 = schemaLocation;
                                                current_block = 8869332144787829186;
                                            } else {
                                                if xmlStrEqual(schemaLocation, (*bkt).schemaLocation) == 0 {
                                                    if schemaLocation.is_null() {
                                                        schemaLocation = b"in_memory_buffer\0" as *const u8
                                                            as *const i8 as *mut xmlChar;
                                                    }
                                                    xmlSchemaCustomWarning(
                                                        pctxt as xmlSchemaAbstractCtxtPtr,
                                                        XML_SCHEMAP_WARN_SKIP_SCHEMA,
                                                        invokingNode,
                                                        0 as xmlSchemaTypePtr,
                                                        b"Skipping import of schema located at '%s' for the namespace '%s', since this namespace was already imported with the schema located at '%s'\0"
                                                            as *const u8 as *const i8,
                                                        schemaLocation,
                                                        importNamespace,
                                                        (*bkt).schemaLocation,
                                                    );
                                                }
                                                current_block = 16820852522665970781;
                                            }
                                        } else {
                                            current_block = 8869332144787829186;
                                        }
                                    }
                                } else if !bkt.is_null() {
                                    if ((*bkt).origTargetNamespace).is_null()
                                        && (*bkt).targetNamespace != sourceTargetNamespace
                                    {
                                        let mut chamel: xmlSchemaBucketPtr = 0
                                            as *mut xmlSchemaBucket;
                                        chamel = xmlSchemaGetChameleonSchemaBucket(
                                            pctxt,
                                            schemaLocation,
                                            sourceTargetNamespace,
                                        );
                                        if !chamel.is_null() {
                                            let fresh216 = &mut ((*relation).bucket);
                                            *fresh216 = chamel;
                                            current_block = 16820852522665970781;
                                        } else {
                                            bkt = 0 as xmlSchemaBucketPtr;
                                            current_block = 8869332144787829186;
                                        }
                                    } else {
                                        let fresh217 = &mut ((*relation).bucket);
                                        *fresh217 = bkt;
                                        current_block = 16820852522665970781;
                                    }
                                } else {
                                    current_block = 8869332144787829186;
                                }
                                match current_block {
                                    16820852522665970781 => {}
                                    _ => {
                                        if !bkt.is_null() && !((*bkt).doc).is_null() {
                                            xmlSchemaInternalErr(
                                                pctxt as xmlSchemaAbstractCtxtPtr,
                                                b"xmlSchemaAddSchemaDoc\0" as *const u8
                                                    as *const i8,
                                                b"trying to load a schema doc, but a doc is already assigned to the schema bucket\0"
                                                    as *const u8 as *const i8,
                                            );
                                            current_block = 1545328529343146367;
                                        } else {
                                            current_block = 13370431095695323903;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    match current_block {
        13370431095695323903 => {
            if !schemaDoc.is_null() {
                doc = schemaDoc;
                preserveDoc = 1 as i32;
                if !((*schemaDoc).URL).is_null() {
                    schemaLocation = xmlDictLookup(
                        (*pctxt).dict,
                        (*schemaDoc).URL,
                        -(1 as i32),
                    );
                } else {
                    schemaLocation = b"in_memory_buffer\0" as *const u8
                        as *const i8 as *mut xmlChar;
                }
                current_block = 14851765859726653900;
            } else if !schemaLocation.is_null() || !schemaBuffer.is_null() {
                let mut parserCtxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
                parserCtxt = xmlNewParserCtxt();
                if parserCtxt.is_null() {
                    xmlSchemaPErrMemory(
                        0 as xmlSchemaParserCtxtPtr,
                        b"xmlSchemaGetDoc, allocating a parser context\0" as *const u8
                            as *const i8,
                        0 as xmlNodePtr,
                    );
                    current_block = 1545328529343146367;
                } else {
                    if !((*pctxt).dict).is_null() && !((*parserCtxt).dict).is_null() {
                        xmlDictFree((*parserCtxt).dict);
                        let fresh218 = &mut ((*parserCtxt).dict);
                        *fresh218 = (*pctxt).dict;
                        xmlDictReference((*parserCtxt).dict);
                    }
                    if !schemaLocation.is_null() {
                        doc = xmlCtxtReadFile(
                            parserCtxt,
                            schemaLocation as *const i8,
                            0 as *const i8,
                            XML_PARSE_NOENT as i32,
                        );
                    } else if !schemaBuffer.is_null() {
                        doc = xmlCtxtReadMemory(
                            parserCtxt,
                            schemaBuffer,
                            schemaBufferLen,
                            0 as *const i8,
                            0 as *const i8,
                            XML_PARSE_NOENT as i32,
                        );
                        schemaLocation = b"in_memory_buffer\0" as *const u8
                            as *const i8 as *mut xmlChar;
                        if !doc.is_null() {
                            let fresh219 = &mut ((*doc).URL);
                            *fresh219 = xmlStrdup(schemaLocation);
                        }
                    }
                    if doc.is_null() {
                        let mut lerr: xmlErrorPtr = 0 as *mut xmlError;
                        lerr = xmlGetLastError();
                        if lerr.is_null() || (*lerr).domain != XML_FROM_IO as i32
                        {
                            located = 1 as i32;
                            res = XML_SCHEMAP_SRC_IMPORT_2_1 as i32;
                            xmlSchemaCustomErr(
                                pctxt as xmlSchemaAbstractCtxtPtr,
                                res as xmlParserErrors,
                                invokingNode,
                                0 as xmlSchemaBasicItemPtr,
                                b"Failed to parse the XML resource '%s'\0" as *const u8
                                    as *const i8,
                                schemaLocation,
                                0 as *const xmlChar,
                            );
                        }
                    }
                    xmlFreeParserCtxt(parserCtxt);
                    if doc.is_null() && located != 0 {
                        current_block = 5528773336718582786;
                    } else {
                        current_block = 14851765859726653900;
                    }
                }
            } else {
                xmlSchemaPErr(
                    pctxt,
                    0 as xmlNodePtr,
                    XML_SCHEMAP_NOTHING_TO_PARSE as i32,
                    b"No information for parsing was provided with the given schema parser context.\n\0"
                        as *const u8 as *const i8,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
                current_block = 1545328529343146367;
            }
            match current_block {
                1545328529343146367 => {}
                _ => {
                    match current_block {
                        14851765859726653900 => {
                            if !doc.is_null() {
                                let mut docElem: xmlNodePtr = 0 as xmlNodePtr;
                                located = 1 as i32;
                                docElem = xmlDocGetRootElement(doc as *const xmlDoc);
                                if docElem.is_null() {
                                    xmlSchemaCustomErr(
                                        pctxt as xmlSchemaAbstractCtxtPtr,
                                        XML_SCHEMAP_NOROOT,
                                        invokingNode,
                                        0 as xmlSchemaBasicItemPtr,
                                        b"The document '%s' has no document element\0" as *const u8
                                            as *const i8,
                                        schemaLocation,
                                        0 as *const xmlChar,
                                    );
                                    current_block = 5528773336718582786;
                                } else {
                                    xmlSchemaCleanupDoc(pctxt, docElem);
                                    if !(!docElem.is_null() && !((*docElem).ns).is_null()
                                        && xmlStrEqual(
                                            (*docElem).name,
                                            b"schema\0" as *const u8 as *const i8
                                                as *const xmlChar,
                                        ) != 0
                                        && xmlStrEqual((*(*docElem).ns).href, xmlSchemaNs) != 0)
                                    {
                                        xmlSchemaCustomErr(
                                            pctxt as xmlSchemaAbstractCtxtPtr,
                                            XML_SCHEMAP_NOT_SCHEMA,
                                            invokingNode,
                                            0 as xmlSchemaBasicItemPtr,
                                            b"The XML document '%s' is not a schema document\0"
                                                as *const u8 as *const i8,
                                            schemaLocation,
                                            0 as *const xmlChar,
                                        );
                                        current_block = 5528773336718582786;
                                    } else {
                                        targetNamespace = xmlSchemaGetProp(
                                            pctxt,
                                            docElem,
                                            b"targetNamespace\0" as *const u8 as *const i8,
                                        );
                                        current_block = 2956972668325154207;
                                    }
                                }
                            } else {
                                current_block = 2956972668325154207;
                            }
                            match current_block {
                                5528773336718582786 => {}
                                _ => {
                                    if bkt.is_null() && located != 0 {
                                        bkt = xmlSchemaBucketCreate(pctxt, type_0, targetNamespace);
                                        if bkt.is_null() {
                                            current_block = 1545328529343146367;
                                        } else {
                                            current_block = 13505557363059842426;
                                        }
                                    } else {
                                        current_block = 13505557363059842426;
                                    }
                                    match current_block {
                                        1545328529343146367 => {}
                                        _ => {
                                            if !bkt.is_null() {
                                                let fresh220 = &mut ((*bkt).schemaLocation);
                                                *fresh220 = schemaLocation;
                                                (*bkt).located = located;
                                                if !doc.is_null() {
                                                    let fresh221 = &mut ((*bkt).doc);
                                                    *fresh221 = doc;
                                                    let fresh222 = &mut ((*bkt).targetNamespace);
                                                    *fresh222 = targetNamespace;
                                                    let fresh223 = &mut ((*bkt).origTargetNamespace);
                                                    *fresh223 = targetNamespace;
                                                    if preserveDoc != 0 {
                                                        (*bkt).preserveDoc = 1 as i32;
                                                    }
                                                }
                                                if type_0 == 0 as i32 || type_0 == 1 as i32
                                                {
                                                    let fresh224 = &mut ((*bkt).imported);
                                                    *fresh224 += 1;
                                                }
                                                if !relation.is_null() {
                                                    let fresh225 = &mut ((*relation).bucket);
                                                    *fresh225 = bkt;
                                                }
                                            }
                                            current_block = 16820852522665970781;
                                        }
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                    match current_block {
                        16820852522665970781 => {}
                        1545328529343146367 => {}
                        _ => {
                            if !doc.is_null() && preserveDoc == 0 {
                                xmlFreeDoc(doc);
                                if !bkt.is_null() {
                                    let fresh226 = &mut ((*bkt).doc);
                                    *fresh226 = 0 as xmlDocPtr;
                                }
                            }
                            return (*pctxt).err;
                        }
                    }
                }
            }
        }
        _ => {}
    }
    match current_block {
        1545328529343146367 => {
            if !doc.is_null() && preserveDoc == 0 {
                xmlFreeDoc(doc);
                if !bkt.is_null() {
                    let fresh227 = &mut ((*bkt).doc);
                    *fresh227 = 0 as xmlDocPtr;
                }
            }
            return -(1 as i32);
        }
        _ => {
            if !bucket.is_null() {
                *bucket = bkt;
            }
            return 0 as i32;
        }
    };
}
unsafe extern "C" fn xmlSchemaParseImport(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> i32 {
    let mut child: xmlNodePtr = 0 as *mut xmlNode;
    let mut namespaceName: *const xmlChar = 0 as *const xmlChar;
    let mut schemaLocation: *const xmlChar = 0 as *const xmlChar;
    let mut thisTargetNamespace: *const xmlChar = 0 as *const xmlChar;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut ret: i32 = 0 as i32;
    let mut bucket: xmlSchemaBucketPtr = 0 as xmlSchemaBucketPtr;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return -(1 as i32);
    }
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"namespace\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"schemaLocation\0" as *const u8 as *const i8
                        as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    if xmlSchemaPValAttr(
        pctxt,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"namespace\0" as *const u8 as *const i8,
        xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
        &mut namespaceName,
    ) != 0 as i32
    {
        xmlSchemaPSimpleTypeErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            node,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
            0 as *const i8,
            namespaceName,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*pctxt).err;
    }
    if xmlSchemaPValAttr(
        pctxt,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"schemaLocation\0" as *const u8 as *const i8,
        xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
        &mut schemaLocation,
    ) != 0 as i32
    {
        xmlSchemaPSimpleTypeErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            node,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
            0 as *const i8,
            schemaLocation,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*pctxt).err;
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            pctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?)\0" as *const u8 as *const i8,
        );
    }
    thisTargetNamespace = (*(*(*pctxt).constructor).bucket).origTargetNamespace;
    if !namespaceName.is_null() {
        if xmlStrEqual(thisTargetNamespace, namespaceName) != 0 {
            xmlSchemaPCustomErr(
                pctxt,
                XML_SCHEMAP_SRC_IMPORT_1_1,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"The value of the attribute 'namespace' must not match the target namespace '%s' of the importing schema\0"
                    as *const u8 as *const i8,
                thisTargetNamespace,
            );
            return (*pctxt).err;
        }
    } else if thisTargetNamespace.is_null() {
        xmlSchemaPCustomErr(
            pctxt,
            XML_SCHEMAP_SRC_IMPORT_1_2,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"The attribute 'namespace' must be existent if the importing schema has no target namespace\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
        );
        return (*pctxt).err;
    }
    if !schemaLocation.is_null() {
        schemaLocation = xmlSchemaBuildAbsoluteURI((*pctxt).dict, schemaLocation, node);
    }
    ret = xmlSchemaAddSchemaDoc(
        pctxt,
        1 as i32,
        schemaLocation,
        0 as xmlDocPtr,
        0 as *const i8,
        0 as i32,
        node,
        thisTargetNamespace,
        namespaceName,
        &mut bucket,
    );
    if ret != 0 as i32 {
        return ret;
    }
    if bucket.is_null() && !schemaLocation.is_null() {
        xmlSchemaCustomWarning(
            pctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_WARN_UNLOCATED_SCHEMA,
            node,
            0 as xmlSchemaTypePtr,
            b"Failed to locate a schema at location '%s'. Skipping the import\0"
                as *const u8 as *const i8,
            schemaLocation,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    if !bucket.is_null()
        && (!((*bucket).doc).is_null() && (*bucket).parsed == 0 as i32)
    {
        ret = xmlSchemaParseNewDoc(pctxt, schema, bucket);
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaParseIncludeOrRedefineAttrs(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut schemaLocation: *mut *mut xmlChar,
    mut type_0: i32,
) -> i32 {
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if pctxt.is_null() || schema.is_null() || node.is_null() || schemaLocation.is_null()
    {
        return -(1 as i32);
    }
    *schemaLocation = 0 as *mut xmlChar;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"schemaLocation\0" as *const u8 as *const i8
                        as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        pctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    attr = xmlSchemaGetPropNode(
        node,
        b"schemaLocation\0" as *const u8 as *const i8,
    );
    if !attr.is_null() {
        let mut base: *mut xmlChar = 0 as *mut xmlChar;
        let mut uri: *mut xmlChar = 0 as *mut xmlChar;
        if !(xmlSchemaPValAttrNode(
            pctxt,
            0 as xmlSchemaBasicItemPtr,
            attr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
            schemaLocation as *mut *const xmlChar,
        ) != 0 as i32)
        {
            base = xmlNodeGetBase((*node).doc, node as *const xmlNode);
            if base.is_null() {
                uri = xmlBuildURI(*schemaLocation, (*(*node).doc).URL);
            } else {
                uri = xmlBuildURI(*schemaLocation, base);
                xmlFree.expect("non-null function pointer")(base as *mut libc::c_void);
            }
            if uri.is_null() {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaParseIncludeOrRedefine\0" as *const u8
                        as *const i8,
                    b"could not build an URI from the schemaLocation\0" as *const u8
                        as *const i8,
                );
                return -(1 as i32);
            } else {
                *schemaLocation = xmlDictLookup((*pctxt).dict, uri, -(1 as i32))
                    as *mut xmlChar;
                xmlFree.expect("non-null function pointer")(uri as *mut libc::c_void);
                if xmlStrEqual(*schemaLocation, (*pctxt).URL) != 0 {
                    if type_0 == 3 as i32 {
                        xmlSchemaPCustomErr(
                            pctxt,
                            XML_SCHEMAP_SRC_REDEFINE,
                            0 as xmlSchemaBasicItemPtr,
                            node,
                            b"The schema document '%s' cannot redefine itself.\0"
                                as *const u8 as *const i8,
                            *schemaLocation,
                        );
                    } else {
                        xmlSchemaPCustomErr(
                            pctxt,
                            XML_SCHEMAP_SRC_INCLUDE,
                            0 as xmlSchemaBasicItemPtr,
                            node,
                            b"The schema document '%s' cannot include itself.\0"
                                as *const u8 as *const i8,
                            *schemaLocation,
                        );
                    }
                } else {
                    return 0 as i32
                }
            }
        }
    } else {
        xmlSchemaPMissingAttrErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"schemaLocation\0" as *const u8 as *const i8,
            0 as *const i8,
        );
    }
    return (*pctxt).err;
}
unsafe extern "C" fn xmlSchemaParseIncludeOrRedefine(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut type_0: i32,
) -> i32 {
    let mut current_block: u64;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut schemaLocation: *const xmlChar = 0 as *const xmlChar;
    let mut res: i32 = 0 as i32;
    let mut isChameleon: i32 = 0 as i32;
    let mut wasChameleon: i32 = 0 as i32;
    let mut bucket: xmlSchemaBucketPtr = 0 as xmlSchemaBucketPtr;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return -(1 as i32);
    }
    res = xmlSchemaParseIncludeOrRedefineAttrs(
        pctxt,
        schema,
        node,
        &mut schemaLocation as *mut *const xmlChar as *mut *mut xmlChar,
        type_0,
    );
    if res != 0 as i32 {
        return res;
    }
    res = xmlSchemaAddSchemaDoc(
        pctxt,
        type_0,
        schemaLocation,
        0 as xmlDocPtr,
        0 as *const i8,
        0 as i32,
        node,
        (*pctxt).targetNamespace,
        0 as *const xmlChar,
        &mut bucket,
    );
    if res != 0 as i32 {
        return res;
    }
    if bucket.is_null() || ((*bucket).doc).is_null() {
        if type_0 == 2 as i32 {
            res = XML_SCHEMAP_SRC_INCLUDE as i32;
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                res as xmlParserErrors,
                node,
                0 as xmlSchemaBasicItemPtr,
                b"Failed to load the document '%s' for inclusion\0" as *const u8
                    as *const i8,
                schemaLocation,
                0 as *const xmlChar,
            );
        } else {
            res = XML_SCHEMAP_SRC_REDEFINE as i32;
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                res as xmlParserErrors,
                node,
                0 as xmlSchemaBasicItemPtr,
                b"Failed to load the document '%s' for redefinition\0" as *const u8
                    as *const i8,
                schemaLocation,
                0 as *const xmlChar,
            );
        }
    } else {
        if !((*bucket).origTargetNamespace).is_null() {
            if ((*pctxt).targetNamespace).is_null() {
                xmlSchemaCustomErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    XML_SCHEMAP_SRC_INCLUDE,
                    node,
                    0 as xmlSchemaBasicItemPtr,
                    b"The target namespace of the included/redefined schema '%s' has to be absent, since the including/redefining schema has no target namespace\0"
                        as *const u8 as *const i8,
                    schemaLocation,
                    0 as *const xmlChar,
                );
                current_block = 2122687029741063289;
            } else if xmlStrEqual(
                    (*bucket).origTargetNamespace,
                    (*pctxt).targetNamespace,
                ) == 0
                {
                xmlSchemaPCustomErrExt(
                    pctxt,
                    XML_SCHEMAP_SRC_INCLUDE,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    b"The target namespace '%s' of the included/redefined schema '%s' differs from '%s' of the including/redefining schema\0"
                        as *const u8 as *const i8,
                    (*bucket).origTargetNamespace,
                    schemaLocation,
                    (*pctxt).targetNamespace,
                );
                current_block = 2122687029741063289;
            } else {
                current_block = 8693738493027456495;
            }
        } else if !((*pctxt).targetNamespace).is_null() {
            isChameleon = 1 as i32;
            if (*bucket).parsed != 0 && !((*bucket).origTargetNamespace).is_null() {
                xmlSchemaCustomErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    XML_SCHEMAP_SRC_INCLUDE,
                    node,
                    0 as xmlSchemaBasicItemPtr,
                    b"The target namespace of the included/redefined schema '%s' has to be absent or the same as the including/redefining schema's target namespace\0"
                        as *const u8 as *const i8,
                    schemaLocation,
                    0 as *const xmlChar,
                );
                current_block = 2122687029741063289;
            } else {
                let fresh228 = &mut ((*bucket).targetNamespace);
                *fresh228 = (*pctxt).targetNamespace;
                current_block = 8693738493027456495;
            }
        } else {
            current_block = 8693738493027456495;
        }
        match current_block {
            8693738493027456495 => {}
            _ => return (*pctxt).err,
        }
    }
    if !bucket.is_null() && (*bucket).parsed == 0 && !((*bucket).doc).is_null() {
        if isChameleon != 0 {
            if (*schema).flags & (1 as i32) << 9 as i32
                == 0 as i32
            {
                (*schema).flags |= (1 as i32) << 9 as i32;
            } else {
                wasChameleon = 1 as i32;
            }
        }
        xmlSchemaParseNewDoc(pctxt, schema, bucket);
        if isChameleon != 0 && wasChameleon == 0 {
            (*schema).flags ^= (1 as i32) << 9 as i32;
        }
    }
    child = (*node).children;
    if type_0 == 3 as i32 {
        let fresh229 = &mut ((*pctxt).redefined);
        *fresh229 = bucket;
        (*pctxt).isRedefine = 1 as i32;
        while !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"complexType\0" as *const u8 as *const i8
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"group\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"attributeGroup\0" as *const u8 as *const i8
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            if !(!child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0)
            {
                if !child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"simpleType\0" as *const u8 as *const i8
                            as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                {
                    xmlSchemaParseSimpleType(pctxt, schema, child, 1 as i32);
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"complexType\0" as *const u8 as *const i8
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseComplexType(pctxt, schema, child, 1 as i32);
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"group\0" as *const u8 as *const i8
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseModelGroupDefinition(pctxt, schema, child);
                } else if !child.is_null() && !((*child).ns).is_null()
                        && xmlStrEqual(
                            (*child).name,
                            b"attributeGroup\0" as *const u8 as *const i8
                                as *const xmlChar,
                        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                    {
                    xmlSchemaParseAttributeGroupDefinition(pctxt, schema, child);
                }
            }
            child = (*child).next;
        }
        let fresh230 = &mut ((*pctxt).redefined);
        *fresh230 = 0 as xmlSchemaBucketPtr;
        (*pctxt).isRedefine = 0 as i32;
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        child = (*child).next;
    }
    if !child.is_null() {
        res = XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED as i32;
        if type_0 == 3 as i32 {
            xmlSchemaPContentErr(
                pctxt,
                res as xmlParserErrors,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"(annotation | (simpleType | complexType | group | attributeGroup))*\0"
                    as *const u8 as *const i8,
            );
        } else {
            xmlSchemaPContentErr(
                pctxt,
                res as xmlParserErrors,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"(annotation?)\0" as *const u8 as *const i8,
            );
        }
    }
    return res;
}
unsafe extern "C" fn xmlSchemaParseRedefine(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> i32 {
    let mut res: i32 = 0;
    res = xmlSchemaParseIncludeOrRedefine(pctxt, schema, node, 3 as i32);
    if res != 0 as i32 {
        return res;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaParseInclude(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
) -> i32 {
    let mut res: i32 = 0;
    res = xmlSchemaParseIncludeOrRedefine(pctxt, schema, node, 2 as i32);
    if res != 0 as i32 {
        return res;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaParseModelGroup(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut type_0: xmlSchemaTypeType,
    mut withParticle: i32,
) -> xmlSchemaTreeItemPtr {
    let mut item: xmlSchemaModelGroupPtr = 0 as *mut xmlSchemaModelGroup;
    let mut particle: xmlSchemaParticlePtr = 0 as xmlSchemaParticlePtr;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut min: i32 = 1 as i32;
    let mut max: i32 = 1 as i32;
    let mut isElemRef: i32 = 0;
    let mut hasRefs: i32 = 0 as i32;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTreeItemPtr;
    }
    item = xmlSchemaAddModelGroup(ctxt, schema, type_0, node);
    if item.is_null() {
        return 0 as xmlSchemaTreeItemPtr;
    }
    if withParticle != 0 {
        if type_0 as u32 == XML_SCHEMA_TYPE_ALL as i32 as u32 {
            min = xmlGetMinOccurs(
                ctxt,
                node,
                0 as i32,
                1 as i32,
                1 as i32,
                b"(0 | 1)\0" as *const u8 as *const i8,
            );
            max = xmlGetMaxOccurs(
                ctxt,
                node,
                1 as i32,
                1 as i32,
                1 as i32,
                b"1\0" as *const u8 as *const i8,
            );
        } else {
            min = xmlGetMinOccurs(
                ctxt,
                node,
                0 as i32,
                -(1 as i32),
                1 as i32,
                b"xs:nonNegativeInteger\0" as *const u8 as *const i8,
            );
            max = xmlGetMaxOccurs(
                ctxt,
                node,
                0 as i32,
                (1 as i32) << 30 as i32,
                1 as i32,
                b"(xs:nonNegativeInteger | unbounded)\0" as *const u8
                    as *const i8,
            );
        }
        xmlSchemaPCheckParticleCorrect_2(
            ctxt,
            0 as xmlSchemaParticlePtr,
            node,
            min,
            max,
        );
        particle = xmlSchemaAddParticle(ctxt, node, min, max);
        if particle.is_null() {
            return 0 as xmlSchemaTreeItemPtr;
        }
        let fresh231 = &mut ((*particle).children);
        *fresh231 = item as xmlSchemaTreeItemPtr;
        attr = (*node).properties;
        while !attr.is_null() {
            if ((*attr).ns).is_null() {
                if xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                    && xmlStrEqual(
                        (*attr).name,
                        b"maxOccurs\0" as *const u8 as *const i8
                            as *mut xmlChar,
                    ) == 0
                    && xmlStrEqual(
                        (*attr).name,
                        b"minOccurs\0" as *const u8 as *const i8
                            as *mut xmlChar,
                    ) == 0
                {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        0 as xmlSchemaBasicItemPtr,
                        attr,
                    );
                }
            } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
            attr = (*attr).next;
        }
    } else {
        attr = (*node).properties;
        while !attr.is_null() {
            if ((*attr).ns).is_null() {
                if xmlStrEqual(
                    (*attr).name,
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        0 as xmlSchemaBasicItemPtr,
                        attr,
                    );
                }
            } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
            attr = (*attr).next;
        }
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let fresh232 = &mut ((*item).annot);
        *fresh232 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = (*child).next;
    }
    if type_0 as u32 == XML_SCHEMA_TYPE_ALL as i32 as u32 {
        let mut part: xmlSchemaParticlePtr = 0 as *mut xmlSchemaParticle;
        let mut last: xmlSchemaParticlePtr = 0 as xmlSchemaParticlePtr;
        while !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"element\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            part = xmlSchemaParseElement(
                ctxt,
                schema,
                child,
                &mut isElemRef,
                0 as i32,
            ) as xmlSchemaParticlePtr;
            if !part.is_null() {
                if isElemRef != 0 {
                    hasRefs += 1;
                }
                if (*part).minOccurs > 1 as i32 {
                    xmlSchemaPCustomErr(
                        ctxt,
                        XML_SCHEMAP_COS_ALL_LIMITED,
                        0 as xmlSchemaBasicItemPtr,
                        child,
                        b"Invalid value for minOccurs (must be 0 or 1)\0" as *const u8
                            as *const i8,
                        0 as *const xmlChar,
                    );
                    (*part).minOccurs = 1 as i32;
                }
                if (*part).maxOccurs > 1 as i32 {
                    xmlSchemaPCustomErr(
                        ctxt,
                        XML_SCHEMAP_COS_ALL_LIMITED,
                        0 as xmlSchemaBasicItemPtr,
                        child,
                        b"Invalid value for maxOccurs (must be 0 or 1)\0" as *const u8
                            as *const i8,
                        0 as *const xmlChar,
                    );
                    (*part).maxOccurs = 1 as i32;
                }
                if last.is_null() {
                    let fresh233 = &mut ((*item).children);
                    *fresh233 = part as xmlSchemaTreeItemPtr;
                } else {
                    let fresh234 = &mut ((*last).next);
                    *fresh234 = part as xmlSchemaTreeItemPtr;
                }
                last = part;
            }
            child = (*child).next;
        }
        if !child.is_null() {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"(annotation?, (annotation?, element*)\0" as *const u8
                    as *const i8,
            );
        }
    } else {
        let mut part_0: xmlSchemaTreeItemPtr = 0 as xmlSchemaTreeItemPtr;
        let mut last_0: xmlSchemaTreeItemPtr = 0 as xmlSchemaTreeItemPtr;
        while !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"element\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"group\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"any\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"choice\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"sequence\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"element\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
                part_0 = xmlSchemaParseElement(
                    ctxt,
                    schema,
                    child,
                    &mut isElemRef,
                    0 as i32,
                ) as xmlSchemaTreeItemPtr;
                if !part_0.is_null() && isElemRef != 0 {
                    hasRefs += 1;
                }
            } else if !child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"group\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                {
                part_0 = xmlSchemaParseModelGroupDefRef(ctxt, schema, child);
                if !part_0.is_null() {
                    hasRefs += 1;
                }
                if (*ctxt).isRedefine != 0 && !((*ctxt).redef).is_null()
                    && (*(*(*ctxt).redef).item).type_0 as u32
                        == XML_SCHEMA_TYPE_GROUP as i32 as u32
                    && !part_0.is_null() && !((*part_0).children).is_null()
                {
                    if (*((*part_0).children as xmlSchemaQNameRefPtr)).name
                        == (*(*ctxt).redef).refName
                        && (*((*part_0).children as xmlSchemaQNameRefPtr))
                            .targetNamespace == (*(*ctxt).redef).refTargetNs
                    {
                        if (*ctxt).redefCounter != 0 as i32 {
                            let mut str: *mut xmlChar = 0 as *mut xmlChar;
                            xmlSchemaCustomErr(
                                ctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAP_SRC_REDEFINE,
                                child,
                                0 as xmlSchemaBasicItemPtr,
                                b"The redefining model group definition '%s' must not contain more than one reference to the redefined definition\0"
                                    as *const u8 as *const i8,
                                xmlSchemaFormatQName(
                                    &mut str,
                                    (*(*ctxt).redef).refTargetNs,
                                    (*(*ctxt).redef).refName,
                                ),
                                0 as *const xmlChar,
                            );
                            if !str.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(str as *mut libc::c_void);
                                str = 0 as *mut xmlChar;
                            }
                            part_0 = 0 as xmlSchemaTreeItemPtr;
                        } else if (*(part_0 as xmlSchemaParticlePtr)).minOccurs
                                != 1 as i32
                                || (*(part_0 as xmlSchemaParticlePtr)).maxOccurs
                                    != 1 as i32
                            {
                            let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                            xmlSchemaCustomErr(
                                ctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAP_SRC_REDEFINE,
                                child,
                                0 as xmlSchemaBasicItemPtr,
                                b"The redefining model group definition '%s' must not contain a reference to the redefined definition with a maxOccurs/minOccurs other than 1\0"
                                    as *const u8 as *const i8,
                                xmlSchemaFormatQName(
                                    &mut str_0,
                                    (*(*ctxt).redef).refTargetNs,
                                    (*(*ctxt).redef).refName,
                                ),
                                0 as *const xmlChar,
                            );
                            if !str_0.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(str_0 as *mut libc::c_void);
                                str_0 = 0 as *mut xmlChar;
                            }
                            part_0 = 0 as xmlSchemaTreeItemPtr;
                        }
                        let fresh235 = &mut ((*(*ctxt).redef).reference);
                        *fresh235 = part_0 as xmlSchemaBasicItemPtr;
                        let fresh236 = &mut ((*ctxt).redefCounter);
                        *fresh236 += 1;
                    }
                }
            } else if !child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"any\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                {
                part_0 = xmlSchemaParseAny(ctxt, schema, child) as xmlSchemaTreeItemPtr;
            } else if !child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"choice\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                {
                part_0 = xmlSchemaParseModelGroup(
                    ctxt,
                    schema,
                    child,
                    XML_SCHEMA_TYPE_CHOICE,
                    1 as i32,
                );
            } else if !child.is_null() && !((*child).ns).is_null()
                    && xmlStrEqual(
                        (*child).name,
                        b"sequence\0" as *const u8 as *const i8
                            as *const xmlChar,
                    ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
                {
                part_0 = xmlSchemaParseModelGroup(
                    ctxt,
                    schema,
                    child,
                    XML_SCHEMA_TYPE_SEQUENCE,
                    1 as i32,
                );
            }
            if !part_0.is_null() {
                if last_0.is_null() {
                    let fresh237 = &mut ((*item).children);
                    *fresh237 = part_0;
                } else {
                    let fresh238 = &mut ((*last_0).next);
                    *fresh238 = part_0;
                }
                last_0 = part_0;
            }
            child = (*child).next;
        }
        if !child.is_null() {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"(annotation?, (element | group | choice | sequence | any)*)\0"
                    as *const u8 as *const i8,
            );
        }
    }
    if max == 0 as i32 && min == 0 as i32 {
        return 0 as xmlSchemaTreeItemPtr;
    }
    if hasRefs != 0 {
        xmlSchemaAddItemSize(
            &mut (*(*ctxt).constructor).pending,
            10 as i32,
            item as *mut libc::c_void,
        );
    }
    if withParticle != 0 {
        return particle as xmlSchemaTreeItemPtr
    } else {
        return item as xmlSchemaTreeItemPtr
    };
}
unsafe extern "C" fn xmlSchemaParseRestriction(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut parentType: xmlSchemaTypeType,
) -> xmlSchemaTypePtr {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    type_0 = (*ctxt).ctxtType;
    (*type_0).flags |= (1 as i32) << 2 as i32;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"base\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    if xmlSchemaPValAttrQName(
        ctxt,
        schema,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"base\0" as *const u8 as *const i8,
        &mut (*type_0).baseNs,
        &mut (*type_0).base,
    ) == 0 as i32
    {
        if ((*type_0).base).is_null()
            && (*type_0).type_0 as u32
                == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        {
            xmlSchemaPMissingAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"base\0" as *const u8 as *const i8,
                0 as *const i8,
            );
        } else if (*ctxt).isRedefine != 0
                && (*type_0).flags & (1 as i32) << 3 as i32 != 0
            {
            if ((*type_0).base).is_null() {
                xmlSchemaPMissingAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_MISSING,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    b"base\0" as *const u8 as *const i8,
                    0 as *const i8,
                );
            } else if xmlStrEqual((*type_0).base, (*type_0).name) == 0
                    || xmlStrEqual((*type_0).baseNs, (*type_0).targetNamespace) == 0
                {
                let mut str1: *mut xmlChar = 0 as *mut xmlChar;
                let mut str2: *mut xmlChar = 0 as *mut xmlChar;
                xmlSchemaPCustomErrExt(
                    ctxt,
                    XML_SCHEMAP_SRC_REDEFINE,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    b"This is a redefinition, but the QName value '%s' of the 'base' attribute does not match the type's designation '%s'\0"
                        as *const u8 as *const i8,
                    xmlSchemaFormatQName(&mut str1, (*type_0).baseNs, (*type_0).base),
                    xmlSchemaFormatQName(
                        &mut str2,
                        (*type_0).targetNamespace,
                        (*type_0).name,
                    ),
                    0 as *const xmlChar,
                );
                if !str1.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str1 as *mut libc::c_void);
                    str1 = 0 as *mut xmlChar;
                }
                if !str2.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str2 as *mut libc::c_void);
                    str2 = 0 as *mut xmlChar;
                }
                let fresh239 = &mut ((*type_0).base);
                *fresh239 = 0 as *const xmlChar;
                let fresh240 = &mut ((*type_0).baseNs);
                *fresh240 = 0 as *const xmlChar;
            }
        }
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as i32),
        );
        child = (*child).next;
    }
    if parentType as u32
        == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
    {
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            if !((*type_0).base).is_null() {
                xmlSchemaPContentErr(
                    ctxt,
                    XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    child,
                    b"The attribute 'base' and the <simpleType> child are mutually exclusive\0"
                        as *const u8 as *const i8,
                    0 as *const i8,
                );
            } else {
                let fresh241 = &mut ((*type_0).baseType);
                *fresh241 = xmlSchemaParseSimpleType(
                    ctxt,
                    schema,
                    child,
                    0 as i32,
                );
            }
            child = (*child).next;
        } else if ((*type_0).base).is_null() {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                b"Either the attribute 'base' or a <simpleType> child must be present\0"
                    as *const u8 as *const i8,
                0 as *const i8,
            );
        }
    } else if parentType as u32
            == XML_SCHEMA_TYPE_COMPLEX_CONTENT as i32 as u32
        {
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"all\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            let fresh242 = &mut ((*type_0).subtypes);
            *fresh242 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_ALL,
                1 as i32,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"choice\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let fresh243 = &mut ((*type_0).subtypes);
            *fresh243 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_CHOICE,
                1 as i32,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"sequence\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let fresh244 = &mut ((*type_0).subtypes);
            *fresh244 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_SEQUENCE,
                1 as i32,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"group\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let fresh245 = &mut ((*type_0).subtypes);
            *fresh245 = xmlSchemaParseModelGroupDefRef(ctxt, schema, child)
                as xmlSchemaTypePtr;
            child = (*child).next;
        }
    } else if parentType as u32
            == XML_SCHEMA_TYPE_SIMPLE_CONTENT as i32 as u32
        {
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            let fresh246 = &mut ((*type_0).contentTypeDef);
            *fresh246 = xmlSchemaParseSimpleType(ctxt, schema, child, 0 as i32);
            if ((*type_0).contentTypeDef).is_null() {
                return 0 as xmlSchemaTypePtr;
            }
            child = (*child).next;
        }
    }
    if parentType as u32
        == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
        || parentType as u32
            == XML_SCHEMA_TYPE_SIMPLE_CONTENT as i32 as u32
    {
        let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
        let mut lastfacet: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
        while !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"minInclusive\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"minExclusive\0" as *const u8 as *const i8
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"maxInclusive\0" as *const u8 as *const i8
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"maxExclusive\0" as *const u8 as *const i8
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"totalDigits\0" as *const u8 as *const i8
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"fractionDigits\0" as *const u8 as *const i8
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"pattern\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"enumeration\0" as *const u8 as *const i8
                        as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"whiteSpace\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"length\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"maxLength\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            || !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"minLength\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            facet = xmlSchemaParseFacet(ctxt, schema, child);
            if !facet.is_null() {
                if lastfacet.is_null() {
                    let fresh247 = &mut ((*type_0).facets);
                    *fresh247 = facet;
                } else {
                    let fresh248 = &mut ((*lastfacet).next);
                    *fresh248 = facet;
                }
                lastfacet = facet;
                let fresh249 = &mut ((*lastfacet).next);
                *fresh249 = 0 as *mut _xmlSchemaFacet;
            }
            child = (*child).next;
        }
        if !((*type_0).facets).is_null() {
            let mut facetLink: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
            let mut lastFacetLink: xmlSchemaFacetLinkPtr = 0 as xmlSchemaFacetLinkPtr;
            facet = (*type_0).facets;
            loop {
                facetLink = xmlMalloc
                    .expect(
                        "non-null function pointer",
                    )(::std::mem::size_of::<xmlSchemaFacetLink>() as u64)
                    as xmlSchemaFacetLinkPtr;
                if facetLink.is_null() {
                    xmlSchemaPErrMemory(
                        ctxt,
                        b"allocating a facet link\0" as *const u8 as *const i8,
                        0 as xmlNodePtr,
                    );
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(facetLink as *mut libc::c_void);
                    return 0 as xmlSchemaTypePtr;
                }
                let fresh250 = &mut ((*facetLink).facet);
                *fresh250 = facet;
                let fresh251 = &mut ((*facetLink).next);
                *fresh251 = 0 as *mut _xmlSchemaFacetLink;
                if lastFacetLink.is_null() {
                    let fresh252 = &mut ((*type_0).facetSet);
                    *fresh252 = facetLink;
                } else {
                    let fresh253 = &mut ((*lastFacetLink).next);
                    *fresh253 = facetLink;
                }
                lastFacetLink = facetLink;
                facet = (*facet).next;
                if facet.is_null() {
                    break;
                }
            }
        }
    }
    if (*type_0).type_0 as u32
        == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
    {
        if xmlSchemaParseLocalAttributes(
            ctxt,
            schema,
            &mut child,
            &mut (*type_0).attrUses as *mut *mut libc::c_void
                as *mut xmlSchemaItemListPtr,
            XML_SCHEMA_TYPE_RESTRICTION as i32,
            0 as *mut i32,
        ) == -(1 as i32)
        {
            return 0 as xmlSchemaTypePtr;
        }
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"anyAttribute\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            let fresh254 = &mut ((*type_0).attributeWildcard);
            *fresh254 = xmlSchemaParseAnyAttribute(ctxt, schema, child);
            child = (*child).next;
        }
    }
    if !child.is_null() {
        if parentType as u32
            == XML_SCHEMA_TYPE_COMPLEX_CONTENT as i32 as u32
        {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"annotation?, (group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?))\0"
                    as *const u8 as *const i8,
            );
        } else if parentType as u32
                == XML_SCHEMA_TYPE_SIMPLE_CONTENT as i32 as u32
            {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"(annotation?, (simpleType?, (minExclusive | minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | length | minLength | maxLength | enumeration | whiteSpace | pattern)*)?, ((attribute | attributeGroup)*, anyAttribute?))\0"
                    as *const u8 as *const i8,
            );
        } else {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"(annotation?, (simpleType?, (minExclusive | minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | length | minLength | maxLength | enumeration | whiteSpace | pattern)*))\0"
                    as *const u8 as *const i8,
            );
        }
    }
    return 0 as xmlSchemaTypePtr;
}
unsafe extern "C" fn xmlSchemaParseExtension(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut parentType: xmlSchemaTypeType,
) -> xmlSchemaTypePtr {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    type_0 = (*ctxt).ctxtType;
    (*type_0).flags |= (1 as i32) << 1 as i32;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"base\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    if xmlSchemaPValAttrQName(
        ctxt,
        schema,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"base\0" as *const u8 as *const i8,
        &mut (*type_0).baseNs,
        &mut (*type_0).base,
    ) == 0 as i32 && ((*type_0).base).is_null()
    {
        xmlSchemaPMissingAttrErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"base\0" as *const u8 as *const i8,
            0 as *const i8,
        );
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as i32),
        );
        child = (*child).next;
    }
    if parentType as u32
        == XML_SCHEMA_TYPE_COMPLEX_CONTENT as i32 as u32
    {
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"all\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            let fresh255 = &mut ((*type_0).subtypes);
            *fresh255 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_ALL,
                1 as i32,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"choice\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let fresh256 = &mut ((*type_0).subtypes);
            *fresh256 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_CHOICE,
                1 as i32,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"sequence\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let fresh257 = &mut ((*type_0).subtypes);
            *fresh257 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_SEQUENCE,
                1 as i32,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"group\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let fresh258 = &mut ((*type_0).subtypes);
            *fresh258 = xmlSchemaParseModelGroupDefRef(ctxt, schema, child)
                as xmlSchemaTypePtr;
            child = (*child).next;
        }
    }
    if !child.is_null() {
        if xmlSchemaParseLocalAttributes(
            ctxt,
            schema,
            &mut child,
            &mut (*type_0).attrUses as *mut *mut libc::c_void
                as *mut xmlSchemaItemListPtr,
            XML_SCHEMA_TYPE_EXTENSION as i32,
            0 as *mut i32,
        ) == -(1 as i32)
        {
            return 0 as xmlSchemaTypePtr;
        }
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"anyAttribute\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            let fresh259 = &mut ((*(*ctxt).ctxtType).attributeWildcard);
            *fresh259 = xmlSchemaParseAnyAttribute(ctxt, schema, child);
            child = (*child).next;
        }
    }
    if !child.is_null() {
        if parentType as u32
            == XML_SCHEMA_TYPE_COMPLEX_CONTENT as i32 as u32
        {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"(annotation?, ((group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?)))\0"
                    as *const u8 as *const i8,
            );
        } else {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"(annotation?, ((attribute | attributeGroup)*, anyAttribute?))\0"
                    as *const u8 as *const i8,
            );
        }
    }
    return 0 as xmlSchemaTypePtr;
}
unsafe extern "C" fn xmlSchemaParseSimpleContent(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut hasRestrictionOrExtension: *mut i32,
) -> i32 {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null()
        || hasRestrictionOrExtension.is_null()
    {
        return -(1 as i32);
    }
    *hasRestrictionOrExtension = 0 as i32;
    type_0 = (*ctxt).ctxtType;
    (*type_0).contentType = XML_SCHEMA_CONTENT_SIMPLE;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as i32),
        );
        child = (*child).next;
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            0 as xmlNodePtr,
            0 as *const i8,
            b"(annotation?, (restriction | extension))\0" as *const u8
                as *const i8,
        );
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            0 as xmlNodePtr,
            0 as *const i8,
            b"(annotation?, (restriction | extension))\0" as *const u8
                as *const i8,
        );
    }
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"restriction\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaParseRestriction(ctxt, schema, child, XML_SCHEMA_TYPE_SIMPLE_CONTENT);
        *hasRestrictionOrExtension = 1 as i32;
        child = (*child).next;
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"extension\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        xmlSchemaParseExtension(ctxt, schema, child, XML_SCHEMA_TYPE_SIMPLE_CONTENT);
        *hasRestrictionOrExtension = 1 as i32;
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, (restriction | extension))\0" as *const u8
                as *const i8,
        );
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaParseComplexContent(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut hasRestrictionOrExtension: *mut i32,
) -> i32 {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null()
        || hasRestrictionOrExtension.is_null()
    {
        return -(1 as i32);
    }
    *hasRestrictionOrExtension = 0 as i32;
    type_0 = (*ctxt).ctxtType;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    (*attr).name,
                    b"mixed\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    if xmlGetBooleanProp(
        ctxt,
        node,
        b"mixed\0" as *const u8 as *const i8,
        0 as i32,
    ) != 0
    {
        if (*type_0).flags & (1 as i32) << 0 as i32 == 0 as i32 {
            (*type_0).flags |= (1 as i32) << 0 as i32;
        }
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as i32),
        );
        child = (*child).next;
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            0 as xmlNodePtr,
            0 as *const i8,
            b"(annotation?, (restriction | extension))\0" as *const u8
                as *const i8,
        );
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            0 as xmlNodePtr,
            0 as *const i8,
            b"(annotation?, (restriction | extension))\0" as *const u8
                as *const i8,
        );
    }
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"restriction\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        xmlSchemaParseRestriction(ctxt, schema, child, XML_SCHEMA_TYPE_COMPLEX_CONTENT);
        *hasRestrictionOrExtension = 1 as i32;
        child = (*child).next;
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"extension\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        xmlSchemaParseExtension(ctxt, schema, child, XML_SCHEMA_TYPE_COMPLEX_CONTENT);
        *hasRestrictionOrExtension = 1 as i32;
        child = (*child).next;
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, (restriction | extension))\0" as *const u8
                as *const i8,
        );
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaParseComplexType(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut topLevel: i32,
) -> xmlSchemaTypePtr {
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ctxtType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut child: xmlNodePtr = 0 as xmlNodePtr;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut attrValue: *const xmlChar = 0 as *const xmlChar;
    let mut final_0: i32 = 0 as i32;
    let mut block: i32 = 0 as i32;
    let mut hasRestrictionOrExtension: i32 = 0 as i32;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    ctxtType = (*ctxt).ctxtType;
    if topLevel != 0 {
        attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const i8);
        if attr.is_null() {
            xmlSchemaPMissingAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"name\0" as *const u8 as *const i8,
                0 as *const i8,
            );
            return 0 as xmlSchemaTypePtr;
        } else {
            if xmlSchemaPValAttrNode(
                ctxt,
                0 as xmlSchemaBasicItemPtr,
                attr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                &mut name,
            ) != 0 as i32
            {
                return 0 as xmlSchemaTypePtr;
            }
        }
    }
    if topLevel == 0 as i32 {
        type_0 = xmlSchemaAddType(
            ctxt,
            schema,
            XML_SCHEMA_TYPE_COMPLEX,
            0 as *const xmlChar,
            (*ctxt).targetNamespace,
            node,
            0 as i32,
        );
        if type_0.is_null() {
            return 0 as xmlSchemaTypePtr;
        }
        name = (*type_0).name;
        let fresh260 = &mut ((*type_0).node);
        *fresh260 = node;
        (*type_0).type_0 = XML_SCHEMA_TYPE_COMPLEX;
    } else {
        type_0 = xmlSchemaAddType(
            ctxt,
            schema,
            XML_SCHEMA_TYPE_COMPLEX,
            name,
            (*ctxt).targetNamespace,
            node,
            1 as i32,
        );
        if type_0.is_null() {
            return 0 as xmlSchemaTypePtr;
        }
        let fresh261 = &mut ((*type_0).node);
        *fresh261 = node;
        (*type_0).type_0 = XML_SCHEMA_TYPE_COMPLEX;
        (*type_0).flags |= (1 as i32) << 3 as i32;
    }
    let fresh262 = &mut ((*type_0).targetNamespace);
    *fresh262 = (*ctxt).targetNamespace;
    attr = (*node).properties;
    while !attr.is_null() {
        if ((*attr).ns).is_null() {
            if xmlStrEqual(
                (*attr).name,
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
                xmlSchemaPValAttrID(
                    ctxt,
                    node,
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                );
            } else if xmlStrEqual(
                    (*attr).name,
                    b"mixed\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                if xmlSchemaPGetBoolNodeValue(
                    ctxt,
                    0 as xmlSchemaBasicItemPtr,
                    attr as xmlNodePtr,
                ) != 0
                {
                    (*type_0).flags |= (1 as i32) << 0 as i32;
                }
            } else if topLevel != 0 {
                if !(xmlStrEqual(
                    (*attr).name,
                    b"name\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0)
                {
                    if xmlStrEqual(
                        (*attr).name,
                        b"abstract\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) != 0
                    {
                        if xmlSchemaPGetBoolNodeValue(
                            ctxt,
                            0 as xmlSchemaBasicItemPtr,
                            attr as xmlNodePtr,
                        ) != 0
                        {
                            (*type_0).flags |= (1 as i32) << 20 as i32;
                        }
                    } else if xmlStrEqual(
                            (*attr).name,
                            b"final\0" as *const u8 as *const i8
                                as *mut xmlChar,
                        ) != 0
                        {
                        attrValue = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if xmlSchemaPValAttrBlockFinal(
                            attrValue,
                            &mut (*type_0).flags,
                            -(1 as i32),
                            (1 as i32) << 9 as i32,
                            (1 as i32) << 10 as i32,
                            -(1 as i32),
                            -(1 as i32),
                            -(1 as i32),
                        ) != 0 as i32
                        {
                            xmlSchemaPSimpleTypeErr(
                                ctxt,
                                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr,
                                0 as xmlSchemaTypePtr,
                                b"(#all | List of (extension | restriction))\0" as *const u8
                                    as *const i8,
                                attrValue,
                                0 as *const i8,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        } else {
                            final_0 = 1 as i32;
                        }
                    } else if xmlStrEqual(
                            (*attr).name,
                            b"block\0" as *const u8 as *const i8
                                as *mut xmlChar,
                        ) != 0
                        {
                        attrValue = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if xmlSchemaPValAttrBlockFinal(
                            attrValue,
                            &mut (*type_0).flags,
                            -(1 as i32),
                            (1 as i32) << 18 as i32,
                            (1 as i32) << 19 as i32,
                            -(1 as i32),
                            -(1 as i32),
                            -(1 as i32),
                        ) != 0 as i32
                        {
                            xmlSchemaPSimpleTypeErr(
                                ctxt,
                                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr,
                                0 as xmlSchemaTypePtr,
                                b"(#all | List of (extension | restriction)) \0"
                                    as *const u8 as *const i8,
                                attrValue,
                                0 as *const i8,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        } else {
                            block = 1 as i32;
                        }
                    } else {
                        xmlSchemaPIllegalAttrErr(
                            ctxt,
                            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                            0 as xmlSchemaBasicItemPtr,
                            attr,
                        );
                    }
                }
            } else {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                );
            }
        } else if xmlStrEqual((*(*attr).ns).href, xmlSchemaNs) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                attr,
            );
        }
        attr = (*attr).next;
    }
    if block == 0 {
        if (*schema).flags & (1 as i32) << 7 as i32 != 0 {
            (*type_0).flags |= (1 as i32) << 19 as i32;
        }
        if (*schema).flags & (1 as i32) << 6 as i32 != 0 {
            (*type_0).flags |= (1 as i32) << 18 as i32;
        }
    }
    if final_0 == 0 {
        if (*schema).flags & (1 as i32) << 3 as i32 != 0 {
            (*type_0).flags |= (1 as i32) << 10 as i32;
        }
        if (*schema).flags & (1 as i32) << 2 as i32 != 0 {
            (*type_0).flags |= (1 as i32) << 9 as i32;
        }
    }
    child = (*node).children;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        let fresh263 = &mut ((*type_0).annot);
        *fresh263 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = (*child).next;
    }
    let fresh264 = &mut ((*ctxt).ctxtType);
    *fresh264 = type_0;
    if !child.is_null() && !((*child).ns).is_null()
        && xmlStrEqual(
            (*child).name,
            b"simpleContent\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
    {
        if (*type_0).flags & (1 as i32) << 0 as i32 != 0 {
            (*type_0).flags ^= (1 as i32) << 0 as i32;
        }
        xmlSchemaParseSimpleContent(ctxt, schema, child, &mut hasRestrictionOrExtension);
        child = (*child).next;
    } else if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"complexContent\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
        (*type_0).contentType = XML_SCHEMA_CONTENT_EMPTY;
        xmlSchemaParseComplexContent(
            ctxt,
            schema,
            child,
            &mut hasRestrictionOrExtension,
        );
        child = (*child).next;
    } else {
        let fresh265 = &mut ((*type_0).baseType);
        *fresh265 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
        (*type_0).flags |= (1 as i32) << 2 as i32;
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"all\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            let fresh266 = &mut ((*type_0).subtypes);
            *fresh266 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_ALL,
                1 as i32,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"choice\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let fresh267 = &mut ((*type_0).subtypes);
            *fresh267 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_CHOICE,
                1 as i32,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"sequence\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let fresh268 = &mut ((*type_0).subtypes);
            *fresh268 = xmlSchemaParseModelGroup(
                ctxt,
                schema,
                child,
                XML_SCHEMA_TYPE_SEQUENCE,
                1 as i32,
            ) as xmlSchemaTypePtr;
            child = (*child).next;
        } else if !child.is_null() && !((*child).ns).is_null()
                && xmlStrEqual(
                    (*child).name,
                    b"group\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
            {
            let fresh269 = &mut ((*type_0).subtypes);
            *fresh269 = xmlSchemaParseModelGroupDefRef(ctxt, schema, child)
                as xmlSchemaTypePtr;
            child = (*child).next;
        }
        if xmlSchemaParseLocalAttributes(
            ctxt,
            schema,
            &mut child,
            &mut (*type_0).attrUses as *mut *mut libc::c_void
                as *mut xmlSchemaItemListPtr,
            XML_SCHEMA_TYPE_RESTRICTION as i32,
            0 as *mut i32,
        ) == -(1 as i32)
        {
            return 0 as xmlSchemaTypePtr;
        }
        if !child.is_null() && !((*child).ns).is_null()
            && xmlStrEqual(
                (*child).name,
                b"anyAttribute\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0 && xmlStrEqual((*(*child).ns).href, xmlSchemaNs) != 0
        {
            let fresh270 = &mut ((*type_0).attributeWildcard);
            *fresh270 = xmlSchemaParseAnyAttribute(ctxt, schema, child);
            child = (*child).next;
        }
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, (simpleContent | complexContent | ((group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?))))\0"
                as *const u8 as *const i8,
        );
    }
    if topLevel != 0 && (*ctxt).isRedefine != 0 && hasRestrictionOrExtension == 0 {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_SRC_REDEFINE,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"This is a redefinition, thus the <complexType> must have a <restriction> or <extension> grand-child\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
        );
    }
    let fresh271 = &mut ((*ctxt).ctxtType);
    *fresh271 = ctxtType;
    return type_0;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaNewParserCtxt(
    mut URL: *const i8,
) -> xmlSchemaParserCtxtPtr {
    let mut ret: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    if URL.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    ret = xmlSchemaParserCtxtCreate();
    if ret.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    let fresh272 = &mut ((*ret).dict);
    *fresh272 = xmlDictCreate();
    let fresh273 = &mut ((*ret).URL);
    *fresh273 = xmlDictLookup((*ret).dict, URL as *const xmlChar, -(1 as i32));
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaNewMemParserCtxt(
    mut buffer: *const i8,
    mut size: i32,
) -> xmlSchemaParserCtxtPtr {
    let mut ret: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    if buffer.is_null() || size <= 0 as i32 {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    ret = xmlSchemaParserCtxtCreate();
    if ret.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    let fresh274 = &mut ((*ret).buffer);
    *fresh274 = buffer;
    (*ret).size = size;
    let fresh275 = &mut ((*ret).dict);
    *fresh275 = xmlDictCreate();
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaNewDocParserCtxt(
    mut doc: xmlDocPtr,
) -> xmlSchemaParserCtxtPtr {
    let mut ret: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    if doc.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    ret = xmlSchemaParserCtxtCreate();
    if ret.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    let fresh276 = &mut ((*ret).doc);
    *fresh276 = doc;
    let fresh277 = &mut ((*ret).dict);
    *fresh277 = xmlDictCreate();
    (*ret).preserve = 1 as i32;
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFreeParserCtxt(mut ctxt: xmlSchemaParserCtxtPtr) {
    if ctxt.is_null() {
        return;
    }
    if !((*ctxt).doc).is_null() && (*ctxt).preserve == 0 {
        xmlFreeDoc((*ctxt).doc);
    }
    if !((*ctxt).vctxt).is_null() {
        xmlSchemaFreeValidCtxt((*ctxt).vctxt);
    }
    if (*ctxt).ownsConstructor != 0 && !((*ctxt).constructor).is_null() {
        xmlSchemaConstructionCtxtFree((*ctxt).constructor);
        let fresh278 = &mut ((*ctxt).constructor);
        *fresh278 = 0 as xmlSchemaConstructionCtxtPtr;
        (*ctxt).ownsConstructor = 0 as i32;
    }
    if !((*ctxt).attrProhibs).is_null() {
        xmlSchemaItemListFree((*ctxt).attrProhibs);
    }
    xmlDictFree((*ctxt).dict);
    xmlFree.expect("non-null function pointer")(ctxt as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaBuildContentModelForSubstGroup(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut particle: xmlSchemaParticlePtr,
    mut counter: i32,
    mut end: xmlAutomataStatePtr,
) -> i32 {
    let mut start: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
    let mut tmp: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
    let mut elemDecl: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
    let mut member: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
    let mut substGroup: xmlSchemaSubstGroupPtr = 0 as *mut xmlSchemaSubstGroup;
    let mut i: i32 = 0;
    let mut ret: i32 = 0 as i32;
    elemDecl = (*particle).children as xmlSchemaElementPtr;
    start = (*pctxt).state;
    if end.is_null() {
        end = xmlAutomataNewState((*pctxt).am);
    }
    substGroup = xmlSchemaSubstGroupGet(pctxt, elemDecl);
    if substGroup.is_null() {
        xmlSchemaPErr(
            pctxt,
            xmlSchemaGetComponentNode(particle as xmlSchemaBasicItemPtr),
            XML_SCHEMAP_INTERNAL as i32,
            b"Internal error: xmlSchemaBuildContentModelForSubstGroup, declaration is marked having a subst. group but none available.\n\0"
                as *const u8 as *const i8,
            (*elemDecl).name,
            0 as *const xmlChar,
        );
        return 0 as i32;
    }
    if counter >= 0 as i32 {
        tmp = xmlAutomataNewCountedTrans(
            (*pctxt).am,
            start,
            0 as xmlAutomataStatePtr,
            counter,
        );
        xmlAutomataNewTransition2(
            (*pctxt).am,
            tmp,
            end,
            (*elemDecl).name,
            (*elemDecl).targetNamespace,
            elemDecl as *mut libc::c_void,
        );
        i = 0 as i32;
        while i < (*(*substGroup).members).nbItems {
            member = *((*(*substGroup).members).items).offset(i as isize)
                as xmlSchemaElementPtr;
            xmlAutomataNewTransition2(
                (*pctxt).am,
                tmp,
                end,
                (*member).name,
                (*member).targetNamespace,
                member as *mut libc::c_void,
            );
            i += 1;
        }
    } else if (*particle).maxOccurs == 1 as i32 {
        xmlAutomataNewEpsilon(
            (*pctxt).am,
            xmlAutomataNewTransition2(
                (*pctxt).am,
                start,
                0 as xmlAutomataStatePtr,
                (*elemDecl).name,
                (*elemDecl).targetNamespace,
                elemDecl as *mut libc::c_void,
            ),
            end,
        );
        i = 0 as i32;
        while i < (*(*substGroup).members).nbItems {
            member = *((*(*substGroup).members).items).offset(i as isize)
                as xmlSchemaElementPtr;
            tmp = xmlAutomataNewTransition2(
                (*pctxt).am,
                start,
                0 as xmlAutomataStatePtr,
                (*member).name,
                (*member).targetNamespace,
                member as *mut libc::c_void,
            );
            xmlAutomataNewEpsilon((*pctxt).am, tmp, end);
            i += 1;
        }
    } else {
        let mut hop: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
        let mut maxOccurs: i32 = if (*particle).maxOccurs
            == (1 as i32) << 30 as i32
        {
            (1 as i32) << 30 as i32
        } else {
            (*particle).maxOccurs - 1 as i32
        };
        let mut minOccurs: i32 = if (*particle).minOccurs < 1 as i32 {
            0 as i32
        } else {
            (*particle).minOccurs - 1 as i32
        };
        counter = xmlAutomataNewCounter((*pctxt).am, minOccurs, maxOccurs);
        hop = xmlAutomataNewState((*pctxt).am);
        xmlAutomataNewEpsilon(
            (*pctxt).am,
            xmlAutomataNewTransition2(
                (*pctxt).am,
                start,
                0 as xmlAutomataStatePtr,
                (*elemDecl).name,
                (*elemDecl).targetNamespace,
                elemDecl as *mut libc::c_void,
            ),
            hop,
        );
        i = 0 as i32;
        while i < (*(*substGroup).members).nbItems {
            member = *((*(*substGroup).members).items).offset(i as isize)
                as xmlSchemaElementPtr;
            xmlAutomataNewEpsilon(
                (*pctxt).am,
                xmlAutomataNewTransition2(
                    (*pctxt).am,
                    start,
                    0 as xmlAutomataStatePtr,
                    (*member).name,
                    (*member).targetNamespace,
                    member as *mut libc::c_void,
                ),
                hop,
            );
            i += 1;
        }
        xmlAutomataNewCountedTrans((*pctxt).am, hop, start, counter);
        xmlAutomataNewCounterTrans((*pctxt).am, hop, end, counter);
    }
    if (*particle).minOccurs == 0 as i32 {
        xmlAutomataNewEpsilon((*pctxt).am, start, end);
        ret = 1 as i32;
    }
    let fresh279 = &mut ((*pctxt).state);
    *fresh279 = end;
    return ret;
}
unsafe extern "C" fn xmlSchemaBuildContentModelForElement(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut particle: xmlSchemaParticlePtr,
) -> i32 {
    let mut ret: i32 = 0 as i32;
    if (*((*particle).children as xmlSchemaElementPtr)).flags
        & (1 as i32) << 17 as i32 != 0
    {
        ret = xmlSchemaBuildContentModelForSubstGroup(
            ctxt,
            particle,
            -(1 as i32),
            0 as xmlAutomataStatePtr,
        );
    } else {
        let mut elemDecl: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
        let mut start: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
        elemDecl = (*particle).children as xmlSchemaElementPtr;
        if (*elemDecl).flags & (1 as i32) << 4 as i32 != 0 {
            return 0 as i32;
        }
        if (*particle).maxOccurs == 1 as i32 {
            start = (*ctxt).state;
            let fresh280 = &mut ((*ctxt).state);
            *fresh280 = xmlAutomataNewTransition2(
                (*ctxt).am,
                start,
                0 as xmlAutomataStatePtr,
                (*elemDecl).name,
                (*elemDecl).targetNamespace,
                elemDecl as *mut libc::c_void,
            );
        } else if (*particle).maxOccurs >= (1 as i32) << 30 as i32
                && (*particle).minOccurs < 2 as i32
            {
            start = (*ctxt).state;
            let fresh281 = &mut ((*ctxt).state);
            *fresh281 = xmlAutomataNewTransition2(
                (*ctxt).am,
                start,
                0 as xmlAutomataStatePtr,
                (*elemDecl).name,
                (*elemDecl).targetNamespace,
                elemDecl as *mut libc::c_void,
            );
            let fresh282 = &mut ((*ctxt).state);
            *fresh282 = xmlAutomataNewTransition2(
                (*ctxt).am,
                (*ctxt).state,
                (*ctxt).state,
                (*elemDecl).name,
                (*elemDecl).targetNamespace,
                elemDecl as *mut libc::c_void,
            );
        } else {
            let mut counter: i32 = 0;
            let mut maxOccurs: i32 = if (*particle).maxOccurs
                == (1 as i32) << 30 as i32
            {
                (1 as i32) << 30 as i32
            } else {
                (*particle).maxOccurs - 1 as i32
            };
            let mut minOccurs: i32 = if (*particle).minOccurs < 1 as i32
            {
                0 as i32
            } else {
                (*particle).minOccurs - 1 as i32
            };
            start = xmlAutomataNewEpsilon(
                (*ctxt).am,
                (*ctxt).state,
                0 as xmlAutomataStatePtr,
            );
            counter = xmlAutomataNewCounter((*ctxt).am, minOccurs, maxOccurs);
            let fresh283 = &mut ((*ctxt).state);
            *fresh283 = xmlAutomataNewTransition2(
                (*ctxt).am,
                start,
                0 as xmlAutomataStatePtr,
                (*elemDecl).name,
                (*elemDecl).targetNamespace,
                elemDecl as *mut libc::c_void,
            );
            xmlAutomataNewCountedTrans((*ctxt).am, (*ctxt).state, start, counter);
            let fresh284 = &mut ((*ctxt).state);
            *fresh284 = xmlAutomataNewCounterTrans(
                (*ctxt).am,
                (*ctxt).state,
                0 as xmlAutomataStatePtr,
                counter,
            );
        }
        if (*particle).minOccurs == 0 as i32 {
            xmlAutomataNewEpsilon((*ctxt).am, start, (*ctxt).state);
            ret = 1 as i32;
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaBuildAContentModel(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut particle: xmlSchemaParticlePtr,
) -> i32 {
    let mut ret: i32 = 0 as i32;
    let mut tmp2: i32 = 0;
    if particle.is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaBuildAContentModel\0" as *const u8 as *const i8,
            b"particle is NULL\0" as *const u8 as *const i8,
        );
        return 1 as i32;
    }
    if ((*particle).children).is_null() {
        return 1 as i32;
    }
    match (*(*particle).children).type_0 as u32 {
        2 => {
            let mut start: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            let mut end: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            let mut wild: xmlSchemaWildcardPtr = 0 as *mut xmlSchemaWildcard;
            let mut ns: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
            wild = (*particle).children as xmlSchemaWildcardPtr;
            start = (*pctxt).state;
            end = xmlAutomataNewState((*pctxt).am);
            if (*particle).maxOccurs == 1 as i32 {
                if (*wild).any == 1 as i32 {
                    let fresh285 = &mut ((*pctxt).state);
                    *fresh285 = xmlAutomataNewTransition2(
                        (*pctxt).am,
                        start,
                        0 as xmlAutomataStatePtr,
                        b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                        b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                        wild as *mut libc::c_void,
                    );
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, end);
                    let fresh286 = &mut ((*pctxt).state);
                    *fresh286 = xmlAutomataNewTransition2(
                        (*pctxt).am,
                        start,
                        0 as xmlAutomataStatePtr,
                        b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                        0 as *const xmlChar,
                        wild as *mut libc::c_void,
                    );
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, end);
                } else if !((*wild).nsSet).is_null() {
                    ns = (*wild).nsSet;
                    loop {
                        let fresh287 = &mut ((*pctxt).state);
                        *fresh287 = start;
                        let fresh288 = &mut ((*pctxt).state);
                        *fresh288 = xmlAutomataNewTransition2(
                            (*pctxt).am,
                            (*pctxt).state,
                            0 as xmlAutomataStatePtr,
                            b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                            (*ns).value,
                            wild as *mut libc::c_void,
                        );
                        xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, end);
                        ns = (*ns).next;
                        if ns.is_null() {
                            break;
                        }
                    }
                } else if !((*wild).negNsSet).is_null() {
                    let fresh289 = &mut ((*pctxt).state);
                    *fresh289 = xmlAutomataNewNegTrans(
                        (*pctxt).am,
                        start,
                        end,
                        b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                        (*(*wild).negNsSet).value,
                        wild as *mut libc::c_void,
                    );
                }
            } else {
                let mut counter: i32 = 0;
                let mut hop: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
                let mut maxOccurs: i32 = if (*particle).maxOccurs
                    == (1 as i32) << 30 as i32
                {
                    (1 as i32) << 30 as i32
                } else {
                    (*particle).maxOccurs - 1 as i32
                };
                let mut minOccurs: i32 = if (*particle).minOccurs
                    < 1 as i32
                {
                    0 as i32
                } else {
                    (*particle).minOccurs - 1 as i32
                };
                counter = xmlAutomataNewCounter((*pctxt).am, minOccurs, maxOccurs);
                hop = xmlAutomataNewState((*pctxt).am);
                if (*wild).any == 1 as i32 {
                    let fresh290 = &mut ((*pctxt).state);
                    *fresh290 = xmlAutomataNewTransition2(
                        (*pctxt).am,
                        start,
                        0 as xmlAutomataStatePtr,
                        b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                        b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                        wild as *mut libc::c_void,
                    );
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, hop);
                    let fresh291 = &mut ((*pctxt).state);
                    *fresh291 = xmlAutomataNewTransition2(
                        (*pctxt).am,
                        start,
                        0 as xmlAutomataStatePtr,
                        b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                        0 as *const xmlChar,
                        wild as *mut libc::c_void,
                    );
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, hop);
                } else if !((*wild).nsSet).is_null() {
                    ns = (*wild).nsSet;
                    loop {
                        let fresh292 = &mut ((*pctxt).state);
                        *fresh292 = xmlAutomataNewTransition2(
                            (*pctxt).am,
                            start,
                            0 as xmlAutomataStatePtr,
                            b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                            (*ns).value,
                            wild as *mut libc::c_void,
                        );
                        xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, hop);
                        ns = (*ns).next;
                        if ns.is_null() {
                            break;
                        }
                    }
                } else if !((*wild).negNsSet).is_null() {
                    let fresh293 = &mut ((*pctxt).state);
                    *fresh293 = xmlAutomataNewNegTrans(
                        (*pctxt).am,
                        start,
                        hop,
                        b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                        (*(*wild).negNsSet).value,
                        wild as *mut libc::c_void,
                    );
                }
                xmlAutomataNewCountedTrans((*pctxt).am, hop, start, counter);
                xmlAutomataNewCounterTrans((*pctxt).am, hop, end, counter);
            }
            if (*particle).minOccurs == 0 as i32 {
                xmlAutomataNewEpsilon((*pctxt).am, start, end);
                ret = 1 as i32;
            }
            let fresh294 = &mut ((*pctxt).state);
            *fresh294 = end;
        }
        14 => {
            ret = xmlSchemaBuildContentModelForElement(pctxt, particle);
        }
        6 => {
            let mut sub: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
            ret = 1 as i32;
            if (*particle).minOccurs == 1 as i32
                && (*particle).maxOccurs == 1 as i32
            {
                sub = (*(*particle).children).children;
                while !sub.is_null() {
                    tmp2 = xmlSchemaBuildAContentModel(
                        pctxt,
                        sub as xmlSchemaParticlePtr,
                    );
                    if tmp2 != 1 as i32 {
                        ret = 0 as i32;
                    }
                    sub = (*sub).next;
                }
            } else {
                let mut oldstate: xmlAutomataStatePtr = (*pctxt).state;
                if (*particle).maxOccurs >= (1 as i32) << 30 as i32 {
                    if (*particle).minOccurs > 1 as i32 {
                        let mut tmp: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
                        let mut counter_0: i32 = 0;
                        let fresh295 = &mut ((*pctxt).state);
                        *fresh295 = xmlAutomataNewEpsilon(
                            (*pctxt).am,
                            oldstate,
                            0 as xmlAutomataStatePtr,
                        );
                        oldstate = (*pctxt).state;
                        counter_0 = xmlAutomataNewCounter(
                            (*pctxt).am,
                            (*particle).minOccurs - 1 as i32,
                            (1 as i32) << 30 as i32,
                        );
                        sub = (*(*particle).children).children;
                        while !sub.is_null() {
                            tmp2 = xmlSchemaBuildAContentModel(
                                pctxt,
                                sub as xmlSchemaParticlePtr,
                            );
                            if tmp2 != 1 as i32 {
                                ret = 0 as i32;
                            }
                            sub = (*sub).next;
                        }
                        tmp = (*pctxt).state;
                        xmlAutomataNewCountedTrans(
                            (*pctxt).am,
                            tmp,
                            oldstate,
                            counter_0,
                        );
                        let fresh296 = &mut ((*pctxt).state);
                        *fresh296 = xmlAutomataNewCounterTrans(
                            (*pctxt).am,
                            tmp,
                            0 as xmlAutomataStatePtr,
                            counter_0,
                        );
                        if ret == 1 as i32 {
                            xmlAutomataNewEpsilon((*pctxt).am, oldstate, (*pctxt).state);
                        }
                    } else {
                        let fresh297 = &mut ((*pctxt).state);
                        *fresh297 = xmlAutomataNewEpsilon(
                            (*pctxt).am,
                            oldstate,
                            0 as xmlAutomataStatePtr,
                        );
                        oldstate = (*pctxt).state;
                        sub = (*(*particle).children).children;
                        while !sub.is_null() {
                            tmp2 = xmlSchemaBuildAContentModel(
                                pctxt,
                                sub as xmlSchemaParticlePtr,
                            );
                            if tmp2 != 1 as i32 {
                                ret = 0 as i32;
                            }
                            sub = (*sub).next;
                        }
                        xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, oldstate);
                        let fresh298 = &mut ((*pctxt).state);
                        *fresh298 = xmlAutomataNewEpsilon(
                            (*pctxt).am,
                            (*pctxt).state,
                            0 as xmlAutomataStatePtr,
                        );
                        if (*particle).minOccurs == 0 as i32 {
                            xmlAutomataNewEpsilon((*pctxt).am, oldstate, (*pctxt).state);
                            ret = 1 as i32;
                        }
                    }
                } else if (*particle).maxOccurs > 1 as i32
                        || (*particle).minOccurs > 1 as i32
                    {
                    let mut tmp_0: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
                    let mut counter_1: i32 = 0;
                    let fresh299 = &mut ((*pctxt).state);
                    *fresh299 = xmlAutomataNewEpsilon(
                        (*pctxt).am,
                        oldstate,
                        0 as xmlAutomataStatePtr,
                    );
                    oldstate = (*pctxt).state;
                    counter_1 = xmlAutomataNewCounter(
                        (*pctxt).am,
                        (*particle).minOccurs - 1 as i32,
                        (*particle).maxOccurs - 1 as i32,
                    );
                    sub = (*(*particle).children).children;
                    while !sub.is_null() {
                        tmp2 = xmlSchemaBuildAContentModel(
                            pctxt,
                            sub as xmlSchemaParticlePtr,
                        );
                        if tmp2 != 1 as i32 {
                            ret = 0 as i32;
                        }
                        sub = (*sub).next;
                    }
                    tmp_0 = (*pctxt).state;
                    xmlAutomataNewCountedTrans((*pctxt).am, tmp_0, oldstate, counter_1);
                    let fresh300 = &mut ((*pctxt).state);
                    *fresh300 = xmlAutomataNewCounterTrans(
                        (*pctxt).am,
                        tmp_0,
                        0 as xmlAutomataStatePtr,
                        counter_1,
                    );
                    if (*particle).minOccurs == 0 as i32
                        || ret == 1 as i32
                    {
                        xmlAutomataNewEpsilon((*pctxt).am, oldstate, (*pctxt).state);
                        ret = 1 as i32;
                    }
                } else {
                    sub = (*(*particle).children).children;
                    while !sub.is_null() {
                        tmp2 = xmlSchemaBuildAContentModel(
                            pctxt,
                            sub as xmlSchemaParticlePtr,
                        );
                        if tmp2 != 1 as i32 {
                            ret = 0 as i32;
                        }
                        sub = (*sub).next;
                    }
                    let fresh301 = &mut ((*pctxt).state);
                    *fresh301 = xmlAutomataNewEpsilon(
                        (*pctxt).am,
                        (*pctxt).state,
                        0 as xmlAutomataStatePtr,
                    );
                    if (*particle).minOccurs == 0 as i32 {
                        xmlAutomataNewEpsilon((*pctxt).am, oldstate, (*pctxt).state);
                        ret = 1 as i32;
                    }
                }
            }
        }
        7 => {
            let mut sub_0: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
            let mut start_0: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            let mut end_0: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            ret = 0 as i32;
            start_0 = (*pctxt).state;
            end_0 = xmlAutomataNewState((*pctxt).am);
            if (*particle).maxOccurs == 1 as i32 {
                sub_0 = (*(*particle).children).children;
                while !sub_0.is_null() {
                    let fresh302 = &mut ((*pctxt).state);
                    *fresh302 = start_0;
                    tmp2 = xmlSchemaBuildAContentModel(
                        pctxt,
                        sub_0 as xmlSchemaParticlePtr,
                    );
                    if tmp2 == 1 as i32 {
                        ret = 1 as i32;
                    }
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, end_0);
                    sub_0 = (*sub_0).next;
                }
            } else {
                let mut counter_2: i32 = 0;
                let mut hop_0: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
                let mut base: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
                let mut maxOccurs_0: i32 = if (*particle).maxOccurs
                    == (1 as i32) << 30 as i32
                {
                    (1 as i32) << 30 as i32
                } else {
                    (*particle).maxOccurs - 1 as i32
                };
                let mut minOccurs_0: i32 = if (*particle).minOccurs
                    < 1 as i32
                {
                    0 as i32
                } else {
                    (*particle).minOccurs - 1 as i32
                };
                counter_2 = xmlAutomataNewCounter((*pctxt).am, minOccurs_0, maxOccurs_0);
                hop_0 = xmlAutomataNewState((*pctxt).am);
                base = xmlAutomataNewState((*pctxt).am);
                sub_0 = (*(*particle).children).children;
                while !sub_0.is_null() {
                    let fresh303 = &mut ((*pctxt).state);
                    *fresh303 = base;
                    tmp2 = xmlSchemaBuildAContentModel(
                        pctxt,
                        sub_0 as xmlSchemaParticlePtr,
                    );
                    if tmp2 == 1 as i32 {
                        ret = 1 as i32;
                    }
                    xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, hop_0);
                    sub_0 = (*sub_0).next;
                }
                xmlAutomataNewEpsilon((*pctxt).am, start_0, base);
                xmlAutomataNewCountedTrans((*pctxt).am, hop_0, base, counter_2);
                xmlAutomataNewCounterTrans((*pctxt).am, hop_0, end_0, counter_2);
                if ret == 1 as i32 {
                    xmlAutomataNewEpsilon((*pctxt).am, base, end_0);
                }
            }
            if (*particle).minOccurs == 0 as i32 {
                xmlAutomataNewEpsilon((*pctxt).am, start_0, end_0);
                ret = 1 as i32;
            }
            let fresh304 = &mut ((*pctxt).state);
            *fresh304 = end_0;
        }
        8 => {
            let mut start_1: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            let mut tmp_1: xmlAutomataStatePtr = 0 as *mut xmlAutomataState;
            let mut sub_1: xmlSchemaParticlePtr = 0 as *mut xmlSchemaParticle;
            let mut elemDecl: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
            ret = 1 as i32;
            sub_1 = (*(*particle).children).children as xmlSchemaParticlePtr;
            if !sub_1.is_null() {
                ret = 0 as i32;
                start_1 = (*pctxt).state;
                tmp_1 = xmlAutomataNewState((*pctxt).am);
                xmlAutomataNewEpsilon((*pctxt).am, (*pctxt).state, tmp_1);
                let fresh305 = &mut ((*pctxt).state);
                *fresh305 = tmp_1;
                while !sub_1.is_null() {
                    let fresh306 = &mut ((*pctxt).state);
                    *fresh306 = tmp_1;
                    elemDecl = (*sub_1).children as xmlSchemaElementPtr;
                    if elemDecl.is_null() {
                        xmlSchemaInternalErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaBuildAContentModel\0" as *const u8
                                as *const i8,
                            b"<element> particle has no term\0" as *const u8
                                as *const i8,
                        );
                        return ret;
                    }
                    if (*elemDecl).flags & (1 as i32) << 17 as i32 != 0 {
                        let mut counter_3: i32 = 0;
                        counter_3 = xmlAutomataNewCounter(
                            (*pctxt).am,
                            (*sub_1).minOccurs,
                            (*sub_1).maxOccurs,
                        );
                        xmlSchemaBuildContentModelForSubstGroup(
                            pctxt,
                            sub_1,
                            counter_3,
                            (*pctxt).state,
                        );
                    } else if (*sub_1).minOccurs == 1 as i32
                            && (*sub_1).maxOccurs == 1 as i32
                        {
                        xmlAutomataNewOnceTrans2(
                            (*pctxt).am,
                            (*pctxt).state,
                            (*pctxt).state,
                            (*elemDecl).name,
                            (*elemDecl).targetNamespace,
                            1 as i32,
                            1 as i32,
                            elemDecl as *mut libc::c_void,
                        );
                    } else if (*sub_1).minOccurs == 0 as i32
                            && (*sub_1).maxOccurs == 1 as i32
                        {
                        xmlAutomataNewCountTrans2(
                            (*pctxt).am,
                            (*pctxt).state,
                            (*pctxt).state,
                            (*elemDecl).name,
                            (*elemDecl).targetNamespace,
                            0 as i32,
                            1 as i32,
                            elemDecl as *mut libc::c_void,
                        );
                    }
                    sub_1 = (*sub_1).next as xmlSchemaParticlePtr;
                }
                let fresh307 = &mut ((*pctxt).state);
                *fresh307 = xmlAutomataNewAllTrans(
                    (*pctxt).am,
                    (*pctxt).state,
                    0 as xmlAutomataStatePtr,
                    0 as i32,
                );
                if (*particle).minOccurs == 0 as i32 {
                    xmlAutomataNewEpsilon((*pctxt).am, start_1, (*pctxt).state);
                    ret = 1 as i32;
                }
            }
        }
        17 => {
            ret = 1 as i32;
        }
        _ => {
            xmlSchemaInternalErr2(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaBuildAContentModel\0" as *const u8 as *const i8,
                b"found unexpected term of type '%s' in content model\0" as *const u8
                    as *const i8,
                xmlSchemaGetComponentTypeStr(
                    (*particle).children as xmlSchemaBasicItemPtr,
                ),
                0 as *const xmlChar,
            );
            return ret;
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaBuildContentModel(
    mut type_0: xmlSchemaTypePtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) {
    if (*type_0).type_0 as u32
        != XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        || !((*type_0).contModel).is_null()
        || (*type_0).contentType as u32
            != XML_SCHEMA_CONTENT_ELEMENTS as i32 as u32
            && (*type_0).contentType as u32
                != XML_SCHEMA_CONTENT_MIXED as i32 as u32
    {
        return;
    }
    let fresh308 = &mut ((*ctxt).am);
    *fresh308 = 0 as xmlAutomataPtr;
    let fresh309 = &mut ((*ctxt).am);
    *fresh309 = xmlNewAutomata();
    if ((*ctxt).am).is_null() {
        (*__xmlGenericError())
            .expect(
                "non-null function pointer",
            )(
            *__xmlGenericErrorContext(),
            b"Cannot create automata for complex type %s\n\0" as *const u8
                as *const i8,
            (*type_0).name,
        );
        return;
    }
    let fresh310 = &mut ((*ctxt).state);
    *fresh310 = xmlAutomataGetInitState((*ctxt).am);
    xmlSchemaBuildAContentModel(ctxt, (*type_0).subtypes as xmlSchemaParticlePtr);
    xmlAutomataSetFinalState((*ctxt).am, (*ctxt).state);
    let fresh311 = &mut ((*type_0).contModel);
    *fresh311 = xmlAutomataCompile((*ctxt).am);
    if ((*type_0).contModel).is_null() {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_INTERNAL,
            type_0 as xmlSchemaBasicItemPtr,
            (*type_0).node,
            b"Failed to compile the content model\0" as *const u8 as *const i8,
            0 as *const xmlChar,
        );
    } else if xmlRegexpIsDeterminist((*type_0).contModel) != 1 as i32 {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_NOT_DETERMINISTIC,
            type_0 as xmlSchemaBasicItemPtr,
            (*type_0).node,
            b"The content model is not determinist\0" as *const u8
                as *const i8,
            0 as *const xmlChar,
        );
    }
    let fresh312 = &mut ((*ctxt).state);
    *fresh312 = 0 as xmlAutomataStatePtr;
    xmlFreeAutomata((*ctxt).am);
    let fresh313 = &mut ((*ctxt).am);
    *fresh313 = 0 as xmlAutomataPtr;
}
unsafe extern "C" fn xmlSchemaResolveElementReferences(
    mut elemDecl: xmlSchemaElementPtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) {
    if ctxt.is_null() || elemDecl.is_null()
        || !elemDecl.is_null()
            && (*elemDecl).flags & (1 as i32) << 8 as i32 != 0
    {
        return;
    }
    (*elemDecl).flags |= (1 as i32) << 8 as i32;
    if ((*elemDecl).subtypes).is_null() && !((*elemDecl).namedType).is_null() {
        let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        type_0 = xmlSchemaGetType(
            (*ctxt).schema,
            (*elemDecl).namedType,
            (*elemDecl).namedTypeNs,
        );
        if type_0.is_null() {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                elemDecl as xmlSchemaBasicItemPtr,
                (*elemDecl).node,
                b"type\0" as *const u8 as *const i8,
                (*elemDecl).namedType,
                (*elemDecl).namedTypeNs,
                XML_SCHEMA_TYPE_BASIC,
                b"type definition\0" as *const u8 as *const i8,
            );
        } else {
            let fresh314 = &mut ((*elemDecl).subtypes);
            *fresh314 = type_0;
        }
    }
    if !((*elemDecl).substGroup).is_null() {
        let mut substHead: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
        substHead = xmlSchemaGetElem(
            (*ctxt).schema,
            (*elemDecl).substGroup,
            (*elemDecl).substGroupNs,
        );
        if substHead.is_null() {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                elemDecl as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"substitutionGroup\0" as *const u8 as *const i8,
                (*elemDecl).substGroup,
                (*elemDecl).substGroupNs,
                XML_SCHEMA_TYPE_ELEMENT,
                0 as *const i8,
            );
        } else {
            xmlSchemaResolveElementReferences(substHead, ctxt);
            let fresh315 = &mut ((*elemDecl).refDecl);
            *fresh315 = substHead;
            if ((*elemDecl).subtypes).is_null() {
                let fresh316 = &mut ((*elemDecl).subtypes);
                *fresh316 = (*substHead).subtypes;
            }
        }
    }
    if ((*elemDecl).subtypes).is_null() && ((*elemDecl).namedType).is_null()
        && ((*elemDecl).substGroup).is_null()
    {
        let fresh317 = &mut ((*elemDecl).subtypes);
        *fresh317 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
    }
}
unsafe extern "C" fn xmlSchemaResolveUnionMemberTypes(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> i32 {
    let mut link: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut lastLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut newLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut memberType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    link = (*type_0).memberTypes;
    lastLink = 0 as xmlSchemaTypeLinkPtr;
    while !link.is_null() {
        let mut name: *const xmlChar = 0 as *const xmlChar;
        let mut nsName: *const xmlChar = 0 as *const xmlChar;
        name = (*((*link).type_0 as xmlSchemaQNameRefPtr)).name;
        nsName = (*((*link).type_0 as xmlSchemaQNameRefPtr)).targetNamespace;
        memberType = xmlSchemaGetType((*ctxt).schema, name, nsName);
        if memberType.is_null()
            || !((*memberType).type_0 as u32
                == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                || (*memberType).type_0 as u32
                    == XML_SCHEMA_TYPE_BASIC as i32 as u32
                    && (*memberType).builtInType != XML_SCHEMAS_ANYTYPE as i32)
        {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                type_0 as xmlSchemaBasicItemPtr,
                (*type_0).node,
                b"memberTypes\0" as *const u8 as *const i8,
                name,
                nsName,
                XML_SCHEMA_TYPE_SIMPLE,
                0 as *const i8,
            );
            if lastLink.is_null() {
                let fresh318 = &mut ((*type_0).memberTypes);
                *fresh318 = (*link).next;
            } else {
                let fresh319 = &mut ((*lastLink).next);
                *fresh319 = (*link).next;
            }
            newLink = link;
            link = (*link).next;
            xmlFree.expect("non-null function pointer")(newLink as *mut libc::c_void);
        } else {
            let fresh320 = &mut ((*link).type_0);
            *fresh320 = memberType;
            lastLink = link;
            link = (*link).next;
        }
    }
    memberType = (*type_0).subtypes;
    while !memberType.is_null() {
        link = xmlMalloc
            .expect(
                "non-null function pointer",
            )(::std::mem::size_of::<xmlSchemaTypeLink>() as u64)
            as xmlSchemaTypeLinkPtr;
        if link.is_null() {
            xmlSchemaPErrMemory(
                ctxt,
                b"allocating a type link\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
        let fresh321 = &mut ((*link).type_0);
        *fresh321 = memberType;
        let fresh322 = &mut ((*link).next);
        *fresh322 = 0 as *mut _xmlSchemaTypeLink;
        if lastLink.is_null() {
            let fresh323 = &mut ((*type_0).memberTypes);
            *fresh323 = link;
        } else {
            let fresh324 = &mut ((*lastLink).next);
            *fresh324 = link;
        }
        lastLink = link;
        memberType = (*memberType).next;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaIsDerivedFromBuiltInType(
    mut type_0: xmlSchemaTypePtr,
    mut valType: i32,
) -> i32 {
    if type_0.is_null() {
        return 0 as i32;
    }
    if (*type_0).type_0 as u32
        == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        || (*type_0).builtInType == XML_SCHEMAS_ANYTYPE as i32
    {
        return 0 as i32;
    }
    if (*type_0).type_0 as u32
        == XML_SCHEMA_TYPE_BASIC as i32 as u32
    {
        if (*type_0).builtInType == valType {
            return 1 as i32;
        }
        if (*type_0).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as i32
            || (*type_0).builtInType == XML_SCHEMAS_ANYTYPE as i32
        {
            return 0 as i32;
        }
        return xmlSchemaIsDerivedFromBuiltInType((*type_0).subtypes, valType);
    }
    return xmlSchemaIsDerivedFromBuiltInType((*type_0).subtypes, valType);
}
unsafe extern "C" fn xmlSchemaGetPrimitiveType(
    mut type_0: xmlSchemaTypePtr,
) -> xmlSchemaTypePtr {
    while !type_0.is_null() {
        if (*type_0).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as i32
            || (*type_0).flags & (1 as i32) << 14 as i32 != 0
        {
            return type_0;
        }
        type_0 = (*type_0).baseType;
    }
    return 0 as xmlSchemaTypePtr;
}
unsafe extern "C" fn xmlSchemaCloneWildcardNsConstraints(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut dest: xmlSchemaWildcardPtr,
    mut source: xmlSchemaWildcardPtr,
) -> i32 {
    let mut cur: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut tmp: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut last: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    if source.is_null() || dest.is_null() {
        return -(1 as i32);
    }
    (*dest).any = (*source).any;
    cur = (*source).nsSet;
    last = 0 as xmlSchemaWildcardNsPtr;
    while !cur.is_null() {
        tmp = xmlSchemaNewWildcardNsConstraint(ctxt);
        if tmp.is_null() {
            return -(1 as i32);
        }
        let fresh325 = &mut ((*tmp).value);
        *fresh325 = (*cur).value;
        if last.is_null() {
            let fresh326 = &mut ((*dest).nsSet);
            *fresh326 = tmp;
        } else {
            let fresh327 = &mut ((*last).next);
            *fresh327 = tmp;
        }
        last = tmp;
        cur = (*cur).next;
    }
    if !((*dest).negNsSet).is_null() {
        xmlSchemaFreeWildcardNsSet((*dest).negNsSet);
    }
    if !((*source).negNsSet).is_null() {
        let fresh328 = &mut ((*dest).negNsSet);
        *fresh328 = xmlSchemaNewWildcardNsConstraint(ctxt);
        if ((*dest).negNsSet).is_null() {
            return -(1 as i32);
        }
        let fresh329 = &mut ((*(*dest).negNsSet).value);
        *fresh329 = (*(*source).negNsSet).value;
    } else {
        let fresh330 = &mut ((*dest).negNsSet);
        *fresh330 = 0 as xmlSchemaWildcardNsPtr;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaUnionWildcards(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut completeWild: xmlSchemaWildcardPtr,
    mut curWild: xmlSchemaWildcardPtr,
) -> i32 {
    let mut cur: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut curB: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut tmp: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    if (*completeWild).any == (*curWild).any
        && ((*completeWild).nsSet == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr)
            as i32
            == ((*curWild).nsSet == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr)
                as i32
        && ((*completeWild).negNsSet == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr)
            as i32
            == ((*curWild).negNsSet == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr)
                as i32
    {
        if ((*completeWild).negNsSet).is_null()
            || (*(*completeWild).negNsSet).value == (*(*curWild).negNsSet).value
        {
            if !((*completeWild).nsSet).is_null() {
                let mut found: i32 = 0 as i32;
                cur = (*completeWild).nsSet;
                while !cur.is_null() {
                    found = 0 as i32;
                    curB = (*curWild).nsSet;
                    while !curB.is_null() {
                        if (*cur).value == (*curB).value {
                            found = 1 as i32;
                            break;
                        } else {
                            curB = (*curB).next;
                        }
                    }
                    if found == 0 {
                        break;
                    }
                    cur = (*cur).next;
                }
                if found != 0 {
                    return 0 as i32;
                }
            } else {
                return 0 as i32
            }
        }
    }
    if (*completeWild).any != (*curWild).any {
        if (*completeWild).any == 0 as i32 {
            (*completeWild).any = 1 as i32;
            if !((*completeWild).nsSet).is_null() {
                xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                let fresh331 = &mut ((*completeWild).nsSet);
                *fresh331 = 0 as xmlSchemaWildcardNsPtr;
            }
            if !((*completeWild).negNsSet).is_null() {
                xmlFree
                    .expect(
                        "non-null function pointer",
                    )((*completeWild).negNsSet as *mut libc::c_void);
                let fresh332 = &mut ((*completeWild).negNsSet);
                *fresh332 = 0 as xmlSchemaWildcardNsPtr;
            }
        }
        return 0 as i32;
    }
    if !((*completeWild).nsSet).is_null() && !((*curWild).nsSet).is_null() {
        let mut found_0: i32 = 0;
        let mut start: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
        cur = (*curWild).nsSet;
        start = (*completeWild).nsSet;
        while !cur.is_null() {
            found_0 = 0 as i32;
            curB = start;
            while !curB.is_null() {
                if (*cur).value == (*curB).value {
                    found_0 = 1 as i32;
                    break;
                } else {
                    curB = (*curB).next;
                }
            }
            if found_0 == 0 {
                tmp = xmlSchemaNewWildcardNsConstraint(ctxt);
                if tmp.is_null() {
                    return -(1 as i32);
                }
                let fresh333 = &mut ((*tmp).value);
                *fresh333 = (*cur).value;
                let fresh334 = &mut ((*tmp).next);
                *fresh334 = (*completeWild).nsSet;
                let fresh335 = &mut ((*completeWild).nsSet);
                *fresh335 = tmp;
            }
            cur = (*cur).next;
        }
        return 0 as i32;
    }
    if !((*completeWild).negNsSet).is_null() && !((*curWild).negNsSet).is_null()
        && (*(*completeWild).negNsSet).value != (*(*curWild).negNsSet).value
    {
        let fresh336 = &mut ((*(*completeWild).negNsSet).value);
        *fresh336 = 0 as *const xmlChar;
        return 0 as i32;
    }
    if !((*completeWild).negNsSet).is_null()
        && !((*(*completeWild).negNsSet).value).is_null()
        && !((*curWild).nsSet).is_null()
        || !((*curWild).negNsSet).is_null() && !((*(*curWild).negNsSet).value).is_null()
            && !((*completeWild).nsSet).is_null()
    {
        let mut nsFound: i32 = 0;
        let mut absentFound: i32 = 0 as i32;
        if !((*completeWild).nsSet).is_null() {
            cur = (*completeWild).nsSet;
            curB = (*curWild).negNsSet;
        } else {
            cur = (*curWild).nsSet;
            curB = (*completeWild).negNsSet;
        }
        nsFound = 0 as i32;
        while !cur.is_null() {
            if ((*cur).value).is_null() {
                absentFound = 1 as i32;
            } else if (*cur).value == (*curB).value {
                nsFound = 1 as i32;
            }
            if nsFound != 0 && absentFound != 0 {
                break;
            }
            cur = (*cur).next;
        }
        if nsFound != 0 && absentFound != 0 {
            (*completeWild).any = 1 as i32;
            if !((*completeWild).nsSet).is_null() {
                xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                let fresh337 = &mut ((*completeWild).nsSet);
                *fresh337 = 0 as xmlSchemaWildcardNsPtr;
            }
            if !((*completeWild).negNsSet).is_null() {
                xmlFree
                    .expect(
                        "non-null function pointer",
                    )((*completeWild).negNsSet as *mut libc::c_void);
                let fresh338 = &mut ((*completeWild).negNsSet);
                *fresh338 = 0 as xmlSchemaWildcardNsPtr;
            }
        } else if nsFound != 0 && absentFound == 0 {
            if !((*completeWild).nsSet).is_null() {
                xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                let fresh339 = &mut ((*completeWild).nsSet);
                *fresh339 = 0 as xmlSchemaWildcardNsPtr;
            }
            if ((*completeWild).negNsSet).is_null() {
                let fresh340 = &mut ((*completeWild).negNsSet);
                *fresh340 = xmlSchemaNewWildcardNsConstraint(ctxt);
                if ((*completeWild).negNsSet).is_null() {
                    return -(1 as i32);
                }
            }
            let fresh341 = &mut ((*(*completeWild).negNsSet).value);
            *fresh341 = 0 as *const xmlChar;
        } else if nsFound == 0 && absentFound != 0 {
            xmlSchemaPErr(
                ctxt,
                (*completeWild).node,
                XML_SCHEMAP_UNION_NOT_EXPRESSIBLE as i32,
                b"The union of the wildcard is not expressible.\n\0" as *const u8
                    as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return XML_SCHEMAP_UNION_NOT_EXPRESSIBLE as i32;
        } else {
            if nsFound == 0 && absentFound == 0 {
                if ((*completeWild).negNsSet).is_null() {
                    if !((*completeWild).nsSet).is_null() {
                        xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                        let fresh342 = &mut ((*completeWild).nsSet);
                        *fresh342 = 0 as xmlSchemaWildcardNsPtr;
                    }
                    let fresh343 = &mut ((*completeWild).negNsSet);
                    *fresh343 = xmlSchemaNewWildcardNsConstraint(ctxt);
                    if ((*completeWild).negNsSet).is_null() {
                        return -(1 as i32);
                    }
                    let fresh344 = &mut ((*(*completeWild).negNsSet).value);
                    *fresh344 = (*(*curWild).negNsSet).value;
                }
            }
        }
        return 0 as i32;
    }
    if !((*completeWild).negNsSet).is_null()
        && ((*(*completeWild).negNsSet).value).is_null() && !((*curWild).nsSet).is_null()
        || !((*curWild).negNsSet).is_null() && ((*(*curWild).negNsSet).value).is_null()
            && !((*completeWild).nsSet).is_null()
    {
        if !((*completeWild).nsSet).is_null() {
            cur = (*completeWild).nsSet;
        } else {
            cur = (*curWild).nsSet;
        }
        while !cur.is_null() {
            if ((*cur).value).is_null() {
                (*completeWild).any = 1 as i32;
                if !((*completeWild).nsSet).is_null() {
                    xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                    let fresh345 = &mut ((*completeWild).nsSet);
                    *fresh345 = 0 as xmlSchemaWildcardNsPtr;
                }
                if !((*completeWild).negNsSet).is_null() {
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )((*completeWild).negNsSet as *mut libc::c_void);
                    let fresh346 = &mut ((*completeWild).negNsSet);
                    *fresh346 = 0 as xmlSchemaWildcardNsPtr;
                }
                return 0 as i32;
            }
            cur = (*cur).next;
        }
        if ((*completeWild).negNsSet).is_null() {
            if !((*completeWild).nsSet).is_null() {
                xmlSchemaFreeWildcardNsSet((*completeWild).nsSet);
                let fresh347 = &mut ((*completeWild).nsSet);
                *fresh347 = 0 as xmlSchemaWildcardNsPtr;
            }
            let fresh348 = &mut ((*completeWild).negNsSet);
            *fresh348 = xmlSchemaNewWildcardNsConstraint(ctxt);
            if ((*completeWild).negNsSet).is_null() {
                return -(1 as i32);
            }
            let fresh349 = &mut ((*(*completeWild).negNsSet).value);
            *fresh349 = 0 as *const xmlChar;
        }
        return 0 as i32;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaIntersectWildcards(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut completeWild: xmlSchemaWildcardPtr,
    mut curWild: xmlSchemaWildcardPtr,
) -> i32 {
    let mut cur: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut curB: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut prev: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    let mut tmp: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
    if (*completeWild).any == (*curWild).any
        && ((*completeWild).nsSet == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr)
            as i32
            == ((*curWild).nsSet == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr)
                as i32
        && ((*completeWild).negNsSet == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr)
            as i32
            == ((*curWild).negNsSet == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr)
                as i32
    {
        if ((*completeWild).negNsSet).is_null()
            || (*(*completeWild).negNsSet).value == (*(*curWild).negNsSet).value
        {
            if !((*completeWild).nsSet).is_null() {
                let mut found: i32 = 0 as i32;
                cur = (*completeWild).nsSet;
                while !cur.is_null() {
                    found = 0 as i32;
                    curB = (*curWild).nsSet;
                    while !curB.is_null() {
                        if (*cur).value == (*curB).value {
                            found = 1 as i32;
                            break;
                        } else {
                            curB = (*curB).next;
                        }
                    }
                    if found == 0 {
                        break;
                    }
                    cur = (*cur).next;
                }
                if found != 0 {
                    return 0 as i32;
                }
            } else {
                return 0 as i32
            }
        }
    }
    if (*completeWild).any != (*curWild).any && (*completeWild).any != 0 {
        if xmlSchemaCloneWildcardNsConstraints(ctxt, completeWild, curWild)
            == -(1 as i32)
        {
            return -(1 as i32);
        }
        return 0 as i32;
    }
    if !((*completeWild).negNsSet).is_null() && !((*curWild).nsSet).is_null()
        || !((*curWild).negNsSet).is_null() && !((*completeWild).nsSet).is_null()
    {
        let mut neg: *const xmlChar = 0 as *const xmlChar;
        if ((*completeWild).nsSet).is_null() {
            neg = (*(*completeWild).negNsSet).value;
            if xmlSchemaCloneWildcardNsConstraints(ctxt, completeWild, curWild)
                == -(1 as i32)
            {
                return -(1 as i32);
            }
        } else {
            neg = (*(*curWild).negNsSet).value;
        }
        prev = 0 as xmlSchemaWildcardNsPtr;
        cur = (*completeWild).nsSet;
        while !cur.is_null() {
            if ((*cur).value).is_null() {
                if prev.is_null() {
                    let fresh350 = &mut ((*completeWild).nsSet);
                    *fresh350 = (*cur).next;
                } else {
                    let fresh351 = &mut ((*prev).next);
                    *fresh351 = (*cur).next;
                }
                xmlFree.expect("non-null function pointer")(cur as *mut libc::c_void);
                break;
            } else {
                prev = cur;
                cur = (*cur).next;
            }
        }
        if !neg.is_null() {
            prev = 0 as xmlSchemaWildcardNsPtr;
            cur = (*completeWild).nsSet;
            while !cur.is_null() {
                if (*cur).value == neg {
                    if prev.is_null() {
                        let fresh352 = &mut ((*completeWild).nsSet);
                        *fresh352 = (*cur).next;
                    } else {
                        let fresh353 = &mut ((*prev).next);
                        *fresh353 = (*cur).next;
                    }
                    xmlFree
                        .expect("non-null function pointer")(cur as *mut libc::c_void);
                    break;
                } else {
                    prev = cur;
                    cur = (*cur).next;
                }
            }
        }
        return 0 as i32;
    }
    if !((*completeWild).nsSet).is_null() && !((*curWild).nsSet).is_null() {
        let mut found_0: i32 = 0;
        cur = (*completeWild).nsSet;
        prev = 0 as xmlSchemaWildcardNsPtr;
        while !cur.is_null() {
            found_0 = 0 as i32;
            curB = (*curWild).nsSet;
            while !curB.is_null() {
                if (*cur).value == (*curB).value {
                    found_0 = 1 as i32;
                    break;
                } else {
                    curB = (*curB).next;
                }
            }
            if found_0 == 0 {
                if prev.is_null() {
                    let fresh354 = &mut ((*completeWild).nsSet);
                    *fresh354 = (*cur).next;
                } else {
                    let fresh355 = &mut ((*prev).next);
                    *fresh355 = (*cur).next;
                }
                tmp = (*cur).next;
                xmlFree.expect("non-null function pointer")(cur as *mut libc::c_void);
                cur = tmp;
            } else {
                prev = cur;
                cur = (*cur).next;
            }
        }
        return 0 as i32;
    }
    if !((*completeWild).negNsSet).is_null() && !((*curWild).negNsSet).is_null()
        && (*(*completeWild).negNsSet).value != (*(*curWild).negNsSet).value
        && !((*(*completeWild).negNsSet).value).is_null()
        && !((*(*curWild).negNsSet).value).is_null()
    {
        xmlSchemaPErr(
            ctxt,
            (*completeWild).node,
            XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE as i32,
            b"The intersection of the wildcard is not expressible.\n\0" as *const u8
                as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE as i32;
    }
    if !((*completeWild).negNsSet).is_null() && !((*curWild).negNsSet).is_null()
        && (*(*completeWild).negNsSet).value != (*(*curWild).negNsSet).value
        && ((*(*completeWild).negNsSet).value).is_null()
    {
        let fresh356 = &mut ((*(*completeWild).negNsSet).value);
        *fresh356 = (*(*curWild).negNsSet).value;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaCheckCOSNSSubset(
    mut sub: xmlSchemaWildcardPtr,
    mut super_0: xmlSchemaWildcardPtr,
) -> i32 {
    if (*super_0).any != 0 {
        return 0 as i32;
    }
    if !((*sub).negNsSet).is_null() && !((*super_0).negNsSet).is_null()
        && (*(*sub).negNsSet).value == (*(*super_0).negNsSet).value
    {
        return 0 as i32;
    }
    if !((*sub).nsSet).is_null() {
        if !((*super_0).nsSet).is_null() {
            let mut cur: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
            let mut curB: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
            let mut found: i32 = 0 as i32;
            cur = (*sub).nsSet;
            while !cur.is_null() {
                found = 0 as i32;
                curB = (*super_0).nsSet;
                while !curB.is_null() {
                    if (*cur).value == (*curB).value {
                        found = 1 as i32;
                        break;
                    } else {
                        curB = (*curB).next;
                    }
                }
                if found == 0 {
                    return 1 as i32;
                }
                cur = (*cur).next;
            }
            if found != 0 {
                return 0 as i32;
            }
        } else if !((*super_0).negNsSet).is_null() {
            let mut cur_0: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
            cur_0 = (*sub).nsSet;
            while !cur_0.is_null() {
                if (*cur_0).value == (*(*super_0).negNsSet).value {
                    return 1 as i32;
                }
                cur_0 = (*cur_0).next;
            }
            return 0 as i32;
        }
    }
    return 1 as i32;
}
unsafe extern "C" fn xmlSchemaGetEffectiveValueConstraint(
    mut attruse: xmlSchemaAttributeUsePtr,
    mut fixed: *mut i32,
    mut value: *mut *const xmlChar,
    mut val: *mut xmlSchemaValPtr,
) -> i32 {
    *fixed = 0 as i32;
    *value = 0 as *const xmlChar;
    if !val.is_null() {
        *val = 0 as xmlSchemaValPtr;
    }
    if !((*attruse).defValue).is_null() {
        *value = (*attruse).defValue;
        if !val.is_null() {
            *val = (*attruse).defVal;
        }
        if (*attruse).flags & (1 as i32) << 0 as i32 != 0 {
            *fixed = 1 as i32;
        }
        return 1 as i32;
    } else {
        if !((*attruse).attrDecl).is_null()
            && !((*(*attruse).attrDecl).defValue).is_null()
        {
            *value = (*(*attruse).attrDecl).defValue;
            if !val.is_null() {
                *val = (*(*attruse).attrDecl).defVal;
            }
            if (*(*attruse).attrDecl).flags & (1 as i32) << 9 as i32 != 0
            {
                *fixed = 1 as i32;
            }
            return 1 as i32;
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaCheckCVCWildcardNamespace(
    mut wild: xmlSchemaWildcardPtr,
    mut ns: *const xmlChar,
) -> i32 {
    if wild.is_null() {
        return -(1 as i32);
    }
    if (*wild).any != 0 {
        return 0 as i32
    } else {
        if !((*wild).nsSet).is_null() {
            let mut cur: xmlSchemaWildcardNsPtr = 0 as *mut xmlSchemaWildcardNs;
            cur = (*wild).nsSet;
            while !cur.is_null() {
                if xmlStrEqual((*cur).value, ns) != 0 {
                    return 0 as i32;
                }
                cur = (*cur).next;
            }
        } else if !((*wild).negNsSet).is_null() && !ns.is_null()
                && xmlStrEqual((*(*wild).negNsSet).value, ns) == 0
            {
            return 0 as i32
        }
    }
    return 1 as i32;
}
unsafe extern "C" fn xmlSchemaCheckDerivationOKRestriction2to4(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut action: i32,
    mut item: xmlSchemaBasicItemPtr,
    mut baseItem: xmlSchemaBasicItemPtr,
    mut uses: xmlSchemaItemListPtr,
    mut baseUses: xmlSchemaItemListPtr,
    mut wild: xmlSchemaWildcardPtr,
    mut baseWild: xmlSchemaWildcardPtr,
) -> i32 {
    let mut cur: xmlSchemaAttributeUsePtr = 0 as xmlSchemaAttributeUsePtr;
    let mut bcur: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
    let mut i: i32 = 0;
    let mut j: i32 = 0;
    let mut found: i32 = 0;
    let mut bEffValue: *const xmlChar = 0 as *const xmlChar;
    let mut effFixed: i32 = 0;
    if !uses.is_null() {
        i = 0 as i32;
        while i < (*uses).nbItems {
            cur = *((*uses).items).offset(i as isize) as xmlSchemaAttributeUsePtr;
            found = 0 as i32;
            if !baseUses.is_null() {
                j = 0 as i32;
                while j < (*baseUses).nbItems {
                    bcur = *((*baseUses).items).offset(j as isize)
                        as xmlSchemaAttributeUsePtr;
                    if (*(*cur).attrDecl).name == (*(*bcur).attrDecl).name
                        && (*(*cur).attrDecl).targetNamespace
                            == (*(*bcur).attrDecl).targetNamespace
                    {
                        found = 1 as i32;
                        if (*cur).occurs == 2 as i32
                            && (*bcur).occurs == 1 as i32
                        {
                            let mut str: *mut xmlChar = 0 as *mut xmlChar;
                            xmlSchemaPAttrUseErr4(
                                pctxt,
                                XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1,
                                xmlSchemaGetComponentNode(item),
                                item,
                                cur,
                                b"The 'optional' attribute use is inconsistent with the corresponding 'required' attribute use of the %s %s\0"
                                    as *const u8 as *const i8,
                                if action == 0 as i32 {
                                    b"base\0" as *const u8 as *const i8
                                        as *const xmlChar
                                } else {
                                    b"redefined\0" as *const u8 as *const i8
                                        as *const xmlChar
                                },
                                xmlSchemaGetComponentDesignation(
                                    &mut str,
                                    baseItem as *mut libc::c_void,
                                ),
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                            if !str.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(str as *mut libc::c_void);
                                str = 0 as *mut xmlChar;
                            }
                        } else if xmlSchemaCheckCOSSTDerivedOK(
                                pctxt as xmlSchemaAbstractCtxtPtr,
                                (*(*cur).attrDecl).subtypes,
                                (*(*bcur).attrDecl).subtypes,
                                0 as i32,
                            ) != 0 as i32
                            {
                            let mut strA: *mut xmlChar = 0 as *mut xmlChar;
                            let mut strB: *mut xmlChar = 0 as *mut xmlChar;
                            let mut strC: *mut xmlChar = 0 as *mut xmlChar;
                            xmlSchemaPAttrUseErr4(
                                pctxt,
                                XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2,
                                xmlSchemaGetComponentNode(item),
                                item,
                                cur,
                                b"The attribute declaration's %s is not validly derived from the corresponding %s of the attribute declaration in the %s %s\0"
                                    as *const u8 as *const i8,
                                xmlSchemaGetComponentDesignation(
                                    &mut strA,
                                    (*(*cur).attrDecl).subtypes as *mut libc::c_void,
                                ),
                                xmlSchemaGetComponentDesignation(
                                    &mut strB,
                                    (*(*bcur).attrDecl).subtypes as *mut libc::c_void,
                                ),
                                if action == 0 as i32 {
                                    b"base\0" as *const u8 as *const i8
                                        as *const xmlChar
                                } else {
                                    b"redefined\0" as *const u8 as *const i8
                                        as *const xmlChar
                                },
                                xmlSchemaGetComponentDesignation(
                                    &mut strC,
                                    baseItem as *mut libc::c_void,
                                ),
                            );
                            if !strA.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(strA as *mut libc::c_void);
                                strA = 0 as *mut xmlChar;
                            }
                            if !strB.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(strB as *mut libc::c_void);
                                strB = 0 as *mut xmlChar;
                            }
                            if !strC.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(strC as *mut libc::c_void);
                                strC = 0 as *mut xmlChar;
                            }
                        } else {
                            xmlSchemaGetEffectiveValueConstraint(
                                bcur,
                                &mut effFixed,
                                &mut bEffValue,
                                0 as *mut xmlSchemaValPtr,
                            );
                            if !bEffValue.is_null() && effFixed == 1 as i32 {
                                let mut rEffValue: *const xmlChar = 0 as *const xmlChar;
                                xmlSchemaGetEffectiveValueConstraint(
                                    bcur,
                                    &mut effFixed,
                                    &mut rEffValue,
                                    0 as *mut xmlSchemaValPtr,
                                );
                                if effFixed == 0 as i32 || !(rEffValue == bEffValue)
                                {
                                    let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                                    xmlSchemaPAttrUseErr4(
                                        pctxt,
                                        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3,
                                        xmlSchemaGetComponentNode(item),
                                        item,
                                        cur,
                                        b"The effective value constraint of the attribute use is inconsistent with its correspondent in the %s %s\0"
                                            as *const u8 as *const i8,
                                        if action == 0 as i32 {
                                            b"base\0" as *const u8 as *const i8
                                                as *const xmlChar
                                        } else {
                                            b"redefined\0" as *const u8 as *const i8
                                                as *const xmlChar
                                        },
                                        xmlSchemaGetComponentDesignation(
                                            &mut str_0,
                                            baseItem as *mut libc::c_void,
                                        ),
                                        0 as *const xmlChar,
                                        0 as *const xmlChar,
                                    );
                                    if !str_0.is_null() {
                                        xmlFree
                                            .expect(
                                                "non-null function pointer",
                                            )(str_0 as *mut libc::c_void);
                                        str_0 = 0 as *mut xmlChar;
                                    }
                                }
                            }
                        }
                        break;
                    } else {
                        j += 1;
                    }
                }
            }
            if found == 0 {
                if baseWild.is_null()
                    || xmlSchemaCheckCVCWildcardNamespace(
                        baseWild,
                        (*(*cur).attrDecl).targetNamespace,
                    ) != 0 as i32
                {
                    let mut str_1: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaPAttrUseErr4(
                        pctxt,
                        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2,
                        xmlSchemaGetComponentNode(item),
                        item,
                        cur,
                        b"Neither a matching attribute use, nor a matching wildcard exists in the %s %s\0"
                            as *const u8 as *const i8,
                        if action == 0 as i32 {
                            b"base\0" as *const u8 as *const i8
                                as *const xmlChar
                        } else {
                            b"redefined\0" as *const u8 as *const i8
                                as *const xmlChar
                        },
                        xmlSchemaGetComponentDesignation(
                            &mut str_1,
                            baseItem as *mut libc::c_void,
                        ),
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                    if !str_1.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str_1 as *mut libc::c_void);
                        str_1 = 0 as *mut xmlChar;
                    }
                }
            }
            i += 1;
        }
    }
    if !baseUses.is_null() {
        j = 0 as i32;
        while j < (*baseUses).nbItems {
            bcur = *((*baseUses).items).offset(j as isize) as xmlSchemaAttributeUsePtr;
            if !((*bcur).occurs != 1 as i32) {
                found = 0 as i32;
                if !uses.is_null() {
                    i = 0 as i32;
                    while i < (*uses).nbItems {
                        cur = *((*uses).items).offset(i as isize)
                            as xmlSchemaAttributeUsePtr;
                        if (*(*cur).attrDecl).name == (*(*bcur).attrDecl).name
                            && (*(*cur).attrDecl).targetNamespace
                                == (*(*bcur).attrDecl).targetNamespace
                        {
                            found = 1 as i32;
                            break;
                        } else {
                            i += 1;
                        }
                    }
                }
                if found == 0 {
                    let mut strA_0: *mut xmlChar = 0 as *mut xmlChar;
                    let mut strB_0: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaCustomErr4(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3,
                        0 as xmlNodePtr,
                        item,
                        b"A matching attribute use for the 'required' %s of the %s %s is missing\0"
                            as *const u8 as *const i8,
                        xmlSchemaGetComponentDesignation(
                            &mut strA_0,
                            bcur as *mut libc::c_void,
                        ),
                        if action == 0 as i32 {
                            b"base\0" as *const u8 as *const i8
                                as *const xmlChar
                        } else {
                            b"redefined\0" as *const u8 as *const i8
                                as *const xmlChar
                        },
                        xmlSchemaGetComponentDesignation(
                            &mut strB_0,
                            baseItem as *mut libc::c_void,
                        ),
                        0 as *const xmlChar,
                    );
                    if !strA_0.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(strA_0 as *mut libc::c_void);
                        strA_0 = 0 as *mut xmlChar;
                    }
                    if !strB_0.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(strB_0 as *mut libc::c_void);
                        strB_0 = 0 as *mut xmlChar;
                    }
                }
            }
            j += 1;
        }
    }
    if !wild.is_null() {
        if baseWild.is_null() {
            let mut str_2: *mut xmlChar = 0 as *mut xmlChar;
            xmlSchemaCustomErr4(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1,
                0 as xmlNodePtr,
                item,
                b"The %s has an attribute wildcard, but the %s %s '%s' does not have one\0"
                    as *const u8 as *const i8,
                xmlSchemaGetComponentTypeStr(item),
                if action == 0 as i32 {
                    b"base\0" as *const u8 as *const i8 as *const xmlChar
                } else {
                    b"redefined\0" as *const u8 as *const i8 as *const xmlChar
                },
                xmlSchemaGetComponentTypeStr(baseItem),
                xmlSchemaGetComponentQName(&mut str_2, baseItem as *mut libc::c_void),
            );
            if !str_2.is_null() {
                xmlFree.expect("non-null function pointer")(str_2 as *mut libc::c_void);
                str_2 = 0 as *mut xmlChar;
            }
            return (*pctxt).err;
        } else {
            if (*baseWild).any == 0 as i32
                && xmlSchemaCheckCOSNSSubset(wild, baseWild) != 0
            {
                let mut str_3: *mut xmlChar = 0 as *mut xmlChar;
                xmlSchemaCustomErr4(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2,
                    0 as xmlNodePtr,
                    item,
                    b"The attribute wildcard is not a valid subset of the wildcard in the %s %s '%s'\0"
                        as *const u8 as *const i8,
                    if action == 0 as i32 {
                        b"base\0" as *const u8 as *const i8 as *const xmlChar
                    } else {
                        b"redefined\0" as *const u8 as *const i8
                            as *const xmlChar
                    },
                    xmlSchemaGetComponentTypeStr(baseItem),
                    xmlSchemaGetComponentQName(
                        &mut str_3,
                        baseItem as *mut libc::c_void,
                    ),
                    0 as *const xmlChar,
                );
                if !str_3.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str_3 as *mut libc::c_void);
                    str_3 = 0 as *mut xmlChar;
                }
                return (*pctxt).err;
            }
        }
        if !((*baseItem).type_0 as u32
            == XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (*(baseItem as xmlSchemaTypePtr)).builtInType
                == XML_SCHEMAS_ANYTYPE as i32)
            && (*wild).processContents < (*baseWild).processContents
        {
            let mut str_4: *mut xmlChar = 0 as *mut xmlChar;
            xmlSchemaCustomErr4(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3,
                0 as xmlNodePtr,
                baseItem,
                b"The {process contents} of the attribute wildcard is weaker than the one in the %s %s '%s'\0"
                    as *const u8 as *const i8,
                if action == 0 as i32 {
                    b"base\0" as *const u8 as *const i8 as *const xmlChar
                } else {
                    b"redefined\0" as *const u8 as *const i8 as *const xmlChar
                },
                xmlSchemaGetComponentTypeStr(baseItem),
                xmlSchemaGetComponentQName(&mut str_4, baseItem as *mut libc::c_void),
                0 as *const xmlChar,
            );
            if !str_4.is_null() {
                xmlFree.expect("non-null function pointer")(str_4 as *mut libc::c_void);
                str_4 = 0 as *mut xmlChar;
            }
            return (*pctxt).err;
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaFixupTypeAttributeUses(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> i32 {
    let mut current_block: u64;
    let mut baseType: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
    let mut use_0: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
    let mut uses: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    let mut baseUses: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    let mut prohibs: xmlSchemaItemListPtr = 0 as xmlSchemaItemListPtr;
    if ((*type_0).baseType).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaFixupTypeAttributeUses\0" as *const u8 as *const i8,
            b"no base type\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    baseType = (*type_0).baseType;
    if (*baseType).type_0 as u32
        != XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (*baseType).flags & (1 as i32) << 22 as i32
            == 0 as i32
    {
        if xmlSchemaTypeFixup(baseType, pctxt as xmlSchemaAbstractCtxtPtr)
            == -(1 as i32)
        {
            return -(1 as i32);
        }
    }
    uses = (*type_0).attrUses as xmlSchemaItemListPtr;
    baseUses = (*baseType).attrUses as xmlSchemaItemListPtr;
    if !uses.is_null() {
        if (*type_0).flags & (1 as i32) << 2 as i32 != 0 {
            if xmlSchemaExpandAttributeGroupRefs(
                pctxt,
                type_0 as xmlSchemaBasicItemPtr,
                &mut (*type_0).attributeWildcard,
                uses,
                (*pctxt).attrProhibs,
            ) == -(1 as i32)
            {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaFixupTypeAttributeUses\0" as *const u8
                        as *const i8,
                    b"failed to expand attributes\0" as *const u8 as *const i8,
                );
            }
            if (*(*pctxt).attrProhibs).nbItems != 0 as i32 {
                prohibs = (*pctxt).attrProhibs;
            }
        } else if xmlSchemaExpandAttributeGroupRefs(
                pctxt,
                type_0 as xmlSchemaBasicItemPtr,
                &mut (*type_0).attributeWildcard,
                uses,
                0 as xmlSchemaItemListPtr,
            ) == -(1 as i32)
            {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaFixupTypeAttributeUses\0" as *const u8 as *const i8,
                b"failed to expand attributes\0" as *const u8 as *const i8,
            );
        }
    }
    if !baseUses.is_null() {
        let mut i: i32 = 0;
        let mut j: i32 = 0;
        let mut pro: xmlSchemaAttributeUseProhibPtr = 0
            as *mut xmlSchemaAttributeUseProhib;
        if (*type_0).flags & (1 as i32) << 2 as i32 != 0 {
            let mut usesCount: i32 = 0;
            let mut tmp: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
            if !uses.is_null() {
                usesCount = (*uses).nbItems;
            } else {
                usesCount = 0 as i32;
            }
            i = 0 as i32;
            loop {
                if !(i < (*baseUses).nbItems) {
                    current_block = 1874315696050160458;
                    break;
                }
                use_0 = *((*baseUses).items).offset(i as isize)
                    as xmlSchemaAttributeUsePtr;
                if !prohibs.is_null() {
                    j = 0 as i32;
                    loop {
                        if !(j < (*prohibs).nbItems) {
                            current_block = 572715077006366937;
                            break;
                        }
                        pro = *((*prohibs).items).offset(j as isize)
                            as xmlSchemaAttributeUseProhibPtr;
                        if (*(*use_0).attrDecl).name == (*pro).name
                            && (*(*use_0).attrDecl).targetNamespace
                                == (*pro).targetNamespace
                        {
                            current_block = 3275366147856559585;
                            break;
                        }
                        j += 1;
                    }
                } else {
                    current_block = 572715077006366937;
                }
                match current_block {
                    572715077006366937 => {
                        if usesCount != 0 {
                            j = 0 as i32;
                            loop {
                                if !(j < usesCount) {
                                    current_block = 11763295167351361500;
                                    break;
                                }
                                tmp = *((*uses).items).offset(j as isize)
                                    as xmlSchemaAttributeUsePtr;
                                if (*(*use_0).attrDecl).name == (*(*tmp).attrDecl).name
                                    && (*(*use_0).attrDecl).targetNamespace
                                        == (*(*tmp).attrDecl).targetNamespace
                                {
                                    current_block = 3275366147856559585;
                                    break;
                                }
                                j += 1;
                            }
                        } else {
                            current_block = 11763295167351361500;
                        }
                        match current_block {
                            3275366147856559585 => {}
                            _ => {
                                if uses.is_null() {
                                    let fresh357 = &mut ((*type_0).attrUses);
                                    *fresh357 = xmlSchemaItemListCreate() as *mut libc::c_void;
                                    if ((*type_0).attrUses).is_null() {
                                        current_block = 6737818789714211697;
                                        break;
                                    }
                                    uses = (*type_0).attrUses as xmlSchemaItemListPtr;
                                }
                                xmlSchemaItemListAddSize(
                                    uses,
                                    2 as i32,
                                    use_0 as *mut libc::c_void,
                                );
                            }
                        }
                    }
                    _ => {}
                }
                i += 1;
            }
        } else {
            i = 0 as i32;
            loop {
                if !(i < (*baseUses).nbItems) {
                    current_block = 1874315696050160458;
                    break;
                }
                use_0 = *((*baseUses).items).offset(i as isize)
                    as xmlSchemaAttributeUsePtr;
                if uses.is_null() {
                    let fresh358 = &mut ((*type_0).attrUses);
                    *fresh358 = xmlSchemaItemListCreate() as *mut libc::c_void;
                    if ((*type_0).attrUses).is_null() {
                        current_block = 6737818789714211697;
                        break;
                    }
                    uses = (*type_0).attrUses as xmlSchemaItemListPtr;
                }
                xmlSchemaItemListAddSize(
                    uses,
                    (*baseUses).nbItems,
                    use_0 as *mut libc::c_void,
                );
                i += 1;
            }
        }
    } else {
        current_block = 1874315696050160458;
    }
    match current_block {
        1874315696050160458 => {
            if !uses.is_null() {
                if (*uses).nbItems == 0 as i32 {
                    xmlSchemaItemListFree(uses);
                    let fresh359 = &mut ((*type_0).attrUses);
                    *fresh359 = 0 as *mut libc::c_void;
                }
            }
            if (*type_0).flags & (1 as i32) << 1 as i32 != 0 {
                if !((*baseType).attributeWildcard).is_null() {
                    if !((*type_0).attributeWildcard).is_null() {
                        if xmlSchemaUnionWildcards(
                            pctxt,
                            (*type_0).attributeWildcard,
                            (*baseType).attributeWildcard,
                        ) == -(1 as i32)
                        {
                            current_block = 6737818789714211697;
                        } else {
                            current_block = 9705665520141849625;
                        }
                    } else {
                        let fresh360 = &mut ((*type_0).attributeWildcard);
                        *fresh360 = (*baseType).attributeWildcard;
                        current_block = 9705665520141849625;
                    }
                } else {
                    current_block = 9705665520141849625;
                }
            } else {
                current_block = 9705665520141849625;
            }
            match current_block {
                6737818789714211697 => {}
                _ => return 0 as i32,
            }
        }
        _ => {}
    }
    return -(1 as i32);
}
unsafe extern "C" fn xmlSchemaTypeFinalContains(
    mut type_0: xmlSchemaTypePtr,
    mut final_0: i32,
) -> i32 {
    if type_0.is_null() {
        return 0 as i32;
    }
    if (*type_0).flags & final_0 != 0 {
        return 1 as i32
    } else {
        return 0 as i32
    };
}
unsafe extern "C" fn xmlSchemaGetUnionSimpleTypeMemberTypes(
    mut type_0: xmlSchemaTypePtr,
) -> xmlSchemaTypeLinkPtr {
    while !type_0.is_null()
        && (*type_0).type_0 as u32
            == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
    {
        if !((*type_0).memberTypes).is_null() {
            return (*type_0).memberTypes
        } else {
            type_0 = (*type_0).baseType;
        }
    }
    return 0 as xmlSchemaTypeLinkPtr;
}
unsafe extern "C" fn xmlSchemaGetParticleEmptiable(
    mut particle: xmlSchemaParticlePtr,
) -> i32 {
    let mut part: xmlSchemaParticlePtr = 0 as *mut xmlSchemaParticle;
    let mut emptiable: i32 = 0;
    if ((*particle).children).is_null() || (*particle).minOccurs == 0 as i32 {
        return 1 as i32;
    }
    part = (*(*particle).children).children as xmlSchemaParticlePtr;
    if part.is_null() {
        return 1 as i32;
    }
    while !part.is_null() {
        if (*(*part).children).type_0 as u32
            == XML_SCHEMA_TYPE_ELEMENT as i32 as u32
            || (*(*part).children).type_0 as u32
                == XML_SCHEMA_TYPE_ANY as i32 as u32
        {
            emptiable = ((*part).minOccurs == 0 as i32) as i32;
        } else {
            emptiable = xmlSchemaGetParticleEmptiable(part);
        }
        if (*(*particle).children).type_0 as u32
            == XML_SCHEMA_TYPE_CHOICE as i32 as u32
        {
            if emptiable != 0 {
                return 1 as i32;
            }
        } else if emptiable == 0 {
            return 0 as i32
        }
        part = (*part).next as xmlSchemaParticlePtr;
    }
    if (*(*particle).children).type_0 as u32
        == XML_SCHEMA_TYPE_CHOICE as i32 as u32
    {
        return 0 as i32
    } else {
        return 1 as i32
    };
}
unsafe extern "C" fn xmlSchemaIsParticleEmptiable(
    mut particle: xmlSchemaParticlePtr,
) -> i32 {
    if particle.is_null() || (*particle).minOccurs == 0 as i32
        || ((*particle).children).is_null()
    {
        return 1 as i32;
    }
    if (*(*particle).children).type_0 as u32
        == XML_SCHEMA_TYPE_SEQUENCE as i32 as u32
        || (*(*particle).children).type_0 as u32
            == XML_SCHEMA_TYPE_CHOICE as i32 as u32
        || (*(*particle).children).type_0 as u32
            == XML_SCHEMA_TYPE_ALL as i32 as u32
    {
        return xmlSchemaGetParticleEmptiable(particle);
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaCheckCOSSTDerivedOK(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
    mut baseType: xmlSchemaTypePtr,
    mut subset: i32,
) -> i32 {
    if type_0 == baseType {
        return 0 as i32;
    }
    if (*type_0).type_0 as u32
        != XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (*type_0).flags & (1 as i32) << 22 as i32 == 0 as i32
    {
        if xmlSchemaTypeFixup(type_0, actxt) == -(1 as i32) {
            return -(1 as i32);
        }
    }
    if (*baseType).type_0 as u32
        != XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (*baseType).flags & (1 as i32) << 22 as i32
            == 0 as i32
    {
        if xmlSchemaTypeFixup(baseType, actxt) == -(1 as i32) {
            return -(1 as i32);
        }
    }
    if subset & (1 as i32) << 0 as i32 != 0
        || xmlSchemaTypeFinalContains(
            (*type_0).baseType,
            (1 as i32) << 10 as i32,
        ) != 0
    {
        return XML_SCHEMAP_COS_ST_DERIVED_OK_2_1 as i32;
    }
    if (*type_0).baseType == baseType {
        return 0 as i32;
    }
    if !((*(*type_0).baseType).type_0 as u32
        == XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (*(*type_0).baseType).builtInType == XML_SCHEMAS_ANYTYPE as i32)
        && xmlSchemaCheckCOSSTDerivedOK(actxt, (*type_0).baseType, baseType, subset)
            == 0 as i32
    {
        return 0 as i32;
    }
    if (*baseType).type_0 as u32
        == XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (*baseType).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as i32
        && ((*type_0).flags & (1 as i32) << 6 as i32 != 0
            || (*type_0).flags & (1 as i32) << 7 as i32 != 0)
    {
        return 0 as i32;
    }
    if (*baseType).flags & (1 as i32) << 7 as i32 != 0 {
        let mut cur: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
        cur = (*baseType).memberTypes;
        while !cur.is_null() {
            if (*(*cur).type_0).type_0 as u32
                != XML_SCHEMA_TYPE_BASIC as i32 as u32
                && (*(*cur).type_0).flags & (1 as i32) << 22 as i32
                    == 0 as i32
            {
                if xmlSchemaTypeFixup((*cur).type_0, actxt) == -(1 as i32) {
                    return -(1 as i32);
                }
            }
            if xmlSchemaCheckCOSSTDerivedOK(actxt, type_0, (*cur).type_0, subset)
                == 0 as i32
            {
                return 0 as i32;
            }
            cur = (*cur).next;
        }
    }
    return XML_SCHEMAP_COS_ST_DERIVED_OK_2_2 as i32;
}
unsafe extern "C" fn xmlSchemaCheckTypeDefCircularInternal(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut ctxtType: xmlSchemaTypePtr,
    mut ancestor: xmlSchemaTypePtr,
) -> i32 {
    let mut ret: i32 = 0;
    if ancestor.is_null()
        || (*ancestor).type_0 as u32
            == XML_SCHEMA_TYPE_BASIC as i32 as u32
    {
        return 0 as i32;
    }
    if ctxtType == ancestor {
        xmlSchemaPCustomErr(
            pctxt,
            XML_SCHEMAP_ST_PROPS_CORRECT_2,
            ctxtType as xmlSchemaBasicItemPtr,
            xmlSchemaGetComponentNode(ctxtType as xmlSchemaBasicItemPtr),
            b"The definition is circular\0" as *const u8 as *const i8,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_ST_PROPS_CORRECT_2 as i32;
    }
    if (*ancestor).flags & (1 as i32) << 16 as i32 != 0 {
        return 0 as i32;
    }
    (*ancestor).flags |= (1 as i32) << 16 as i32;
    ret = xmlSchemaCheckTypeDefCircularInternal(pctxt, ctxtType, (*ancestor).baseType);
    (*ancestor).flags ^= (1 as i32) << 16 as i32;
    return ret;
}
unsafe extern "C" fn xmlSchemaCheckTypeDefCircular(
    mut item: xmlSchemaTypePtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) {
    if item.is_null()
        || (*item).type_0 as u32
            == XML_SCHEMA_TYPE_BASIC as i32 as u32
        || ((*item).baseType).is_null()
    {
        return;
    }
    xmlSchemaCheckTypeDefCircularInternal(ctxt, item, (*item).baseType);
}
unsafe extern "C" fn xmlSchemaCheckUnionTypeDefCircularRecur(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut ctxType: xmlSchemaTypePtr,
    mut members: xmlSchemaTypeLinkPtr,
) -> i32 {
    let mut member: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut memberType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    member = members;
    while !member.is_null() {
        memberType = (*member).type_0;
        while !memberType.is_null()
            && (*memberType).type_0 as u32
                != XML_SCHEMA_TYPE_BASIC as i32 as u32
        {
            if memberType == ctxType {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_SRC_SIMPLE_TYPE_4,
                    ctxType as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The union type definition is circular\0" as *const u8
                        as *const i8,
                    0 as *const xmlChar,
                );
                return XML_SCHEMAP_SRC_SIMPLE_TYPE_4 as i32;
            }
            if (*memberType).flags & (1 as i32) << 7 as i32 != 0
                && (*memberType).flags & (1 as i32) << 16 as i32
                    == 0 as i32
            {
                let mut res: i32 = 0;
                (*memberType).flags |= (1 as i32) << 16 as i32;
                res = xmlSchemaCheckUnionTypeDefCircularRecur(
                    pctxt,
                    ctxType,
                    xmlSchemaGetUnionSimpleTypeMemberTypes(memberType),
                );
                (*memberType).flags ^= (1 as i32) << 16 as i32;
                if res != 0 as i32 {
                    return res;
                }
            }
            memberType = (*memberType).baseType;
        }
        member = (*member).next;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaCheckUnionTypeDefCircular(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> i32 {
    if (*type_0).flags & (1 as i32) << 7 as i32 == 0 {
        return 0 as i32;
    }
    return xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, type_0, (*type_0).memberTypes);
}
unsafe extern "C" fn xmlSchemaResolveTypeReferences(
    mut typeDef: xmlSchemaTypePtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) {
    if typeDef.is_null() {
        return;
    }
    if ((*typeDef).baseType).is_null() {
        let fresh361 = &mut ((*typeDef).baseType);
        *fresh361 = xmlSchemaGetType((*ctxt).schema, (*typeDef).base, (*typeDef).baseNs);
        if ((*typeDef).baseType).is_null() {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                typeDef as xmlSchemaBasicItemPtr,
                (*typeDef).node,
                b"base\0" as *const u8 as *const i8,
                (*typeDef).base,
                (*typeDef).baseNs,
                XML_SCHEMA_TYPE_SIMPLE,
                0 as *const i8,
            );
            return;
        }
    }
    if (*typeDef).type_0 as u32
        == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
        || (*typeDef).type_0 as u32
            == XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (*typeDef).builtInType != XML_SCHEMAS_ANYTYPE as i32
    {
        if (*typeDef).flags & (1 as i32) << 7 as i32 != 0 {
            xmlSchemaResolveUnionMemberTypes(ctxt, typeDef);
            return;
        } else {
            if (*typeDef).flags & (1 as i32) << 6 as i32 != 0 {
                if ((*typeDef).subtypes).is_null() && !((*typeDef).base).is_null() {
                    let fresh362 = &mut ((*typeDef).subtypes);
                    *fresh362 = xmlSchemaGetType(
                        (*ctxt).schema,
                        (*typeDef).base,
                        (*typeDef).baseNs,
                    );
                    if ((*typeDef).subtypes).is_null()
                        || !((*(*typeDef).subtypes).type_0 as u32
                            == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                            || (*(*typeDef).subtypes).type_0 as u32
                                == XML_SCHEMA_TYPE_BASIC as i32 as u32
                                && (*(*typeDef).subtypes).builtInType
                                    != XML_SCHEMAS_ANYTYPE as i32)
                    {
                        let fresh363 = &mut ((*typeDef).subtypes);
                        *fresh363 = 0 as xmlSchemaTypePtr;
                        xmlSchemaPResCompAttrErr(
                            ctxt,
                            XML_SCHEMAP_SRC_RESOLVE,
                            typeDef as xmlSchemaBasicItemPtr,
                            (*typeDef).node,
                            b"itemType\0" as *const u8 as *const i8,
                            (*typeDef).base,
                            (*typeDef).baseNs,
                            XML_SCHEMA_TYPE_SIMPLE,
                            0 as *const i8,
                        );
                    }
                }
                return;
            }
        }
    } else if !((*typeDef).subtypes).is_null()
            && (*(*typeDef).subtypes).type_0 as u32
                == XML_SCHEMA_TYPE_PARTICLE as i32 as u32
            && !((*((*typeDef).subtypes as xmlSchemaParticlePtr)).children).is_null()
            && (*(*((*typeDef).subtypes as xmlSchemaParticlePtr)).children).type_0
                as u32
                == XML_SCHEMA_EXTRA_QNAMEREF as i32 as u32
        {
        let mut ref_0: xmlSchemaQNameRefPtr = (*((*typeDef).subtypes
            as xmlSchemaParticlePtr))
            .children as xmlSchemaQNameRefPtr;
        let mut groupDef: xmlSchemaModelGroupDefPtr = 0 as *mut xmlSchemaModelGroupDef;
        let fresh364 = &mut ((*((*typeDef).subtypes as xmlSchemaParticlePtr)).children);
        *fresh364 = 0 as xmlSchemaTreeItemPtr;
        groupDef = xmlSchemaGetNamedComponent(
            (*ctxt).schema,
            (*ref_0).itemType,
            (*ref_0).name,
            (*ref_0).targetNamespace,
        ) as xmlSchemaModelGroupDefPtr;
        if groupDef.is_null() {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                0 as xmlSchemaBasicItemPtr,
                xmlSchemaGetComponentNode(
                    (*typeDef).subtypes as xmlSchemaParticlePtr as xmlSchemaBasicItemPtr,
                ),
                b"ref\0" as *const u8 as *const i8,
                (*ref_0).name,
                (*ref_0).targetNamespace,
                (*ref_0).itemType,
                0 as *const i8,
            );
            let fresh365 = &mut ((*typeDef).subtypes);
            *fresh365 = 0 as xmlSchemaTypePtr;
        } else if ((*(groupDef as xmlSchemaModelGroupPtr)).children).is_null() {
            let fresh366 = &mut ((*typeDef).subtypes);
            *fresh366 = 0 as xmlSchemaTypePtr;
        } else {
            let fresh367 = &mut ((*((*typeDef).subtypes as xmlSchemaParticlePtr))
                .children);
            *fresh367 = (*(groupDef as xmlSchemaModelGroupPtr)).children;
            if (*(*(groupDef as xmlSchemaModelGroupPtr)).children).type_0 as u32
                == XML_SCHEMA_TYPE_ALL as i32 as u32
            {
                if (*((*typeDef).subtypes as xmlSchemaParticlePtr)).maxOccurs
                    != 1 as i32
                {
                    xmlSchemaCustomErr(
                        ctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_COS_ALL_LIMITED,
                        xmlSchemaGetComponentNode(
                            (*typeDef).subtypes as xmlSchemaParticlePtr
                                as xmlSchemaBasicItemPtr,
                        ),
                        0 as xmlSchemaBasicItemPtr,
                        b"The particle's {max occurs} must be 1, since the reference resolves to an 'all' model group\0"
                            as *const u8 as *const i8,
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                }
            }
        }
    }
}
unsafe extern "C" fn xmlSchemaCheckSTPropsCorrect(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> i32 {
    let mut baseType: xmlSchemaTypePtr = (*type_0).baseType;
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    if baseType.is_null() {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_ST_PROPS_CORRECT_1,
            type_0 as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"No base type existent\0" as *const u8 as *const i8,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_ST_PROPS_CORRECT_1 as i32;
    }
    if !((*baseType).type_0 as u32
        == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
        || (*baseType).type_0 as u32
            == XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (*baseType).builtInType != XML_SCHEMAS_ANYTYPE as i32)
    {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_ST_PROPS_CORRECT_1,
            type_0 as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"The base type '%s' is not a simple type\0" as *const u8
                as *const i8,
            xmlSchemaGetComponentQName(&mut str, baseType as *mut libc::c_void),
        );
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
        return XML_SCHEMAP_ST_PROPS_CORRECT_1 as i32;
    }
    if ((*type_0).flags & (1 as i32) << 6 as i32 != 0
        || (*type_0).flags & (1 as i32) << 7 as i32 != 0)
        && (*type_0).flags & (1 as i32) << 2 as i32 == 0 as i32
        && (!((*baseType).type_0 as u32
            == XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (*baseType).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as i32)
            && (*baseType).type_0 as u32
                != XML_SCHEMA_TYPE_SIMPLE as i32 as u32)
    {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_ST_PROPS_CORRECT_1,
            type_0 as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"A type, derived by list or union, must have the simple ur-type definition as base type, not '%s'\0"
                as *const u8 as *const i8,
            xmlSchemaGetComponentQName(&mut str, baseType as *mut libc::c_void),
        );
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
        return XML_SCHEMAP_ST_PROPS_CORRECT_1 as i32;
    }
    if (*type_0).flags & (1 as i32) << 8 as i32 == 0
        && (*type_0).flags & (1 as i32) << 7 as i32 == 0
        && (*type_0).flags & (1 as i32) << 6 as i32 == 0
    {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_ST_PROPS_CORRECT_1,
            type_0 as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"The variety is absent\0" as *const u8 as *const i8,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_ST_PROPS_CORRECT_1 as i32;
    }
    if xmlSchemaTypeFinalContains(baseType, (1 as i32) << 10 as i32) != 0
    {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_ST_PROPS_CORRECT_3,
            type_0 as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"The 'final' of its base type '%s' must not contain 'restriction'\0"
                as *const u8 as *const i8,
            xmlSchemaGetComponentQName(&mut str, baseType as *mut libc::c_void),
        );
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
        return XML_SCHEMAP_ST_PROPS_CORRECT_3 as i32;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaCheckCOSSTRestricts(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> i32 {
    let mut str: *mut xmlChar = 0 as *mut xmlChar;
    if (*type_0).type_0 as u32
        != XML_SCHEMA_TYPE_SIMPLE as i32 as u32
    {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaCheckCOSSTRestricts\0" as *const u8 as *const i8,
            b"given type is not a user-derived simpleType\0" as *const u8
                as *const i8,
        );
        return -(1 as i32);
    }
    if (*type_0).flags & (1 as i32) << 8 as i32 != 0 {
        let mut primitive: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        if (*(*type_0).baseType).flags & (1 as i32) << 8 as i32 == 0 {
            xmlSchemaPCustomErr(
                pctxt,
                XML_SCHEMAP_COS_ST_RESTRICTS_1_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The base type '%s' is not an atomic simple type\0" as *const u8
                    as *const i8,
                xmlSchemaGetComponentQName(
                    &mut str,
                    (*type_0).baseType as *mut libc::c_void,
                ),
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
            return XML_SCHEMAP_COS_ST_RESTRICTS_1_1 as i32;
        }
        if xmlSchemaTypeFinalContains(
            (*type_0).baseType,
            (1 as i32) << 10 as i32,
        ) != 0
        {
            xmlSchemaPCustomErr(
                pctxt,
                XML_SCHEMAP_COS_ST_RESTRICTS_1_2,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The final of its base type '%s' must not contain 'restriction'\0"
                    as *const u8 as *const i8,
                xmlSchemaGetComponentQName(
                    &mut str,
                    (*type_0).baseType as *mut libc::c_void,
                ),
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
            return XML_SCHEMAP_COS_ST_RESTRICTS_1_2 as i32;
        }
        if !((*type_0).facets).is_null() {
            let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
            let mut ok: i32 = 1 as i32;
            primitive = xmlSchemaGetPrimitiveType(type_0);
            if primitive.is_null() {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaCheckCOSSTRestricts\0" as *const u8
                        as *const i8,
                    b"failed to get primitive type\0" as *const u8 as *const i8,
                );
                return -(1 as i32);
            }
            facet = (*type_0).facets;
            loop {
                if xmlSchemaIsBuiltInTypeFacet(primitive, (*facet).type_0 as i32)
                    == 0 as i32
                {
                    ok = 0 as i32;
                    xmlSchemaPIllegalFacetAtomicErr(
                        pctxt,
                        XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1,
                        type_0,
                        primitive,
                        facet,
                    );
                }
                facet = (*facet).next;
                if facet.is_null() {
                    break;
                }
            }
            if ok == 0 as i32 {
                return XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1 as i32;
            }
        }
    } else if (*type_0).flags & (1 as i32) << 6 as i32 != 0 {
        let mut itemType: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
        itemType = (*type_0).subtypes;
        if itemType.is_null()
            || !((*itemType).type_0 as u32
                == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                || (*itemType).type_0 as u32
                    == XML_SCHEMA_TYPE_BASIC as i32 as u32
                    && (*itemType).builtInType != XML_SCHEMAS_ANYTYPE as i32)
        {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaCheckCOSSTRestricts\0" as *const u8 as *const i8,
                b"failed to evaluate the item type\0" as *const u8 as *const i8,
            );
            return -(1 as i32);
        }
        if (*itemType).type_0 as u32
            != XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (*itemType).flags & (1 as i32) << 22 as i32
                == 0 as i32
        {
            xmlSchemaTypeFixup(itemType, pctxt as xmlSchemaAbstractCtxtPtr);
        }
        if (*itemType).flags & (1 as i32) << 8 as i32 == 0
            && (*itemType).flags & (1 as i32) << 7 as i32 == 0
        {
            xmlSchemaPCustomErr(
                pctxt,
                XML_SCHEMAP_COS_ST_RESTRICTS_2_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The item type '%s' does not have a variety of atomic or union\0"
                    as *const u8 as *const i8,
                xmlSchemaGetComponentQName(&mut str, itemType as *mut libc::c_void),
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
            return XML_SCHEMAP_COS_ST_RESTRICTS_2_1 as i32;
        } else {
            if (*itemType).flags & (1 as i32) << 7 as i32 != 0 {
                let mut member: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
                member = (*itemType).memberTypes;
                while !member.is_null() {
                    if (*(*member).type_0).flags & (1 as i32) << 8 as i32
                        == 0
                    {
                        xmlSchemaPCustomErr(
                            pctxt,
                            XML_SCHEMAP_COS_ST_RESTRICTS_2_1,
                            type_0 as xmlSchemaBasicItemPtr,
                            0 as xmlNodePtr,
                            b"The item type is a union type, but the member type '%s' of this item type is not atomic\0"
                                as *const u8 as *const i8,
                            xmlSchemaGetComponentQName(
                                &mut str,
                                (*member).type_0 as *mut libc::c_void,
                            ),
                        );
                        if !str.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(str as *mut libc::c_void);
                            str = 0 as *mut xmlChar;
                        }
                        return XML_SCHEMAP_COS_ST_RESTRICTS_2_1 as i32;
                    }
                    member = (*member).next;
                }
            }
        }
        if (*(*type_0).baseType).type_0 as u32
            == XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (*(*type_0).baseType).builtInType
                == XML_SCHEMAS_ANYSIMPLETYPE as i32
        {
            let mut facet_0: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
            if xmlSchemaTypeFinalContains(
                itemType,
                (1 as i32) << 11 as i32,
            ) != 0
            {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The final of its item type '%s' must not contain 'list'\0"
                        as *const u8 as *const i8,
                    xmlSchemaGetComponentQName(&mut str, itemType as *mut libc::c_void),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1 as i32;
            }
            if !((*type_0).facets).is_null() {
                facet_0 = (*type_0).facets;
                loop {
                    if (*facet_0).type_0 as u32
                        != XML_SCHEMA_FACET_WHITESPACE as i32 as u32
                    {
                        xmlSchemaPIllegalFacetListUnionErr(
                            pctxt,
                            XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2,
                            type_0,
                            facet_0,
                        );
                        return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2 as i32;
                    }
                    facet_0 = (*facet_0).next;
                    if facet_0.is_null() {
                        break;
                    }
                }
            }
        } else {
            if (*(*type_0).baseType).flags & (1 as i32) << 6 as i32 == 0
            {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The base type '%s' must be a list type\0" as *const u8
                        as *const i8,
                    xmlSchemaGetComponentQName(
                        &mut str,
                        (*type_0).baseType as *mut libc::c_void,
                    ),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1 as i32;
            }
            if xmlSchemaTypeFinalContains(
                (*type_0).baseType,
                (1 as i32) << 10 as i32,
            ) != 0
            {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The 'final' of the base type '%s' must not contain 'restriction'\0"
                        as *const u8 as *const i8,
                    xmlSchemaGetComponentQName(
                        &mut str,
                        (*type_0).baseType as *mut libc::c_void,
                    ),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2 as i32;
            }
            let mut baseItemType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
            baseItemType = (*(*type_0).baseType).subtypes;
            if baseItemType.is_null()
                || !((*baseItemType).type_0 as u32
                    == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                    || (*baseItemType).type_0 as u32
                        == XML_SCHEMA_TYPE_BASIC as i32 as u32
                        && (*baseItemType).builtInType
                            != XML_SCHEMAS_ANYTYPE as i32)
            {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaCheckCOSSTRestricts\0" as *const u8
                        as *const i8,
                    b"failed to eval the item type of a base type\0" as *const u8
                        as *const i8,
                );
                return -(1 as i32);
            }
            if itemType != baseItemType
                && xmlSchemaCheckCOSSTDerivedOK(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    itemType,
                    baseItemType,
                    0 as i32,
                ) != 0 as i32
            {
                let mut strBIT: *mut xmlChar = 0 as *mut xmlChar;
                let mut strBT: *mut xmlChar = 0 as *mut xmlChar;
                xmlSchemaPCustomErrExt(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The item type '%s' is not validly derived from the item type '%s' of the base type '%s'\0"
                        as *const u8 as *const i8,
                    xmlSchemaGetComponentQName(&mut str, itemType as *mut libc::c_void),
                    xmlSchemaGetComponentQName(
                        &mut strBIT,
                        baseItemType as *mut libc::c_void,
                    ),
                    xmlSchemaGetComponentQName(
                        &mut strBT,
                        (*type_0).baseType as *mut libc::c_void,
                    ),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                if !strBIT.is_null() {
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(strBIT as *mut libc::c_void);
                    strBIT = 0 as *mut xmlChar;
                }
                if !strBT.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(strBT as *mut libc::c_void);
                    strBT = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3 as i32;
            }
            if !((*type_0).facets).is_null() {
                let mut facet_1: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
                let mut ok_0: i32 = 1 as i32;
                facet_1 = (*type_0).facets;
                loop {
                    match (*facet_1).type_0 as u32 {
                        1009 | 1011 | 1010 | 1008 | 1006 | 1007 => {}
                        _ => {
                            xmlSchemaPIllegalFacetListUnionErr(
                                pctxt,
                                XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4,
                                type_0,
                                facet_1,
                            );
                            ok_0 = 0 as i32;
                        }
                    }
                    facet_1 = (*facet_1).next;
                    if facet_1.is_null() {
                        break;
                    }
                }
                if ok_0 == 0 as i32 {
                    return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4 as i32;
                }
            }
        }
    } else if (*type_0).flags & (1 as i32) << 7 as i32 != 0 {
        let mut member_0: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
        member_0 = (*type_0).memberTypes;
        while !member_0.is_null() {
            if (*(*member_0).type_0).type_0 as u32
                != XML_SCHEMA_TYPE_BASIC as i32 as u32
                && (*(*member_0).type_0).flags & (1 as i32) << 22 as i32
                    == 0 as i32
            {
                xmlSchemaTypeFixup(
                    (*member_0).type_0,
                    pctxt as xmlSchemaAbstractCtxtPtr,
                );
            }
            if (*(*member_0).type_0).flags & (1 as i32) << 8 as i32 == 0
                && (*(*member_0).type_0).flags & (1 as i32) << 6 as i32
                    == 0
            {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_3_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The member type '%s' is neither an atomic, nor a list type\0"
                        as *const u8 as *const i8,
                    xmlSchemaGetComponentQName(
                        &mut str,
                        (*member_0).type_0 as *mut libc::c_void,
                    ),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_3_1 as i32;
            }
            member_0 = (*member_0).next;
        }
        if (*(*type_0).baseType).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as i32
        {
            member_0 = (*type_0).memberTypes;
            while !member_0.is_null() {
                if xmlSchemaTypeFinalContains(
                    (*member_0).type_0,
                    (1 as i32) << 12 as i32,
                ) != 0
                {
                    xmlSchemaPCustomErr(
                        pctxt,
                        XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1,
                        type_0 as xmlSchemaBasicItemPtr,
                        0 as xmlNodePtr,
                        b"The 'final' of member type '%s' contains 'union'\0"
                            as *const u8 as *const i8,
                        xmlSchemaGetComponentQName(
                            &mut str,
                            (*member_0).type_0 as *mut libc::c_void,
                        ),
                    );
                    if !str.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str as *mut libc::c_void);
                        str = 0 as *mut xmlChar;
                    }
                    return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1 as i32;
                }
                member_0 = (*member_0).next;
            }
            if !((*type_0).facetSet).is_null() {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"No facets allowed\0" as *const u8 as *const i8,
                    0 as *const xmlChar,
                );
                return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2 as i32;
            }
        } else {
            if (*(*type_0).baseType).flags & (1 as i32) << 7 as i32 == 0
            {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The base type '%s' is not a union type\0" as *const u8
                        as *const i8,
                    xmlSchemaGetComponentQName(
                        &mut str,
                        (*type_0).baseType as *mut libc::c_void,
                    ),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1 as i32;
            }
            if xmlSchemaTypeFinalContains(
                (*type_0).baseType,
                (1 as i32) << 10 as i32,
            ) != 0
            {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The 'final' of its base type '%s' must not contain 'restriction'\0"
                        as *const u8 as *const i8,
                    xmlSchemaGetComponentQName(
                        &mut str,
                        (*type_0).baseType as *mut libc::c_void,
                    ),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2 as i32;
            }
            let mut baseMember: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
            if !((*type_0).memberTypes).is_null() {
                member_0 = (*type_0).memberTypes;
                baseMember = xmlSchemaGetUnionSimpleTypeMemberTypes((*type_0).baseType);
                if member_0.is_null() && !baseMember.is_null() {
                    xmlSchemaInternalErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaCheckCOSSTRestricts\0" as *const u8
                            as *const i8,
                        b"different number of member types in base\0" as *const u8
                            as *const i8,
                    );
                }
                while !member_0.is_null() {
                    if baseMember.is_null() {
                        xmlSchemaInternalErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaCheckCOSSTRestricts\0" as *const u8
                                as *const i8,
                            b"different number of member types in base\0" as *const u8
                                as *const i8,
                        );
                    } else if (*member_0).type_0 != (*baseMember).type_0
                            && xmlSchemaCheckCOSSTDerivedOK(
                                pctxt as xmlSchemaAbstractCtxtPtr,
                                (*member_0).type_0,
                                (*baseMember).type_0,
                                0 as i32,
                            ) != 0 as i32
                        {
                        let mut strBMT: *mut xmlChar = 0 as *mut xmlChar;
                        let mut strBT_0: *mut xmlChar = 0 as *mut xmlChar;
                        xmlSchemaPCustomErrExt(
                            pctxt,
                            XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3,
                            type_0 as xmlSchemaBasicItemPtr,
                            0 as xmlNodePtr,
                            b"The member type %s is not validly derived from its corresponding member type %s of the base type %s\0"
                                as *const u8 as *const i8,
                            xmlSchemaGetComponentQName(
                                &mut str,
                                (*member_0).type_0 as *mut libc::c_void,
                            ),
                            xmlSchemaGetComponentQName(
                                &mut strBMT,
                                (*baseMember).type_0 as *mut libc::c_void,
                            ),
                            xmlSchemaGetComponentQName(
                                &mut strBT_0,
                                (*type_0).baseType as *mut libc::c_void,
                            ),
                        );
                        if !str.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(str as *mut libc::c_void);
                            str = 0 as *mut xmlChar;
                        }
                        if !strBMT.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(strBMT as *mut libc::c_void);
                            strBMT = 0 as *mut xmlChar;
                        }
                        if !strBT_0.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(strBT_0 as *mut libc::c_void);
                            strBT_0 = 0 as *mut xmlChar;
                        }
                        return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3 as i32;
                    }
                    member_0 = (*member_0).next;
                    if !baseMember.is_null() {
                        baseMember = (*baseMember).next;
                    }
                }
            }
            if !((*type_0).facets).is_null() {
                let mut facet_2: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
                let mut ok_1: i32 = 1 as i32;
                facet_2 = (*type_0).facets;
                loop {
                    if (*facet_2).type_0 as u32
                        != XML_SCHEMA_FACET_PATTERN as i32 as u32
                        && (*facet_2).type_0 as u32
                            != XML_SCHEMA_FACET_ENUMERATION as i32
                                as u32
                    {
                        xmlSchemaPIllegalFacetListUnionErr(
                            pctxt,
                            XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4,
                            type_0,
                            facet_2,
                        );
                        ok_1 = 0 as i32;
                    }
                    facet_2 = (*facet_2).next;
                    if facet_2.is_null() {
                        break;
                    }
                }
                if ok_1 == 0 as i32 {
                    return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4 as i32;
                }
            }
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaCreateVCtxtOnPCtxt(
    mut ctxt: xmlSchemaParserCtxtPtr,
) -> i32 {
    if ((*ctxt).vctxt).is_null() {
        let fresh368 = &mut ((*ctxt).vctxt);
        *fresh368 = xmlSchemaNewValidCtxt(0 as xmlSchemaPtr);
        if ((*ctxt).vctxt).is_null() {
            xmlSchemaPErr(
                ctxt,
                0 as xmlNodePtr,
                XML_SCHEMAP_INTERNAL as i32,
                b"Internal error: xmlSchemaCreateVCtxtOnPCtxt, failed to create a temp. validation context.\n\0"
                    as *const u8 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return -(1 as i32);
        }
        xmlSchemaSetValidErrors(
            (*ctxt).vctxt,
            (*ctxt).error,
            (*ctxt).warning,
            (*ctxt).errCtxt,
        );
        xmlSchemaSetValidStructuredErrors(
            (*ctxt).vctxt,
            (*ctxt).serror,
            (*ctxt).errCtxt,
        );
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaParseCheckCOSValidDefault(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut node: xmlNodePtr,
    mut type_0: xmlSchemaTypePtr,
    mut value: *const xmlChar,
    mut val: *mut xmlSchemaValPtr,
) -> i32 {
    let mut ret: i32 = 0 as i32;
    if (*type_0).type_0 as u32
        == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        || (*type_0).builtInType == XML_SCHEMAS_ANYTYPE as i32
    {
        if !((*type_0).contentType as u32
            == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
            || (*type_0).contentType as u32
                == XML_SCHEMA_CONTENT_BASIC as i32 as u32)
            && (!((*type_0).contentType as u32
                == XML_SCHEMA_CONTENT_MIXED as i32 as u32)
                || xmlSchemaIsParticleEmptiable(
                    (*type_0).subtypes as xmlSchemaParticlePtr,
                ) == 0)
        {
            xmlSchemaPCustomErr(
                pctxt,
                XML_SCHEMAP_COS_VALID_DEFAULT_2_1,
                type_0 as xmlSchemaBasicItemPtr,
                (*type_0).node,
                b"For a string to be a valid default, the type definition must be a simple type or a complex type with mixed content and a particle emptiable\0"
                    as *const u8 as *const i8,
                0 as *const xmlChar,
            );
            return XML_SCHEMAP_COS_VALID_DEFAULT_2_1 as i32;
        }
    }
    if (*type_0).type_0 as u32
        == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
        || (*type_0).type_0 as u32
            == XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (*type_0).builtInType != XML_SCHEMAS_ANYTYPE as i32
    {
        ret = xmlSchemaVCheckCVCSimpleType(
            pctxt as xmlSchemaAbstractCtxtPtr,
            node,
            type_0,
            value,
            val,
            1 as i32,
            1 as i32,
            0 as i32,
        );
    } else if (*type_0).contentType as u32
            == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
            || (*type_0).contentType as u32
                == XML_SCHEMA_CONTENT_BASIC as i32 as u32
        {
        ret = xmlSchemaVCheckCVCSimpleType(
            pctxt as xmlSchemaAbstractCtxtPtr,
            node,
            (*type_0).contentTypeDef,
            value,
            val,
            1 as i32,
            1 as i32,
            0 as i32,
        );
    } else {
        return ret
    }
    if ret < 0 as i32 {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaParseCheckCOSValidDefault\0" as *const u8 as *const i8,
            b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8
                as *const i8,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaCheckCTPropsCorrect(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> i32 {
    let mut current_block: u64;
    if !((*type_0).baseType).is_null()
        && ((*(*type_0).baseType).type_0 as u32
            == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
            || (*(*type_0).baseType).type_0 as u32
                == XML_SCHEMA_TYPE_BASIC as i32 as u32
                && (*(*type_0).baseType).builtInType
                    != XML_SCHEMAS_ANYTYPE as i32)
        && (*type_0).flags & (1 as i32) << 1 as i32 == 0 as i32
    {
        xmlSchemaCustomErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_SRC_CT_1,
            0 as xmlNodePtr,
            type_0 as xmlSchemaBasicItemPtr,
            b"If the base type is a simple type, the derivation method must be 'extension'\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_SRC_CT_1 as i32;
    }
    if !((*type_0).attrUses).is_null()
        && (*((*type_0).attrUses as xmlSchemaItemListPtr)).nbItems > 1 as i32
    {
        let mut uses: xmlSchemaItemListPtr = (*type_0).attrUses as xmlSchemaItemListPtr;
        let mut use_0: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
        let mut tmp: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
        let mut i: i32 = 0;
        let mut j: i32 = 0;
        let mut hasId: i32 = 0 as i32;
        i = (*uses).nbItems - 1 as i32;
        's_32: loop {
            if !(i >= 0 as i32) {
                current_block = 4090602189656566074;
                break;
            }
            use_0 = *((*uses).items).offset(i as isize) as xmlSchemaAttributeUsePtr;
            if i > 0 as i32 {
                j = i - 1 as i32;
                loop {
                    if !(j >= 0 as i32) {
                        current_block = 18317007320854588510;
                        break;
                    }
                    tmp = *((*uses).items).offset(j as isize)
                        as xmlSchemaAttributeUsePtr;
                    if (*(*use_0).attrDecl).name == (*(*tmp).attrDecl).name
                        && (*(*use_0).attrDecl).targetNamespace
                            == (*(*tmp).attrDecl).targetNamespace
                    {
                        let mut str: *mut xmlChar = 0 as *mut xmlChar;
                        xmlSchemaCustomErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            XML_SCHEMAP_AG_PROPS_CORRECT,
                            0 as xmlNodePtr,
                            type_0 as xmlSchemaBasicItemPtr,
                            b"Duplicate %s\0" as *const u8 as *const i8,
                            xmlSchemaGetComponentDesignation(
                                &mut str,
                                use_0 as *mut libc::c_void,
                            ),
                            0 as *const xmlChar,
                        );
                        if !str.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(str as *mut libc::c_void);
                            str = 0 as *mut xmlChar;
                        }
                        if xmlSchemaItemListRemove(uses, i) == -(1 as i32) {
                            current_block = 13937361906707278470;
                            break 's_32;
                        } else {
                            current_block = 2473556513754201174;
                            break;
                        }
                    } else {
                        j -= 1;
                    }
                }
            } else {
                current_block = 18317007320854588510;
            }
            match current_block {
                18317007320854588510 => {
                    if !((*(*use_0).attrDecl).subtypes).is_null() {
                        if xmlSchemaIsDerivedFromBuiltInType(
                            (*(*use_0).attrDecl).subtypes,
                            XML_SCHEMAS_ID as i32,
                        ) != 0
                        {
                            if hasId != 0 {
                                let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                                xmlSchemaCustomErr(
                                    pctxt as xmlSchemaAbstractCtxtPtr,
                                    XML_SCHEMAP_AG_PROPS_CORRECT,
                                    0 as xmlNodePtr,
                                    type_0 as xmlSchemaBasicItemPtr,
                                    b"There must not exist more than one attribute declaration of type 'xs:ID' (or derived from 'xs:ID'). The %s violates this constraint\0"
                                        as *const u8 as *const i8,
                                    xmlSchemaGetComponentDesignation(
                                        &mut str_0,
                                        use_0 as *mut libc::c_void,
                                    ),
                                    0 as *const xmlChar,
                                );
                                if !str_0.is_null() {
                                    xmlFree
                                        .expect(
                                            "non-null function pointer",
                                        )(str_0 as *mut libc::c_void);
                                    str_0 = 0 as *mut xmlChar;
                                }
                                if xmlSchemaItemListRemove(uses, i) == -(1 as i32) {
                                    current_block = 13937361906707278470;
                                    break;
                                }
                            }
                            hasId = 1 as i32;
                        }
                    }
                }
                _ => {}
            }
            i -= 1;
        }
        match current_block {
            4090602189656566074 => {}
            _ => return -(1 as i32),
        }
    }
    return 0 as i32;
}
 extern "C" fn xmlSchemaAreEqualTypes(
    mut typeA: xmlSchemaTypePtr,
    mut typeB: xmlSchemaTypePtr,
) -> i32 {
    if typeA.is_null() || typeB.is_null() {
        return 0 as i32;
    }
    return (typeA == typeB) as i32;
}
unsafe extern "C" fn xmlSchemaCheckCOSCTDerivedOK(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
    mut baseType: xmlSchemaTypePtr,
    mut set: i32,
) -> i32 {
    let mut equal: i32 = xmlSchemaAreEqualTypes(type_0, baseType);
    if equal == 0 {
        if set & (1 as i32) << 1 as i32 != 0
            && (*type_0).flags & (1 as i32) << 1 as i32 != 0
            || set & (1 as i32) << 0 as i32 != 0
                && (*type_0).flags & (1 as i32) << 2 as i32 != 0
        {
            return 1 as i32;
        }
    } else {
        return 0 as i32
    }
    if (*type_0).baseType == baseType {
        return 0 as i32;
    }
    if (*(*type_0).baseType).type_0 as u32
        == XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (*(*type_0).baseType).builtInType == XML_SCHEMAS_ANYTYPE as i32
    {
        return 1 as i32;
    }
    if (*(*type_0).baseType).type_0 as u32
        == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        || (*(*type_0).baseType).builtInType == XML_SCHEMAS_ANYTYPE as i32
    {
        return xmlSchemaCheckCOSCTDerivedOK(actxt, (*type_0).baseType, baseType, set)
    } else {
        return xmlSchemaCheckCOSSTDerivedOK(actxt, (*type_0).baseType, baseType, set)
    };
}
unsafe extern "C" fn xmlSchemaCheckCOSDerivedOK(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
    mut baseType: xmlSchemaTypePtr,
    mut set: i32,
) -> i32 {
    if (*type_0).type_0 as u32
        == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
        || (*type_0).type_0 as u32
            == XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (*type_0).builtInType != XML_SCHEMAS_ANYTYPE as i32
    {
        return xmlSchemaCheckCOSSTDerivedOK(actxt, type_0, baseType, set)
    } else {
        return xmlSchemaCheckCOSCTDerivedOK(actxt, type_0, baseType, set)
    };
}
unsafe extern "C" fn xmlSchemaCheckCOSCTExtends(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> i32 {
    let mut base: xmlSchemaTypePtr = (*type_0).baseType;
    if (*base).type_0 as u32
        == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        || (*base).builtInType == XML_SCHEMAS_ANYTYPE as i32
    {
        if (*base).flags & (1 as i32) << 9 as i32 != 0 {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The 'final' of the base type definition contains 'extension'\0"
                    as *const u8 as *const i8,
                0 as *const xmlChar,
            );
            return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as i32;
        }
        if !(!((*type_0).contentTypeDef).is_null()
            && (*type_0).contentTypeDef == (*base).contentTypeDef)
        {
            if !((*type_0).contentType as u32
                == XML_SCHEMA_CONTENT_EMPTY as i32 as u32
                && (*base).contentType as u32
                    == XML_SCHEMA_CONTENT_EMPTY as i32 as u32)
            {
                if ((*type_0).subtypes).is_null() {
                    xmlSchemaPCustomErr(
                        ctxt,
                        XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                        type_0 as xmlSchemaBasicItemPtr,
                        0 as xmlNodePtr,
                        b"The content type must specify a particle\0" as *const u8
                            as *const i8,
                        0 as *const xmlChar,
                    );
                    return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as i32;
                }
                if !((*base).contentType as u32
                    == XML_SCHEMA_CONTENT_EMPTY as i32 as u32)
                {
                    if (*type_0).contentType as u32
                        != (*base).contentType as u32
                        || (*type_0).contentType as u32
                            != XML_SCHEMA_CONTENT_MIXED as i32 as u32
                            && (*type_0).contentType as u32
                                != XML_SCHEMA_CONTENT_ELEMENTS as i32
                                    as u32
                    {
                        xmlSchemaPCustomErr(
                            ctxt,
                            XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                            type_0 as xmlSchemaBasicItemPtr,
                            0 as xmlNodePtr,
                            b"The content type of both, the type and its base type, must either 'mixed' or 'element-only'\0"
                                as *const u8 as *const i8,
                            0 as *const xmlChar,
                        );
                        return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as i32;
                    }
                }
            }
        }
    } else {
        if (*type_0).contentTypeDef != base {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The content type must be the simple base type\0" as *const u8
                    as *const i8,
                0 as *const xmlChar,
            );
            return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as i32;
        }
        if (*base).flags & (1 as i32) << 9 as i32 != 0 {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The 'final' of the base type definition contains 'extension'\0"
                    as *const u8 as *const i8,
                0 as *const xmlChar,
            );
            return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as i32;
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaCheckDerivationOKRestriction(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> i32 {
    let mut base: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    base = (*type_0).baseType;
    if !((*base).type_0 as u32
        == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        || (*base).builtInType == XML_SCHEMAS_ANYTYPE as i32)
    {
        xmlSchemaCustomErr(
            ctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
            (*type_0).node,
            type_0 as xmlSchemaBasicItemPtr,
            b"The base type must be a complex type\0" as *const u8
                as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*ctxt).err;
    }
    if (*base).flags & (1 as i32) << 10 as i32 != 0 {
        xmlSchemaCustomErr(
            ctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
            (*type_0).node,
            type_0 as xmlSchemaBasicItemPtr,
            b"The 'final' of the base type definition contains 'restriction'\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*ctxt).err;
    }
    if xmlSchemaCheckDerivationOKRestriction2to4(
        ctxt,
        0 as i32,
        type_0 as xmlSchemaBasicItemPtr,
        base as xmlSchemaBasicItemPtr,
        (*type_0).attrUses as xmlSchemaItemListPtr,
        (*base).attrUses as xmlSchemaItemListPtr,
        (*type_0).attributeWildcard,
        (*base).attributeWildcard,
    ) == -(1 as i32)
    {
        return -(1 as i32);
    }
    if !((*base).builtInType == XML_SCHEMAS_ANYTYPE as i32) {
        if (*type_0).contentType as u32
            == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
            || (*type_0).contentType as u32
                == XML_SCHEMA_CONTENT_BASIC as i32 as u32
        {
            if (*base).contentType as u32
                == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
                || (*base).contentType as u32
                    == XML_SCHEMA_CONTENT_BASIC as i32 as u32
            {
                let mut err: i32 = 0;
                err = xmlSchemaCheckCOSSTDerivedOK(
                    ctxt as xmlSchemaAbstractCtxtPtr,
                    (*type_0).contentTypeDef,
                    (*base).contentTypeDef,
                    0 as i32,
                );
                if err != 0 as i32 {
                    let mut strA: *mut xmlChar = 0 as *mut xmlChar;
                    let mut strB: *mut xmlChar = 0 as *mut xmlChar;
                    if err == -(1 as i32) {
                        return -(1 as i32);
                    }
                    xmlSchemaCustomErr(
                        ctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                        0 as xmlNodePtr,
                        type_0 as xmlSchemaBasicItemPtr,
                        b"The {content type} %s is not validly derived from the base type's {content type} %s\0"
                            as *const u8 as *const i8,
                        xmlSchemaGetComponentDesignation(
                            &mut strA,
                            (*type_0).contentTypeDef as *mut libc::c_void,
                        ),
                        xmlSchemaGetComponentDesignation(
                            &mut strB,
                            (*base).contentTypeDef as *mut libc::c_void,
                        ),
                    );
                    if !strA.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(strA as *mut libc::c_void);
                        strA = 0 as *mut xmlChar;
                    }
                    if !strB.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(strB as *mut libc::c_void);
                        strB = 0 as *mut xmlChar;
                    }
                    return (*ctxt).err;
                }
            } else if (*base).contentType as u32
                    == XML_SCHEMA_CONTENT_MIXED as i32 as u32
                    && xmlSchemaIsParticleEmptiable(
                        (*base).subtypes as xmlSchemaParticlePtr,
                    ) != 0
                {} else {
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The content type of the base type must be either a simple type or 'mixed' and an emptiable particle\0"
                        as *const u8 as *const i8,
                    0 as *const xmlChar,
                );
                return (*ctxt).err;
            }
        } else if (*type_0).contentType as u32
                == XML_SCHEMA_CONTENT_EMPTY as i32 as u32
            {
            if !((*base).contentType as u32
                == XML_SCHEMA_CONTENT_EMPTY as i32 as u32)
            {
                if ((*base).contentType as u32
                    == XML_SCHEMA_CONTENT_ELEMENTS as i32 as u32
                    || (*base).contentType as u32
                        == XML_SCHEMA_CONTENT_MIXED as i32 as u32)
                    && xmlSchemaIsParticleEmptiable(
                        (*base).subtypes as xmlSchemaParticlePtr,
                    ) != 0
                {} else {
                    xmlSchemaPCustomErr(
                        ctxt,
                        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                        type_0 as xmlSchemaBasicItemPtr,
                        0 as xmlNodePtr,
                        b"The content type of the base type must be either empty or 'mixed' (or 'elements-only') and an emptiable particle\0"
                            as *const u8 as *const i8,
                        0 as *const xmlChar,
                    );
                    return (*ctxt).err;
                }
            }
        } else if (*type_0).contentType as u32
                == XML_SCHEMA_CONTENT_ELEMENTS as i32 as u32
                || (*type_0).contentType as u32
                    == XML_SCHEMA_CONTENT_MIXED as i32 as u32
            {
            if (*type_0).contentType as u32
                == XML_SCHEMA_CONTENT_MIXED as i32 as u32
                && !((*base).contentType as u32
                    == XML_SCHEMA_CONTENT_MIXED as i32 as u32)
            {
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"If the content type is 'mixed', then the content type of the base type must also be 'mixed'\0"
                        as *const u8 as *const i8,
                    0 as *const xmlChar,
                );
                return (*ctxt).err;
            }
        } else {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The type is not a valid restriction of its base type\0" as *const u8
                    as *const i8,
                0 as *const xmlChar,
            );
            return (*ctxt).err;
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaCheckCTComponent(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> i32 {
    let mut ret: i32 = 0;
    ret = xmlSchemaCheckCTPropsCorrect(ctxt, type_0);
    if ret != 0 as i32 {
        return ret;
    }
    if (*type_0).flags & (1 as i32) << 1 as i32 != 0 {
        ret = xmlSchemaCheckCOSCTExtends(ctxt, type_0);
    } else {
        ret = xmlSchemaCheckDerivationOKRestriction(ctxt, type_0);
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaCheckSRCCT(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> i32 {
    let mut base: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ret: i32 = 0 as i32;
    base = (*type_0).baseType;
    if !((*type_0).contentType as u32
        == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
        || (*type_0).contentType as u32
            == XML_SCHEMA_CONTENT_BASIC as i32 as u32)
    {
        if !((*base).type_0 as u32
            == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
            || (*base).builtInType == XML_SCHEMAS_ANYTYPE as i32)
        {
            let mut str: *mut xmlChar = 0 as *mut xmlChar;
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_SRC_CT_1,
                type_0 as xmlSchemaBasicItemPtr,
                (*type_0).node,
                b"If using <complexContent>, the base type is expected to be a complex type. The base type '%s' is a simple type\0"
                    as *const u8 as *const i8,
                xmlSchemaFormatQName(&mut str, (*base).targetNamespace, (*base).name),
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
            return XML_SCHEMAP_SRC_CT_1 as i32;
        }
    } else {
        if (*base).type_0 as u32
            == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
            || (*base).type_0 as u32
                == XML_SCHEMA_TYPE_BASIC as i32 as u32
                && (*base).builtInType != XML_SCHEMAS_ANYTYPE as i32
        {
            if (*type_0).flags & (1 as i32) << 1 as i32
                == 0 as i32
            {
                let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_SRC_CT_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"If using <simpleContent> and <restriction>, the base type must be a complex type. The base type '%s' is a simple type\0"
                        as *const u8 as *const i8,
                    xmlSchemaFormatQName(
                        &mut str_0,
                        (*base).targetNamespace,
                        (*base).name,
                    ),
                );
                if !str_0.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str_0 as *mut libc::c_void);
                    str_0 = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_SRC_CT_1 as i32;
            }
        } else if (*base).contentType as u32
                == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
                || (*base).contentType as u32
                    == XML_SCHEMA_CONTENT_BASIC as i32 as u32
            {
            if ((*base).contentTypeDef).is_null() {
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_INTERNAL,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"Internal error: xmlSchemaCheckSRCCT, '%s', base type has no content type\0"
                        as *const u8 as *const i8,
                    (*type_0).name,
                );
                return -(1 as i32);
            }
        } else if (*base).contentType as u32
                == XML_SCHEMA_CONTENT_MIXED as i32 as u32
                && (*type_0).flags & (1 as i32) << 2 as i32 != 0
            {
            if xmlSchemaIsParticleEmptiable((*base).subtypes as xmlSchemaParticlePtr)
                == 0
            {
                ret = XML_SCHEMAP_SRC_CT_1 as i32;
            } else if ((*type_0).contentTypeDef).is_null() {
                let mut str_1: *mut xmlChar = 0 as *mut xmlChar;
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_SRC_CT_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"A <simpleType> is expected among the children of <restriction>, if <simpleContent> is used and the base type '%s' is a complex type\0"
                        as *const u8 as *const i8,
                    xmlSchemaFormatQName(
                        &mut str_1,
                        (*base).targetNamespace,
                        (*base).name,
                    ),
                );
                if !str_1.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str_1 as *mut libc::c_void);
                    str_1 = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_SRC_CT_1 as i32;
            }
        } else {
            ret = XML_SCHEMAP_SRC_CT_1 as i32;
        }
        if ret > 0 as i32 {
            let mut str_2: *mut xmlChar = 0 as *mut xmlChar;
            if (*type_0).flags & (1 as i32) << 2 as i32 != 0 {
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_SRC_CT_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"If <simpleContent> and <restriction> is used, the base type must be a simple type or a complex type with mixed content and particle emptiable. The base type '%s' is none of those\0"
                        as *const u8 as *const i8,
                    xmlSchemaFormatQName(
                        &mut str_2,
                        (*base).targetNamespace,
                        (*base).name,
                    ),
                );
            } else {
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_SRC_CT_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"If <simpleContent> and <extension> is used, the base type must be a simple type. The base type '%s' is a complex type\0"
                        as *const u8 as *const i8,
                    xmlSchemaFormatQName(
                        &mut str_2,
                        (*base).targetNamespace,
                        (*base).name,
                    ),
                );
            }
            if !str_2.is_null() {
                xmlFree.expect("non-null function pointer")(str_2 as *mut libc::c_void);
                str_2 = 0 as *mut xmlChar;
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaDeriveFacetErr(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut facet1: xmlSchemaFacetPtr,
    mut facet2: xmlSchemaFacetPtr,
    mut lessGreater: i32,
    mut orEqual: i32,
    mut ofBase: i32,
) {
    let mut msg: *mut xmlChar = 0 as *mut xmlChar;
    msg = xmlStrdup(b"'\0" as *const u8 as *const i8 as *mut xmlChar);
    msg = xmlStrcat(msg, xmlSchemaFacetTypeToString((*facet1).type_0));
    msg = xmlStrcat(
        msg,
        b"' has to be\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    if lessGreater == 0 as i32 {
        msg = xmlStrcat(
            msg,
            b" equal to\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    if lessGreater == 1 as i32 {
        msg = xmlStrcat(
            msg,
            b" greater than\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    } else {
        msg = xmlStrcat(
            msg,
            b" less than\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    if orEqual != 0 {
        msg = xmlStrcat(
            msg,
            b" or equal to\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    msg = xmlStrcat(msg, b" '\0" as *const u8 as *const i8 as *mut xmlChar);
    msg = xmlStrcat(msg, xmlSchemaFacetTypeToString((*facet2).type_0));
    if ofBase != 0 {
        msg = xmlStrcat(
            msg,
            b"' of the base type\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    } else {
        msg = xmlStrcat(msg, b"'\0" as *const u8 as *const i8 as *mut xmlChar);
    }
    xmlSchemaPCustomErr(
        pctxt,
        XML_SCHEMAP_INVALID_FACET_VALUE,
        facet1 as xmlSchemaBasicItemPtr,
        0 as xmlNodePtr,
        msg as *const i8,
        0 as *const xmlChar,
    );
    if !msg.is_null() {
        xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void);
    }
}
unsafe extern "C" fn xmlSchemaDeriveAndValidateFacets(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> i32 {
    let mut current_block: u64;
    let mut base: xmlSchemaTypePtr = (*type_0).baseType;
    let mut link: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
    let mut cur: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
    let mut last: xmlSchemaFacetLinkPtr = 0 as xmlSchemaFacetLinkPtr;
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut bfacet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut flength: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut ftotdig: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut ffracdig: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fmaxlen: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fminlen: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fmininc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fmaxinc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fminexc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut fmaxexc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bflength: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bftotdig: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bffracdig: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfmaxlen: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfminlen: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfmininc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfmaxinc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfminexc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut bfmaxexc: xmlSchemaFacetPtr = 0 as xmlSchemaFacetPtr;
    let mut res: i32 = 0;
    if ((*type_0).facetSet).is_null() && ((*base).facetSet).is_null() {
        return 0 as i32;
    }
    last = (*type_0).facetSet;
    if !last.is_null() {
        while !((*last).next).is_null() {
            last = (*last).next;
        }
    }
    cur = (*type_0).facetSet;
    while !cur.is_null() {
        facet = (*cur).facet;
        match (*facet).type_0 as u32 {
            1009 => {
                flength = facet;
            }
            1011 => {
                fminlen = facet;
            }
            1000 => {
                fmininc = facet;
            }
            1001 => {
                fminexc = facet;
            }
            1010 => {
                fmaxlen = facet;
            }
            1002 => {
                fmaxinc = facet;
            }
            1003 => {
                fmaxexc = facet;
            }
            1004 => {
                ftotdig = facet;
            }
            1005 => {
                ffracdig = facet;
            }
            _ => {}
        }
        cur = (*cur).next;
    }
    cur = (*base).facetSet;
    while !cur.is_null() {
        facet = (*cur).facet;
        match (*facet).type_0 as u32 {
            1009 => {
                bflength = facet;
            }
            1011 => {
                bfminlen = facet;
            }
            1000 => {
                bfmininc = facet;
            }
            1001 => {
                bfminexc = facet;
            }
            1010 => {
                bfmaxlen = facet;
            }
            1002 => {
                bfmaxinc = facet;
            }
            1003 => {
                bfmaxexc = facet;
            }
            1004 => {
                bftotdig = facet;
            }
            1005 => {
                bffracdig = facet;
            }
            _ => {}
        }
        cur = (*cur).next;
    }
    if !flength.is_null() && (!fminlen.is_null() || !fmaxlen.is_null()) {
        xmlSchemaPCustomErr(
            pctxt,
            XML_SCHEMAP_INVALID_FACET_VALUE,
            flength as xmlSchemaBasicItemPtr,
            (*flength).node,
            b"It is an error for both 'length' and either of 'minLength' or 'maxLength' to be specified on the same type definition\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
        );
    }
    if !fmaxinc.is_null() && !fmaxexc.is_null() {
        xmlSchemaPCustomErrExt(
            pctxt,
            XML_SCHEMAP_INVALID_FACET_VALUE,
            fmaxinc as xmlSchemaBasicItemPtr,
            (*fmaxinc).node,
            b"It is an error for both '%s' and '%s' to be specified on the same type definition\0"
                as *const u8 as *const i8,
            xmlSchemaFacetTypeToString((*fmaxinc).type_0) as *mut xmlChar,
            xmlSchemaFacetTypeToString((*fmaxexc).type_0) as *mut xmlChar,
            0 as *const xmlChar,
        );
    }
    if !fmininc.is_null() && !fminexc.is_null() {
        xmlSchemaPCustomErrExt(
            pctxt,
            XML_SCHEMAP_INVALID_FACET_VALUE,
            fmininc as xmlSchemaBasicItemPtr,
            (*fmininc).node,
            b"It is an error for both '%s' and '%s' to be specified on the same type definition\0"
                as *const u8 as *const i8,
            xmlSchemaFacetTypeToString((*fmininc).type_0) as *mut xmlChar,
            xmlSchemaFacetTypeToString((*fminexc).type_0) as *mut xmlChar,
            0 as *const xmlChar,
        );
    }
    if !flength.is_null() && !bflength.is_null() {
        res = xmlSchemaCompareValues((*flength).val, (*bflength).val);
        if res == -(2 as i32) {
            current_block = 6717603523453139513;
        } else {
            if res != 0 as i32 {
                xmlSchemaDeriveFacetErr(
                    pctxt,
                    flength,
                    bflength,
                    0 as i32,
                    0 as i32,
                    1 as i32,
                );
            }
            if res != 0 as i32 && (*bflength).fixed != 0 {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_INVALID_FACET_VALUE,
                    flength as xmlSchemaBasicItemPtr,
                    (*flength).node,
                    b"The base type's facet is 'fixed', thus the value must not differ\0"
                        as *const u8 as *const i8,
                    0 as *const xmlChar,
                );
            }
            current_block = 317151059986244064;
        }
    } else {
        current_block = 317151059986244064;
    }
    match current_block {
        317151059986244064 => {
            if !fminlen.is_null() && !bfminlen.is_null() {
                res = xmlSchemaCompareValues((*fminlen).val, (*bfminlen).val);
                if res == -(2 as i32) {
                    current_block = 6717603523453139513;
                } else {
                    if res == -(1 as i32) {
                        xmlSchemaDeriveFacetErr(
                            pctxt,
                            fminlen,
                            bfminlen,
                            1 as i32,
                            1 as i32,
                            1 as i32,
                        );
                    }
                    if res != 0 as i32 && (*bfminlen).fixed != 0 {
                        xmlSchemaPCustomErr(
                            pctxt,
                            XML_SCHEMAP_INVALID_FACET_VALUE,
                            fminlen as xmlSchemaBasicItemPtr,
                            (*fminlen).node,
                            b"The base type's facet is 'fixed', thus the value must not differ\0"
                                as *const u8 as *const i8,
                            0 as *const xmlChar,
                        );
                    }
                    current_block = 7385833325316299293;
                }
            } else {
                current_block = 7385833325316299293;
            }
            match current_block {
                6717603523453139513 => {}
                _ => {
                    if !fmaxlen.is_null() && !bfmaxlen.is_null() {
                        res = xmlSchemaCompareValues((*fmaxlen).val, (*bfmaxlen).val);
                        if res == -(2 as i32) {
                            current_block = 6717603523453139513;
                        } else {
                            if res == 1 as i32 {
                                xmlSchemaDeriveFacetErr(
                                    pctxt,
                                    fmaxlen,
                                    bfmaxlen,
                                    -(1 as i32),
                                    1 as i32,
                                    1 as i32,
                                );
                            }
                            if res != 0 as i32 && (*bfmaxlen).fixed != 0 {
                                xmlSchemaPCustomErr(
                                    pctxt,
                                    XML_SCHEMAP_INVALID_FACET_VALUE,
                                    fmaxlen as xmlSchemaBasicItemPtr,
                                    (*fmaxlen).node,
                                    b"The base type's facet is 'fixed', thus the value must not differ\0"
                                        as *const u8 as *const i8,
                                    0 as *const xmlChar,
                                );
                            }
                            current_block = 8732226822098929438;
                        }
                    } else {
                        current_block = 8732226822098929438;
                    }
                    match current_block {
                        6717603523453139513 => {}
                        _ => {
                            if flength.is_null() {
                                flength = bflength;
                            }
                            if !flength.is_null() {
                                if fminlen.is_null() {
                                    fminlen = bfminlen;
                                }
                                if !fminlen.is_null() {
                                    res = xmlSchemaCompareValues(
                                        (*flength).val,
                                        (*fminlen).val,
                                    );
                                    if res == -(2 as i32) {
                                        current_block = 6717603523453139513;
                                    } else {
                                        if res == -(1 as i32) {
                                            xmlSchemaDeriveFacetErr(
                                                pctxt,
                                                flength,
                                                fminlen,
                                                1 as i32,
                                                1 as i32,
                                                0 as i32,
                                            );
                                        }
                                        current_block = 2798392256336243897;
                                    }
                                } else {
                                    current_block = 2798392256336243897;
                                }
                                match current_block {
                                    6717603523453139513 => {}
                                    _ => {
                                        if fmaxlen.is_null() {
                                            fmaxlen = bfmaxlen;
                                        }
                                        if !fmaxlen.is_null() {
                                            res = xmlSchemaCompareValues(
                                                (*flength).val,
                                                (*fmaxlen).val,
                                            );
                                            if res == -(2 as i32) {
                                                current_block = 6717603523453139513;
                                            } else {
                                                if res == 1 as i32 {
                                                    xmlSchemaDeriveFacetErr(
                                                        pctxt,
                                                        flength,
                                                        fmaxlen,
                                                        -(1 as i32),
                                                        1 as i32,
                                                        0 as i32,
                                                    );
                                                }
                                                current_block = 2945622622075328793;
                                            }
                                        } else {
                                            current_block = 2945622622075328793;
                                        }
                                    }
                                }
                            } else {
                                current_block = 2945622622075328793;
                            }
                            match current_block {
                                6717603523453139513 => {}
                                _ => {
                                    if !fmaxinc.is_null() {
                                        if !fmininc.is_null() {
                                            res = xmlSchemaCompareValues(
                                                (*fmaxinc).val,
                                                (*fmininc).val,
                                            );
                                            if res == -(2 as i32) {
                                                current_block = 6717603523453139513;
                                            } else {
                                                if res == -(1 as i32) {
                                                    xmlSchemaDeriveFacetErr(
                                                        pctxt,
                                                        fmaxinc,
                                                        fmininc,
                                                        1 as i32,
                                                        1 as i32,
                                                        0 as i32,
                                                    );
                                                }
                                                current_block = 3024367268842933116;
                                            }
                                        } else {
                                            current_block = 3024367268842933116;
                                        }
                                        match current_block {
                                            6717603523453139513 => {}
                                            _ => {
                                                if !bfmaxinc.is_null() {
                                                    res = xmlSchemaCompareValues(
                                                        (*fmaxinc).val,
                                                        (*bfmaxinc).val,
                                                    );
                                                    if res == -(2 as i32) {
                                                        current_block = 6717603523453139513;
                                                    } else {
                                                        if res == 1 as i32 {
                                                            xmlSchemaDeriveFacetErr(
                                                                pctxt,
                                                                fmaxinc,
                                                                bfmaxinc,
                                                                -(1 as i32),
                                                                1 as i32,
                                                                1 as i32,
                                                            );
                                                        }
                                                        if res != 0 as i32 && (*bfmaxinc).fixed != 0 {
                                                            xmlSchemaPCustomErr(
                                                                pctxt,
                                                                XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                fmaxinc as xmlSchemaBasicItemPtr,
                                                                (*fmaxinc).node,
                                                                b"The base type's facet is 'fixed', thus the value must not differ\0"
                                                                    as *const u8 as *const i8,
                                                                0 as *const xmlChar,
                                                            );
                                                        }
                                                        current_block = 16778110326724371720;
                                                    }
                                                } else {
                                                    current_block = 16778110326724371720;
                                                }
                                                match current_block {
                                                    6717603523453139513 => {}
                                                    _ => {
                                                        if !bfmaxexc.is_null() {
                                                            res = xmlSchemaCompareValues(
                                                                (*fmaxinc).val,
                                                                (*bfmaxexc).val,
                                                            );
                                                            if res == -(2 as i32) {
                                                                current_block = 6717603523453139513;
                                                            } else {
                                                                if res != -(1 as i32) {
                                                                    xmlSchemaDeriveFacetErr(
                                                                        pctxt,
                                                                        fmaxinc,
                                                                        bfmaxexc,
                                                                        -(1 as i32),
                                                                        0 as i32,
                                                                        1 as i32,
                                                                    );
                                                                }
                                                                current_block = 9180031981464905198;
                                                            }
                                                        } else {
                                                            current_block = 9180031981464905198;
                                                        }
                                                        match current_block {
                                                            6717603523453139513 => {}
                                                            _ => {
                                                                if !bfmininc.is_null() {
                                                                    res = xmlSchemaCompareValues(
                                                                        (*fmaxinc).val,
                                                                        (*bfmininc).val,
                                                                    );
                                                                    if res == -(2 as i32) {
                                                                        current_block = 6717603523453139513;
                                                                    } else {
                                                                        if res == -(1 as i32) {
                                                                            xmlSchemaDeriveFacetErr(
                                                                                pctxt,
                                                                                fmaxinc,
                                                                                bfmininc,
                                                                                1 as i32,
                                                                                1 as i32,
                                                                                1 as i32,
                                                                            );
                                                                        }
                                                                        current_block = 6584656659744957450;
                                                                    }
                                                                } else {
                                                                    current_block = 6584656659744957450;
                                                                }
                                                                match current_block {
                                                                    6717603523453139513 => {}
                                                                    _ => {
                                                                        if !bfminexc.is_null() {
                                                                            res = xmlSchemaCompareValues(
                                                                                (*fmaxinc).val,
                                                                                (*bfminexc).val,
                                                                            );
                                                                            if res == -(2 as i32) {
                                                                                current_block = 6717603523453139513;
                                                                            } else {
                                                                                if res != 1 as i32 {
                                                                                    xmlSchemaDeriveFacetErr(
                                                                                        pctxt,
                                                                                        fmaxinc,
                                                                                        bfminexc,
                                                                                        1 as i32,
                                                                                        0 as i32,
                                                                                        1 as i32,
                                                                                    );
                                                                                }
                                                                                current_block = 10938659635288570931;
                                                                            }
                                                                        } else {
                                                                            current_block = 10938659635288570931;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        current_block = 10938659635288570931;
                                    }
                                    match current_block {
                                        6717603523453139513 => {}
                                        _ => {
                                            if !fmaxexc.is_null() {
                                                if !fminexc.is_null() {
                                                    res = xmlSchemaCompareValues(
                                                        (*fmaxexc).val,
                                                        (*fminexc).val,
                                                    );
                                                    if res == -(2 as i32) {
                                                        current_block = 6717603523453139513;
                                                    } else {
                                                        if res == -(1 as i32) {
                                                            xmlSchemaDeriveFacetErr(
                                                                pctxt,
                                                                fmaxexc,
                                                                fminexc,
                                                                1 as i32,
                                                                1 as i32,
                                                                0 as i32,
                                                            );
                                                        }
                                                        current_block = 7545150590528655645;
                                                    }
                                                } else {
                                                    current_block = 7545150590528655645;
                                                }
                                                match current_block {
                                                    6717603523453139513 => {}
                                                    _ => {
                                                        if !bfmaxexc.is_null() {
                                                            res = xmlSchemaCompareValues(
                                                                (*fmaxexc).val,
                                                                (*bfmaxexc).val,
                                                            );
                                                            if res == -(2 as i32) {
                                                                current_block = 6717603523453139513;
                                                            } else {
                                                                if res == 1 as i32 {
                                                                    xmlSchemaDeriveFacetErr(
                                                                        pctxt,
                                                                        fmaxexc,
                                                                        bfmaxexc,
                                                                        -(1 as i32),
                                                                        1 as i32,
                                                                        1 as i32,
                                                                    );
                                                                }
                                                                if res != 0 as i32 && (*bfmaxexc).fixed != 0 {
                                                                    xmlSchemaPCustomErr(
                                                                        pctxt,
                                                                        XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                        fmaxexc as xmlSchemaBasicItemPtr,
                                                                        (*fmaxexc).node,
                                                                        b"The base type's facet is 'fixed', thus the value must not differ\0"
                                                                            as *const u8 as *const i8,
                                                                        0 as *const xmlChar,
                                                                    );
                                                                }
                                                                current_block = 1421636490742020198;
                                                            }
                                                        } else {
                                                            current_block = 1421636490742020198;
                                                        }
                                                        match current_block {
                                                            6717603523453139513 => {}
                                                            _ => {
                                                                if !bfmaxinc.is_null() {
                                                                    res = xmlSchemaCompareValues(
                                                                        (*fmaxexc).val,
                                                                        (*bfmaxinc).val,
                                                                    );
                                                                    if res == -(2 as i32) {
                                                                        current_block = 6717603523453139513;
                                                                    } else {
                                                                        if res == 1 as i32 {
                                                                            xmlSchemaDeriveFacetErr(
                                                                                pctxt,
                                                                                fmaxexc,
                                                                                bfmaxinc,
                                                                                -(1 as i32),
                                                                                1 as i32,
                                                                                1 as i32,
                                                                            );
                                                                        }
                                                                        current_block = 12129449210080749085;
                                                                    }
                                                                } else {
                                                                    current_block = 12129449210080749085;
                                                                }
                                                                match current_block {
                                                                    6717603523453139513 => {}
                                                                    _ => {
                                                                        if !bfmininc.is_null() {
                                                                            res = xmlSchemaCompareValues(
                                                                                (*fmaxexc).val,
                                                                                (*bfmininc).val,
                                                                            );
                                                                            if res == -(2 as i32) {
                                                                                current_block = 6717603523453139513;
                                                                            } else {
                                                                                if res != 1 as i32 {
                                                                                    xmlSchemaDeriveFacetErr(
                                                                                        pctxt,
                                                                                        fmaxexc,
                                                                                        bfmininc,
                                                                                        1 as i32,
                                                                                        0 as i32,
                                                                                        1 as i32,
                                                                                    );
                                                                                }
                                                                                current_block = 11508203296038873488;
                                                                            }
                                                                        } else {
                                                                            current_block = 11508203296038873488;
                                                                        }
                                                                        match current_block {
                                                                            6717603523453139513 => {}
                                                                            _ => {
                                                                                if !bfminexc.is_null() {
                                                                                    res = xmlSchemaCompareValues(
                                                                                        (*fmaxexc).val,
                                                                                        (*bfminexc).val,
                                                                                    );
                                                                                    if res == -(2 as i32) {
                                                                                        current_block = 6717603523453139513;
                                                                                    } else {
                                                                                        if res != 1 as i32 {
                                                                                            xmlSchemaDeriveFacetErr(
                                                                                                pctxt,
                                                                                                fmaxexc,
                                                                                                bfminexc,
                                                                                                1 as i32,
                                                                                                0 as i32,
                                                                                                1 as i32,
                                                                                            );
                                                                                        }
                                                                                        current_block = 5482373152242628851;
                                                                                    }
                                                                                } else {
                                                                                    current_block = 5482373152242628851;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            } else {
                                                current_block = 5482373152242628851;
                                            }
                                            match current_block {
                                                6717603523453139513 => {}
                                                _ => {
                                                    if !fminexc.is_null() {
                                                        if !fmaxinc.is_null() {
                                                            res = xmlSchemaCompareValues(
                                                                (*fminexc).val,
                                                                (*fmaxinc).val,
                                                            );
                                                            if res == -(2 as i32) {
                                                                current_block = 6717603523453139513;
                                                            } else {
                                                                if res != -(1 as i32) {
                                                                    xmlSchemaDeriveFacetErr(
                                                                        pctxt,
                                                                        fminexc,
                                                                        fmaxinc,
                                                                        -(1 as i32),
                                                                        0 as i32,
                                                                        0 as i32,
                                                                    );
                                                                }
                                                                current_block = 2925215368761540503;
                                                            }
                                                        } else {
                                                            current_block = 2925215368761540503;
                                                        }
                                                        match current_block {
                                                            6717603523453139513 => {}
                                                            _ => {
                                                                if !bfminexc.is_null() {
                                                                    res = xmlSchemaCompareValues(
                                                                        (*fminexc).val,
                                                                        (*bfminexc).val,
                                                                    );
                                                                    if res == -(2 as i32) {
                                                                        current_block = 6717603523453139513;
                                                                    } else {
                                                                        if res == -(1 as i32) {
                                                                            xmlSchemaDeriveFacetErr(
                                                                                pctxt,
                                                                                fminexc,
                                                                                bfminexc,
                                                                                1 as i32,
                                                                                1 as i32,
                                                                                1 as i32,
                                                                            );
                                                                        }
                                                                        if res != 0 as i32 && (*bfminexc).fixed != 0 {
                                                                            xmlSchemaPCustomErr(
                                                                                pctxt,
                                                                                XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                fminexc as xmlSchemaBasicItemPtr,
                                                                                (*fminexc).node,
                                                                                b"The base type's facet is 'fixed', thus the value must not differ\0"
                                                                                    as *const u8 as *const i8,
                                                                                0 as *const xmlChar,
                                                                            );
                                                                        }
                                                                        current_block = 12299212226970775842;
                                                                    }
                                                                } else {
                                                                    current_block = 12299212226970775842;
                                                                }
                                                                match current_block {
                                                                    6717603523453139513 => {}
                                                                    _ => {
                                                                        if !bfmaxinc.is_null() {
                                                                            res = xmlSchemaCompareValues(
                                                                                (*fminexc).val,
                                                                                (*bfmaxinc).val,
                                                                            );
                                                                            if res == -(2 as i32) {
                                                                                current_block = 6717603523453139513;
                                                                            } else {
                                                                                if res == 1 as i32 {
                                                                                    xmlSchemaDeriveFacetErr(
                                                                                        pctxt,
                                                                                        fminexc,
                                                                                        bfmaxinc,
                                                                                        -(1 as i32),
                                                                                        1 as i32,
                                                                                        1 as i32,
                                                                                    );
                                                                                }
                                                                                current_block = 16813369756331276724;
                                                                            }
                                                                        } else {
                                                                            current_block = 16813369756331276724;
                                                                        }
                                                                        match current_block {
                                                                            6717603523453139513 => {}
                                                                            _ => {
                                                                                if !bfmininc.is_null() {
                                                                                    res = xmlSchemaCompareValues(
                                                                                        (*fminexc).val,
                                                                                        (*bfmininc).val,
                                                                                    );
                                                                                    if res == -(2 as i32) {
                                                                                        current_block = 6717603523453139513;
                                                                                    } else {
                                                                                        if res == -(1 as i32) {
                                                                                            xmlSchemaDeriveFacetErr(
                                                                                                pctxt,
                                                                                                fminexc,
                                                                                                bfmininc,
                                                                                                1 as i32,
                                                                                                1 as i32,
                                                                                                1 as i32,
                                                                                            );
                                                                                        }
                                                                                        current_block = 5267916556966421873;
                                                                                    }
                                                                                } else {
                                                                                    current_block = 5267916556966421873;
                                                                                }
                                                                                match current_block {
                                                                                    6717603523453139513 => {}
                                                                                    _ => {
                                                                                        if !bfmaxexc.is_null() {
                                                                                            res = xmlSchemaCompareValues(
                                                                                                (*fminexc).val,
                                                                                                (*bfmaxexc).val,
                                                                                            );
                                                                                            if res == -(2 as i32) {
                                                                                                current_block = 6717603523453139513;
                                                                                            } else {
                                                                                                if res != -(1 as i32) {
                                                                                                    xmlSchemaDeriveFacetErr(
                                                                                                        pctxt,
                                                                                                        fminexc,
                                                                                                        bfmaxexc,
                                                                                                        -(1 as i32),
                                                                                                        0 as i32,
                                                                                                        1 as i32,
                                                                                                    );
                                                                                                }
                                                                                                current_block = 6091595930016798176;
                                                                                            }
                                                                                        } else {
                                                                                            current_block = 6091595930016798176;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        current_block = 6091595930016798176;
                                                    }
                                                    match current_block {
                                                        6717603523453139513 => {}
                                                        _ => {
                                                            if !fmininc.is_null() {
                                                                if !fmaxexc.is_null() {
                                                                    res = xmlSchemaCompareValues(
                                                                        (*fmininc).val,
                                                                        (*fmaxexc).val,
                                                                    );
                                                                    if res == -(2 as i32) {
                                                                        current_block = 6717603523453139513;
                                                                    } else {
                                                                        if res != -(1 as i32) {
                                                                            xmlSchemaDeriveFacetErr(
                                                                                pctxt,
                                                                                fmininc,
                                                                                fmaxexc,
                                                                                -(1 as i32),
                                                                                0 as i32,
                                                                                0 as i32,
                                                                            );
                                                                        }
                                                                        current_block = 6497888915984600225;
                                                                    }
                                                                } else {
                                                                    current_block = 6497888915984600225;
                                                                }
                                                                match current_block {
                                                                    6717603523453139513 => {}
                                                                    _ => {
                                                                        if !bfmininc.is_null() {
                                                                            res = xmlSchemaCompareValues(
                                                                                (*fmininc).val,
                                                                                (*bfmininc).val,
                                                                            );
                                                                            if res == -(2 as i32) {
                                                                                current_block = 6717603523453139513;
                                                                            } else {
                                                                                if res == -(1 as i32) {
                                                                                    xmlSchemaDeriveFacetErr(
                                                                                        pctxt,
                                                                                        fmininc,
                                                                                        bfmininc,
                                                                                        1 as i32,
                                                                                        1 as i32,
                                                                                        1 as i32,
                                                                                    );
                                                                                }
                                                                                if res != 0 as i32 && (*bfmininc).fixed != 0 {
                                                                                    xmlSchemaPCustomErr(
                                                                                        pctxt,
                                                                                        XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                        fmininc as xmlSchemaBasicItemPtr,
                                                                                        (*fmininc).node,
                                                                                        b"The base type's facet is 'fixed', thus the value must not differ\0"
                                                                                            as *const u8 as *const i8,
                                                                                        0 as *const xmlChar,
                                                                                    );
                                                                                }
                                                                                current_block = 9350489878244555550;
                                                                            }
                                                                        } else {
                                                                            current_block = 9350489878244555550;
                                                                        }
                                                                        match current_block {
                                                                            6717603523453139513 => {}
                                                                            _ => {
                                                                                if !bfmaxinc.is_null() {
                                                                                    res = xmlSchemaCompareValues(
                                                                                        (*fmininc).val,
                                                                                        (*bfmaxinc).val,
                                                                                    );
                                                                                    if res == -(2 as i32) {
                                                                                        current_block = 6717603523453139513;
                                                                                    } else {
                                                                                        if res == 1 as i32 {
                                                                                            xmlSchemaDeriveFacetErr(
                                                                                                pctxt,
                                                                                                fmininc,
                                                                                                bfmaxinc,
                                                                                                -(1 as i32),
                                                                                                1 as i32,
                                                                                                1 as i32,
                                                                                            );
                                                                                        }
                                                                                        current_block = 11364608634565542496;
                                                                                    }
                                                                                } else {
                                                                                    current_block = 11364608634565542496;
                                                                                }
                                                                                match current_block {
                                                                                    6717603523453139513 => {}
                                                                                    _ => {
                                                                                        if !bfminexc.is_null() {
                                                                                            res = xmlSchemaCompareValues(
                                                                                                (*fmininc).val,
                                                                                                (*bfminexc).val,
                                                                                            );
                                                                                            if res == -(2 as i32) {
                                                                                                current_block = 6717603523453139513;
                                                                                            } else {
                                                                                                if res != 1 as i32 {
                                                                                                    xmlSchemaDeriveFacetErr(
                                                                                                        pctxt,
                                                                                                        fmininc,
                                                                                                        bfminexc,
                                                                                                        1 as i32,
                                                                                                        0 as i32,
                                                                                                        1 as i32,
                                                                                                    );
                                                                                                }
                                                                                                current_block = 3304481414499905106;
                                                                                            }
                                                                                        } else {
                                                                                            current_block = 3304481414499905106;
                                                                                        }
                                                                                        match current_block {
                                                                                            6717603523453139513 => {}
                                                                                            _ => {
                                                                                                if !bfmaxexc.is_null() {
                                                                                                    res = xmlSchemaCompareValues(
                                                                                                        (*fmininc).val,
                                                                                                        (*bfmaxexc).val,
                                                                                                    );
                                                                                                    if res == -(2 as i32) {
                                                                                                        current_block = 6717603523453139513;
                                                                                                    } else {
                                                                                                        if res != -(1 as i32) {
                                                                                                            xmlSchemaDeriveFacetErr(
                                                                                                                pctxt,
                                                                                                                fmininc,
                                                                                                                bfmaxexc,
                                                                                                                -(1 as i32),
                                                                                                                0 as i32,
                                                                                                                1 as i32,
                                                                                                            );
                                                                                                        }
                                                                                                        current_block = 1707335883933721018;
                                                                                                    }
                                                                                                } else {
                                                                                                    current_block = 1707335883933721018;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            } else {
                                                                current_block = 1707335883933721018;
                                                            }
                                                            match current_block {
                                                                6717603523453139513 => {}
                                                                _ => {
                                                                    if !ftotdig.is_null() && !bftotdig.is_null() {
                                                                        res = xmlSchemaCompareValues(
                                                                            (*ftotdig).val,
                                                                            (*bftotdig).val,
                                                                        );
                                                                        if res == -(2 as i32) {
                                                                            current_block = 6717603523453139513;
                                                                        } else {
                                                                            if res == 1 as i32 {
                                                                                xmlSchemaDeriveFacetErr(
                                                                                    pctxt,
                                                                                    ftotdig,
                                                                                    bftotdig,
                                                                                    -(1 as i32),
                                                                                    1 as i32,
                                                                                    1 as i32,
                                                                                );
                                                                            }
                                                                            if res != 0 as i32 && (*bftotdig).fixed != 0 {
                                                                                xmlSchemaPCustomErr(
                                                                                    pctxt,
                                                                                    XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                    ftotdig as xmlSchemaBasicItemPtr,
                                                                                    (*ftotdig).node,
                                                                                    b"The base type's facet is 'fixed', thus the value must not differ\0"
                                                                                        as *const u8 as *const i8,
                                                                                    0 as *const xmlChar,
                                                                                );
                                                                            }
                                                                            current_block = 2606663910910355487;
                                                                        }
                                                                    } else {
                                                                        current_block = 2606663910910355487;
                                                                    }
                                                                    match current_block {
                                                                        6717603523453139513 => {}
                                                                        _ => {
                                                                            if !ffracdig.is_null() && !bffracdig.is_null() {
                                                                                res = xmlSchemaCompareValues(
                                                                                    (*ffracdig).val,
                                                                                    (*bffracdig).val,
                                                                                );
                                                                                if res == -(2 as i32) {
                                                                                    current_block = 6717603523453139513;
                                                                                } else {
                                                                                    if res == 1 as i32 {
                                                                                        xmlSchemaDeriveFacetErr(
                                                                                            pctxt,
                                                                                            ffracdig,
                                                                                            bffracdig,
                                                                                            -(1 as i32),
                                                                                            1 as i32,
                                                                                            1 as i32,
                                                                                        );
                                                                                    }
                                                                                    if res != 0 as i32 && (*bffracdig).fixed != 0 {
                                                                                        xmlSchemaPCustomErr(
                                                                                            pctxt,
                                                                                            XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                            ffracdig as xmlSchemaBasicItemPtr,
                                                                                            (*ffracdig).node,
                                                                                            b"The base type's facet is 'fixed', thus the value must not differ\0"
                                                                                                as *const u8 as *const i8,
                                                                                            0 as *const xmlChar,
                                                                                        );
                                                                                    }
                                                                                    current_block = 5913497314667414582;
                                                                                }
                                                                            } else {
                                                                                current_block = 5913497314667414582;
                                                                            }
                                                                            match current_block {
                                                                                6717603523453139513 => {}
                                                                                _ => {
                                                                                    if ftotdig.is_null() {
                                                                                        ftotdig = bftotdig;
                                                                                    }
                                                                                    if ffracdig.is_null() {
                                                                                        ffracdig = bffracdig;
                                                                                    }
                                                                                    if !ftotdig.is_null() && !ffracdig.is_null() {
                                                                                        res = xmlSchemaCompareValues(
                                                                                            (*ffracdig).val,
                                                                                            (*ftotdig).val,
                                                                                        );
                                                                                        if res == -(2 as i32) {
                                                                                            current_block = 6717603523453139513;
                                                                                        } else {
                                                                                            if res == 1 as i32 {
                                                                                                xmlSchemaDeriveFacetErr(
                                                                                                    pctxt,
                                                                                                    ffracdig,
                                                                                                    ftotdig,
                                                                                                    -(1 as i32),
                                                                                                    1 as i32,
                                                                                                    0 as i32,
                                                                                                );
                                                                                            }
                                                                                            current_block = 9190931632177426379;
                                                                                        }
                                                                                    } else {
                                                                                        current_block = 9190931632177426379;
                                                                                    }
                                                                                    match current_block {
                                                                                        6717603523453139513 => {}
                                                                                        _ => {
                                                                                            cur = (*base).facetSet;
                                                                                            while !cur.is_null() {
                                                                                                bfacet = (*cur).facet;
                                                                                                if !((*bfacet).type_0 as u32
                                                                                                    == XML_SCHEMA_FACET_PATTERN as i32 as u32
                                                                                                    || (*bfacet).type_0 as u32
                                                                                                        == XML_SCHEMA_FACET_ENUMERATION as i32
                                                                                                            as u32)
                                                                                                {
                                                                                                    link = (*type_0).facetSet;
                                                                                                    while !link.is_null() {
                                                                                                        facet = (*link).facet;
                                                                                                        if (*facet).type_0 as u32
                                                                                                            == (*bfacet).type_0 as u32
                                                                                                        {
                                                                                                            match (*facet).type_0 as u32 {
                                                                                                                1008 => {
                                                                                                                    if (*facet).whitespace < (*bfacet).whitespace {
                                                                                                                        xmlSchemaPCustomErr(
                                                                                                                            pctxt,
                                                                                                                            XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                                                            facet as xmlSchemaBasicItemPtr,
                                                                                                                            (*facet).node,
                                                                                                                            b"The 'whitespace' value has to be equal to or stronger than the 'whitespace' value of the base type\0"
                                                                                                                                as *const u8 as *const i8,
                                                                                                                            0 as *const xmlChar,
                                                                                                                        );
                                                                                                                    }
                                                                                                                    if (*bfacet).fixed != 0
                                                                                                                        && (*facet).whitespace != (*bfacet).whitespace
                                                                                                                    {
                                                                                                                        xmlSchemaPCustomErr(
                                                                                                                            pctxt,
                                                                                                                            XML_SCHEMAP_INVALID_FACET_VALUE,
                                                                                                                            facet as xmlSchemaBasicItemPtr,
                                                                                                                            (*facet).node,
                                                                                                                            b"The base type's facet is 'fixed', thus the value must not differ\0"
                                                                                                                                as *const u8 as *const i8,
                                                                                                                            0 as *const xmlChar,
                                                                                                                        );
                                                                                                                    }
                                                                                                                }
                                                                                                                _ => {}
                                                                                                            }
                                                                                                            break;
                                                                                                        } else {
                                                                                                            link = (*link).next;
                                                                                                        }
                                                                                                    }
                                                                                                    if link.is_null() {
                                                                                                        link = xmlMalloc
                                                                                                            .expect(
                                                                                                                "non-null function pointer",
                                                                                                            )(
                                                                                                            ::std::mem::size_of::<xmlSchemaFacetLink>() as u64,
                                                                                                        ) as xmlSchemaFacetLinkPtr;
                                                                                                        if link.is_null() {
                                                                                                            xmlSchemaPErrMemory(
                                                                                                                pctxt,
                                                                                                                b"deriving facets, creating a facet link\0" as *const u8
                                                                                                                    as *const i8,
                                                                                                                0 as xmlNodePtr,
                                                                                                            );
                                                                                                            return -(1 as i32);
                                                                                                        }
                                                                                                        let fresh369 = &mut ((*link).facet);
                                                                                                        *fresh369 = (*cur).facet;
                                                                                                        let fresh370 = &mut ((*link).next);
                                                                                                        *fresh370 = 0 as *mut _xmlSchemaFacetLink;
                                                                                                        if last.is_null() {
                                                                                                            let fresh371 = &mut ((*type_0).facetSet);
                                                                                                            *fresh371 = link;
                                                                                                        } else {
                                                                                                            let fresh372 = &mut ((*last).next);
                                                                                                            *fresh372 = link;
                                                                                                        }
                                                                                                        last = link;
                                                                                                    }
                                                                                                }
                                                                                                cur = (*cur).next;
                                                                                            }
                                                                                            return 0 as i32;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    xmlSchemaInternalErr(
        pctxt as xmlSchemaAbstractCtxtPtr,
        b"xmlSchemaDeriveAndValidateFacets\0" as *const u8 as *const i8,
        b"an error occurred\0" as *const u8 as *const i8,
    );
    return -(1 as i32);
}
unsafe extern "C" fn xmlSchemaFinishMemberTypeDefinitionsProperty(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> i32 {
    let mut link: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut lastLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut prevLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut subLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    let mut newLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
    link = (*type_0).memberTypes;
    while !link.is_null() {
        if (*(*link).type_0).type_0 as u32
            != XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (*(*link).type_0).flags & (1 as i32) << 22 as i32
                == 0 as i32
        {
            xmlSchemaTypeFixup((*link).type_0, pctxt as xmlSchemaAbstractCtxtPtr);
        }
        if (*(*link).type_0).flags & (1 as i32) << 7 as i32 != 0 {
            subLink = xmlSchemaGetUnionSimpleTypeMemberTypes((*link).type_0);
            if !subLink.is_null() {
                let fresh373 = &mut ((*link).type_0);
                *fresh373 = (*subLink).type_0;
                if !((*subLink).next).is_null() {
                    lastLink = (*link).next;
                    subLink = (*subLink).next;
                    prevLink = link;
                    while !subLink.is_null() {
                        newLink = xmlMalloc
                            .expect(
                                "non-null function pointer",
                            )(
                            ::std::mem::size_of::<xmlSchemaTypeLink>() as u64,
                        ) as xmlSchemaTypeLinkPtr;
                        if newLink.is_null() {
                            xmlSchemaPErrMemory(
                                pctxt,
                                b"allocating a type link\0" as *const u8
                                    as *const i8,
                                0 as xmlNodePtr,
                            );
                            return -(1 as i32);
                        }
                        let fresh374 = &mut ((*newLink).type_0);
                        *fresh374 = (*subLink).type_0;
                        let fresh375 = &mut ((*prevLink).next);
                        *fresh375 = newLink;
                        prevLink = newLink;
                        let fresh376 = &mut ((*newLink).next);
                        *fresh376 = lastLink;
                        subLink = (*subLink).next;
                    }
                }
            }
        }
        link = (*link).next;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaTypeFixupOptimFacets(mut type_0: xmlSchemaTypePtr) {
    let mut has: i32 = 0 as i32;
    let mut needVal: i32 = 0 as i32;
    let mut normVal: i32 = 0 as i32;
    has = if (*(*type_0).baseType).flags & (1 as i32) << 27 as i32 != 0 {
        1 as i32
    } else {
        0 as i32
    };
    if has != 0 {
        needVal = if (*(*type_0).baseType).flags
            & (1 as i32) << 21 as i32 != 0
        {
            1 as i32
        } else {
            0 as i32
        };
        normVal = if (*(*type_0).baseType).flags
            & (1 as i32) << 28 as i32 != 0
        {
            1 as i32
        } else {
            0 as i32
        };
    }
    if !((*type_0).facets).is_null() {
        let mut fac: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
        fac = (*type_0).facets;
        while !fac.is_null() {
            match (*fac).type_0 as u32 {
                1008 => {}
                1006 => {
                    normVal = 1 as i32;
                    has = 1 as i32;
                }
                1007 => {
                    needVal = 1 as i32;
                    normVal = 1 as i32;
                    has = 1 as i32;
                }
                _ => {
                    has = 1 as i32;
                }
            }
            fac = (*fac).next;
        }
    }
    if normVal != 0 {
        (*type_0).flags |= (1 as i32) << 28 as i32;
    }
    if needVal != 0 {
        (*type_0).flags |= (1 as i32) << 21 as i32;
    }
    if has != 0 {
        (*type_0).flags |= (1 as i32) << 27 as i32;
    }
    if has != 0 && needVal == 0
        && (*type_0).flags & (1 as i32) << 8 as i32 != 0
    {
        let mut prim: xmlSchemaTypePtr = xmlSchemaGetPrimitiveType(type_0);
        if (*prim).builtInType != XML_SCHEMAS_ANYSIMPLETYPE as i32
            && (*prim).builtInType != XML_SCHEMAS_STRING as i32
        {
            (*type_0).flags |= (1 as i32) << 21 as i32;
        }
    }
}
unsafe extern "C" fn xmlSchemaTypeFixupWhitespace(
    mut type_0: xmlSchemaTypePtr,
) -> i32 {
    if (*type_0).flags & (1 as i32) << 6 as i32 != 0 {
        (*type_0).flags |= (1 as i32) << 26 as i32;
        return 0 as i32;
    } else {
        if (*type_0).flags & (1 as i32) << 7 as i32 != 0 {
            return 0 as i32;
        }
    }
    if !((*type_0).facetSet).is_null() {
        let mut lin: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
        lin = (*type_0).facetSet;
        while !lin.is_null() {
            if (*(*lin).facet).type_0 as u32
                == XML_SCHEMA_FACET_WHITESPACE as i32 as u32
            {
                match (*(*lin).facet).whitespace {
                    1 => {
                        (*type_0).flags |= (1 as i32) << 24 as i32;
                    }
                    2 => {
                        (*type_0).flags |= (1 as i32) << 25 as i32;
                    }
                    3 => {
                        (*type_0).flags |= (1 as i32) << 26 as i32;
                    }
                    _ => return -(1 as i32),
                }
                return 0 as i32;
            }
            lin = (*lin).next;
        }
    }
    let mut anc: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    anc = (*type_0).baseType;
    while !anc.is_null() && (*anc).builtInType != XML_SCHEMAS_ANYTYPE as i32 {
        if (*anc).type_0 as u32
            == XML_SCHEMA_TYPE_BASIC as i32 as u32
        {
            if (*anc).builtInType == XML_SCHEMAS_NORMSTRING as i32 {
                (*type_0).flags |= (1 as i32) << 25 as i32;
            } else if (*anc).builtInType == XML_SCHEMAS_STRING as i32
                    || (*anc).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as i32
                {
                (*type_0).flags |= (1 as i32) << 24 as i32;
            } else {
                (*type_0).flags |= (1 as i32) << 26 as i32;
            }
            break;
        } else {
            anc = (*anc).baseType;
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaFixupSimpleTypeStageOne(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> i32 {
    if (*type_0).type_0 as u32
        != XML_SCHEMA_TYPE_SIMPLE as i32 as u32
    {
        return 0 as i32;
    }
    if !((*type_0).type_0 as u32
        != XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (*type_0).flags & (1 as i32) << 29 as i32 == 0 as i32)
    {
        return 0 as i32;
    }
    (*type_0).flags |= (1 as i32) << 29 as i32;
    if (*type_0).flags & (1 as i32) << 6 as i32 != 0 {
        if ((*type_0).subtypes).is_null() {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaFixupSimpleTypeStageOne\0" as *const u8
                    as *const i8,
                b"list type has no item-type assigned\0" as *const u8
                    as *const i8,
            );
            return -(1 as i32);
        }
    } else if (*type_0).flags & (1 as i32) << 7 as i32 != 0 {
        if ((*type_0).memberTypes).is_null() {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaFixupSimpleTypeStageOne\0" as *const u8
                    as *const i8,
                b"union type has no member-types assigned\0" as *const u8
                    as *const i8,
            );
            return -(1 as i32);
        }
    } else {
        if ((*type_0).baseType).is_null() {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaFixupSimpleTypeStageOne\0" as *const u8
                    as *const i8,
                b"type has no base-type assigned\0" as *const u8 as *const i8,
            );
            return -(1 as i32);
        }
        if (*(*type_0).baseType).type_0 as u32
            != XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (*(*type_0).baseType).flags & (1 as i32) << 29 as i32
                == 0 as i32
        {
            if xmlSchemaFixupSimpleTypeStageOne(pctxt, (*type_0).baseType)
                == -(1 as i32)
            {
                return -(1 as i32);
            }
        }
        if (*(*type_0).baseType).flags & (1 as i32) << 8 as i32 != 0 {
            (*type_0).flags |= (1 as i32) << 8 as i32;
        } else if (*(*type_0).baseType).flags & (1 as i32) << 6 as i32
                != 0
            {
            (*type_0).flags |= (1 as i32) << 6 as i32;
            let fresh377 = &mut ((*type_0).subtypes);
            *fresh377 = (*(*type_0).baseType).subtypes;
        } else if (*(*type_0).baseType).flags & (1 as i32) << 7 as i32
                != 0
            {
            (*type_0).flags |= (1 as i32) << 7 as i32;
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaFixupSimpleTypeStageTwo(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> i32 {
    let mut current_block: u64;
    let mut res: i32 = 0;
    let mut olderrs: i32 = (*pctxt).nberrors;
    if (*type_0).type_0 as u32
        != XML_SCHEMA_TYPE_SIMPLE as i32 as u32
    {
        return -(1 as i32);
    }
    if !((*type_0).type_0 as u32
        != XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (*type_0).flags & (1 as i32) << 22 as i32 == 0 as i32)
    {
        return 0 as i32;
    }
    (*type_0).flags |= (1 as i32) << 22 as i32;
    (*type_0).contentType = XML_SCHEMA_CONTENT_SIMPLE;
    if ((*type_0).baseType).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaFixupSimpleTypeStageTwo\0" as *const u8 as *const i8,
            b"missing baseType\0" as *const u8 as *const i8,
        );
    } else {
        if (*(*type_0).baseType).type_0 as u32
            != XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (*(*type_0).baseType).flags & (1 as i32) << 22 as i32
                == 0 as i32
        {
            xmlSchemaTypeFixup((*type_0).baseType, pctxt as xmlSchemaAbstractCtxtPtr);
        }
        if !((*type_0).memberTypes).is_null()
            && xmlSchemaFinishMemberTypeDefinitionsProperty(pctxt, type_0)
                == -(1 as i32)
        {
            return -(1 as i32);
        }
        res = xmlSchemaCheckSTPropsCorrect(pctxt, type_0);
        if !(res == -(1 as i32)) {
            if res != 0 as i32 {
                current_block = 16935711101380438426;
            } else {
                res = xmlSchemaCheckCOSSTRestricts(pctxt, type_0);
                if res == -(1 as i32) {
                    current_block = 7438021731138147780;
                } else if res != 0 as i32 {
                    current_block = 16935711101380438426;
                } else {
                    res = xmlSchemaCheckFacetValues(type_0, pctxt);
                    if res == -(1 as i32) {
                        current_block = 7438021731138147780;
                    } else if res != 0 as i32 {
                        current_block = 16935711101380438426;
                    } else {
                        if !((*type_0).facetSet).is_null()
                            || !((*(*type_0).baseType).facetSet).is_null()
                        {
                            res = xmlSchemaDeriveAndValidateFacets(pctxt, type_0);
                            if res == -(1 as i32) {
                                current_block = 7438021731138147780;
                            } else if res != 0 as i32 {
                                current_block = 16935711101380438426;
                            } else {
                                current_block = 4068382217303356765;
                            }
                        } else {
                            current_block = 4068382217303356765;
                        }
                        match current_block {
                            16935711101380438426 => {}
                            7438021731138147780 => {}
                            _ => {
                                res = xmlSchemaTypeFixupWhitespace(type_0);
                                if res == -(1 as i32) {
                                    current_block = 7438021731138147780;
                                } else if res != 0 as i32 {
                                    current_block = 16935711101380438426;
                                } else {
                                    xmlSchemaTypeFixupOptimFacets(type_0);
                                    current_block = 16935711101380438426;
                                }
                            }
                        }
                    }
                }
            }
            match current_block {
                7438021731138147780 => {}
                _ => {
                    if olderrs != (*pctxt).nberrors {
                        return (*pctxt).err;
                    }
                    return 0 as i32;
                }
            }
        }
    }
    return -(1 as i32);
}
unsafe extern "C" fn xmlSchemaFixupComplexType(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut type_0: xmlSchemaTypePtr,
) -> i32 {
    let mut current_block: u64;
    let mut res: i32 = 0 as i32;
    let mut olderrs: i32 = (*pctxt).nberrors;
    let mut baseType: xmlSchemaTypePtr = (*type_0).baseType;
    if !((*type_0).type_0 as u32
        != XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (*type_0).flags & (1 as i32) << 22 as i32 == 0 as i32)
    {
        return 0 as i32;
    }
    (*type_0).flags |= (1 as i32) << 22 as i32;
    if baseType.is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaFixupComplexType\0" as *const u8 as *const i8,
            b"missing baseType\0" as *const u8 as *const i8,
        );
    } else {
        if (*baseType).type_0 as u32
            != XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (*baseType).flags & (1 as i32) << 22 as i32
                == 0 as i32
        {
            xmlSchemaTypeFixup(baseType, pctxt as xmlSchemaAbstractCtxtPtr);
        }
        if (*baseType).flags & (1 as i32) << 23 as i32 != 0 {
            return 0 as i32;
        }
        res = xmlSchemaCheckSRCCT(pctxt, type_0);
        if !(res == -(1 as i32)) {
            if res != 0 as i32 {
                current_block = 6926858937233525393;
            } else {
                if (*type_0).contentType as u32
                    == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
                {
                    if ((*baseType).type_0 as u32
                        == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                        || (*baseType).builtInType == XML_SCHEMAS_ANYTYPE as i32)
                        && !((*baseType).contentTypeDef).is_null()
                        && (*type_0).flags & (1 as i32) << 2 as i32 != 0
                    {
                        let mut contentBase: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
                        let mut content: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
                        if !((*type_0).contentTypeDef).is_null() {
                            contentBase = (*type_0).contentTypeDef;
                            let fresh378 = &mut ((*type_0).contentTypeDef);
                            *fresh378 = 0 as xmlSchemaTypePtr;
                        } else {
                            contentBase = (*baseType).contentTypeDef;
                        }
                        content = xmlSchemaAddType(
                            pctxt,
                            (*pctxt).schema,
                            XML_SCHEMA_TYPE_SIMPLE,
                            0 as *const xmlChar,
                            (*type_0).targetNamespace,
                            (*type_0).node,
                            0 as i32,
                        );
                        if content.is_null() {
                            current_block = 345336241299298347;
                        } else {
                            (*content).type_0 = XML_SCHEMA_TYPE_SIMPLE;
                            let fresh379 = &mut ((*content).baseType);
                            *fresh379 = contentBase;
                            let fresh380 = &mut ((*content).facets);
                            *fresh380 = (*type_0).facets;
                            let fresh381 = &mut ((*type_0).facets);
                            *fresh381 = 0 as xmlSchemaFacetPtr;
                            let fresh382 = &mut ((*content).facetSet);
                            *fresh382 = (*type_0).facetSet;
                            let fresh383 = &mut ((*type_0).facetSet);
                            *fresh383 = 0 as xmlSchemaFacetLinkPtr;
                            let fresh384 = &mut ((*type_0).contentTypeDef);
                            *fresh384 = content;
                            if (*contentBase).type_0 as u32
                                != XML_SCHEMA_TYPE_BASIC as i32 as u32
                                && (*contentBase).flags
                                    & (1 as i32) << 22 as i32
                                    == 0 as i32
                            {
                                xmlSchemaTypeFixup(
                                    contentBase,
                                    pctxt as xmlSchemaAbstractCtxtPtr,
                                );
                            }
                            res = xmlSchemaFixupSimpleTypeStageOne(pctxt, content);
                            if res == -(1 as i32) {
                                current_block = 345336241299298347;
                            } else if res != 0 as i32 {
                                current_block = 6926858937233525393;
                            } else {
                                res = xmlSchemaFixupSimpleTypeStageTwo(pctxt, content);
                                if res == -(1 as i32) {
                                    current_block = 345336241299298347;
                                } else if res != 0 as i32 {
                                    current_block = 6926858937233525393;
                                } else {
                                    current_block = 5265702136860997526;
                                }
                            }
                        }
                    } else if ((*baseType).type_0 as u32
                            == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                            || (*baseType).builtInType
                                == XML_SCHEMAS_ANYTYPE as i32)
                            && (*baseType).contentType as u32
                                == XML_SCHEMA_CONTENT_MIXED as i32 as u32
                            && (*type_0).flags & (1 as i32) << 2 as i32
                                != 0
                        {
                        if ((*type_0).contentTypeDef).is_null()
                            || ((*(*type_0).contentTypeDef).baseType).is_null()
                        {
                            xmlSchemaPCustomErr(
                                pctxt,
                                XML_SCHEMAP_INTERNAL,
                                type_0 as xmlSchemaBasicItemPtr,
                                0 as xmlNodePtr,
                                b"Internal error: xmlSchemaTypeFixup, complex type '%s': the <simpleContent><restriction> is missing a <simpleType> child, but was not caught by xmlSchemaCheckSRCCT()\0"
                                    as *const u8 as *const i8,
                                (*type_0).name,
                            );
                            current_block = 345336241299298347;
                        } else {
                            current_block = 5265702136860997526;
                        }
                    } else if ((*baseType).type_0 as u32
                            == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                            || (*baseType).builtInType
                                == XML_SCHEMAS_ANYTYPE as i32)
                            && (*type_0).flags & (1 as i32) << 1 as i32
                                != 0
                        {
                        if ((*baseType).contentTypeDef).is_null() {
                            xmlSchemaPCustomErr(
                                pctxt,
                                XML_SCHEMAP_INTERNAL,
                                type_0 as xmlSchemaBasicItemPtr,
                                0 as xmlNodePtr,
                                b"Internal error: xmlSchemaTypeFixup, complex type '%s': the <extension>ed base type is a complex type with no simple content type\0"
                                    as *const u8 as *const i8,
                                (*type_0).name,
                            );
                            current_block = 345336241299298347;
                        } else {
                            let fresh385 = &mut ((*type_0).contentTypeDef);
                            *fresh385 = (*baseType).contentTypeDef;
                            current_block = 5265702136860997526;
                        }
                    } else if ((*baseType).type_0 as u32
                            == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                            || (*baseType).type_0 as u32
                                == XML_SCHEMA_TYPE_BASIC as i32 as u32
                                && (*baseType).builtInType
                                    != XML_SCHEMAS_ANYTYPE as i32)
                            && (*type_0).flags & (1 as i32) << 1 as i32
                                != 0
                        {
                        let fresh386 = &mut ((*type_0).contentTypeDef);
                        *fresh386 = baseType;
                        current_block = 5265702136860997526;
                    } else {
                        xmlSchemaPCustomErr(
                            pctxt,
                            XML_SCHEMAP_INTERNAL,
                            type_0 as xmlSchemaBasicItemPtr,
                            0 as xmlNodePtr,
                            b"Internal error: xmlSchemaTypeFixup, complex type '%s' with <simpleContent>: unhandled derivation case\0"
                                as *const u8 as *const i8,
                            (*type_0).name,
                        );
                        current_block = 345336241299298347;
                    }
                } else {
                    let mut dummySequence: i32 = 0 as i32;
                    let mut particle: xmlSchemaParticlePtr = (*type_0).subtypes
                        as xmlSchemaParticlePtr;
                    if particle.is_null()
                        || (*particle).type_0 as u32
                            == XML_SCHEMA_TYPE_PARTICLE as i32 as u32
                            && ((*(*particle).children).type_0 as u32
                                == XML_SCHEMA_TYPE_ALL as i32 as u32
                                || (*(*particle).children).type_0 as u32
                                    == XML_SCHEMA_TYPE_SEQUENCE as i32 as u32
                                || (*(*particle).children).type_0 as u32
                                    == XML_SCHEMA_TYPE_CHOICE as i32 as u32
                                    && (*particle).minOccurs == 0 as i32)
                            && ((*(*particle).children).children).is_null()
                    {
                        if (*type_0).flags & (1 as i32) << 0 as i32 != 0
                        {
                            if particle.is_null()
                                || (*(*particle).children).type_0 as u32
                                    != XML_SCHEMA_TYPE_SEQUENCE as i32 as u32
                            {
                                particle = xmlSchemaAddParticle(
                                    pctxt,
                                    (*type_0).node,
                                    1 as i32,
                                    1 as i32,
                                );
                                if particle.is_null() {
                                    current_block = 345336241299298347;
                                } else {
                                    let fresh387 = &mut ((*particle).children);
                                    *fresh387 = xmlSchemaAddModelGroup(
                                        pctxt,
                                        (*pctxt).schema,
                                        XML_SCHEMA_TYPE_SEQUENCE,
                                        (*type_0).node,
                                    ) as xmlSchemaTreeItemPtr;
                                    if ((*particle).children).is_null() {
                                        current_block = 345336241299298347;
                                    } else {
                                        let fresh388 = &mut ((*type_0).subtypes);
                                        *fresh388 = particle as xmlSchemaTypePtr;
                                        current_block = 17075014677070940716;
                                    }
                                }
                            } else {
                                current_block = 17075014677070940716;
                            }
                            match current_block {
                                345336241299298347 => {}
                                _ => {
                                    dummySequence = 1 as i32;
                                    (*type_0).contentType = XML_SCHEMA_CONTENT_ELEMENTS;
                                    current_block = 4216521074440650966;
                                }
                            }
                        } else {
                            (*type_0).contentType = XML_SCHEMA_CONTENT_EMPTY;
                            current_block = 4216521074440650966;
                        }
                    } else {
                        (*type_0).contentType = XML_SCHEMA_CONTENT_ELEMENTS;
                        current_block = 4216521074440650966;
                    }
                    match current_block {
                        345336241299298347 => {}
                        _ => {
                            if (*type_0).flags & (1 as i32) << 2 as i32
                                != 0
                            {
                                if (*type_0).contentType as u32
                                    != XML_SCHEMA_CONTENT_EMPTY as i32 as u32
                                {
                                    if (*type_0).flags & (1 as i32) << 0 as i32
                                        != 0
                                    {
                                        (*type_0).contentType = XML_SCHEMA_CONTENT_MIXED;
                                    }
                                }
                                current_block = 5265702136860997526;
                            } else if (*type_0).contentType as u32
                                    == XML_SCHEMA_CONTENT_EMPTY as i32 as u32
                                {
                                (*type_0).contentType = (*baseType).contentType;
                                let fresh389 = &mut ((*type_0).subtypes);
                                *fresh389 = (*baseType).subtypes;
                                let fresh390 = &mut ((*type_0).contentTypeDef);
                                *fresh390 = (*baseType).contentTypeDef;
                                current_block = 5265702136860997526;
                            } else if (*baseType).contentType as u32
                                    == XML_SCHEMA_CONTENT_EMPTY as i32 as u32
                                {
                                if (*type_0).flags & (1 as i32) << 0 as i32
                                    != 0
                                {
                                    (*type_0).contentType = XML_SCHEMA_CONTENT_MIXED;
                                }
                                current_block = 5265702136860997526;
                            } else {
                                if (*type_0).flags & (1 as i32) << 0 as i32
                                    != 0
                                {
                                    (*type_0).contentType = XML_SCHEMA_CONTENT_MIXED;
                                }
                                if !((*type_0).subtypes as xmlSchemaParticlePtr).is_null()
                                    && !((*((*type_0).subtypes as xmlSchemaParticlePtr))
                                        .children)
                                        .is_null()
                                    && (*(*((*type_0).subtypes as xmlSchemaParticlePtr))
                                        .children)
                                        .type_0 as u32
                                        == XML_SCHEMA_TYPE_ALL as i32 as u32
                                {
                                    xmlSchemaCustomErr(
                                        pctxt as xmlSchemaAbstractCtxtPtr,
                                        XML_SCHEMAP_COS_ALL_LIMITED,
                                        xmlSchemaGetComponentNode(type_0 as xmlSchemaBasicItemPtr),
                                        0 as xmlSchemaBasicItemPtr,
                                        b"The type has an 'all' model group in its {content type} and thus cannot be derived from a non-empty type, since this would produce a 'sequence' model group containing the 'all' model group; 'all' model groups are not allowed to appear inside other model groups\0"
                                            as *const u8 as *const i8,
                                        0 as *const xmlChar,
                                        0 as *const xmlChar,
                                    );
                                    current_block = 5265702136860997526;
                                } else if !((*baseType).subtypes as xmlSchemaParticlePtr)
                                        .is_null()
                                        && !((*((*baseType).subtypes as xmlSchemaParticlePtr))
                                            .children)
                                            .is_null()
                                        && (*(*((*baseType).subtypes as xmlSchemaParticlePtr))
                                            .children)
                                            .type_0 as u32
                                            == XML_SCHEMA_TYPE_ALL as i32 as u32
                                    {
                                    xmlSchemaCustomErr(
                                        pctxt as xmlSchemaAbstractCtxtPtr,
                                        XML_SCHEMAP_COS_ALL_LIMITED,
                                        xmlSchemaGetComponentNode(type_0 as xmlSchemaBasicItemPtr),
                                        0 as xmlSchemaBasicItemPtr,
                                        b"A type cannot be derived by extension from a type which has an 'all' model group in its {content type}, since this would produce a 'sequence' model group containing the 'all' model group; 'all' model groups are not allowed to appear inside other model groups\0"
                                            as *const u8 as *const i8,
                                        0 as *const xmlChar,
                                        0 as *const xmlChar,
                                    );
                                    current_block = 5265702136860997526;
                                } else if dummySequence == 0 {
                                    let mut effectiveContent: xmlSchemaTreeItemPtr = (*type_0)
                                        .subtypes as xmlSchemaTreeItemPtr;
                                    particle = xmlSchemaAddParticle(
                                        pctxt,
                                        (*type_0).node,
                                        1 as i32,
                                        1 as i32,
                                    );
                                    if particle.is_null() {
                                        current_block = 345336241299298347;
                                    } else {
                                        let fresh391 = &mut ((*particle).children);
                                        *fresh391 = xmlSchemaAddModelGroup(
                                            pctxt,
                                            (*pctxt).schema,
                                            XML_SCHEMA_TYPE_SEQUENCE,
                                            (*type_0).node,
                                        ) as xmlSchemaTreeItemPtr;
                                        if ((*particle).children).is_null() {
                                            current_block = 345336241299298347;
                                        } else {
                                            let fresh392 = &mut ((*type_0).subtypes);
                                            *fresh392 = particle as xmlSchemaTypePtr;
                                            let fresh393 = &mut ((*(*particle).children).children);
                                            *fresh393 = xmlSchemaAddParticle(
                                                pctxt,
                                                (*type_0).node,
                                                (*((*baseType).subtypes as xmlSchemaParticlePtr)).minOccurs,
                                                (*((*baseType).subtypes as xmlSchemaParticlePtr)).maxOccurs,
                                            ) as xmlSchemaTreeItemPtr;
                                            if ((*(*particle).children).children).is_null() {
                                                current_block = 345336241299298347;
                                            } else {
                                                particle = (*(*particle).children).children
                                                    as xmlSchemaParticlePtr;
                                                let fresh394 = &mut ((*particle).children);
                                                *fresh394 = (*((*baseType).subtypes
                                                    as xmlSchemaParticlePtr))
                                                    .children;
                                                let fresh395 = &mut ((*particle).next);
                                                *fresh395 = effectiveContent;
                                                current_block = 5265702136860997526;
                                            }
                                        }
                                    }
                                } else {
                                    let fresh396 = &mut ((*(*particle).children).children);
                                    *fresh396 = (*baseType).subtypes as xmlSchemaTreeItemPtr;
                                    current_block = 5265702136860997526;
                                }
                            }
                        }
                    }
                }
                match current_block {
                    345336241299298347 => {}
                    6926858937233525393 => {}
                    _ => {
                        res = xmlSchemaFixupTypeAttributeUses(pctxt, type_0);
                        if res == -(1 as i32) {
                            current_block = 345336241299298347;
                        } else if res != 0 as i32 {
                            current_block = 6926858937233525393;
                        } else {
                            res = xmlSchemaCheckCTComponent(pctxt, type_0);
                            if res == -(1 as i32) {
                                current_block = 345336241299298347;
                            } else if res != 0 as i32 {
                                current_block = 6926858937233525393;
                            } else if olderrs != (*pctxt).nberrors {
                                return (*pctxt).err
                            } else {
                                return 0 as i32
                            }
                        }
                    }
                }
            }
            match current_block {
                345336241299298347 => {}
                _ => {
                    (*type_0).flags |= (1 as i32) << 23 as i32;
                    return (*pctxt).err;
                }
            }
        }
    }
    (*type_0).flags |= (1 as i32) << 23 as i32;
    return -(1 as i32);
}
unsafe extern "C" fn xmlSchemaTypeFixup(
    mut type_0: xmlSchemaTypePtr,
    mut actxt: xmlSchemaAbstractCtxtPtr,
) -> i32 {
    if type_0.is_null() {
        return 0 as i32;
    }
    if (*actxt).type_0 != 1 as i32 {
        xmlSchemaInternalErr(
            actxt,
            b"xmlSchemaTypeFixup\0" as *const u8 as *const i8,
            b"this function needs a parser context\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    if !((*type_0).type_0 as u32
        != XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (*type_0).flags & (1 as i32) << 22 as i32 == 0 as i32)
    {
        return 0 as i32;
    }
    if (*type_0).type_0 as u32
        == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
    {
        return xmlSchemaFixupComplexType(actxt as xmlSchemaParserCtxtPtr, type_0)
    } else {
        if (*type_0).type_0 as u32
            == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
        {
            return xmlSchemaFixupSimpleTypeStageTwo(
                actxt as xmlSchemaParserCtxtPtr,
                type_0,
            );
        }
    }
    return 0 as i32;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaCheckFacet(
    mut facet: xmlSchemaFacetPtr,
    mut typeDecl: xmlSchemaTypePtr,
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut name: *const xmlChar,
) -> i32 {
    let mut current_block: u64;
    let mut ret: i32 = 0 as i32;
    let mut ctxtGiven: i32 = 0;
    if facet.is_null() || typeDecl.is_null() {
        return -(1 as i32);
    }
    if pctxt.is_null() {
        ctxtGiven = 0 as i32;
    } else {
        ctxtGiven = 1 as i32;
    }
    match (*facet).type_0 as u32 {
        1000 | 1001 | 1002 | 1003 | 1007 => {
            let mut base: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
            if (*typeDecl).type_0 as u32
                != XML_SCHEMA_TYPE_BASIC as i32 as u32
            {
                base = (*typeDecl).baseType;
                if base.is_null() {
                    xmlSchemaInternalErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaCheckFacet\0" as *const u8 as *const i8,
                        b"a type user derived type has no base type\0" as *const u8
                            as *const i8,
                    );
                    return -(1 as i32);
                }
            } else {
                base = typeDecl;
            }
            if ctxtGiven == 0 {
                pctxt = xmlSchemaNewParserCtxt(
                    b"*\0" as *const u8 as *const i8,
                );
                if pctxt.is_null() {
                    return -(1 as i32);
                }
            }
            ret = xmlSchemaVCheckCVCSimpleType(
                pctxt as xmlSchemaAbstractCtxtPtr,
                (*facet).node,
                base,
                (*facet).value,
                &mut (*facet).val,
                1 as i32,
                1 as i32,
                0 as i32,
            );
            if ret != 0 as i32 {
                if ret < 0 as i32 {
                    if ctxtGiven != 0 {
                        xmlSchemaCustomErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            XML_SCHEMAP_INTERNAL,
                            (*facet).node,
                            0 as xmlSchemaBasicItemPtr,
                            b"Internal error: xmlSchemaCheckFacet, failed to validate the value '%s' of the facet '%s' against the base type\0"
                                as *const u8 as *const i8,
                            (*facet).value,
                            xmlSchemaFacetTypeToString((*facet).type_0),
                        );
                    }
                    current_block = 5348683486121694512;
                } else {
                    ret = XML_SCHEMAP_INVALID_FACET_VALUE as i32;
                    if ctxtGiven != 0 {
                        let mut str: *mut xmlChar = 0 as *mut xmlChar;
                        xmlSchemaCustomErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            ret as xmlParserErrors,
                            (*facet).node,
                            facet as xmlSchemaBasicItemPtr,
                            b"The value '%s' of the facet does not validate against the base type '%s'\0"
                                as *const u8 as *const i8,
                            (*facet).value,
                            xmlSchemaFormatQName(
                                &mut str,
                                (*base).targetNamespace,
                                (*base).name,
                            ),
                        );
                        if !str.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(str as *mut libc::c_void);
                            str = 0 as *mut xmlChar;
                        }
                    }
                    current_block = 15604527402135937264;
                }
            } else {
                if ((*facet).val).is_null() {
                    if ctxtGiven != 0 {
                        xmlSchemaInternalErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaCheckFacet\0" as *const u8 as *const i8,
                            b"value was not computed\0" as *const u8
                                as *const i8,
                        );
                    }
                    (*__xmlGenericError())
                        .expect(
                            "non-null function pointer",
                        )(
                        *__xmlGenericErrorContext(),
                        b"Unimplemented block at %s:%d\n\0" as *const u8
                            as *const i8,
                        b"xmlschemas.c\0" as *const u8 as *const i8,
                        18869 as i32,
                    );
                }
                current_block = 15604527402135937264;
            }
        }
        1006 => {
            let fresh397 = &mut ((*facet).regexp);
            *fresh397 = xmlRegexpCompile((*facet).value);
            if ((*facet).regexp).is_null() {
                ret = XML_SCHEMAP_REGEXP_INVALID as i32;
                if ctxtGiven != 0 {
                    xmlSchemaCustomErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        ret as xmlParserErrors,
                        (*facet).node,
                        typeDecl as xmlSchemaBasicItemPtr,
                        b"The value '%s' of the facet 'pattern' is not a valid regular expression\0"
                            as *const u8 as *const i8,
                        (*facet).value,
                        0 as *const xmlChar,
                    );
                }
            }
            current_block = 15604527402135937264;
        }
        1004 | 1005 | 1009 | 1010 | 1011 => {
            if (*facet).type_0 as u32
                == XML_SCHEMA_FACET_TOTALDIGITS as i32 as u32
            {
                ret = xmlSchemaValidatePredefinedType(
                    xmlSchemaGetBuiltInType(XML_SCHEMAS_PINTEGER),
                    (*facet).value,
                    &mut (*facet).val,
                );
            } else {
                ret = xmlSchemaValidatePredefinedType(
                    xmlSchemaGetBuiltInType(XML_SCHEMAS_NNINTEGER),
                    (*facet).value,
                    &mut (*facet).val,
                );
            }
            if ret != 0 as i32 {
                if ret < 0 as i32 {
                    if ctxtGiven != 0 {
                        xmlSchemaInternalErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaCheckFacet\0" as *const u8 as *const i8,
                            b"validating facet value\0" as *const u8
                                as *const i8,
                        );
                    }
                    current_block = 5348683486121694512;
                } else {
                    ret = XML_SCHEMAP_INVALID_FACET_VALUE as i32;
                    if ctxtGiven != 0 {
                        xmlSchemaCustomErr4(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            ret as xmlParserErrors,
                            (*facet).node,
                            typeDecl as xmlSchemaBasicItemPtr,
                            b"The value '%s' of the facet '%s' is not a valid '%s'\0"
                                as *const u8 as *const i8,
                            (*facet).value,
                            xmlSchemaFacetTypeToString((*facet).type_0),
                            if (*facet).type_0 as u32
                                != XML_SCHEMA_FACET_TOTALDIGITS as i32
                                    as u32
                            {
                                b"nonNegativeInteger\0" as *const u8 as *const i8
                                    as *mut xmlChar
                            } else {
                                b"positiveInteger\0" as *const u8 as *const i8
                                    as *mut xmlChar
                            },
                            0 as *const xmlChar,
                        );
                    }
                    current_block = 15604527402135937264;
                }
            } else {
                current_block = 15604527402135937264;
            }
        }
        1008 => {
            if xmlStrEqual(
                (*facet).value,
                b"preserve\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
                (*facet).whitespace = 1 as i32;
            } else if xmlStrEqual(
                    (*facet).value,
                    b"replace\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                (*facet).whitespace = 2 as i32;
            } else if xmlStrEqual(
                    (*facet).value,
                    b"collapse\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                (*facet).whitespace = 3 as i32;
            } else {
                ret = XML_SCHEMAP_INVALID_FACET_VALUE as i32;
                if ctxtGiven != 0 {
                    xmlSchemaCustomErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        ret as xmlParserErrors,
                        (*facet).node,
                        typeDecl as xmlSchemaBasicItemPtr,
                        b"The value '%s' of the facet 'whitespace' is not valid\0"
                            as *const u8 as *const i8,
                        (*facet).value,
                        0 as *const xmlChar,
                    );
                }
            }
            current_block = 15604527402135937264;
        }
        _ => {
            current_block = 15604527402135937264;
        }
    }
    match current_block {
        5348683486121694512 => {
            if ctxtGiven == 0 && !pctxt.is_null() {
                xmlSchemaFreeParserCtxt(pctxt);
            }
            return -(1 as i32);
        }
        _ => {
            if ctxtGiven == 0 && !pctxt.is_null() {
                xmlSchemaFreeParserCtxt(pctxt);
            }
            return ret;
        }
    };
}
unsafe extern "C" fn xmlSchemaCheckFacetValues(
    mut typeDecl: xmlSchemaTypePtr,
    mut pctxt: xmlSchemaParserCtxtPtr,
) -> i32 {
    let mut current_block: u64;
    let mut res: i32 = 0;
    let mut olderrs: i32 = (*pctxt).nberrors;
    let mut name: *const xmlChar = (*typeDecl).name;
    if !((*typeDecl).facets).is_null() {
        let mut facet: xmlSchemaFacetPtr = (*typeDecl).facets;
        if ((*pctxt).vctxt).is_null() {
            if xmlSchemaCreateVCtxtOnPCtxt(pctxt) == -(1 as i32) {
                return -(1 as i32);
            }
        }
        let fresh398 = &mut ((*(*pctxt).vctxt).schema);
        *fresh398 = (*pctxt).schema;
        loop {
            if facet.is_null() {
                current_block = 7746791466490516765;
                break;
            }
            res = xmlSchemaCheckFacet(facet, typeDecl, pctxt, name);
            if res == -(1 as i32) {
                current_block = 966742325134978464;
                break;
            }
            facet = (*facet).next;
        }
        match current_block {
            966742325134978464 => return -(1 as i32),
            _ => {
                let fresh399 = &mut ((*(*pctxt).vctxt).schema);
                *fresh399 = 0 as xmlSchemaPtr;
            }
        }
    }
    if olderrs != (*pctxt).nberrors {
        return (*pctxt).err;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaGetCircModelGrDefRef(
    mut groupDef: xmlSchemaModelGroupDefPtr,
    mut particle: xmlSchemaTreeItemPtr,
) -> xmlSchemaTreeItemPtr {
    let mut circ: xmlSchemaTreeItemPtr = 0 as xmlSchemaTreeItemPtr;
    let mut term: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
    let mut gdef: xmlSchemaModelGroupDefPtr = 0 as *mut xmlSchemaModelGroupDef;
    let mut current_block_13: u64;
    while !particle.is_null() {
        term = (*particle).children;
        if !term.is_null() {
            match (*term).type_0 as u32 {
                17 => {
                    current_block_13 = 17757133326439237465;
                    match current_block_13 {
                        7522209452724882128 => {
                            circ = xmlSchemaGetCircModelGrDefRef(
                                groupDef,
                                (*term).children,
                            );
                            if !circ.is_null() {
                                return circ;
                            }
                        }
                        _ => {
                            gdef = term as xmlSchemaModelGroupDefPtr;
                            if gdef == groupDef {
                                return particle;
                            }
                            if !((*gdef).flags & (1 as i32) << 0 as i32
                                != 0)
                            {
                                if !((*gdef).children).is_null() {
                                    (*gdef).flags |= (1 as i32) << 0 as i32;
                                    circ = xmlSchemaGetCircModelGrDefRef(
                                        groupDef,
                                        (*(*gdef).children).children,
                                    );
                                    (*gdef).flags ^= (1 as i32) << 0 as i32;
                                    if !circ.is_null() {
                                        return circ;
                                    }
                                }
                            }
                        }
                    }
                }
                6 | 7 | 8 => {
                    current_block_13 = 7522209452724882128;
                    match current_block_13 {
                        7522209452724882128 => {
                            circ = xmlSchemaGetCircModelGrDefRef(
                                groupDef,
                                (*term).children,
                            );
                            if !circ.is_null() {
                                return circ;
                            }
                        }
                        _ => {
                            gdef = term as xmlSchemaModelGroupDefPtr;
                            if gdef == groupDef {
                                return particle;
                            }
                            if !((*gdef).flags & (1 as i32) << 0 as i32
                                != 0)
                            {
                                if !((*gdef).children).is_null() {
                                    (*gdef).flags |= (1 as i32) << 0 as i32;
                                    circ = xmlSchemaGetCircModelGrDefRef(
                                        groupDef,
                                        (*(*gdef).children).children,
                                    );
                                    (*gdef).flags ^= (1 as i32) << 0 as i32;
                                    if !circ.is_null() {
                                        return circ;
                                    }
                                }
                            }
                        }
                    }
                }
                _ => {}
            }
        }
        particle = (*particle).next;
    }
    return 0 as xmlSchemaTreeItemPtr;
}
unsafe extern "C" fn xmlSchemaCheckGroupDefCircular(
    mut item: xmlSchemaModelGroupDefPtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) {
    if item.is_null()
        || (*item).type_0 as u32
            != XML_SCHEMA_TYPE_GROUP as i32 as u32
        || ((*item).children).is_null()
    {
        return;
    }
    let mut circ: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
    circ = xmlSchemaGetCircModelGrDefRef(item, (*(*item).children).children);
    if !circ.is_null() {
        let mut str: *mut xmlChar = 0 as *mut xmlChar;
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_MG_PROPS_CORRECT_2,
            0 as xmlSchemaBasicItemPtr,
            xmlSchemaGetComponentNode(circ as xmlSchemaBasicItemPtr),
            b"Circular reference to the model group definition '%s' defined\0"
                as *const u8 as *const i8,
            xmlSchemaFormatQName(&mut str, (*item).targetNamespace, (*item).name),
        );
        if !str.is_null() {
            xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
            str = 0 as *mut xmlChar;
        }
        let fresh400 = &mut ((*circ).children);
        *fresh400 = 0 as xmlSchemaTreeItemPtr;
    }
}
unsafe extern "C" fn xmlSchemaModelGroupToModelGroupDefFixup(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut mg: xmlSchemaModelGroupPtr,
) {
    let mut particle: xmlSchemaParticlePtr = (*mg).children as xmlSchemaParticlePtr;
    while !particle.is_null() {
        if ((*particle).children).is_null()
            || (*(*particle).children).type_0 as u32
                != XML_SCHEMA_TYPE_GROUP as i32 as u32
        {
            particle = (*particle).next as xmlSchemaParticlePtr;
        } else if ((*((*particle).children as xmlSchemaModelGroupPtr)).children)
                .is_null()
            {
            let fresh401 = &mut ((*particle).children);
            *fresh401 = 0 as xmlSchemaTreeItemPtr;
            particle = (*particle).next as xmlSchemaParticlePtr;
        } else {
            let fresh402 = &mut ((*particle).children);
            *fresh402 = (*((*particle).children as xmlSchemaModelGroupPtr)).children;
            particle = (*particle).next as xmlSchemaParticlePtr;
        }
    }
}
unsafe extern "C" fn xmlSchemaCheckAttrGroupCircularRecur(
    mut ctxtGr: xmlSchemaAttributeGroupPtr,
    mut list: xmlSchemaItemListPtr,
) -> xmlSchemaQNameRefPtr {
    let mut gr: xmlSchemaAttributeGroupPtr = 0 as *mut xmlSchemaAttributeGroup;
    let mut ref_0: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    let mut circ: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    let mut i: i32 = 0;
    i = 0 as i32;
    while i < (*list).nbItems {
        ref_0 = *((*list).items).offset(i as isize) as xmlSchemaQNameRefPtr;
        if (*ref_0).type_0 as u32
            == XML_SCHEMA_EXTRA_QNAMEREF as i32 as u32
            && (*ref_0).itemType as u32
                == XML_SCHEMA_TYPE_ATTRIBUTEGROUP as i32 as u32
            && !((*ref_0).item).is_null()
        {
            gr = (*ref_0).item as xmlSchemaAttributeGroupPtr;
            if gr == ctxtGr {
                return ref_0;
            }
            if !((*gr).flags & (1 as i32) << 2 as i32 != 0) {
                if !((*gr).attrUses).is_null()
                    && (*gr).flags & (1 as i32) << 4 as i32 != 0
                {
                    (*gr).flags |= (1 as i32) << 2 as i32;
                    circ = xmlSchemaCheckAttrGroupCircularRecur(
                        ctxtGr,
                        (*gr).attrUses as xmlSchemaItemListPtr,
                    );
                    (*gr).flags ^= (1 as i32) << 2 as i32;
                    if !circ.is_null() {
                        return circ;
                    }
                }
            }
        }
        i += 1;
    }
    return 0 as xmlSchemaQNameRefPtr;
}
unsafe extern "C" fn xmlSchemaCheckAttrGroupCircular(
    mut attrGr: xmlSchemaAttributeGroupPtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) -> i32 {
    if ((*attrGr).attrUses).is_null() {
        return 0 as i32
    } else {
        if (*attrGr).flags & (1 as i32) << 4 as i32 == 0 as i32 {
            return 0 as i32
        } else {
            let mut circ: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
            circ = xmlSchemaCheckAttrGroupCircularRecur(
                attrGr,
                (*attrGr).attrUses as xmlSchemaItemListPtr,
            );
            if !circ.is_null() {
                let mut str: *mut xmlChar = 0 as *mut xmlChar;
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3,
                    0 as xmlSchemaBasicItemPtr,
                    xmlSchemaGetComponentNode(circ as xmlSchemaBasicItemPtr),
                    b"Circular reference to the attribute group '%s' defined\0"
                        as *const u8 as *const i8,
                    xmlSchemaGetComponentQName(&mut str, attrGr as *mut libc::c_void),
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                let fresh403 = &mut ((*circ).item);
                *fresh403 = 0 as xmlSchemaBasicItemPtr;
                return (*ctxt).err;
            }
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaExpandAttributeGroupRefs(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut item: xmlSchemaBasicItemPtr,
    mut completeWild: *mut xmlSchemaWildcardPtr,
    mut list: xmlSchemaItemListPtr,
    mut prohibs: xmlSchemaItemListPtr,
) -> i32 {
    let mut gr: xmlSchemaAttributeGroupPtr = 0 as *mut xmlSchemaAttributeGroup;
    let mut use_0: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
    let mut sublist: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    let mut i: i32 = 0;
    let mut j: i32 = 0;
    let mut created: i32 = if (*completeWild).is_null() {
        0 as i32
    } else {
        1 as i32
    };
    if !prohibs.is_null() {
        (*prohibs).nbItems = 0 as i32;
    }
    i = 0 as i32;
    while i < (*list).nbItems {
        use_0 = *((*list).items).offset(i as isize) as xmlSchemaAttributeUsePtr;
        if (*use_0).type_0 as u32
            == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB as i32 as u32
        {
            if prohibs.is_null() {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaExpandAttributeGroupRefs\0" as *const u8
                        as *const i8,
                    b"unexpected attr prohibition found\0" as *const u8
                        as *const i8,
                );
                return -(1 as i32);
            }
            if xmlSchemaItemListRemove(list, i) == -(1 as i32) {
                return -(1 as i32);
            }
            i -= 1;
            xmlSchemaItemListAddSize(
                prohibs,
                2 as i32,
                use_0 as *mut libc::c_void,
            );
        } else if (*use_0).type_0 as u32
                == XML_SCHEMA_EXTRA_QNAMEREF as i32 as u32
                && (*(use_0 as xmlSchemaQNameRefPtr)).itemType as u32
                    == XML_SCHEMA_TYPE_ATTRIBUTEGROUP as i32 as u32
            {
            if ((*(use_0 as xmlSchemaQNameRefPtr)).item).is_null() {
                return -(1 as i32);
            }
            gr = (*(use_0 as xmlSchemaQNameRefPtr)).item as xmlSchemaAttributeGroupPtr;
            if (*gr).flags & (1 as i32) << 0 as i32 == 0 as i32 {
                if xmlSchemaAttributeGroupExpandRefs(pctxt, gr) == -(1 as i32) {
                    return -(1 as i32);
                }
            }
            if !((*gr).attributeWildcard).is_null() {
                if (*completeWild).is_null() {
                    *completeWild = (*gr).attributeWildcard;
                } else {
                    if created == 0 {
                        let mut tmpWild: xmlSchemaWildcardPtr = 0
                            as *mut xmlSchemaWildcard;
                        tmpWild = xmlSchemaAddWildcard(
                            pctxt,
                            (*pctxt).schema,
                            XML_SCHEMA_TYPE_ANY_ATTRIBUTE,
                            xmlSchemaGetComponentNode(item),
                        );
                        if tmpWild.is_null() {
                            return -(1 as i32);
                        }
                        if xmlSchemaCloneWildcardNsConstraints(
                            pctxt,
                            tmpWild,
                            *completeWild,
                        ) == -(1 as i32)
                        {
                            return -(1 as i32);
                        }
                        (*tmpWild).processContents = (**completeWild).processContents;
                        *completeWild = tmpWild;
                        created = 1 as i32;
                    }
                    if xmlSchemaIntersectWildcards(
                        pctxt,
                        *completeWild,
                        (*gr).attributeWildcard,
                    ) == -(1 as i32)
                    {
                        return -(1 as i32);
                    }
                }
            }
            sublist = (*gr).attrUses as xmlSchemaItemListPtr;
            if sublist.is_null() || (*sublist).nbItems == 0 as i32 {
                if xmlSchemaItemListRemove(list, i) == -(1 as i32) {
                    return -(1 as i32);
                }
                i -= 1;
            } else {
                let fresh404 = &mut (*((*list).items).offset(i as isize));
                *fresh404 = *((*sublist).items).offset(0 as i32 as isize);
                if (*sublist).nbItems != 1 as i32 {
                    j = 1 as i32;
                    while j < (*sublist).nbItems {
                        i += 1;
                        if xmlSchemaItemListInsert(
                            list,
                            *((*sublist).items).offset(j as isize),
                            i,
                        ) == -(1 as i32)
                        {
                            return -(1 as i32);
                        }
                        j += 1;
                    }
                }
            }
        }
        i += 1;
    }
    if !prohibs.is_null() && (*prohibs).nbItems != 0 as i32
        && (*list).nbItems != 0 as i32
    {
        let mut prohib: xmlSchemaAttributeUseProhibPtr = 0
            as *mut xmlSchemaAttributeUseProhib;
        i = (*prohibs).nbItems - 1 as i32;
        while i >= 0 as i32 {
            prohib = *((*prohibs).items).offset(i as isize)
                as xmlSchemaAttributeUseProhibPtr;
            j = 0 as i32;
            while j < (*list).nbItems {
                use_0 = *((*list).items).offset(j as isize) as xmlSchemaAttributeUsePtr;
                if (*prohib).name == (*(*use_0).attrDecl).name
                    && (*prohib).targetNamespace == (*(*use_0).attrDecl).targetNamespace
                {
                    let mut str: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaCustomWarning(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
                        (*prohib).node,
                        0 as xmlSchemaTypePtr,
                        b"Skipping pointless attribute use prohibition '%s', since a corresponding attribute use exists already in the type definition\0"
                            as *const u8 as *const i8,
                        xmlSchemaFormatQName(
                            &mut str,
                            (*prohib).targetNamespace,
                            (*prohib).name,
                        ),
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                    if !str.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str as *mut libc::c_void);
                        str = 0 as *mut xmlChar;
                    }
                    if xmlSchemaItemListRemove(prohibs, i) == -(1 as i32) {
                        return -(1 as i32);
                    }
                    break;
                } else {
                    j += 1;
                }
            }
            i -= 1;
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaAttributeGroupExpandRefs(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut attrGr: xmlSchemaAttributeGroupPtr,
) -> i32 {
    if ((*attrGr).attrUses).is_null()
        || (*attrGr).flags & (1 as i32) << 0 as i32 != 0
    {
        return 0 as i32;
    }
    (*attrGr).flags |= (1 as i32) << 0 as i32;
    if xmlSchemaExpandAttributeGroupRefs(
        pctxt,
        attrGr as xmlSchemaBasicItemPtr,
        &mut (*attrGr).attributeWildcard,
        (*attrGr).attrUses as xmlSchemaItemListPtr,
        0 as xmlSchemaItemListPtr,
    ) == -(1 as i32)
    {
        return -(1 as i32);
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaCheckAGPropsCorrect(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut attrGr: xmlSchemaAttributeGroupPtr,
) -> i32 {
    if !((*attrGr).attrUses).is_null()
        && (*((*attrGr).attrUses as xmlSchemaItemListPtr)).nbItems > 1 as i32
    {
        let mut uses: xmlSchemaItemListPtr = (*attrGr).attrUses as xmlSchemaItemListPtr;
        let mut use_0: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
        let mut tmp: xmlSchemaAttributeUsePtr = 0 as *mut xmlSchemaAttributeUse;
        let mut i: i32 = 0;
        let mut j: i32 = 0;
        let mut hasId: i32 = 0 as i32;
        i = (*uses).nbItems - 1 as i32;
        while i >= 0 as i32 {
            let mut current_block_27: u64;
            use_0 = *((*uses).items).offset(i as isize) as xmlSchemaAttributeUsePtr;
            if i > 0 as i32 {
                j = i - 1 as i32;
                loop {
                    if !(j >= 0 as i32) {
                        current_block_27 = 12124785117276362961;
                        break;
                    }
                    tmp = *((*uses).items).offset(j as isize)
                        as xmlSchemaAttributeUsePtr;
                    if (*(*use_0).attrDecl).name == (*(*tmp).attrDecl).name
                        && (*(*use_0).attrDecl).targetNamespace
                            == (*(*tmp).attrDecl).targetNamespace
                    {
                        let mut str: *mut xmlChar = 0 as *mut xmlChar;
                        xmlSchemaCustomErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            XML_SCHEMAP_AG_PROPS_CORRECT,
                            (*attrGr).node,
                            attrGr as xmlSchemaBasicItemPtr,
                            b"Duplicate %s\0" as *const u8 as *const i8,
                            xmlSchemaGetComponentDesignation(
                                &mut str,
                                use_0 as *mut libc::c_void,
                            ),
                            0 as *const xmlChar,
                        );
                        if !str.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(str as *mut libc::c_void);
                            str = 0 as *mut xmlChar;
                        }
                        if xmlSchemaItemListRemove(uses, i) == -(1 as i32) {
                            return -(1 as i32);
                        }
                        current_block_27 = 7245201122033322888;
                        break;
                    } else {
                        j -= 1;
                    }
                }
            } else {
                current_block_27 = 12124785117276362961;
            }
            match current_block_27 {
                12124785117276362961 => {
                    if !((*(*use_0).attrDecl).subtypes).is_null() {
                        if xmlSchemaIsDerivedFromBuiltInType(
                            (*(*use_0).attrDecl).subtypes,
                            XML_SCHEMAS_ID as i32,
                        ) != 0
                        {
                            if hasId != 0 {
                                let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                                xmlSchemaCustomErr(
                                    pctxt as xmlSchemaAbstractCtxtPtr,
                                    XML_SCHEMAP_AG_PROPS_CORRECT,
                                    (*attrGr).node,
                                    attrGr as xmlSchemaBasicItemPtr,
                                    b"There must not exist more than one attribute declaration of type 'xs:ID' (or derived from 'xs:ID'). The %s violates this constraint\0"
                                        as *const u8 as *const i8,
                                    xmlSchemaGetComponentDesignation(
                                        &mut str_0,
                                        use_0 as *mut libc::c_void,
                                    ),
                                    0 as *const xmlChar,
                                );
                                if !str_0.is_null() {
                                    xmlFree
                                        .expect(
                                            "non-null function pointer",
                                        )(str_0 as *mut libc::c_void);
                                    str_0 = 0 as *mut xmlChar;
                                }
                                if xmlSchemaItemListRemove(uses, i) == -(1 as i32) {
                                    return -(1 as i32);
                                }
                            }
                            hasId = 1 as i32;
                        }
                    }
                }
                _ => {}
            }
            i -= 1;
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaResolveAttrGroupReferences(
    mut ref_0: xmlSchemaQNameRefPtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) -> i32 {
    let mut group: xmlSchemaAttributeGroupPtr = 0 as *mut xmlSchemaAttributeGroup;
    if !((*ref_0).item).is_null() {
        return 0 as i32;
    }
    group = xmlSchemaGetAttributeGroup(
        (*ctxt).schema,
        (*ref_0).name,
        (*ref_0).targetNamespace,
    );
    if group.is_null() {
        xmlSchemaPResCompAttrErr(
            ctxt,
            XML_SCHEMAP_SRC_RESOLVE,
            0 as xmlSchemaBasicItemPtr,
            (*ref_0).node,
            b"ref\0" as *const u8 as *const i8,
            (*ref_0).name,
            (*ref_0).targetNamespace,
            (*ref_0).itemType,
            0 as *const i8,
        );
        return (*ctxt).err;
    }
    let fresh405 = &mut ((*ref_0).item);
    *fresh405 = group as xmlSchemaBasicItemPtr;
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaCheckAttrPropsCorrect(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut attr: xmlSchemaAttributePtr,
) -> i32 {
    if ((*attr).subtypes).is_null() {
        return 0 as i32;
    }
    if !((*attr).defValue).is_null() {
        let mut ret: i32 = 0;
        if xmlSchemaIsDerivedFromBuiltInType(
            (*attr).subtypes,
            XML_SCHEMAS_ID as i32,
        ) != 0
        {
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_A_PROPS_CORRECT_3,
                0 as xmlNodePtr,
                attr as xmlSchemaBasicItemPtr,
                b"Value constraints are not allowed if the type definition is or is derived from xs:ID\0"
                    as *const u8 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return (*pctxt).err;
        }
        ret = xmlSchemaVCheckCVCSimpleType(
            pctxt as xmlSchemaAbstractCtxtPtr,
            (*attr).node,
            (*attr).subtypes,
            (*attr).defValue,
            &mut (*attr).defVal,
            1 as i32,
            1 as i32,
            0 as i32,
        );
        if ret != 0 as i32 {
            if ret < 0 as i32 {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaCheckAttrPropsCorrect\0" as *const u8
                        as *const i8,
                    b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8
                        as *const i8,
                );
                return -(1 as i32);
            }
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_A_PROPS_CORRECT_2,
                0 as xmlNodePtr,
                attr as xmlSchemaBasicItemPtr,
                b"The value of the value constraint is not valid\0" as *const u8
                    as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return (*pctxt).err;
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaCheckSubstGroupCircular(
    mut elemDecl: xmlSchemaElementPtr,
    mut ancestor: xmlSchemaElementPtr,
) -> xmlSchemaElementPtr {
    let mut ret: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
    if ((*ancestor).refDecl).is_null() {
        return 0 as xmlSchemaElementPtr;
    }
    if (*ancestor).refDecl == elemDecl {
        return ancestor;
    }
    if (*(*ancestor).refDecl).flags & (1 as i32) << 9 as i32 != 0 {
        return 0 as xmlSchemaElementPtr;
    }
    (*(*ancestor).refDecl).flags |= (1 as i32) << 9 as i32;
    ret = xmlSchemaCheckSubstGroupCircular(elemDecl, (*ancestor).refDecl);
    (*(*ancestor).refDecl).flags ^= (1 as i32) << 9 as i32;
    return ret;
}
unsafe extern "C" fn xmlSchemaCheckElemPropsCorrect(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut elemDecl: xmlSchemaElementPtr,
) -> i32 {
    let mut ret: i32 = 0 as i32;
    let mut typeDef: xmlSchemaTypePtr = (*elemDecl).subtypes;
    if !((*elemDecl).refDecl).is_null() {
        let mut head: xmlSchemaElementPtr = (*elemDecl).refDecl;
        let mut circ: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
        xmlSchemaCheckElementDeclComponent(head, pctxt);
        if (*elemDecl).flags & (1 as i32) << 1 as i32 == 0 as i32
        {
            xmlSchemaPCustomErr(
                pctxt,
                XML_SCHEMAP_E_PROPS_CORRECT_3,
                elemDecl as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"Only global element declarations can have a substitution group affiliation\0"
                    as *const u8 as *const i8,
                0 as *const xmlChar,
            );
            ret = XML_SCHEMAP_E_PROPS_CORRECT_3 as i32;
        }
        if head == elemDecl {
            circ = head;
        } else if !((*head).refDecl).is_null() {
            circ = xmlSchemaCheckSubstGroupCircular(head, head);
        } else {
            circ = 0 as xmlSchemaElementPtr;
        }
        if !circ.is_null() {
            let mut strA: *mut xmlChar = 0 as *mut xmlChar;
            let mut strB: *mut xmlChar = 0 as *mut xmlChar;
            xmlSchemaPCustomErrExt(
                pctxt,
                XML_SCHEMAP_E_PROPS_CORRECT_6,
                circ as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The element declaration '%s' defines a circular substitution group to element declaration '%s'\0"
                    as *const u8 as *const i8,
                xmlSchemaGetComponentQName(&mut strA, circ as *mut libc::c_void),
                xmlSchemaGetComponentQName(&mut strB, head as *mut libc::c_void),
                0 as *const xmlChar,
            );
            if !strA.is_null() {
                xmlFree.expect("non-null function pointer")(strA as *mut libc::c_void);
                strA = 0 as *mut xmlChar;
            }
            if !strB.is_null() {
                xmlFree.expect("non-null function pointer")(strB as *mut libc::c_void);
                strB = 0 as *mut xmlChar;
            }
            ret = XML_SCHEMAP_E_PROPS_CORRECT_6 as i32;
        }
        if typeDef != (*(*elemDecl).refDecl).subtypes {
            let mut set: i32 = 0 as i32;
            if (*head).flags & (1 as i32) << 15 as i32 != 0 {
                set |= (1 as i32) << 1 as i32;
            }
            if (*head).flags & (1 as i32) << 16 as i32 != 0 {
                set |= (1 as i32) << 0 as i32;
            }
            if xmlSchemaCheckCOSDerivedOK(
                pctxt as xmlSchemaAbstractCtxtPtr,
                typeDef,
                (*head).subtypes,
                set,
            ) != 0 as i32
            {
                let mut strA_0: *mut xmlChar = 0 as *mut xmlChar;
                let mut strB_0: *mut xmlChar = 0 as *mut xmlChar;
                let mut strC: *mut xmlChar = 0 as *mut xmlChar;
                ret = XML_SCHEMAP_E_PROPS_CORRECT_4 as i32;
                xmlSchemaPCustomErrExt(
                    pctxt,
                    XML_SCHEMAP_E_PROPS_CORRECT_4,
                    elemDecl as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The type definition '%s' was either rejected by the substitution group affiliation '%s', or not validly derived from its type definition '%s'\0"
                        as *const u8 as *const i8,
                    xmlSchemaGetComponentQName(
                        &mut strA_0,
                        typeDef as *mut libc::c_void,
                    ),
                    xmlSchemaGetComponentQName(&mut strB_0, head as *mut libc::c_void),
                    xmlSchemaGetComponentQName(
                        &mut strC,
                        (*head).subtypes as *mut libc::c_void,
                    ),
                );
                if !strA_0.is_null() {
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(strA_0 as *mut libc::c_void);
                    strA_0 = 0 as *mut xmlChar;
                }
                if !strB_0.is_null() {
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(strB_0 as *mut libc::c_void);
                    strB_0 = 0 as *mut xmlChar;
                }
                if !strC.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(strC as *mut libc::c_void);
                    strC = 0 as *mut xmlChar;
                }
            }
        }
    }
    if !((*elemDecl).value).is_null()
        && (((*typeDef).type_0 as u32
            == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
            || (*typeDef).type_0 as u32
                == XML_SCHEMA_TYPE_BASIC as i32 as u32
                && (*typeDef).builtInType != XML_SCHEMAS_ANYTYPE as i32)
            && xmlSchemaIsDerivedFromBuiltInType(typeDef, XML_SCHEMAS_ID as i32)
                != 0
            || ((*typeDef).type_0 as u32
                == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                || (*typeDef).builtInType == XML_SCHEMAS_ANYTYPE as i32)
                && ((*typeDef).contentType as u32
                    == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
                    || (*typeDef).contentType as u32
                        == XML_SCHEMA_CONTENT_BASIC as i32 as u32)
                && xmlSchemaIsDerivedFromBuiltInType(
                    (*typeDef).contentTypeDef,
                    XML_SCHEMAS_ID as i32,
                ) != 0)
    {
        ret = XML_SCHEMAP_E_PROPS_CORRECT_5 as i32;
        xmlSchemaPCustomErr(
            pctxt,
            XML_SCHEMAP_E_PROPS_CORRECT_5,
            elemDecl as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"The type definition (or type definition's content type) is or is derived from ID; value constraints are not allowed in conjunction with such a type definition\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
        );
    } else if !((*elemDecl).value).is_null() {
        let mut vcret: i32 = 0;
        let mut node: xmlNodePtr = 0 as xmlNodePtr;
        if typeDef.is_null() {
            xmlSchemaPErr(
                pctxt,
                (*elemDecl).node,
                XML_SCHEMAP_INTERNAL as i32,
                b"Internal error: xmlSchemaCheckElemPropsCorrect, type is missing... skipping validation of the value constraint\0"
                    as *const u8 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return -(1 as i32);
        }
        if !((*elemDecl).node).is_null() {
            if (*elemDecl).flags & (1 as i32) << 3 as i32 != 0 {
                node = xmlHasProp(
                    (*elemDecl).node as *const xmlNode,
                    b"fixed\0" as *const u8 as *const i8 as *mut xmlChar,
                ) as xmlNodePtr;
            } else {
                node = xmlHasProp(
                    (*elemDecl).node as *const xmlNode,
                    b"default\0" as *const u8 as *const i8 as *mut xmlChar,
                ) as xmlNodePtr;
            }
        }
        vcret = xmlSchemaParseCheckCOSValidDefault(
            pctxt,
            node,
            typeDef,
            (*elemDecl).value,
            &mut (*elemDecl).defVal,
        );
        if vcret != 0 as i32 {
            if vcret < 0 as i32 {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaElemCheckValConstr\0" as *const u8 as *const i8,
                    b"failed to validate the value constraint of an element declaration\0"
                        as *const u8 as *const i8,
                );
                return -(1 as i32);
            }
            return vcret;
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaCheckElemSubstGroup(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut elemDecl: xmlSchemaElementPtr,
) {
    if ((*elemDecl).refDecl).is_null()
        || (*elemDecl).flags & (1 as i32) << 4 as i32 != 0
    {
        return;
    }
    let mut head: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
    let mut headType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut set: i32 = 0;
    let mut methSet: i32 = 0;
    let mut current_block_28: u64;
    head = (*elemDecl).refDecl;
    while !head.is_null() {
        set = 0 as i32;
        methSet = 0 as i32;
        if !((*head).flags & (1 as i32) << 13 as i32 != 0) {
            headType = (*head).subtypes;
            type_0 = (*elemDecl).subtypes;
            if headType == type_0 {
                current_block_28 = 12525254419223051704;
            } else {
                if (*head).flags & (1 as i32) << 12 as i32 != 0 {
                    set |= (1 as i32) << 19 as i32;
                }
                if (*head).flags & (1 as i32) << 11 as i32 != 0 {
                    set |= (1 as i32) << 18 as i32;
                }
                while !type_0.is_null() && type_0 != headType {
                    if (*type_0).flags & (1 as i32) << 1 as i32 != 0
                        && methSet & (1 as i32) << 19 as i32
                            == 0 as i32
                    {
                        methSet |= (1 as i32) << 18 as i32;
                    }
                    if (*type_0).flags & (1 as i32) << 2 as i32 != 0
                        && methSet & (1 as i32) << 19 as i32
                            == 0 as i32
                    {
                        methSet |= (1 as i32) << 19 as i32;
                    }
                    type_0 = (*type_0).baseType;
                }
                type_0 = (*(*elemDecl).subtypes).baseType;
                while !type_0.is_null() {
                    if !((*type_0).type_0 as u32
                        == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                        || (*type_0).builtInType == XML_SCHEMAS_ANYTYPE as i32)
                    {
                        break;
                    }
                    if (*type_0).flags & (1 as i32) << 18 as i32 != 0
                        && set & (1 as i32) << 18 as i32
                            == 0 as i32
                    {
                        set |= (1 as i32) << 18 as i32;
                    }
                    if (*type_0).flags & (1 as i32) << 19 as i32 != 0
                        && set & (1 as i32) << 19 as i32
                            == 0 as i32
                    {
                        set |= (1 as i32) << 19 as i32;
                    }
                    if type_0 == headType {
                        break;
                    }
                    type_0 = (*type_0).baseType;
                }
                if set != 0 as i32
                    && (set & (1 as i32) << 18 as i32 != 0
                        && methSet & (1 as i32) << 18 as i32 != 0
                        || set & (1 as i32) << 19 as i32 != 0
                            && methSet & (1 as i32) << 19 as i32 != 0)
                {
                    current_block_28 = 735147466149431745;
                } else {
                    current_block_28 = 12525254419223051704;
                }
            }
            match current_block_28 {
                735147466149431745 => {}
                _ => {
                    xmlSchemaAddElementSubstitutionMember(ctxt, head, elemDecl);
                    if (*head).flags & (1 as i32) << 17 as i32
                        == 0 as i32
                    {
                        (*head).flags |= (1 as i32) << 17 as i32;
                    }
                }
            }
        }
        head = (*head).refDecl;
    }
}
unsafe extern "C" fn xmlSchemaCheckElementDeclComponent(
    mut elemDecl: xmlSchemaElementPtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) {
    if elemDecl.is_null() {
        return;
    }
    if (*elemDecl).flags & (1 as i32) << 18 as i32 != 0 {
        return;
    }
    (*elemDecl).flags |= (1 as i32) << 18 as i32;
    if xmlSchemaCheckElemPropsCorrect(ctxt, elemDecl) == 0 as i32 {
        xmlSchemaCheckElemSubstGroup(ctxt, elemDecl);
    }
}
unsafe extern "C" fn xmlSchemaResolveModelGroupParticleReferences(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut mg: xmlSchemaModelGroupPtr,
) {
    let mut particle: xmlSchemaParticlePtr = (*mg).children as xmlSchemaParticlePtr;
    let mut ref_0: xmlSchemaQNameRefPtr = 0 as *mut xmlSchemaQNameRef;
    let mut refItem: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    while !particle.is_null() {
        if !(((*particle).children).is_null()
            || (*(*particle).children).type_0 as u32
                != XML_SCHEMA_EXTRA_QNAMEREF as i32 as u32)
        {
            ref_0 = (*particle).children as xmlSchemaQNameRefPtr;
            let fresh406 = &mut ((*particle).children);
            *fresh406 = 0 as xmlSchemaTreeItemPtr;
            refItem = xmlSchemaGetNamedComponent(
                (*ctxt).schema,
                (*ref_0).itemType,
                (*ref_0).name,
                (*ref_0).targetNamespace,
            );
            if refItem.is_null() {
                xmlSchemaPResCompAttrErr(
                    ctxt,
                    XML_SCHEMAP_SRC_RESOLVE,
                    0 as xmlSchemaBasicItemPtr,
                    xmlSchemaGetComponentNode(particle as xmlSchemaBasicItemPtr),
                    b"ref\0" as *const u8 as *const i8,
                    (*ref_0).name,
                    (*ref_0).targetNamespace,
                    (*ref_0).itemType,
                    0 as *const i8,
                );
            } else if (*refItem).type_0 as u32
                    == XML_SCHEMA_TYPE_GROUP as i32 as u32
                {
                if !((*(refItem as xmlSchemaModelGroupPtr)).children).is_null() {
                    if (*(*(refItem as xmlSchemaModelGroupPtr)).children).type_0
                        as u32
                        == XML_SCHEMA_TYPE_ALL as i32 as u32
                    {
                        xmlSchemaCustomErr(
                            ctxt as xmlSchemaAbstractCtxtPtr,
                            XML_SCHEMAP_COS_ALL_LIMITED,
                            xmlSchemaGetComponentNode(particle as xmlSchemaBasicItemPtr),
                            0 as xmlSchemaBasicItemPtr,
                            b"A model group definition is referenced, but it contains an 'all' model group, which cannot be contained by model groups\0"
                                as *const u8 as *const i8,
                            0 as *const xmlChar,
                            0 as *const xmlChar,
                        );
                    } else {
                        let fresh407 = &mut ((*particle).children);
                        *fresh407 = refItem as xmlSchemaTreeItemPtr;
                    }
                }
            } else {
                let fresh408 = &mut ((*particle).children);
                *fresh408 = refItem as xmlSchemaTreeItemPtr;
            }
        }
        particle = (*particle).next as xmlSchemaParticlePtr;
    }
}
unsafe extern "C" fn xmlSchemaAreValuesEqual(
    mut x: xmlSchemaValPtr,
    mut y: xmlSchemaValPtr,
) -> i32 {
    let mut tx: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ty: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ptx: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut pty: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ret: i32 = 0;
    while !x.is_null() {
        tx = xmlSchemaGetBuiltInType(xmlSchemaGetValType(x));
        ty = xmlSchemaGetBuiltInType(xmlSchemaGetValType(y));
        ptx = xmlSchemaGetPrimitiveType(tx);
        pty = xmlSchemaGetPrimitiveType(ty);
        if ptx != pty {
            return 0 as i32;
        }
        if (*ptx).builtInType == XML_SCHEMAS_STRING as i32
            || (*ptx).type_0 as u32
                == XML_SCHEMA_TYPE_BASIC as i32 as u32
                && (*ptx).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as i32
        {
            if xmlStrEqual(xmlSchemaValueGetAsString(x), xmlSchemaValueGetAsString(y))
                == 0
            {
                return 0 as i32;
            }
        } else {
            ret = xmlSchemaCompareValuesWhtsp(
                x,
                XML_SCHEMA_WHITESPACE_PRESERVE,
                y,
                XML_SCHEMA_WHITESPACE_PRESERVE,
            );
            if ret == -(2 as i32) {
                return -(1 as i32);
            }
            if ret != 0 as i32 {
                return 0 as i32;
            }
        }
        x = xmlSchemaValueGetNext(x);
        if !x.is_null() {
            y = xmlSchemaValueGetNext(y);
            if y.is_null() {
                return 0 as i32;
            }
        } else if !(xmlSchemaValueGetNext(y)).is_null() {
            return 0 as i32
        } else {
            return 1 as i32
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaResolveAttrUseReferences(
    mut ause: xmlSchemaAttributeUsePtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) -> i32 {
    if ctxt.is_null() || ause.is_null() {
        return -(1 as i32);
    }
    if ((*ause).attrDecl).is_null()
        || (*(*ause).attrDecl).type_0 as u32
            != XML_SCHEMA_EXTRA_QNAMEREF as i32 as u32
    {
        return 0 as i32;
    }
    let mut ref_0: xmlSchemaQNameRefPtr = (*ause).attrDecl as xmlSchemaQNameRefPtr;
    let fresh409 = &mut ((*ause).attrDecl);
    *fresh409 = xmlSchemaGetAttributeDecl(
        (*ctxt).schema,
        (*ref_0).name,
        (*ref_0).targetNamespace,
    );
    if ((*ause).attrDecl).is_null() {
        xmlSchemaPResCompAttrErr(
            ctxt,
            XML_SCHEMAP_SRC_RESOLVE,
            ause as xmlSchemaBasicItemPtr,
            (*ause).node,
            b"ref\0" as *const u8 as *const i8,
            (*ref_0).name,
            (*ref_0).targetNamespace,
            XML_SCHEMA_TYPE_ATTRIBUTE,
            0 as *const i8,
        );
        return (*ctxt).err;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaCheckAttrUsePropsCorrect(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut use_0: xmlSchemaAttributeUsePtr,
) -> i32 {
    if ctxt.is_null() || use_0.is_null() {
        return -(1 as i32);
    }
    if ((*use_0).defValue).is_null() || ((*use_0).attrDecl).is_null()
        || (*(*use_0).attrDecl).type_0 as u32
            != XML_SCHEMA_TYPE_ATTRIBUTE as i32 as u32
    {
        return 0 as i32;
    }
    if !((*(*use_0).attrDecl).defValue).is_null()
        && (*(*use_0).attrDecl).flags & (1 as i32) << 9 as i32 != 0
        && (*use_0).flags & (1 as i32) << 0 as i32 == 0 as i32
    {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_AU_PROPS_CORRECT_2,
            use_0 as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"The attribute declaration has a 'fixed' value constraint , thus the attribute use must also have a 'fixed' value constraint\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
        );
        return (*ctxt).err;
    }
    if !((*use_0).defVal).is_null() && !((*(*use_0).attrDecl).subtypes).is_null() {
        let mut ret: i32 = 0;
        if xmlSchemaIsDerivedFromBuiltInType(
            (*(*use_0).attrDecl).subtypes,
            XML_SCHEMAS_ID as i32,
        ) != 0
        {
            xmlSchemaCustomErr(
                ctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_AU_PROPS_CORRECT,
                0 as xmlNodePtr,
                use_0 as xmlSchemaBasicItemPtr,
                b"Value constraints are not allowed if the type definition is or is derived from xs:ID\0"
                    as *const u8 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return (*ctxt).err;
        }
        ret = xmlSchemaVCheckCVCSimpleType(
            ctxt as xmlSchemaAbstractCtxtPtr,
            (*use_0).node,
            (*(*use_0).attrDecl).subtypes,
            (*use_0).defValue,
            &mut (*use_0).defVal,
            1 as i32,
            1 as i32,
            0 as i32,
        );
        if ret != 0 as i32 {
            if ret < 0 as i32 {
                xmlSchemaInternalErr(
                    ctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaCheckAttrUsePropsCorrect\0" as *const u8
                        as *const i8,
                    b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8
                        as *const i8,
                );
                return -(1 as i32);
            }
            xmlSchemaCustomErr(
                ctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_AU_PROPS_CORRECT,
                0 as xmlNodePtr,
                use_0 as xmlSchemaBasicItemPtr,
                b"The value of the value constraint is not valid\0" as *const u8
                    as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return (*ctxt).err;
        }
    }
    if !((*(*use_0).attrDecl).defVal).is_null()
        && (*(*use_0).attrDecl).flags & (1 as i32) << 0 as i32
            == 0 as i32
    {
        if xmlSchemaAreValuesEqual((*use_0).defVal, (*(*use_0).attrDecl).defVal) == 0 {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_AU_PROPS_CORRECT_2,
                use_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The 'fixed' value constraint of the attribute use must match the attribute declaration's value constraint '%s'\0"
                    as *const u8 as *const i8,
                (*(*use_0).attrDecl).defValue,
            );
        }
        return (*ctxt).err;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaResolveAttrTypeReferences(
    mut item: xmlSchemaAttributePtr,
    mut ctxt: xmlSchemaParserCtxtPtr,
) -> i32 {
    if (*item).flags & (1 as i32) << 8 as i32 != 0 {
        return 0 as i32;
    }
    (*item).flags |= (1 as i32) << 8 as i32;
    if !((*item).subtypes).is_null() {
        return 0 as i32;
    }
    if !((*item).typeName).is_null() {
        let mut type_0: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        type_0 = xmlSchemaGetType((*ctxt).schema, (*item).typeName, (*item).typeNs);
        if type_0.is_null()
            || !((*type_0).type_0 as u32
                == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                || (*type_0).type_0 as u32
                    == XML_SCHEMA_TYPE_BASIC as i32 as u32
                    && (*type_0).builtInType != XML_SCHEMAS_ANYTYPE as i32)
        {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                item as xmlSchemaBasicItemPtr,
                (*item).node,
                b"type\0" as *const u8 as *const i8,
                (*item).typeName,
                (*item).typeNs,
                XML_SCHEMA_TYPE_SIMPLE,
                0 as *const i8,
            );
            return (*ctxt).err;
        } else {
            let fresh410 = &mut ((*item).subtypes);
            *fresh410 = type_0;
        }
    } else {
        let fresh411 = &mut ((*item).subtypes);
        *fresh411 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaResolveIDCKeyReferences(
    mut idc: xmlSchemaIDCPtr,
    mut pctxt: xmlSchemaParserCtxtPtr,
) -> i32 {
    if (*idc).type_0 as u32
        != XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
    {
        return 0 as i32;
    }
    if !((*(*idc).ref_0).name).is_null() {
        let fresh412 = &mut ((*(*idc).ref_0).item);
        *fresh412 = xmlSchemaGetIDC(
            (*pctxt).schema,
            (*(*idc).ref_0).name,
            (*(*idc).ref_0).targetNamespace,
        ) as xmlSchemaBasicItemPtr;
        if ((*(*idc).ref_0).item).is_null() {
            xmlSchemaPResCompAttrErr(
                pctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                idc as xmlSchemaBasicItemPtr,
                (*idc).node,
                b"refer\0" as *const u8 as *const i8,
                (*(*idc).ref_0).name,
                (*(*idc).ref_0).targetNamespace,
                XML_SCHEMA_TYPE_IDC_KEY,
                0 as *const i8,
            );
            return (*pctxt).err;
        } else {
            if (*(*(*idc).ref_0).item).type_0 as u32
                == XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
            {
                xmlSchemaCustomErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    XML_SCHEMAP_C_PROPS_CORRECT,
                    0 as xmlNodePtr,
                    idc as xmlSchemaBasicItemPtr,
                    b"The keyref references a keyref\0" as *const u8
                        as *const i8,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
                let fresh413 = &mut ((*(*idc).ref_0).item);
                *fresh413 = 0 as xmlSchemaBasicItemPtr;
                return (*pctxt).err;
            } else {
                if (*idc).nbFields
                    != (*((*(*idc).ref_0).item as xmlSchemaIDCPtr)).nbFields
                {
                    let mut str: *mut xmlChar = 0 as *mut xmlChar;
                    let mut refer: xmlSchemaIDCPtr = 0 as *mut xmlSchemaIDC;
                    refer = (*(*idc).ref_0).item as xmlSchemaIDCPtr;
                    xmlSchemaCustomErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_C_PROPS_CORRECT,
                        0 as xmlNodePtr,
                        idc as xmlSchemaBasicItemPtr,
                        b"The cardinality of the keyref differs from the cardinality of the referenced key/unique '%s'\0"
                            as *const u8 as *const i8,
                        xmlSchemaFormatQName(
                            &mut str,
                            (*refer).targetNamespace,
                            (*refer).name,
                        ),
                        0 as *const xmlChar,
                    );
                    if !str.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str as *mut libc::c_void);
                        str = 0 as *mut xmlChar;
                    }
                    return (*pctxt).err;
                }
            }
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaResolveAttrUseProhibReferences(
    mut prohib: xmlSchemaAttributeUseProhibPtr,
    mut pctxt: xmlSchemaParserCtxtPtr,
) -> i32 {
    if (xmlSchemaGetAttributeDecl(
        (*pctxt).schema,
        (*prohib).name,
        (*prohib).targetNamespace,
    ))
        .is_null()
    {
        xmlSchemaPResCompAttrErr(
            pctxt,
            XML_SCHEMAP_SRC_RESOLVE,
            0 as xmlSchemaBasicItemPtr,
            (*prohib).node,
            b"ref\0" as *const u8 as *const i8,
            (*prohib).name,
            (*prohib).targetNamespace,
            XML_SCHEMA_TYPE_ATTRIBUTE,
            0 as *const i8,
        );
        return XML_SCHEMAP_SRC_RESOLVE as i32;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaCheckSRCRedefineFirst(
    mut pctxt: xmlSchemaParserCtxtPtr,
) -> i32 {
    let mut err: i32 = 0 as i32;
    let mut redef: xmlSchemaRedefPtr = (*(*pctxt).constructor).redefs;
    let mut prev: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    let mut item: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    let mut wasRedefined: i32 = 0;
    if redef.is_null() {
        return 0 as i32;
    }
    loop {
        item = (*redef).item;
        prev = xmlSchemaFindRedefCompInGraph(
            (*redef).targetBucket,
            (*item).type_0,
            (*redef).refName,
            (*redef).refTargetNs,
        );
        if prev.is_null() {
            let mut str: *mut xmlChar = 0 as *mut xmlChar;
            let mut node: xmlNodePtr = 0 as *mut xmlNode;
            if !((*redef).reference).is_null() {
                node = xmlSchemaGetComponentNode((*redef).reference);
            } else {
                node = xmlSchemaGetComponentNode(item);
            }
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_SRC_REDEFINE,
                node,
                0 as xmlSchemaBasicItemPtr,
                b"The %s '%s' to be redefined could not be found in the redefined schema\0"
                    as *const u8 as *const i8,
                xmlSchemaGetComponentTypeStr(item),
                xmlSchemaFormatQName(&mut str, (*redef).refTargetNs, (*redef).refName),
            );
            if !str.is_null() {
                xmlFree.expect("non-null function pointer")(str as *mut libc::c_void);
                str = 0 as *mut xmlChar;
            }
            err = (*pctxt).err;
            redef = (*redef).next;
        } else {
            wasRedefined = 0 as i32;
            match (*item).type_0 as u32 {
                5 | 4 => {
                    if (*(prev as xmlSchemaTypePtr)).flags
                        & (1 as i32) << 30 as i32 != 0
                    {
                        wasRedefined = 1 as i32;
                    } else {
                        (*(prev as xmlSchemaTypePtr)).flags
                            |= (1 as i32) << 30 as i32;
                        let fresh414 = &mut ((*(item as xmlSchemaTypePtr)).baseType);
                        *fresh414 = prev as xmlSchemaTypePtr;
                    }
                }
                17 => {
                    if (*(prev as xmlSchemaModelGroupDefPtr)).flags
                        & (1 as i32) << 1 as i32 != 0
                    {
                        wasRedefined = 1 as i32;
                    } else {
                        (*(prev as xmlSchemaModelGroupDefPtr)).flags
                            |= (1 as i32) << 1 as i32;
                        if !((*redef).reference).is_null() {
                            let fresh415 = &mut ((*((*redef).reference
                                as xmlSchemaParticlePtr))
                                .children);
                            *fresh415 = prev as xmlSchemaTreeItemPtr;
                        }
                        let fresh416 = &mut ((*redef).target);
                        *fresh416 = prev;
                    }
                }
                16 => {
                    if (*(prev as xmlSchemaAttributeGroupPtr)).flags
                        & (1 as i32) << 3 as i32 != 0
                    {
                        wasRedefined = 1 as i32;
                    } else {
                        (*(prev as xmlSchemaAttributeGroupPtr)).flags
                            |= (1 as i32) << 3 as i32;
                        if !((*redef).reference).is_null() {
                            let fresh417 = &mut ((*((*redef).reference
                                as xmlSchemaQNameRefPtr))
                                .item);
                            *fresh417 = prev;
                            let fresh418 = &mut ((*redef).target);
                            *fresh418 = 0 as xmlSchemaBasicItemPtr;
                        } else {
                            let fresh419 = &mut ((*redef).target);
                            *fresh419 = prev;
                        }
                    }
                }
                _ => {
                    xmlSchemaInternalErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaResolveRedefReferences\0" as *const u8
                            as *const i8,
                        b"Unexpected redefined component type\0" as *const u8
                            as *const i8,
                    );
                    return -(1 as i32);
                }
            }
            if wasRedefined != 0 {
                let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                let mut node_0: xmlNodePtr = 0 as *mut xmlNode;
                if !((*redef).reference).is_null() {
                    node_0 = xmlSchemaGetComponentNode((*redef).reference);
                } else {
                    node_0 = xmlSchemaGetComponentNode((*redef).item);
                }
                xmlSchemaCustomErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    XML_SCHEMAP_SRC_REDEFINE,
                    node_0,
                    0 as xmlSchemaBasicItemPtr,
                    b"The referenced %s was already redefined. Multiple redefinition of the same component is not supported\0"
                        as *const u8 as *const i8,
                    xmlSchemaGetComponentDesignation(
                        &mut str_0,
                        prev as *mut libc::c_void,
                    ),
                    0 as *const xmlChar,
                );
                if !str_0.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str_0 as *mut libc::c_void);
                    str_0 = 0 as *mut xmlChar;
                }
                err = (*pctxt).err;
                redef = (*redef).next;
            } else {
                redef = (*redef).next;
            }
        }
        if redef.is_null() {
            break;
        }
    }
    return err;
}
unsafe extern "C" fn xmlSchemaCheckSRCRedefineSecond(
    mut pctxt: xmlSchemaParserCtxtPtr,
) -> i32 {
    let mut err: i32 = 0 as i32;
    let mut redef: xmlSchemaRedefPtr = (*(*pctxt).constructor).redefs;
    let mut item: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    if redef.is_null() {
        return 0 as i32;
    }
    loop {
        if ((*redef).target).is_null() {
            redef = (*redef).next;
        } else {
            item = (*redef).item;
            match (*item).type_0 as u32 {
                4 | 5 => {
                    let fresh420 = &mut ((*((*redef).target as xmlSchemaTypePtr)).name);
                    *fresh420 = 0 as *const xmlChar;
                }
                16 => {
                    err = xmlSchemaCheckDerivationOKRestriction2to4(
                        pctxt,
                        1 as i32,
                        item,
                        (*redef).target,
                        (*(item as xmlSchemaAttributeGroupPtr)).attrUses
                            as xmlSchemaItemListPtr,
                        (*((*redef).target as xmlSchemaAttributeGroupPtr)).attrUses
                            as xmlSchemaItemListPtr,
                        (*(item as xmlSchemaAttributeGroupPtr)).attributeWildcard,
                        (*((*redef).target as xmlSchemaAttributeGroupPtr))
                            .attributeWildcard,
                    );
                    if err == -(1 as i32) {
                        return -(1 as i32);
                    }
                }
                17 | _ => {}
            }
            redef = (*redef).next;
        }
        if redef.is_null() {
            break;
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaAddComponents(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut bucket: xmlSchemaBucketPtr,
) -> i32 {
    let mut item: xmlSchemaBasicItemPtr = 0 as *mut xmlSchemaBasicItem;
    let mut err: i32 = 0;
    let mut table: *mut xmlHashTablePtr = 0 as *mut xmlHashTablePtr;
    let mut name: *const xmlChar = 0 as *const xmlChar;
    let mut i: i32 = 0;
    if bucket.is_null() {
        return -(1 as i32);
    }
    if (*bucket).flags & (1 as i32) << 1 as i32 != 0 {
        return 0 as i32;
    }
    (*bucket).flags |= (1 as i32) << 1 as i32;
    let mut current_block_61: u64;
    i = 0 as i32;
    while i < (*(*bucket).globals).nbItems {
        item = *((*(*bucket).globals).items).offset(i as isize) as xmlSchemaBasicItemPtr;
        table = 0 as *mut xmlHashTablePtr;
        match (*item).type_0 as u32 {
            5 | 4 => {
                if (*(item as xmlSchemaTypePtr)).flags
                    & (1 as i32) << 30 as i32 != 0
                {
                    current_block_61 = 6937071982253665452;
                } else {
                    name = (*(item as xmlSchemaTypePtr)).name;
                    if (*bucket).type_0 == 0 as i32
                        || (*bucket).type_0 == 1 as i32
                    {
                        table = &mut (*(*(bucket as xmlSchemaImportPtr)).schema)
                            .typeDecl;
                    } else {
                        table = &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport)
                            .schema)
                            .typeDecl;
                    }
                    current_block_61 = 2500484646272006982;
                }
            }
            14 => {
                name = (*(item as xmlSchemaElementPtr)).name;
                if (*bucket).type_0 == 0 as i32
                    || (*bucket).type_0 == 1 as i32
                {
                    table = &mut (*(*(bucket as xmlSchemaImportPtr)).schema).elemDecl;
                } else {
                    table = &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport)
                        .schema)
                        .elemDecl;
                }
                current_block_61 = 2500484646272006982;
            }
            15 => {
                name = (*(item as xmlSchemaAttributePtr)).name;
                if (*bucket).type_0 == 0 as i32
                    || (*bucket).type_0 == 1 as i32
                {
                    table = &mut (*(*(bucket as xmlSchemaImportPtr)).schema).attrDecl;
                } else {
                    table = &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport)
                        .schema)
                        .attrDecl;
                }
                current_block_61 = 2500484646272006982;
            }
            17 => {
                if (*(item as xmlSchemaModelGroupDefPtr)).flags
                    & (1 as i32) << 1 as i32 != 0
                {
                    current_block_61 = 6937071982253665452;
                } else {
                    name = (*(item as xmlSchemaModelGroupDefPtr)).name;
                    if (*bucket).type_0 == 0 as i32
                        || (*bucket).type_0 == 1 as i32
                    {
                        table = &mut (*(*(bucket as xmlSchemaImportPtr)).schema)
                            .groupDecl;
                    } else {
                        table = &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport)
                            .schema)
                            .groupDecl;
                    }
                    current_block_61 = 2500484646272006982;
                }
            }
            16 => {
                if (*(item as xmlSchemaAttributeGroupPtr)).flags
                    & (1 as i32) << 3 as i32 != 0
                {
                    current_block_61 = 6937071982253665452;
                } else {
                    name = (*(item as xmlSchemaAttributeGroupPtr)).name;
                    if (*bucket).type_0 == 0 as i32
                        || (*bucket).type_0 == 1 as i32
                    {
                        table = &mut (*(*(bucket as xmlSchemaImportPtr)).schema)
                            .attrgrpDecl;
                    } else {
                        table = &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport)
                            .schema)
                            .attrgrpDecl;
                    }
                    current_block_61 = 2500484646272006982;
                }
            }
            23 | 22 | 24 => {
                name = (*(item as xmlSchemaIDCPtr)).name;
                if (*bucket).type_0 == 0 as i32
                    || (*bucket).type_0 == 1 as i32
                {
                    table = &mut (*(*(bucket as xmlSchemaImportPtr)).schema).idcDef;
                } else {
                    table = &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport)
                        .schema)
                        .idcDef;
                }
                current_block_61 = 2500484646272006982;
            }
            18 => {
                name = (*(item as xmlSchemaNotationPtr)).name;
                if (*bucket).type_0 == 0 as i32
                    || (*bucket).type_0 == 1 as i32
                {
                    table = &mut (*(*(bucket as xmlSchemaImportPtr)).schema).notaDecl;
                } else {
                    table = &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport)
                        .schema)
                        .notaDecl;
                }
                current_block_61 = 2500484646272006982;
            }
            _ => {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaAddComponents\0" as *const u8 as *const i8,
                    b"Unexpected global component type\0" as *const u8
                        as *const i8,
                );
                current_block_61 = 6937071982253665452;
            }
        }
        match current_block_61 {
            2500484646272006982 => {
                if (*table).is_null() {
                    *table = xmlHashCreateDict(10 as i32, (*pctxt).dict);
                    if (*table).is_null() {
                        xmlSchemaInternalErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaAddComponents\0" as *const u8
                                as *const i8,
                            b"failed to create a component hash table\0" as *const u8
                                as *const i8,
                        );
                        return -(1 as i32);
                    }
                }
                err = xmlHashAddEntry(*table, name, item as *mut libc::c_void);
                if err != 0 as i32 {
                    let mut str: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaCustomErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_REDEFINED_TYPE,
                        xmlSchemaGetComponentNode(item),
                        item,
                        b"A global %s '%s' does already exist\0" as *const u8
                            as *const i8,
                        xmlSchemaGetComponentTypeStr(item),
                        xmlSchemaGetComponentQName(&mut str, item as *mut libc::c_void),
                    );
                    if !str.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str as *mut libc::c_void);
                        str = 0 as *mut xmlChar;
                    }
                }
            }
            _ => {}
        }
        i += 1;
    }
    if !((*bucket).relations).is_null() {
        let mut rel: xmlSchemaSchemaRelationPtr = (*bucket).relations;
        loop {
            if !((*rel).bucket).is_null()
                && (*(*rel).bucket).flags & (1 as i32) << 1 as i32
                    == 0 as i32
            {
                if xmlSchemaAddComponents(pctxt, (*rel).bucket) == -(1 as i32) {
                    return -(1 as i32);
                }
            }
            rel = (*rel).next;
            if rel.is_null() {
                break;
            }
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaFixupComponents(
    mut pctxt: xmlSchemaParserCtxtPtr,
    mut rootBucket: xmlSchemaBucketPtr,
) -> i32 {
    let mut current_block: u64;
    let mut con: xmlSchemaConstructionCtxtPtr = (*pctxt).constructor;
    let mut item: xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItem;
    let mut items: *mut xmlSchemaTreeItemPtr = 0 as *mut xmlSchemaTreeItemPtr;
    let mut nbItems: i32 = 0;
    let mut i: i32 = 0;
    let mut ret: i32 = 0 as i32;
    let mut oldbucket: xmlSchemaBucketPtr = (*con).bucket;
    let mut elemDecl: xmlSchemaElementPtr = 0 as *mut xmlSchemaElement;
    if ((*con).pending).is_null() || (*(*con).pending).nbItems == 0 as i32 {
        return 0 as i32;
    }
    if ((*con).bucket).is_null() {
        let fresh421 = &mut ((*con).bucket);
        *fresh421 = rootBucket;
    }
    xmlSchemaCheckSRCRedefineFirst(pctxt);
    xmlSchemaAddComponents(pctxt, rootBucket);
    let fresh422 = &mut ((*pctxt).ctxtType);
    *fresh422 = 0 as xmlSchemaTypePtr;
    items = (*(*con).pending).items as *mut xmlSchemaTreeItemPtr;
    nbItems = (*(*con).pending).nbItems;
    i = 0 as i32;
    loop {
        if !(i < nbItems) {
            current_block = 1924505913685386279;
            break;
        }
        item = *items.offset(i as isize);
        match (*item).type_0 as u32 {
            14 => {
                xmlSchemaResolveElementReferences(item as xmlSchemaElementPtr, pctxt);
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                    current_block = 2133922729242721719;
                    break;
                }
            }
            5 | 4 => {
                xmlSchemaResolveTypeReferences(item as xmlSchemaTypePtr, pctxt);
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                    current_block = 2133922729242721719;
                    break;
                }
            }
            15 => {
                xmlSchemaResolveAttrTypeReferences(item as xmlSchemaAttributePtr, pctxt);
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                    current_block = 2133922729242721719;
                    break;
                }
            }
            26 => {
                xmlSchemaResolveAttrUseReferences(
                    item as xmlSchemaAttributeUsePtr,
                    pctxt,
                );
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                    current_block = 2133922729242721719;
                    break;
                }
            }
            2000 => {
                if (*(item as xmlSchemaQNameRefPtr)).itemType as u32
                    == XML_SCHEMA_TYPE_ATTRIBUTEGROUP as i32 as u32
                {
                    xmlSchemaResolveAttrGroupReferences(
                        item as xmlSchemaQNameRefPtr,
                        pctxt,
                    );
                }
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                    current_block = 2133922729242721719;
                    break;
                }
            }
            6 | 7 | 8 => {
                xmlSchemaResolveModelGroupParticleReferences(
                    pctxt,
                    item as xmlSchemaModelGroupPtr,
                );
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                    current_block = 2133922729242721719;
                    break;
                }
            }
            23 | 22 | 24 => {
                xmlSchemaResolveIDCKeyReferences(item as xmlSchemaIDCPtr, pctxt);
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                    current_block = 2133922729242721719;
                    break;
                }
            }
            2001 => {
                xmlSchemaResolveAttrUseProhibReferences(
                    item as xmlSchemaAttributeUseProhibPtr,
                    pctxt,
                );
                if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                    current_block = 2133922729242721719;
                    break;
                }
            }
            _ => {}
        }
        i += 1;
    }
    match current_block {
        1924505913685386279 => {
            if (*pctxt).nberrors != 0 as i32 {
                current_block = 3799963374263564300;
            } else {
                i = 0 as i32;
                loop {
                    if !(i < nbItems) {
                        current_block = 7330218953828964527;
                        break;
                    }
                    item = *items.offset(i as isize);
                    match (*item).type_0 as u32 {
                        5 | 4 => {
                            xmlSchemaCheckTypeDefCircular(
                                item as xmlSchemaTypePtr,
                                pctxt,
                            );
                            if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                                current_block = 2133922729242721719;
                                break;
                            }
                            if (*pctxt).nberrors != 0 as i32 {
                                current_block = 3799963374263564300;
                                break;
                            }
                        }
                        17 => {
                            xmlSchemaCheckGroupDefCircular(
                                item as xmlSchemaModelGroupDefPtr,
                                pctxt,
                            );
                            if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                                current_block = 2133922729242721719;
                                break;
                            }
                            if (*pctxt).nberrors != 0 as i32 {
                                current_block = 3799963374263564300;
                                break;
                            }
                        }
                        16 => {
                            xmlSchemaCheckAttrGroupCircular(
                                item as xmlSchemaAttributeGroupPtr,
                                pctxt,
                            );
                            if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                                current_block = 2133922729242721719;
                                break;
                            }
                            if (*pctxt).nberrors != 0 as i32 {
                                current_block = 3799963374263564300;
                                break;
                            }
                        }
                        _ => {}
                    }
                    i += 1;
                }
                match current_block {
                    2133922729242721719 => {}
                    3799963374263564300 => {}
                    _ => {
                        if (*pctxt).nberrors != 0 as i32 {
                            current_block = 3799963374263564300;
                        } else {
                            i = 0 as i32;
                            while i < nbItems {
                                item = *items.offset(i as isize);
                                match (*item).type_0 as u32 {
                                    6 | 7 => {
                                        xmlSchemaModelGroupToModelGroupDefFixup(
                                            pctxt,
                                            item as xmlSchemaModelGroupPtr,
                                        );
                                    }
                                    _ => {}
                                }
                                i += 1;
                            }
                            if (*pctxt).nberrors != 0 as i32 {
                                current_block = 3799963374263564300;
                            } else {
                                i = 0 as i32;
                                loop {
                                    if !(i < nbItems) {
                                        current_block = 2798392256336243897;
                                        break;
                                    }
                                    item = *items.offset(i as isize);
                                    match (*item).type_0 as u32 {
                                        16 => {
                                            if (*(item as xmlSchemaAttributeGroupPtr)).flags
                                                & (1 as i32) << 0 as i32 == 0
                                                && (*(item as xmlSchemaAttributeGroupPtr)).flags
                                                    & (1 as i32) << 4 as i32 != 0
                                            {
                                                xmlSchemaAttributeGroupExpandRefs(
                                                    pctxt,
                                                    item as xmlSchemaAttributeGroupPtr,
                                                );
                                                if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                                                    current_block = 2133922729242721719;
                                                    break;
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                    i += 1;
                                }
                                match current_block {
                                    2133922729242721719 => {}
                                    _ => {
                                        if (*pctxt).nberrors != 0 as i32 {
                                            current_block = 3799963374263564300;
                                        } else {
                                            i = 0 as i32;
                                            loop {
                                                if !(i < nbItems) {
                                                    current_block = 562309032768341766;
                                                    break;
                                                }
                                                item = *items.offset(i as isize);
                                                match (*item).type_0 as u32 {
                                                    4 => {
                                                        if (*(item as xmlSchemaTypePtr)).type_0 as u32
                                                            != XML_SCHEMA_TYPE_BASIC as i32 as u32
                                                            && (*(item as xmlSchemaTypePtr)).flags
                                                                & (1 as i32) << 29 as i32
                                                                == 0 as i32
                                                        {
                                                            xmlSchemaFixupSimpleTypeStageOne(
                                                                pctxt,
                                                                item as xmlSchemaTypePtr,
                                                            );
                                                            if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                                                                current_block = 2133922729242721719;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    _ => {}
                                                }
                                                i += 1;
                                            }
                                            match current_block {
                                                2133922729242721719 => {}
                                                _ => {
                                                    if (*pctxt).nberrors != 0 as i32 {
                                                        current_block = 3799963374263564300;
                                                    } else {
                                                        i = 0 as i32;
                                                        loop {
                                                            if !(i < nbItems) {
                                                                current_block = 14612007084265645573;
                                                                break;
                                                            }
                                                            item = *items.offset(i as isize);
                                                            match (*item).type_0 as u32 {
                                                                4 => {
                                                                    if !((*(item as xmlSchemaTypePtr)).memberTypes).is_null() {
                                                                        xmlSchemaCheckUnionTypeDefCircular(
                                                                            pctxt,
                                                                            item as xmlSchemaTypePtr,
                                                                        );
                                                                        if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                                                                            current_block = 2133922729242721719;
                                                                            break;
                                                                        }
                                                                    }
                                                                }
                                                                _ => {}
                                                            }
                                                            i += 1;
                                                        }
                                                        match current_block {
                                                            2133922729242721719 => {}
                                                            _ => {
                                                                if (*pctxt).nberrors != 0 as i32 {
                                                                    current_block = 3799963374263564300;
                                                                } else {
                                                                    i = 0 as i32;
                                                                    loop {
                                                                        if !(i < nbItems) {
                                                                            current_block = 7079180960716815705;
                                                                            break;
                                                                        }
                                                                        item = *items.offset(i as isize);
                                                                        match (*item).type_0 as u32 {
                                                                            4 => {
                                                                                if (*(item as xmlSchemaTypePtr)).type_0 as u32
                                                                                    != XML_SCHEMA_TYPE_BASIC as i32 as u32
                                                                                    && (*(item as xmlSchemaTypePtr)).flags
                                                                                        & (1 as i32) << 22 as i32
                                                                                        == 0 as i32
                                                                                {
                                                                                    xmlSchemaFixupSimpleTypeStageTwo(
                                                                                        pctxt,
                                                                                        item as xmlSchemaTypePtr,
                                                                                    );
                                                                                    if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                                                                                        current_block = 2133922729242721719;
                                                                                        break;
                                                                                    }
                                                                                }
                                                                            }
                                                                            _ => {}
                                                                        }
                                                                        i += 1;
                                                                    }
                                                                    match current_block {
                                                                        2133922729242721719 => {}
                                                                        _ => {
                                                                            if (*pctxt).nberrors != 0 as i32 {
                                                                                current_block = 3799963374263564300;
                                                                            } else {
                                                                                i = 0 as i32;
                                                                                loop {
                                                                                    if !(i < nbItems) {
                                                                                        current_block = 5431927413890720344;
                                                                                        break;
                                                                                    }
                                                                                    item = *items.offset(i as isize);
                                                                                    match (*item).type_0 as u32 {
                                                                                        15 => {
                                                                                            xmlSchemaCheckAttrPropsCorrect(
                                                                                                pctxt,
                                                                                                item as xmlSchemaAttributePtr,
                                                                                            );
                                                                                            if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                                                                                                current_block = 2133922729242721719;
                                                                                                break;
                                                                                            }
                                                                                        }
                                                                                        _ => {}
                                                                                    }
                                                                                    i += 1;
                                                                                }
                                                                                match current_block {
                                                                                    2133922729242721719 => {}
                                                                                    _ => {
                                                                                        if (*pctxt).nberrors != 0 as i32 {
                                                                                            current_block = 3799963374263564300;
                                                                                        } else {
                                                                                            i = 0 as i32;
                                                                                            loop {
                                                                                                if !(i < nbItems) {
                                                                                                    current_block = 6215370584428403858;
                                                                                                    break;
                                                                                                }
                                                                                                item = *items.offset(i as isize);
                                                                                                match (*item).type_0 as u32 {
                                                                                                    26 => {
                                                                                                        if !((*(item as xmlSchemaAttributeUsePtr)).defValue)
                                                                                                            .is_null()
                                                                                                        {
                                                                                                            xmlSchemaCheckAttrUsePropsCorrect(
                                                                                                                pctxt,
                                                                                                                item as xmlSchemaAttributeUsePtr,
                                                                                                            );
                                                                                                            if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                                                                                                                current_block = 2133922729242721719;
                                                                                                                break;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    _ => {}
                                                                                                }
                                                                                                i += 1;
                                                                                            }
                                                                                            match current_block {
                                                                                                2133922729242721719 => {}
                                                                                                _ => {
                                                                                                    if (*pctxt).nberrors != 0 as i32 {
                                                                                                        current_block = 3799963374263564300;
                                                                                                    } else {
                                                                                                        i = 0 as i32;
                                                                                                        loop {
                                                                                                            if !(i < nbItems) {
                                                                                                                current_block = 6662862405959679103;
                                                                                                                break;
                                                                                                            }
                                                                                                            item = *items.offset(i as isize);
                                                                                                            match (*item).type_0 as u32 {
                                                                                                                16 => {
                                                                                                                    if !((*(item as xmlSchemaAttributeGroupPtr)).attrUses)
                                                                                                                        .is_null()
                                                                                                                        && (*((*(item as xmlSchemaAttributeGroupPtr)).attrUses
                                                                                                                            as xmlSchemaItemListPtr))
                                                                                                                            .nbItems > 1 as i32
                                                                                                                    {
                                                                                                                        xmlSchemaCheckAGPropsCorrect(
                                                                                                                            pctxt,
                                                                                                                            item as xmlSchemaAttributeGroupPtr,
                                                                                                                        );
                                                                                                                        if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                                                                                                                            current_block = 2133922729242721719;
                                                                                                                            break;
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                                _ => {}
                                                                                                            }
                                                                                                            i += 1;
                                                                                                        }
                                                                                                        match current_block {
                                                                                                            2133922729242721719 => {}
                                                                                                            _ => {
                                                                                                                if (*pctxt).nberrors != 0 as i32 {
                                                                                                                    current_block = 3799963374263564300;
                                                                                                                } else {
                                                                                                                    if !((*(*pctxt).constructor).redefs).is_null() {
                                                                                                                        xmlSchemaCheckSRCRedefineSecond(pctxt);
                                                                                                                    }
                                                                                                                    if (*pctxt).nberrors != 0 as i32 {
                                                                                                                        current_block = 3799963374263564300;
                                                                                                                    } else {
                                                                                                                        i = 0 as i32;
                                                                                                                        loop {
                                                                                                                            if !(i < nbItems) {
                                                                                                                                current_block = 13598848910332274892;
                                                                                                                                break;
                                                                                                                            }
                                                                                                                            item = *((*(*con).pending).items).offset(i as isize)
                                                                                                                                as xmlSchemaTreeItemPtr;
                                                                                                                            match (*item).type_0 as u32 {
                                                                                                                                5 => {
                                                                                                                                    if (*(item as xmlSchemaTypePtr)).type_0 as u32
                                                                                                                                        != XML_SCHEMA_TYPE_BASIC as i32 as u32
                                                                                                                                        && (*(item as xmlSchemaTypePtr)).flags
                                                                                                                                            & (1 as i32) << 22 as i32
                                                                                                                                            == 0 as i32
                                                                                                                                    {
                                                                                                                                        xmlSchemaFixupComplexType(pctxt, item as xmlSchemaTypePtr);
                                                                                                                                        if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                                                                                                                                            current_block = 2133922729242721719;
                                                                                                                                            break;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                _ => {}
                                                                                                                            }
                                                                                                                            i += 1;
                                                                                                                        }
                                                                                                                        match current_block {
                                                                                                                            2133922729242721719 => {}
                                                                                                                            _ => {
                                                                                                                                if (*pctxt).nberrors != 0 as i32 {
                                                                                                                                    current_block = 3799963374263564300;
                                                                                                                                } else {
                                                                                                                                    items = (*(*con).pending).items
                                                                                                                                        as *mut xmlSchemaTreeItemPtr;
                                                                                                                                    nbItems = (*(*con).pending).nbItems;
                                                                                                                                    i = 0 as i32;
                                                                                                                                    loop {
                                                                                                                                        if !(i < nbItems) {
                                                                                                                                            current_block = 2277602629737488951;
                                                                                                                                            break;
                                                                                                                                        }
                                                                                                                                        item = *items.offset(i as isize);
                                                                                                                                        match (*item).type_0 as u32 {
                                                                                                                                            14 => {
                                                                                                                                                elemDecl = item as xmlSchemaElementPtr;
                                                                                                                                                if (*elemDecl).flags
                                                                                                                                                    & (1 as i32) << 18 as i32
                                                                                                                                                    == 0 as i32
                                                                                                                                                {
                                                                                                                                                    xmlSchemaCheckElementDeclComponent(elemDecl, pctxt);
                                                                                                                                                    if (*pctxt).err == XML_SCHEMAP_INTERNAL as i32 {
                                                                                                                                                        current_block = 2133922729242721719;
                                                                                                                                                        break;
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                            _ => {}
                                                                                                                                        }
                                                                                                                                        i += 1;
                                                                                                                                    }
                                                                                                                                    match current_block {
                                                                                                                                        2133922729242721719 => {}
                                                                                                                                        _ => {
                                                                                                                                            if (*pctxt).nberrors != 0 as i32 {
                                                                                                                                                current_block = 3799963374263564300;
                                                                                                                                            } else {
                                                                                                                                                i = 0 as i32;
                                                                                                                                                while i < nbItems {
                                                                                                                                                    item = *items.offset(i as isize);
                                                                                                                                                    match (*item).type_0 as u32 {
                                                                                                                                                        5 => {
                                                                                                                                                            xmlSchemaBuildContentModel(item as xmlSchemaTypePtr, pctxt);
                                                                                                                                                        }
                                                                                                                                                        _ => {}
                                                                                                                                                    }
                                                                                                                                                    i += 1;
                                                                                                                                                }
                                                                                                                                                if (*pctxt).nberrors != 0 as i32 {
                                                                                                                                                    current_block = 3799963374263564300;
                                                                                                                                                } else {
                                                                                                                                                    current_block = 17463883078150051418;
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            match current_block {
                17463883078150051418 => {}
                2133922729242721719 => {}
                _ => {
                    ret = (*pctxt).err;
                    current_block = 17463883078150051418;
                }
            }
        }
        _ => {}
    }
    match current_block {
        2133922729242721719 => {
            ret = -(1 as i32);
        }
        _ => {}
    }
    let fresh423 = &mut ((*con).bucket);
    *fresh423 = oldbucket;
    (*(*con).pending).nbItems = 0 as i32;
    if !((*con).substGroups).is_null() {
        xmlHashFree(
            (*con).substGroups,
            Some(
                xmlSchemaSubstGroupFreeEntry
                    as unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
            ),
        );
        let fresh424 = &mut ((*con).substGroups);
        *fresh424 = 0 as xmlHashTablePtr;
    }
    if !((*con).redefs).is_null() {
        xmlSchemaRedefListFree((*con).redefs);
        let fresh425 = &mut ((*con).redefs);
        *fresh425 = 0 as xmlSchemaRedefPtr;
    }
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaParse(
    mut ctxt: xmlSchemaParserCtxtPtr,
) -> xmlSchemaPtr {
    let mut current_block: u64;
    let mut mainSchema: xmlSchemaPtr = 0 as xmlSchemaPtr;
    let mut bucket: xmlSchemaBucketPtr = 0 as xmlSchemaBucketPtr;
    let mut res: i32 = 0;
    xmlSchemaInitTypes();
    if ctxt.is_null() {
        return 0 as xmlSchemaPtr;
    }
    (*ctxt).nberrors = 0 as i32;
    (*ctxt).err = 0 as i32;
    (*ctxt).counter = 0 as i32;
    mainSchema = xmlSchemaNewSchema(ctxt);
    if !mainSchema.is_null() {
        if ((*ctxt).constructor).is_null() {
            let fresh426 = &mut ((*ctxt).constructor);
            *fresh426 = xmlSchemaConstructionCtxtCreate((*ctxt).dict);
            if ((*ctxt).constructor).is_null() {
                return 0 as xmlSchemaPtr;
            }
            (*ctxt).ownsConstructor = 1 as i32;
        }
        let fresh427 = &mut ((*(*ctxt).constructor).mainSchema);
        *fresh427 = mainSchema;
        res = xmlSchemaAddSchemaDoc(
            ctxt,
            0 as i32,
            (*ctxt).URL,
            (*ctxt).doc,
            (*ctxt).buffer,
            (*ctxt).size,
            0 as xmlNodePtr,
            0 as *const xmlChar,
            0 as *const xmlChar,
            &mut bucket,
        );
        if !(res == -(1 as i32)) {
            if res != 0 as i32 {
                current_block = 7777198333657744202;
            } else if bucket.is_null() {
                if !((*ctxt).URL).is_null() {
                    xmlSchemaCustomErr(
                        ctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_FAILED_LOAD,
                        0 as xmlNodePtr,
                        0 as xmlSchemaBasicItemPtr,
                        b"Failed to locate the main schema resource at '%s'\0"
                            as *const u8 as *const i8,
                        (*ctxt).URL,
                        0 as *const xmlChar,
                    );
                } else {
                    xmlSchemaCustomErr(
                        ctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_FAILED_LOAD,
                        0 as xmlNodePtr,
                        0 as xmlSchemaBasicItemPtr,
                        b"Failed to locate the main schema resource\0" as *const u8
                            as *const i8,
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                }
                current_block = 7777198333657744202;
            } else if xmlSchemaParseNewDocWithContext(ctxt, mainSchema, bucket)
                    == -(1 as i32)
                {
                current_block = 4244197895050895038;
            } else if (*ctxt).nberrors != 0 as i32 {
                current_block = 7777198333657744202;
            } else {
                let fresh428 = &mut ((*mainSchema).doc);
                *fresh428 = (*bucket).doc;
                (*mainSchema).preserve = (*ctxt).preserve;
                let fresh429 = &mut ((*ctxt).schema);
                *fresh429 = mainSchema;
                if xmlSchemaFixupComponents(ctxt, (*(*ctxt).constructor).mainBucket)
                    == -(1 as i32)
                {
                    current_block = 4244197895050895038;
                } else {
                    current_block = 7777198333657744202;
                }
            }
            match current_block {
                4244197895050895038 => {}
                _ => {
                    if (*ctxt).nberrors != 0 as i32 {
                        if !mainSchema.is_null() {
                            xmlSchemaFree(mainSchema);
                            mainSchema = 0 as xmlSchemaPtr;
                        }
                        if !((*ctxt).constructor).is_null() {
                            xmlSchemaConstructionCtxtFree((*ctxt).constructor);
                            let fresh430 = &mut ((*ctxt).constructor);
                            *fresh430 = 0 as xmlSchemaConstructionCtxtPtr;
                            (*ctxt).ownsConstructor = 0 as i32;
                        }
                    }
                    let fresh431 = &mut ((*ctxt).schema);
                    *fresh431 = 0 as xmlSchemaPtr;
                    return mainSchema;
                }
            }
        }
    }
    if !mainSchema.is_null() {
        xmlSchemaFree(mainSchema);
        mainSchema = 0 as xmlSchemaPtr;
    }
    if !((*ctxt).constructor).is_null() {
        xmlSchemaConstructionCtxtFree((*ctxt).constructor);
        let fresh432 = &mut ((*ctxt).constructor);
        *fresh432 = 0 as xmlSchemaConstructionCtxtPtr;
        (*ctxt).ownsConstructor = 0 as i32;
    }
    xmlSchemaInternalErr(
        ctxt as xmlSchemaAbstractCtxtPtr,
        b"xmlSchemaParse\0" as *const u8 as *const i8,
        b"An internal error occurred\0" as *const u8 as *const i8,
    );
    let fresh433 = &mut ((*ctxt).schema);
    *fresh433 = 0 as xmlSchemaPtr;
    return 0 as xmlSchemaPtr;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSetParserErrors(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut err: xmlSchemaValidityErrorFunc,
    mut warn: xmlSchemaValidityWarningFunc,
    mut ctx: *mut libc::c_void,
) {
    if ctxt.is_null() {
        return;
    }
    let fresh434 = &mut ((*ctxt).error);
    *fresh434 = err;
    let fresh435 = &mut ((*ctxt).warning);
    *fresh435 = warn;
    let fresh436 = &mut ((*ctxt).errCtxt);
    *fresh436 = ctx;
    if !((*ctxt).vctxt).is_null() {
        xmlSchemaSetValidErrors((*ctxt).vctxt, err, warn, ctx);
    }
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSetParserStructuredErrors(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut serror: xmlStructuredErrorFunc,
    mut ctx: *mut libc::c_void,
) {
    if ctxt.is_null() {
        return;
    }
    let fresh437 = &mut ((*ctxt).serror);
    *fresh437 = serror;
    let fresh438 = &mut ((*ctxt).errCtxt);
    *fresh438 = ctx;
    if !((*ctxt).vctxt).is_null() {
        xmlSchemaSetValidStructuredErrors((*ctxt).vctxt, serror, ctx);
    }
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaGetParserErrors(
    mut ctxt: xmlSchemaParserCtxtPtr,
    mut err: *mut xmlSchemaValidityErrorFunc,
    mut warn: *mut xmlSchemaValidityWarningFunc,
    mut ctx: *mut *mut libc::c_void,
) -> i32 {
    if ctxt.is_null() {
        return -(1 as i32);
    }
    if !err.is_null() {
        *err = (*ctxt).error;
    }
    if !warn.is_null() {
        *warn = (*ctxt).warning;
    }
    if !ctx.is_null() {
        *ctx = (*ctxt).errCtxt;
    }
    return 0 as i32;
}
 extern "C" fn xmlSchemaFacetTypeToString(
    mut type_0: xmlSchemaTypeType,
) -> *const xmlChar {
    match type_0 as u32 {
        1006 => return b"pattern\0" as *const u8 as *const i8 as *mut xmlChar,
        1003 => {
            return b"maxExclusive\0" as *const u8 as *const i8 as *mut xmlChar;
        }
        1002 => {
            return b"maxInclusive\0" as *const u8 as *const i8 as *mut xmlChar;
        }
        1001 => {
            return b"minExclusive\0" as *const u8 as *const i8 as *mut xmlChar;
        }
        1000 => {
            return b"minInclusive\0" as *const u8 as *const i8 as *mut xmlChar;
        }
        1008 => {
            return b"whiteSpace\0" as *const u8 as *const i8 as *mut xmlChar;
        }
        1007 => {
            return b"enumeration\0" as *const u8 as *const i8 as *mut xmlChar;
        }
        1009 => return b"length\0" as *const u8 as *const i8 as *mut xmlChar,
        1010 => return b"maxLength\0" as *const u8 as *const i8 as *mut xmlChar,
        1011 => return b"minLength\0" as *const u8 as *const i8 as *mut xmlChar,
        1004 => {
            return b"totalDigits\0" as *const u8 as *const i8 as *mut xmlChar;
        }
        1005 => {
            return b"fractionDigits\0" as *const u8 as *const i8
                as *mut xmlChar;
        }
        _ => {}
    }
    return b"Internal Error\0" as *const u8 as *const i8 as *mut xmlChar;
}
unsafe extern "C" fn xmlSchemaGetWhiteSpaceFacetValue(
    mut type_0: xmlSchemaTypePtr,
) -> xmlSchemaWhitespaceValueType {
    if (*type_0).type_0 as u32
        == XML_SCHEMA_TYPE_BASIC as i32 as u32
    {
        if (*type_0).builtInType == XML_SCHEMAS_STRING as i32
            || (*type_0).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as i32
        {
            return XML_SCHEMA_WHITESPACE_PRESERVE
        } else if (*type_0).builtInType == XML_SCHEMAS_NORMSTRING as i32 {
            return XML_SCHEMA_WHITESPACE_REPLACE
        } else {
            return XML_SCHEMA_WHITESPACE_COLLAPSE
        }
    } else {
        if (*type_0).flags & (1 as i32) << 6 as i32 != 0 {
            return XML_SCHEMA_WHITESPACE_COLLAPSE
        } else {
            if (*type_0).flags & (1 as i32) << 7 as i32 != 0 {
                return XML_SCHEMA_WHITESPACE_UNKNOWN
            } else {
                if (*type_0).flags & (1 as i32) << 8 as i32 != 0 {
                    if (*type_0).flags & (1 as i32) << 24 as i32 != 0 {
                        return XML_SCHEMA_WHITESPACE_PRESERVE
                    } else if (*type_0).flags & (1 as i32) << 25 as i32
                            != 0
                        {
                        return XML_SCHEMA_WHITESPACE_REPLACE
                    } else {
                        return XML_SCHEMA_WHITESPACE_COLLAPSE
                    }
                }
            }
        }
    }
    return 4294967295 as xmlSchemaWhitespaceValueType;
}
unsafe extern "C" fn xmlSchemaAssembleByLocation(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut nsName: *const xmlChar,
    mut location: *const xmlChar,
) -> i32 {
    let mut ret: i32 = 0 as i32;
    let mut pctxt: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
    let mut bucket: xmlSchemaBucketPtr = 0 as xmlSchemaBucketPtr;
    if vctxt.is_null() || schema.is_null() {
        return -(1 as i32);
    }
    if ((*vctxt).pctxt).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaAssembleByLocation\0" as *const u8 as *const i8,
            b"no parser context available\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    pctxt = (*vctxt).pctxt;
    if ((*pctxt).constructor).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaAssembleByLocation\0" as *const u8 as *const i8,
            b"no constructor\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    location = xmlSchemaBuildAbsoluteURI((*pctxt).dict, location, node);
    ret = xmlSchemaAddSchemaDoc(
        pctxt,
        1 as i32,
        location,
        0 as xmlDocPtr,
        0 as *const i8,
        0 as i32,
        node,
        0 as *const xmlChar,
        nsName,
        &mut bucket,
    );
    if ret != 0 as i32 {
        return ret;
    }
    if bucket.is_null() {
        xmlSchemaCustomWarning(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_MISC,
            node,
            0 as xmlSchemaTypePtr,
            b"The document at location '%s' could not be acquired\0" as *const u8
                as *const i8,
            location,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return ret;
    }
    if !bucket.is_null() && ((*(*pctxt).constructor).bucket).is_null() {
        let fresh439 = &mut ((*(*pctxt).constructor).bucket);
        *fresh439 = bucket;
    }
    if bucket.is_null()
        || !(!((*bucket).doc).is_null() && (*bucket).parsed == 0 as i32)
    {
        return 0 as i32;
    }
    (*pctxt).nberrors = 0 as i32;
    (*pctxt).err = 0 as i32;
    let fresh440 = &mut ((*pctxt).doc);
    *fresh440 = (*bucket).doc;
    ret = xmlSchemaParseNewDocWithContext(pctxt, schema, bucket);
    if ret == -(1 as i32) {
        let fresh441 = &mut ((*pctxt).doc);
        *fresh441 = 0 as xmlDocPtr;
        let fresh443 = &mut ((*pctxt).doc);
        *fresh443 = 0 as xmlDocPtr;
        return -(1 as i32);
    } else {
        if ret == 0 as i32 && (*pctxt).nberrors != 0 as i32 {
            ret = (*pctxt).err;
        }
        if (*pctxt).nberrors == 0 as i32 {
            xmlSchemaFixupComponents(pctxt, bucket);
            ret = (*pctxt).err;
            if ret != 0 as i32 && (*vctxt).err == 0 as i32 {
                (*vctxt).err = ret;
            }
            (*vctxt).nberrors += (*pctxt).nberrors;
        } else {
            (*vctxt).nberrors += (*pctxt).nberrors;
        }
        let fresh442 = &mut ((*pctxt).doc);
        *fresh442 = 0 as xmlDocPtr;
        return ret;
    };
}
unsafe extern "C" fn xmlSchemaGetMetaAttrInfo(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut metaType: i32,
) -> xmlSchemaAttrInfoPtr {
    if (*vctxt).nbAttrInfos == 0 as i32 {
        return 0 as xmlSchemaAttrInfoPtr;
    }
    let mut i: i32 = 0;
    let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    i = 0 as i32;
    while i < (*vctxt).nbAttrInfos {
        iattr = *((*vctxt).attrInfos).offset(i as isize);
        if (*iattr).metaType == metaType {
            return iattr;
        }
        i += 1;
    }
    return 0 as xmlSchemaAttrInfoPtr;
}
unsafe extern "C" fn xmlSchemaAssembleByXSI(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> i32 {
    let mut cur: *const xmlChar = 0 as *const xmlChar;
    let mut end: *const xmlChar = 0 as *const xmlChar;
    let mut nsname: *const xmlChar = 0 as *const xmlChar;
    let mut location: *const xmlChar = 0 as *const xmlChar;
    let mut count: i32 = 0 as i32;
    let mut ret: i32 = 0 as i32;
    let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    iattr = xmlSchemaGetMetaAttrInfo(vctxt, 3 as i32);
    if iattr.is_null() {
        iattr = xmlSchemaGetMetaAttrInfo(vctxt, 4 as i32);
    }
    if iattr.is_null() {
        return 0 as i32;
    }
    cur = (*iattr).value;
    loop {
        if (*iattr).metaType == 3 as i32 {
            while *cur as i32 == 0x20 as i32
                || 0x9 as i32 <= *cur as i32
                    && *cur as i32 <= 0xa as i32
                || *cur as i32 == 0xd as i32
            {
                cur = cur.offset(1);
            }
            end = cur;
            while *end as i32 != 0 as i32
                && !(*end as i32 == 0x20 as i32
                    || 0x9 as i32 <= *end as i32
                        && *end as i32 <= 0xa as i32
                    || *end as i32 == 0xd as i32)
            {
                end = end.offset(1);
            }
            if end == cur {
                break;
            }
            count += 1;
            nsname = xmlDictLookup(
                (*(*vctxt).schema).dict,
                cur,
                end.offset_from(cur) as i64 as i32,
            );
            cur = end;
        }
        while *cur as i32 == 0x20 as i32
            || 0x9 as i32 <= *cur as i32
                && *cur as i32 <= 0xa as i32
            || *cur as i32 == 0xd as i32
        {
            cur = cur.offset(1);
        }
        end = cur;
        while *end as i32 != 0 as i32
            && !(*end as i32 == 0x20 as i32
                || 0x9 as i32 <= *end as i32
                    && *end as i32 <= 0xa as i32
                || *end as i32 == 0xd as i32)
        {
            end = end.offset(1);
        }
        if end == cur {
            if (*iattr).metaType == 3 as i32 {
                xmlSchemaCustomWarning(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    XML_SCHEMAV_MISC,
                    (*iattr).node,
                    0 as xmlSchemaTypePtr,
                    b"The value must consist of tuples: the target namespace name and the document's URI\0"
                        as *const u8 as *const i8,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
            }
            break;
        } else {
            count += 1;
            location = xmlDictLookup(
                (*(*vctxt).schema).dict,
                cur,
                end.offset_from(cur) as i64 as i32,
            );
            cur = end;
            ret = xmlSchemaAssembleByLocation(
                vctxt,
                (*vctxt).schema,
                (*iattr).node,
                nsname,
                location,
            );
            if ret == -(1 as i32) {
                xmlSchemaInternalErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaAssembleByXSI\0" as *const u8 as *const i8,
                    b"assembling schemata\0" as *const u8 as *const i8,
                );
                return -(1 as i32);
            }
            if !(*cur as i32 != 0 as i32) {
                break;
            }
        }
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaLookupNamespace(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut prefix: *const xmlChar,
) -> *const xmlChar {
    if !((*vctxt).sax).is_null() {
        let mut i: i32 = 0;
        let mut j: i32 = 0;
        let mut inode: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
        i = (*vctxt).depth;
        while i >= 0 as i32 {
            if (**((*vctxt).elemInfos).offset(i as isize)).nbNsBindings
                != 0 as i32
            {
                inode = *((*vctxt).elemInfos).offset(i as isize);
                j = 0 as i32;
                while j < (*inode).nbNsBindings * 2 as i32 {
                    if prefix.is_null()
                        && (*((*inode).nsBindings).offset(j as isize)).is_null()
                        || !prefix.is_null()
                            && xmlStrEqual(
                                prefix,
                                *((*inode).nsBindings).offset(j as isize),
                            ) != 0
                    {
                        return *((*inode).nsBindings)
                            .offset((j + 1 as i32) as isize);
                    }
                    j += 2 as i32;
                }
            }
            i -= 1;
        }
        return 0 as *const xmlChar;
    } else if !((*vctxt).reader).is_null() {
        let mut nsName: *mut xmlChar = 0 as *mut xmlChar;
        nsName = xmlTextReaderLookupNamespace((*vctxt).reader, prefix);
        if !nsName.is_null() {
            let mut ret: *const xmlChar = 0 as *const xmlChar;
            ret = xmlDictLookup((*vctxt).dict, nsName, -(1 as i32));
            xmlFree.expect("non-null function pointer")(nsName as *mut libc::c_void);
            return ret;
        } else {
            return 0 as *const xmlChar
        }
    } else {
        let mut ns: xmlNsPtr = 0 as *mut xmlNs;
        if ((*(*vctxt).inode).node).is_null()
            || ((*(*(*vctxt).inode).node).doc).is_null()
        {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaLookupNamespace\0" as *const u8 as *const i8,
                b"no node or node's doc available\0" as *const u8 as *const i8,
            );
            return 0 as *const xmlChar;
        }
        ns = xmlSearchNs((*(*(*vctxt).inode).node).doc, (*(*vctxt).inode).node, prefix);
        if !ns.is_null() {
            return (*ns).href;
        }
        return 0 as *const xmlChar;
    };
}
unsafe extern "C" fn xmlSchemaValidateNotation(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut schema: xmlSchemaPtr,
    mut node: xmlNodePtr,
    mut value: *const xmlChar,
    mut val: *mut xmlSchemaValPtr,
    mut valNeeded: i32,
) -> i32 {
    let mut ret: i32 = 0;
    if !vctxt.is_null() && ((*vctxt).schema).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaValidateNotation\0" as *const u8 as *const i8,
            b"a schema is needed on the validation context\0" as *const u8
                as *const i8,
        );
        return -(1 as i32);
    }
    ret = xmlValidateQName(value, 1 as i32);
    if ret != 0 as i32 {
        return ret;
    }
    let mut localName: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    localName = xmlSplitQName2(value, &mut prefix);
    if !prefix.is_null() {
        let mut nsName: *const xmlChar = 0 as *const xmlChar;
        if !vctxt.is_null() {
            nsName = xmlSchemaLookupNamespace(vctxt, prefix);
        } else if !node.is_null() {
            let mut ns: xmlNsPtr = xmlSearchNs((*node).doc, node, prefix);
            if !ns.is_null() {
                nsName = (*ns).href;
            }
        } else {
            xmlFree.expect("non-null function pointer")(prefix as *mut libc::c_void);
            xmlFree.expect("non-null function pointer")(localName as *mut libc::c_void);
            return 1 as i32;
        }
        if nsName.is_null() {
            xmlFree.expect("non-null function pointer")(prefix as *mut libc::c_void);
            xmlFree.expect("non-null function pointer")(localName as *mut libc::c_void);
            return 1 as i32;
        }
        if !(xmlSchemaGetNotation(schema, localName, nsName)).is_null() {
            if valNeeded != 0 && !val.is_null() {
                *val = xmlSchemaNewNOTATIONValue(
                    xmlStrdup(localName),
                    xmlStrdup(nsName),
                );
                if (*val).is_null() {
                    ret = -(1 as i32);
                }
            }
        } else {
            ret = 1 as i32;
        }
        xmlFree.expect("non-null function pointer")(prefix as *mut libc::c_void);
        xmlFree.expect("non-null function pointer")(localName as *mut libc::c_void);
    } else if !(xmlSchemaGetNotation(schema, value, 0 as *const xmlChar)).is_null() {
        if valNeeded != 0 && !val.is_null() {
            *val = xmlSchemaNewNOTATIONValue(xmlStrdup(value), 0 as *const xmlChar);
            if (*val).is_null() {
                ret = -(1 as i32);
            }
        }
    } else {
        return 1 as i32
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaVAddNodeQName(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut lname: *const xmlChar,
    mut nsname: *const xmlChar,
) -> i32 {
    let mut i: i32 = 0;
    lname = xmlDictLookup((*vctxt).dict, lname, -(1 as i32));
    if lname.is_null() {
        return -(1 as i32);
    }
    if !nsname.is_null() {
        nsname = xmlDictLookup((*vctxt).dict, nsname, -(1 as i32));
        if nsname.is_null() {
            return -(1 as i32);
        }
    }
    i = 0 as i32;
    while i < (*(*vctxt).nodeQNames).nbItems {
        if *((*(*vctxt).nodeQNames).items).offset(i as isize)
            == lname as *mut libc::c_void
            && *((*(*vctxt).nodeQNames).items).offset((i + 1 as i32) as isize)
                == nsname as *mut libc::c_void
        {
            return i;
        }
        i += 2 as i32;
    }
    i = (*(*vctxt).nodeQNames).nbItems;
    xmlSchemaItemListAdd((*vctxt).nodeQNames, lname as *mut libc::c_void);
    xmlSchemaItemListAdd((*vctxt).nodeQNames, nsname as *mut libc::c_void);
    return i;
}
unsafe extern "C" fn xmlSchemaAugmentIDC(
    mut payload: *mut libc::c_void,
    mut data: *mut libc::c_void,
    mut name: *const xmlChar,
) {
    let mut idcDef: xmlSchemaIDCPtr = payload as xmlSchemaIDCPtr;
    let mut vctxt: xmlSchemaValidCtxtPtr = data as xmlSchemaValidCtxtPtr;
    let mut aidc: xmlSchemaIDCAugPtr = 0 as *mut xmlSchemaIDCAug;
    aidc = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaIDCAug>() as u64)
        as xmlSchemaIDCAugPtr;
    if aidc.is_null() {
        xmlSchemaVErrMemory(
            vctxt,
            b"xmlSchemaAugmentIDC: allocating an augmented IDC definition\0" as *const u8
                as *const i8,
            0 as xmlNodePtr,
        );
        return;
    }
    (*aidc).keyrefDepth = -(1 as i32);
    let fresh444 = &mut ((*aidc).def);
    *fresh444 = idcDef;
    let fresh445 = &mut ((*aidc).next);
    *fresh445 = 0 as xmlSchemaIDCAugPtr;
    if ((*vctxt).aidcs).is_null() {
        let fresh446 = &mut ((*vctxt).aidcs);
        *fresh446 = aidc;
    } else {
        let fresh447 = &mut ((*aidc).next);
        *fresh447 = (*vctxt).aidcs;
        let fresh448 = &mut ((*vctxt).aidcs);
        *fresh448 = aidc;
    }
    if (*vctxt).hasKeyrefs == 0 as i32
        && (*idcDef).type_0 as u32
            == XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
    {
        (*vctxt).hasKeyrefs = 1 as i32;
    }
}
unsafe extern "C" fn xmlSchemaAugmentImportedIDC(
    mut payload: *mut libc::c_void,
    mut data: *mut libc::c_void,
    mut name: *const xmlChar,
) {
    let mut imported: xmlSchemaImportPtr = payload as xmlSchemaImportPtr;
    let mut vctxt: xmlSchemaValidCtxtPtr = data as xmlSchemaValidCtxtPtr;
    if !((*(*imported).schema).idcDef).is_null() {
        xmlHashScan(
            (*(*imported).schema).idcDef,
            Some(
                xmlSchemaAugmentIDC
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *mut libc::c_void,
                        *const xmlChar,
                    ) -> (),
            ),
            vctxt as *mut libc::c_void,
        );
    }
}
unsafe extern "C" fn xmlSchemaIDCNewBinding(
    mut idcDef: xmlSchemaIDCPtr,
) -> xmlSchemaPSVIIDCBindingPtr {
    let mut ret: xmlSchemaPSVIIDCBindingPtr = 0 as *mut xmlSchemaPSVIIDCBinding;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaPSVIIDCBinding>() as u64)
        as xmlSchemaPSVIIDCBindingPtr;
    if ret.is_null() {
        xmlSchemaVErrMemory(
            0 as xmlSchemaValidCtxtPtr,
            b"allocating a PSVI IDC binding item\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaPSVIIDCBindingPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaPSVIIDCBinding>() as u64,
    );
    let fresh449 = &mut ((*ret).definition);
    *fresh449 = idcDef;
    return ret;
}
unsafe extern "C" fn xmlSchemaIDCStoreNodeTableItem(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut item: xmlSchemaPSVIIDCNodePtr,
) -> i32 {
    if ((*vctxt).idcNodes).is_null() {
        let fresh450 = &mut ((*vctxt).idcNodes);
        *fresh450 = xmlMalloc
            .expect(
                "non-null function pointer",
            )(
            (20 as i32 as u64)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>() as u64,
                ),
        ) as *mut xmlSchemaPSVIIDCNodePtr;
        if ((*vctxt).idcNodes).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"allocating the IDC node table item list\0" as *const u8
                    as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
        (*vctxt).sizeIdcNodes = 20 as i32;
    } else if (*vctxt).sizeIdcNodes <= (*vctxt).nbIdcNodes {
        (*vctxt).sizeIdcNodes *= 2 as i32;
        let fresh451 = &mut ((*vctxt).idcNodes);
        *fresh451 = xmlRealloc
            .expect(
                "non-null function pointer",
            )(
            (*vctxt).idcNodes as *mut libc::c_void,
            ((*vctxt).sizeIdcNodes as u64)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>() as u64,
                ),
        ) as *mut xmlSchemaPSVIIDCNodePtr;
        if ((*vctxt).idcNodes).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"re-allocating the IDC node table item list\0" as *const u8
                    as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
    }
    let fresh452 = &mut ((*vctxt).nbIdcNodes);
    let fresh453 = *fresh452;
    *fresh452 = *fresh452 + 1;
    let fresh454 = &mut (*((*vctxt).idcNodes).offset(fresh453 as isize));
    *fresh454 = item;
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaIDCStoreKey(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut key: xmlSchemaPSVIIDCKeyPtr,
) -> i32 {
    if ((*vctxt).idcKeys).is_null() {
        let fresh455 = &mut ((*vctxt).idcKeys);
        *fresh455 = xmlMalloc
            .expect(
                "non-null function pointer",
            )(
            (40 as i32 as u64)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaPSVIIDCKeyPtr>() as u64,
                ),
        ) as *mut xmlSchemaPSVIIDCKeyPtr;
        if ((*vctxt).idcKeys).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"allocating the IDC key storage list\0" as *const u8
                    as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
        (*vctxt).sizeIdcKeys = 40 as i32;
    } else if (*vctxt).sizeIdcKeys <= (*vctxt).nbIdcKeys {
        (*vctxt).sizeIdcKeys *= 2 as i32;
        let fresh456 = &mut ((*vctxt).idcKeys);
        *fresh456 = xmlRealloc
            .expect(
                "non-null function pointer",
            )(
            (*vctxt).idcKeys as *mut libc::c_void,
            ((*vctxt).sizeIdcKeys as u64)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaPSVIIDCKeyPtr>() as u64,
                ),
        ) as *mut xmlSchemaPSVIIDCKeyPtr;
        if ((*vctxt).idcKeys).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"re-allocating the IDC key storage list\0" as *const u8
                    as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
    }
    let fresh457 = &mut ((*vctxt).nbIdcKeys);
    let fresh458 = *fresh457;
    *fresh457 = *fresh457 + 1;
    let fresh459 = &mut (*((*vctxt).idcKeys).offset(fresh458 as isize));
    *fresh459 = key;
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaIDCAppendNodeTableItem(
    mut bind: xmlSchemaPSVIIDCBindingPtr,
    mut ntItem: xmlSchemaPSVIIDCNodePtr,
) -> i32 {
    if ((*bind).nodeTable).is_null() {
        (*bind).sizeNodes = 10 as i32;
        let fresh460 = &mut ((*bind).nodeTable);
        *fresh460 = xmlMalloc
            .expect(
                "non-null function pointer",
            )(
            (10 as i32 as u64)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>() as u64,
                ),
        ) as *mut xmlSchemaPSVIIDCNodePtr;
        if ((*bind).nodeTable).is_null() {
            xmlSchemaVErrMemory(
                0 as xmlSchemaValidCtxtPtr,
                b"allocating an array of IDC node-table items\0" as *const u8
                    as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
    } else if (*bind).sizeNodes <= (*bind).nbNodes {
        (*bind).sizeNodes *= 2 as i32;
        let fresh461 = &mut ((*bind).nodeTable);
        *fresh461 = xmlRealloc
            .expect(
                "non-null function pointer",
            )(
            (*bind).nodeTable as *mut libc::c_void,
            ((*bind).sizeNodes as u64)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>() as u64,
                ),
        ) as *mut xmlSchemaPSVIIDCNodePtr;
        if ((*bind).nodeTable).is_null() {
            xmlSchemaVErrMemory(
                0 as xmlSchemaValidCtxtPtr,
                b"re-allocating an array of IDC node-table items\0" as *const u8
                    as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
    }
    let fresh462 = &mut ((*bind).nbNodes);
    let fresh463 = *fresh462;
    *fresh462 = *fresh462 + 1;
    let fresh464 = &mut (*((*bind).nodeTable).offset(fresh463 as isize));
    *fresh464 = ntItem;
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaIDCAcquireBinding(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut matcher: xmlSchemaIDCMatcherPtr,
) -> xmlSchemaPSVIIDCBindingPtr {
    let mut ielem: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
    ielem = *((*vctxt).elemInfos).offset((*matcher).depth as isize);
    if ((*ielem).idcTable).is_null() {
        let fresh465 = &mut ((*ielem).idcTable);
        *fresh465 = xmlSchemaIDCNewBinding((*(*matcher).aidc).def);
        if ((*ielem).idcTable).is_null() {
            return 0 as xmlSchemaPSVIIDCBindingPtr;
        }
        return (*ielem).idcTable;
    } else {
        let mut bind: xmlSchemaPSVIIDCBindingPtr = 0 as xmlSchemaPSVIIDCBindingPtr;
        bind = (*ielem).idcTable;
        loop {
            if (*bind).definition == (*(*matcher).aidc).def {
                return bind;
            }
            if ((*bind).next).is_null() {
                let fresh466 = &mut ((*bind).next);
                *fresh466 = xmlSchemaIDCNewBinding((*(*matcher).aidc).def);
                if ((*bind).next).is_null() {
                    return 0 as xmlSchemaPSVIIDCBindingPtr;
                }
                return (*bind).next;
            }
            bind = (*bind).next;
            if bind.is_null() {
                break;
            }
        }
    }
    return 0 as xmlSchemaPSVIIDCBindingPtr;
}
unsafe extern "C" fn xmlSchemaIDCAcquireTargetList(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut matcher: xmlSchemaIDCMatcherPtr,
) -> xmlSchemaItemListPtr {
    if ((*matcher).targets).is_null() {
        let fresh467 = &mut ((*matcher).targets);
        *fresh467 = xmlSchemaItemListCreate();
    }
    return (*matcher).targets;
}
unsafe extern "C" fn xmlSchemaIDCFreeKey(mut key: xmlSchemaPSVIIDCKeyPtr) {
    if !((*key).val).is_null() {
        xmlSchemaFreeValue((*key).val);
    }
    xmlFree.expect("non-null function pointer")(key as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaIDCFreeBinding(mut bind: xmlSchemaPSVIIDCBindingPtr) {
    if !((*bind).nodeTable).is_null() {
        xmlFree
            .expect("non-null function pointer")((*bind).nodeTable as *mut libc::c_void);
    }
    if !((*bind).dupls).is_null() {
        xmlSchemaItemListFree((*bind).dupls);
    }
    xmlFree.expect("non-null function pointer")(bind as *mut libc::c_void);
}
unsafe extern "C" fn xmlSchemaIDCFreeIDCTable(mut bind: xmlSchemaPSVIIDCBindingPtr) {
    let mut prev: xmlSchemaPSVIIDCBindingPtr = 0 as *mut xmlSchemaPSVIIDCBinding;
    while !bind.is_null() {
        prev = bind;
        bind = (*bind).next;
        xmlSchemaIDCFreeBinding(prev);
    }
}
unsafe extern "C" fn xmlFreeIDCHashEntry(
    mut payload: *mut libc::c_void,
    mut name: *const xmlChar,
) {
    let mut e: xmlIDCHashEntryPtr = payload as xmlIDCHashEntryPtr;
    let mut n: xmlIDCHashEntryPtr = 0 as *mut xmlIDCHashEntry;
    while !e.is_null() {
        n = (*e).next;
        xmlFree.expect("non-null function pointer")(e as *mut libc::c_void);
        e = n;
    }
}
unsafe extern "C" fn xmlSchemaIDCFreeMatcherList(mut matcher: xmlSchemaIDCMatcherPtr) {
    let mut next: xmlSchemaIDCMatcherPtr = 0 as *mut xmlSchemaIDCMatcher;
    while !matcher.is_null() {
        next = (*matcher).next;
        if !((*matcher).keySeqs).is_null() {
            let mut i: i32 = 0;
            i = 0 as i32;
            while i < (*matcher).sizeKeySeqs {
                if !(*((*matcher).keySeqs).offset(i as isize)).is_null() {
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(*((*matcher).keySeqs).offset(i as isize) as *mut libc::c_void);
                }
                i += 1;
            }
            xmlFree
                .expect(
                    "non-null function pointer",
                )((*matcher).keySeqs as *mut libc::c_void);
        }
        if !((*matcher).targets).is_null() {
            if (*matcher).idcType == XML_SCHEMA_TYPE_IDC_KEYREF as i32 {
                let mut i_0: i32 = 0;
                let mut idcNode: xmlSchemaPSVIIDCNodePtr = 0
                    as *mut xmlSchemaPSVIIDCNode;
                i_0 = 0 as i32;
                while i_0 < (*(*matcher).targets).nbItems {
                    idcNode = *((*(*matcher).targets).items).offset(i_0 as isize)
                        as xmlSchemaPSVIIDCNodePtr;
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )((*idcNode).keys as *mut libc::c_void);
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(idcNode as *mut libc::c_void);
                    i_0 += 1;
                }
            }
            xmlSchemaItemListFree((*matcher).targets);
        }
        if !((*matcher).htab).is_null() {
            xmlHashFree(
                (*matcher).htab,
                Some(
                    xmlFreeIDCHashEntry
                        as unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
                ),
            );
        }
        xmlFree.expect("non-null function pointer")(matcher as *mut libc::c_void);
        matcher = next;
    }
}
unsafe extern "C" fn xmlSchemaIDCReleaseMatcherList(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut matcher: xmlSchemaIDCMatcherPtr,
) {
    let mut next: xmlSchemaIDCMatcherPtr = 0 as *mut xmlSchemaIDCMatcher;
    while !matcher.is_null() {
        next = (*matcher).next;
        if !((*matcher).keySeqs).is_null() {
            let mut i: i32 = 0;
            i = 0 as i32;
            while i < (*matcher).sizeKeySeqs {
                if !(*((*matcher).keySeqs).offset(i as isize)).is_null() {
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(*((*matcher).keySeqs).offset(i as isize) as *mut libc::c_void);
                    let fresh468 = &mut (*((*matcher).keySeqs).offset(i as isize));
                    *fresh468 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                }
                i += 1;
            }
        }
        if !((*matcher).targets).is_null() {
            if (*matcher).idcType == XML_SCHEMA_TYPE_IDC_KEYREF as i32 {
                let mut i_0: i32 = 0;
                let mut idcNode: xmlSchemaPSVIIDCNodePtr = 0
                    as *mut xmlSchemaPSVIIDCNode;
                i_0 = 0 as i32;
                while i_0 < (*(*matcher).targets).nbItems {
                    idcNode = *((*(*matcher).targets).items).offset(i_0 as isize)
                        as xmlSchemaPSVIIDCNodePtr;
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )((*idcNode).keys as *mut libc::c_void);
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(idcNode as *mut libc::c_void);
                    i_0 += 1;
                }
            }
            xmlSchemaItemListFree((*matcher).targets);
            let fresh469 = &mut ((*matcher).targets);
            *fresh469 = 0 as xmlSchemaItemListPtr;
        }
        if !((*matcher).htab).is_null() {
            xmlHashFree(
                (*matcher).htab,
                Some(
                    xmlFreeIDCHashEntry
                        as unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
                ),
            );
            let fresh470 = &mut ((*matcher).htab);
            *fresh470 = 0 as xmlHashTablePtr;
        }
        let fresh471 = &mut ((*matcher).next);
        *fresh471 = 0 as xmlSchemaIDCMatcherPtr;
        if !((*vctxt).idcMatcherCache).is_null() {
            let fresh472 = &mut ((*matcher).nextCached);
            *fresh472 = (*vctxt).idcMatcherCache;
        }
        let fresh473 = &mut ((*vctxt).idcMatcherCache);
        *fresh473 = matcher;
        matcher = next;
    }
}
unsafe extern "C" fn xmlSchemaIDCAddStateObject(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut matcher: xmlSchemaIDCMatcherPtr,
    mut sel: xmlSchemaIDCSelectPtr,
    mut type_0: i32,
) -> i32 {
    let mut sto: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    if !((*vctxt).xpathStatePool).is_null() {
        sto = (*vctxt).xpathStatePool;
        let fresh474 = &mut ((*vctxt).xpathStatePool);
        *fresh474 = (*sto).next;
        let fresh475 = &mut ((*sto).next);
        *fresh475 = 0 as xmlSchemaIDCStateObjPtr;
    } else {
        sto = xmlMalloc
            .expect(
                "non-null function pointer",
            )(::std::mem::size_of::<xmlSchemaIDCStateObj>() as u64)
            as xmlSchemaIDCStateObjPtr;
        if sto.is_null() {
            xmlSchemaVErrMemory(
                0 as xmlSchemaValidCtxtPtr,
                b"allocating an IDC state object\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
        memset(
            sto as *mut libc::c_void,
            0 as i32,
            ::std::mem::size_of::<xmlSchemaIDCStateObj>() as u64,
        );
    }
    if !((*vctxt).xpathStates).is_null() {
        let fresh476 = &mut ((*sto).next);
        *fresh476 = (*vctxt).xpathStates;
    }
    let fresh477 = &mut ((*vctxt).xpathStates);
    *fresh477 = sto;
    if !((*sto).xpathCtxt).is_null() {
        xmlFreeStreamCtxt((*sto).xpathCtxt as xmlStreamCtxtPtr);
    }
    let fresh478 = &mut ((*sto).xpathCtxt);
    *fresh478 = xmlPatternGetStreamCtxt((*sel).xpathComp as xmlPatternPtr)
        as *mut libc::c_void;
    if ((*sto).xpathCtxt).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaIDCAddStateObject\0" as *const u8 as *const i8,
            b"failed to create an XPath validation context\0" as *const u8
                as *const i8,
        );
        return -(1 as i32);
    }
    (*sto).type_0 = type_0;
    (*sto).depth = (*vctxt).depth;
    let fresh479 = &mut ((*sto).matcher);
    *fresh479 = matcher;
    let fresh480 = &mut ((*sto).sel);
    *fresh480 = sel;
    (*sto).nbHistory = 0 as i32;
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaXPathEvaluate(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut nodeType: xmlElementType,
) -> i32 {
    let mut sto: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    let mut head: xmlSchemaIDCStateObjPtr = 0 as xmlSchemaIDCStateObjPtr;
    let mut first: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    let mut res: i32 = 0;
    let mut resolved: i32 = 0 as i32;
    let mut depth: i32 = (*vctxt).depth;
    if ((*vctxt).xpathStates).is_null() {
        return 0 as i32;
    }
    if nodeType as u32 == XML_ATTRIBUTE_NODE as i32 as u32 {
        depth += 1;
    }
    first = (*vctxt).xpathStates;
    sto = first;
    while sto != head {
        if nodeType as u32 == XML_ELEMENT_NODE as i32 as u32 {
            res = xmlStreamPush(
                (*sto).xpathCtxt as xmlStreamCtxtPtr,
                (*(*vctxt).inode).localName,
                (*(*vctxt).inode).nsName,
            );
        } else {
            res = xmlStreamPushAttr(
                (*sto).xpathCtxt as xmlStreamCtxtPtr,
                (*(*vctxt).inode).localName,
                (*(*vctxt).inode).nsName,
            );
        }
        if res == -(1 as i32) {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaXPathEvaluate\0" as *const u8 as *const i8,
                b"calling xmlStreamPush()\0" as *const u8 as *const i8,
            );
            return -(1 as i32);
        }
        if !(res == 0 as i32) {
            if ((*sto).history).is_null() {
                let fresh481 = &mut ((*sto).history);
                *fresh481 = xmlMalloc
                    .expect(
                        "non-null function pointer",
                    )(
                    (5 as i32 as u64)
                        .wrapping_mul(
                            ::std::mem::size_of::<i32>() as u64,
                        ),
                ) as *mut i32;
                if ((*sto).history).is_null() {
                    xmlSchemaVErrMemory(
                        0 as xmlSchemaValidCtxtPtr,
                        b"allocating the state object history\0" as *const u8
                            as *const i8,
                        0 as xmlNodePtr,
                    );
                    return -(1 as i32);
                }
                (*sto).sizeHistory = 5 as i32;
            } else if (*sto).sizeHistory <= (*sto).nbHistory {
                (*sto).sizeHistory *= 2 as i32;
                let fresh482 = &mut ((*sto).history);
                *fresh482 = xmlRealloc
                    .expect(
                        "non-null function pointer",
                    )(
                    (*sto).history as *mut libc::c_void,
                    ((*sto).sizeHistory as u64)
                        .wrapping_mul(
                            ::std::mem::size_of::<i32>() as u64,
                        ),
                ) as *mut i32;
                if ((*sto).history).is_null() {
                    xmlSchemaVErrMemory(
                        0 as xmlSchemaValidCtxtPtr,
                        b"re-allocating the state object history\0" as *const u8
                            as *const i8,
                        0 as xmlNodePtr,
                    );
                    return -(1 as i32);
                }
            }
            let fresh483 = &mut ((*sto).nbHistory);
            let fresh484 = *fresh483;
            *fresh483 = *fresh483 + 1;
            *((*sto).history).offset(fresh484 as isize) = depth;
            if (*sto).type_0 == 1 as i32 {
                let mut sel: xmlSchemaIDCSelectPtr = 0 as *mut xmlSchemaIDCSelect;
                sel = (*(*(*(*sto).matcher).aidc).def).fields;
                while !sel.is_null() {
                    if xmlSchemaIDCAddStateObject(
                        vctxt,
                        (*sto).matcher,
                        sel,
                        2 as i32,
                    ) == -(1 as i32)
                    {
                        return -(1 as i32);
                    }
                    sel = (*sel).next;
                }
            } else if (*sto).type_0 == 2 as i32 {
                if resolved == 0 as i32 {
                    if (*(*vctxt).inode).flags & (1 as i32) << 4 as i32
                        == 0 as i32
                    {
                        (*(*vctxt).inode).flags
                            |= (1 as i32) << 4 as i32;
                    }
                }
                resolved += 1;
            }
        }
        if ((*sto).next).is_null() {
            head = first;
            sto = (*vctxt).xpathStates;
        } else {
            sto = (*sto).next;
        }
    }
    return resolved;
}
unsafe extern "C" fn xmlSchemaFormatIDCKeySequence_1(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut buf: *mut *mut xmlChar,
    mut seq: *mut xmlSchemaPSVIIDCKeyPtr,
    mut count: i32,
    mut for_hash: i32,
) -> *const xmlChar {
    let mut i: i32 = 0;
    let mut res: i32 = 0;
    let mut value: *mut xmlChar = 0 as *mut xmlChar;
    *buf = xmlStrdup(b"[\0" as *const u8 as *const i8 as *mut xmlChar);
    i = 0 as i32;
    while i < count {
        *buf = xmlStrcat(
            *buf,
            b"'\0" as *const u8 as *const i8 as *mut xmlChar,
        );
        if for_hash == 0 {
            res = xmlSchemaGetCanonValueWhtspExt(
                (**seq.offset(i as isize)).val,
                xmlSchemaGetWhiteSpaceFacetValue((**seq.offset(i as isize)).type_0),
                &mut value,
            );
        } else {
            res = xmlSchemaGetCanonValueHash((**seq.offset(i as isize)).val, &mut value);
        }
        if res == 0 as i32 {
            *buf = xmlStrcat(*buf, value);
        } else {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaFormatIDCKeySequence\0" as *const u8 as *const i8,
                b"failed to compute a canonical value\0" as *const u8
                    as *const i8,
            );
            *buf = xmlStrcat(
                *buf,
                b"???\0" as *const u8 as *const i8 as *mut xmlChar,
            );
        }
        if i < count - 1 as i32 {
            *buf = xmlStrcat(
                *buf,
                b"', \0" as *const u8 as *const i8 as *mut xmlChar,
            );
        } else {
            *buf = xmlStrcat(
                *buf,
                b"'\0" as *const u8 as *const i8 as *mut xmlChar,
            );
        }
        if !value.is_null() {
            xmlFree.expect("non-null function pointer")(value as *mut libc::c_void);
            value = 0 as *mut xmlChar;
        }
        i += 1;
    }
    *buf = xmlStrcat(*buf, b"]\0" as *const u8 as *const i8 as *mut xmlChar);
    return *buf;
}
unsafe extern "C" fn xmlSchemaFormatIDCKeySequence(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut buf: *mut *mut xmlChar,
    mut seq: *mut xmlSchemaPSVIIDCKeyPtr,
    mut count: i32,
) -> *const xmlChar {
    return xmlSchemaFormatIDCKeySequence_1(vctxt, buf, seq, count, 0 as i32);
}
unsafe extern "C" fn xmlSchemaHashKeySequence(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut buf: *mut *mut xmlChar,
    mut seq: *mut xmlSchemaPSVIIDCKeyPtr,
    mut count: i32,
) -> *const xmlChar {
    return xmlSchemaFormatIDCKeySequence_1(vctxt, buf, seq, count, 1 as i32);
}
unsafe extern "C" fn xmlSchemaXPathPop(mut vctxt: xmlSchemaValidCtxtPtr) -> i32 {
    let mut sto: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    let mut res: i32 = 0;
    if ((*vctxt).xpathStates).is_null() {
        return 0 as i32;
    }
    sto = (*vctxt).xpathStates;
    loop {
        res = xmlStreamPop((*sto).xpathCtxt as xmlStreamCtxtPtr);
        if res == -(1 as i32) {
            return -(1 as i32);
        }
        sto = (*sto).next;
        if sto.is_null() {
            break;
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaXPathProcessHistory(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut depth: i32,
) -> i32 {
    let mut current_block: u64;
    let mut sto: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    let mut nextsto: xmlSchemaIDCStateObjPtr = 0 as *mut xmlSchemaIDCStateObj;
    let mut res: i32 = 0;
    let mut matchDepth: i32 = 0;
    let mut key: xmlSchemaPSVIIDCKeyPtr = 0 as xmlSchemaPSVIIDCKeyPtr;
    let mut type_0: xmlSchemaTypePtr = (*(*vctxt).inode).typeDef;
    let mut simpleType: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
    if ((*vctxt).xpathStates).is_null() {
        return 0 as i32;
    }
    sto = (*vctxt).xpathStates;
    while !sto.is_null() {
        res = xmlStreamPop((*sto).xpathCtxt as xmlStreamCtxtPtr);
        if res == -(1 as i32) {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaXPathProcessHistory\0" as *const u8 as *const i8,
                b"calling xmlStreamPop()\0" as *const u8 as *const i8,
            );
            return -(1 as i32);
        }
        if !((*sto).nbHistory == 0 as i32) {
            matchDepth = *((*sto).history)
                .offset(((*sto).nbHistory - 1 as i32) as isize);
            if matchDepth != depth {
                sto = (*sto).next;
                continue;
            } else {
                if (*sto).type_0 == 2 as i32 {
                    if (*type_0).type_0 as u32
                        == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                        || (*type_0).builtInType == XML_SCHEMAS_ANYTYPE as i32
                    {
                        if (*type_0).contentType as u32
                            == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
                            || (*type_0).contentType as u32
                                == XML_SCHEMA_CONTENT_BASIC as i32 as u32
                        {
                            simpleType = (*type_0).contentTypeDef;
                            if simpleType.is_null() {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaXPathProcessHistory\0" as *const u8
                                        as *const i8,
                                    b"field resolves to a CT with simple content but the CT is missing the ST definition\0"
                                        as *const u8 as *const i8,
                                );
                                return -(1 as i32);
                            }
                        } else {
                            simpleType = 0 as xmlSchemaTypePtr;
                        }
                    } else {
                        simpleType = type_0;
                    }
                    if simpleType.is_null() {
                        let mut str: *mut xmlChar = 0 as *mut xmlChar;
                        xmlSchemaCustomErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            XML_SCHEMAV_CVC_IDC,
                            0 as xmlNodePtr,
                            (*(*(*sto).matcher).aidc).def as xmlSchemaBasicItemPtr,
                            b"The XPath '%s' of a field of %s does evaluate to a node of non-simple type\0"
                                as *const u8 as *const i8,
                            (*(*sto).sel).xpath,
                            xmlSchemaGetIDCDesignation(
                                &mut str,
                                (*(*(*sto).matcher).aidc).def,
                            ),
                        );
                        if !str.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(str as *mut libc::c_void);
                            str = 0 as *mut xmlChar;
                        }
                        let fresh485 = &mut ((*sto).nbHistory);
                        *fresh485 -= 1;
                        current_block = 10234920862480524530;
                    } else if key.is_null() && ((*(*vctxt).inode).val).is_null() {
                        xmlSchemaCustomErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            XML_SCHEMAV_CVC_IDC,
                            0 as xmlNodePtr,
                            (*(*(*sto).matcher).aidc).def as xmlSchemaBasicItemPtr,
                            b"Warning: No precomputed value available, the value was either invalid or something strange happened\0"
                                as *const u8 as *const i8,
                            0 as *const xmlChar,
                            0 as *const xmlChar,
                        );
                        let fresh486 = &mut ((*sto).nbHistory);
                        *fresh486 -= 1;
                        current_block = 10234920862480524530;
                    } else {
                        let mut matcher: xmlSchemaIDCMatcherPtr = (*sto).matcher;
                        let mut keySeq: *mut xmlSchemaPSVIIDCKeyPtr = 0
                            as *mut xmlSchemaPSVIIDCKeyPtr;
                        let mut pos: i32 = 0;
                        let mut idx: i32 = 0;
                        pos = (*sto).depth - (*matcher).depth;
                        idx = (*(*sto).sel).index;
                        if ((*matcher).keySeqs).is_null() {
                            if pos > 9 as i32 {
                                (*matcher).sizeKeySeqs = pos * 2 as i32;
                            } else {
                                (*matcher).sizeKeySeqs = 10 as i32;
                            }
                            let fresh487 = &mut ((*matcher).keySeqs);
                            *fresh487 = xmlMalloc
                                .expect(
                                    "non-null function pointer",
                                )(
                                ((*matcher).sizeKeySeqs as u64)
                                    .wrapping_mul(
                                        ::std::mem::size_of::<*mut xmlSchemaPSVIIDCKeyPtr>()
                                            as u64,
                                    ),
                            ) as *mut *mut xmlSchemaPSVIIDCKeyPtr;
                            if ((*matcher).keySeqs).is_null() {
                                xmlSchemaVErrMemory(
                                    0 as xmlSchemaValidCtxtPtr,
                                    b"allocating an array of key-sequences\0" as *const u8
                                        as *const i8,
                                    0 as xmlNodePtr,
                                );
                                return -(1 as i32);
                            }
                            memset(
                                (*matcher).keySeqs as *mut libc::c_void,
                                0 as i32,
                                ((*matcher).sizeKeySeqs as u64)
                                    .wrapping_mul(
                                        ::std::mem::size_of::<*mut xmlSchemaPSVIIDCKeyPtr>()
                                            as u64,
                                    ),
                            );
                        } else if pos >= (*matcher).sizeKeySeqs {
                            let mut i: i32 = (*matcher).sizeKeySeqs;
                            (*matcher).sizeKeySeqs *= 2 as i32;
                            let fresh488 = &mut ((*matcher).keySeqs);
                            *fresh488 = xmlRealloc
                                .expect(
                                    "non-null function pointer",
                                )(
                                (*matcher).keySeqs as *mut libc::c_void,
                                ((*matcher).sizeKeySeqs as u64)
                                    .wrapping_mul(
                                        ::std::mem::size_of::<*mut xmlSchemaPSVIIDCKeyPtr>()
                                            as u64,
                                    ),
                            ) as *mut *mut xmlSchemaPSVIIDCKeyPtr;
                            if ((*matcher).keySeqs).is_null() {
                                xmlSchemaVErrMemory(
                                    0 as xmlSchemaValidCtxtPtr,
                                    b"reallocating an array of key-sequences\0" as *const u8
                                        as *const i8,
                                    0 as xmlNodePtr,
                                );
                                return -(1 as i32);
                            }
                            while i < (*matcher).sizeKeySeqs {
                                let fresh489 = &mut (*((*matcher).keySeqs)
                                    .offset(i as isize));
                                *fresh489 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                i += 1;
                            }
                        }
                        keySeq = *((*matcher).keySeqs).offset(pos as isize);
                        if keySeq.is_null() {
                            keySeq = xmlMalloc
                                .expect(
                                    "non-null function pointer",
                                )(
                                ((*(*(*matcher).aidc).def).nbFields as u64)
                                    .wrapping_mul(
                                        ::std::mem::size_of::<xmlSchemaPSVIIDCKeyPtr>()
                                            as u64,
                                    ),
                            ) as *mut xmlSchemaPSVIIDCKeyPtr;
                            if keySeq.is_null() {
                                xmlSchemaVErrMemory(
                                    0 as xmlSchemaValidCtxtPtr,
                                    b"allocating an IDC key-sequence\0" as *const u8
                                        as *const i8,
                                    0 as xmlNodePtr,
                                );
                                return -(1 as i32);
                            }
                            memset(
                                keySeq as *mut libc::c_void,
                                0 as i32,
                                ((*(*(*matcher).aidc).def).nbFields as u64)
                                    .wrapping_mul(
                                        ::std::mem::size_of::<xmlSchemaPSVIIDCKeyPtr>()
                                            as u64,
                                    ),
                            );
                            let fresh491 = &mut (*((*matcher).keySeqs)
                                .offset(pos as isize));
                            *fresh491 = keySeq;
                            current_block = 2291247057274820162;
                        } else if !(*keySeq.offset(idx as isize)).is_null() {
                            let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                            xmlSchemaCustomErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAV_CVC_IDC,
                                0 as xmlNodePtr,
                                (*(*matcher).aidc).def as xmlSchemaBasicItemPtr,
                                b"The XPath '%s' of a field of %s evaluates to a node-set with more than one member\0"
                                    as *const u8 as *const i8,
                                (*(*sto).sel).xpath,
                                xmlSchemaGetIDCDesignation(
                                    &mut str_0,
                                    (*(*matcher).aidc).def,
                                ),
                            );
                            if !str_0.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(str_0 as *mut libc::c_void);
                                str_0 = 0 as *mut xmlChar;
                            }
                            let fresh490 = &mut ((*sto).nbHistory);
                            *fresh490 -= 1;
                            current_block = 10234920862480524530;
                        } else {
                            current_block = 2291247057274820162;
                        }
                        match current_block {
                            10234920862480524530 => {}
                            _ => {
                                if key.is_null() {
                                    key = xmlMalloc
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        ::std::mem::size_of::<xmlSchemaPSVIIDCKey>()
                                            as u64,
                                    ) as xmlSchemaPSVIIDCKeyPtr;
                                    if key.is_null() {
                                        xmlSchemaVErrMemory(
                                            0 as xmlSchemaValidCtxtPtr,
                                            b"allocating a IDC key\0" as *const u8
                                                as *const i8,
                                            0 as xmlNodePtr,
                                        );
                                        xmlFree
                                            .expect(
                                                "non-null function pointer",
                                            )(keySeq as *mut libc::c_void);
                                        let fresh492 = &mut (*((*matcher).keySeqs)
                                            .offset(pos as isize));
                                        *fresh492 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                        return -(1 as i32);
                                    }
                                    let fresh493 = &mut ((*key).type_0);
                                    *fresh493 = simpleType;
                                    let fresh494 = &mut ((*key).val);
                                    *fresh494 = (*(*vctxt).inode).val;
                                    let fresh495 = &mut ((*(*vctxt).inode).val);
                                    *fresh495 = 0 as xmlSchemaValPtr;
                                    if xmlSchemaIDCStoreKey(vctxt, key) == -(1 as i32) {
                                        xmlSchemaIDCFreeKey(key);
                                        return -(1 as i32);
                                    }
                                }
                                let fresh496 = &mut (*keySeq.offset(idx as isize));
                                *fresh496 = key;
                                current_block = 8288085890650723895;
                            }
                        }
                    }
                } else if (*sto).type_0 == 1 as i32 {
                    let mut keySeq_0: *mut *mut xmlSchemaPSVIIDCKeyPtr = 0
                        as *mut *mut xmlSchemaPSVIIDCKeyPtr;
                    let mut ntItem: xmlSchemaPSVIIDCNodePtr = 0
                        as *mut xmlSchemaPSVIIDCNode;
                    let mut matcher_0: xmlSchemaIDCMatcherPtr = 0
                        as *mut xmlSchemaIDCMatcher;
                    let mut idc: xmlSchemaIDCPtr = 0 as *mut xmlSchemaIDC;
                    let mut targets: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
                    let mut pos_0: i32 = 0;
                    let mut i_0: i32 = 0;
                    let mut j: i32 = 0;
                    let mut nbKeys: i32 = 0;
                    matcher_0 = (*sto).matcher;
                    idc = (*(*matcher_0).aidc).def;
                    nbKeys = (*idc).nbFields;
                    pos_0 = depth - (*matcher_0).depth;
                    if ((*matcher_0).keySeqs).is_null()
                        || (*matcher_0).sizeKeySeqs <= pos_0
                    {
                        if (*idc).type_0 as u32
                            == XML_SCHEMA_TYPE_IDC_KEY as i32 as u32
                        {
                            current_block = 13895810181616587163;
                        } else {
                            current_block = 17168440009377621674;
                        }
                    } else {
                        keySeq_0 = &mut *((*matcher_0).keySeqs).offset(pos_0 as isize)
                            as *mut *mut xmlSchemaPSVIIDCKeyPtr;
                        if (*keySeq_0).is_null() {
                            if (*idc).type_0 as u32
                                == XML_SCHEMA_TYPE_IDC_KEY as i32 as u32
                            {
                                current_block = 13895810181616587163;
                            } else {
                                current_block = 17168440009377621674;
                            }
                        } else {
                            i_0 = 0 as i32;
                            loop {
                                if !(i_0 < nbKeys) {
                                    current_block = 14612007084265645573;
                                    break;
                                }
                                if (*(*keySeq_0).offset(i_0 as isize)).is_null() {
                                    if (*idc).type_0 as u32
                                        == XML_SCHEMA_TYPE_IDC_KEY as i32 as u32
                                    {
                                        current_block = 13895810181616587163;
                                        break;
                                    } else {
                                        current_block = 17168440009377621674;
                                        break;
                                    }
                                } else {
                                    i_0 += 1;
                                }
                            }
                            match current_block {
                                13895810181616587163 => {}
                                17168440009377621674 => {}
                                _ => {
                                    targets = xmlSchemaIDCAcquireTargetList(vctxt, matcher_0);
                                    if (*idc).type_0 as u32
                                        != XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
                                        && (*targets).nbItems != 0 as i32
                                    {
                                        let mut ckey: xmlSchemaPSVIIDCKeyPtr = 0
                                            as *mut xmlSchemaPSVIIDCKey;
                                        let mut bkey: xmlSchemaPSVIIDCKeyPtr = 0
                                            as *mut xmlSchemaPSVIIDCKey;
                                        let mut bkeySeq: *mut xmlSchemaPSVIIDCKeyPtr = 0
                                            as *mut xmlSchemaPSVIIDCKeyPtr;
                                        let mut e: xmlIDCHashEntryPtr = 0 as *mut xmlIDCHashEntry;
                                        res = 0 as i32;
                                        if ((*matcher_0).htab).is_null() {
                                            e = 0 as xmlIDCHashEntryPtr;
                                        } else {
                                            let mut value: *mut xmlChar = 0 as *mut xmlChar;
                                            xmlSchemaHashKeySequence(
                                                vctxt,
                                                &mut value,
                                                *keySeq_0,
                                                nbKeys,
                                            );
                                            e = xmlHashLookup((*matcher_0).htab, value)
                                                as xmlIDCHashEntryPtr;
                                            if !value.is_null() {
                                                xmlFree
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(value as *mut libc::c_void);
                                                value = 0 as *mut xmlChar;
                                            }
                                        }
                                        while !e.is_null() {
                                            bkeySeq = (*(*((*targets).items).offset((*e).index as isize)
                                                as xmlSchemaPSVIIDCNodePtr))
                                                .keys;
                                            j = 0 as i32;
                                            while j < nbKeys {
                                                ckey = *(*keySeq_0).offset(j as isize);
                                                bkey = *bkeySeq.offset(j as isize);
                                                res = xmlSchemaAreValuesEqual((*ckey).val, (*bkey).val);
                                                if res == -(1 as i32) {
                                                    return -(1 as i32)
                                                } else {
                                                    if res == 0 as i32 {
                                                        break;
                                                    }
                                                    j += 1;
                                                }
                                            }
                                            if res == 1 as i32 {
                                                break;
                                            }
                                            e = (*e).next;
                                        }
                                        if !e.is_null() {
                                            let mut str_1: *mut xmlChar = 0 as *mut xmlChar;
                                            let mut strB: *mut xmlChar = 0 as *mut xmlChar;
                                            xmlSchemaCustomErr(
                                                vctxt as xmlSchemaAbstractCtxtPtr,
                                                XML_SCHEMAV_CVC_IDC,
                                                0 as xmlNodePtr,
                                                idc as xmlSchemaBasicItemPtr,
                                                b"Duplicate key-sequence %s in %s\0" as *const u8
                                                    as *const i8,
                                                xmlSchemaFormatIDCKeySequence(
                                                    vctxt,
                                                    &mut str_1,
                                                    *keySeq_0,
                                                    nbKeys,
                                                ),
                                                xmlSchemaGetIDCDesignation(&mut strB, idc),
                                            );
                                            if !str_1.is_null() {
                                                xmlFree
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(str_1 as *mut libc::c_void);
                                                str_1 = 0 as *mut xmlChar;
                                            }
                                            if !strB.is_null() {
                                                xmlFree
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(strB as *mut libc::c_void);
                                                strB = 0 as *mut xmlChar;
                                            }
                                            current_block = 17168440009377621674;
                                        } else {
                                            current_block = 2704538829018177290;
                                        }
                                    } else {
                                        current_block = 2704538829018177290;
                                    }
                                    match current_block {
                                        17168440009377621674 => {}
                                        _ => {
                                            ntItem = xmlMalloc
                                                .expect(
                                                    "non-null function pointer",
                                                )(
                                                ::std::mem::size_of::<xmlSchemaPSVIIDCNode>()
                                                    as u64,
                                            ) as xmlSchemaPSVIIDCNodePtr;
                                            if ntItem.is_null() {
                                                xmlSchemaVErrMemory(
                                                    0 as xmlSchemaValidCtxtPtr,
                                                    b"allocating an IDC node-table item\0" as *const u8
                                                        as *const i8,
                                                    0 as xmlNodePtr,
                                                );
                                                xmlFree
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(*keySeq_0 as *mut libc::c_void);
                                                *keySeq_0 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                                return -(1 as i32);
                                            }
                                            memset(
                                                ntItem as *mut libc::c_void,
                                                0 as i32,
                                                ::std::mem::size_of::<xmlSchemaPSVIIDCNode>()
                                                    as u64,
                                            );
                                            if (*idc).type_0 as u32
                                                != XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
                                            {
                                                if xmlSchemaIDCStoreNodeTableItem(vctxt, ntItem)
                                                    == -(1 as i32)
                                                {
                                                    xmlFree
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(ntItem as *mut libc::c_void);
                                                    xmlFree
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(*keySeq_0 as *mut libc::c_void);
                                                    *keySeq_0 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                                    return -(1 as i32);
                                                }
                                                (*ntItem).nodeQNameID = -(1 as i32);
                                            } else {
                                                (*ntItem)
                                                    .nodeQNameID = xmlSchemaVAddNodeQName(
                                                    vctxt,
                                                    (*(*vctxt).inode).localName,
                                                    (*(*vctxt).inode).nsName,
                                                );
                                                if (*ntItem).nodeQNameID == -(1 as i32) {
                                                    xmlFree
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(ntItem as *mut libc::c_void);
                                                    xmlFree
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(*keySeq_0 as *mut libc::c_void);
                                                    *keySeq_0 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                                    return -(1 as i32);
                                                }
                                            }
                                            let fresh497 = &mut ((*ntItem).node);
                                            *fresh497 = (*vctxt).node;
                                            (*ntItem).nodeLine = (*(*vctxt).inode).nodeLine;
                                            let fresh498 = &mut ((*ntItem).keys);
                                            *fresh498 = *keySeq_0;
                                            *keySeq_0 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                            if xmlSchemaItemListAdd(
                                                targets,
                                                ntItem as *mut libc::c_void,
                                            ) == -(1 as i32)
                                            {
                                                if (*idc).type_0 as u32
                                                    == XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
                                                {
                                                    xmlFree
                                                        .expect(
                                                            "non-null function pointer",
                                                        )((*ntItem).keys as *mut libc::c_void);
                                                    xmlFree
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(ntItem as *mut libc::c_void);
                                                }
                                                return -(1 as i32);
                                            }
                                            if (*idc).type_0 as u32
                                                != XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
                                            {
                                                let mut value_0: *mut xmlChar = 0 as *mut xmlChar;
                                                let mut r: xmlIDCHashEntryPtr = 0 as *mut xmlIDCHashEntry;
                                                let mut e_0: xmlIDCHashEntryPtr = 0 as *mut xmlIDCHashEntry;
                                                if ((*matcher_0).htab).is_null() {
                                                    let fresh499 = &mut ((*matcher_0).htab);
                                                    *fresh499 = xmlHashCreate(4 as i32);
                                                }
                                                xmlSchemaHashKeySequence(
                                                    vctxt,
                                                    &mut value_0,
                                                    (*ntItem).keys,
                                                    nbKeys,
                                                );
                                                e_0 = xmlMalloc
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(::std::mem::size_of::<xmlIDCHashEntry>() as u64)
                                                    as xmlIDCHashEntryPtr;
                                                (*e_0).index = (*targets).nbItems - 1 as i32;
                                                r = xmlHashLookup((*matcher_0).htab, value_0)
                                                    as xmlIDCHashEntryPtr;
                                                if !r.is_null() {
                                                    let fresh500 = &mut ((*e_0).next);
                                                    *fresh500 = (*r).next;
                                                    let fresh501 = &mut ((*r).next);
                                                    *fresh501 = e_0;
                                                } else {
                                                    let fresh502 = &mut ((*e_0).next);
                                                    *fresh502 = 0 as xmlIDCHashEntryPtr;
                                                    xmlHashAddEntry(
                                                        (*matcher_0).htab,
                                                        value_0,
                                                        e_0 as *mut libc::c_void,
                                                    );
                                                }
                                                if !value_0.is_null() {
                                                    xmlFree
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(value_0 as *mut libc::c_void);
                                                    value_0 = 0 as *mut xmlChar;
                                                }
                                            }
                                            current_block = 17168440009377621674;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    match current_block {
                        13895810181616587163 => {
                            let mut str_2: *mut xmlChar = 0 as *mut xmlChar;
                            xmlSchemaCustomErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAV_CVC_IDC,
                                0 as xmlNodePtr,
                                idc as xmlSchemaBasicItemPtr,
                                b"Not all fields of %s evaluate to a node\0" as *const u8
                                    as *const i8,
                                xmlSchemaGetIDCDesignation(&mut str_2, idc),
                                0 as *const xmlChar,
                            );
                            if !str_2.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(str_2 as *mut libc::c_void);
                                str_2 = 0 as *mut xmlChar;
                            }
                        }
                        _ => {}
                    }
                    if !keySeq_0.is_null() && !(*keySeq_0).is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(*keySeq_0 as *mut libc::c_void);
                        *keySeq_0 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                    }
                    current_block = 8288085890650723895;
                } else {
                    current_block = 8288085890650723895;
                }
                match current_block {
                    10234920862480524530 => {}
                    _ => {
                        let fresh503 = &mut ((*sto).nbHistory);
                        *fresh503 -= 1;
                    }
                }
            }
        }
        if (*sto).nbHistory == 0 as i32 && (*sto).depth == depth {
            if (*vctxt).xpathStates != sto {
                xmlSchemaInternalErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaXPathProcessHistory\0" as *const u8
                        as *const i8,
                    b"The state object to be removed is not the first in the list\0"
                        as *const u8 as *const i8,
                );
            }
            nextsto = (*sto).next;
            let fresh504 = &mut ((*vctxt).xpathStates);
            *fresh504 = (*sto).next;
            let fresh505 = &mut ((*sto).next);
            *fresh505 = (*vctxt).xpathStatePool;
            let fresh506 = &mut ((*vctxt).xpathStatePool);
            *fresh506 = sto;
            sto = nextsto;
        } else {
            sto = (*sto).next;
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaIDCRegisterMatchers(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut elemDecl: xmlSchemaElementPtr,
) -> i32 {
    let mut matcher: xmlSchemaIDCMatcherPtr = 0 as *mut xmlSchemaIDCMatcher;
    let mut last: xmlSchemaIDCMatcherPtr = 0 as xmlSchemaIDCMatcherPtr;
    let mut idc: xmlSchemaIDCPtr = 0 as *mut xmlSchemaIDC;
    let mut refIdc: xmlSchemaIDCPtr = 0 as *mut xmlSchemaIDC;
    let mut aidc: xmlSchemaIDCAugPtr = 0 as *mut xmlSchemaIDCAug;
    idc = (*elemDecl).idcs as xmlSchemaIDCPtr;
    if idc.is_null() {
        return 0 as i32;
    }
    if !((*(*vctxt).inode).idcMatchers).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaIDCRegisterMatchers\0" as *const u8 as *const i8,
            b"The chain of IDC matchers is expected to be empty\0" as *const u8
                as *const i8,
        );
        return -(1 as i32);
    }
    loop {
        if (*idc).type_0 as u32
            == XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
        {
            refIdc = (*(*idc).ref_0).item as xmlSchemaIDCPtr;
            if !refIdc.is_null() {
                (*(*vctxt).inode).hasKeyrefs = 1 as i32;
                aidc = (*vctxt).aidcs;
                while !aidc.is_null() {
                    if (*aidc).def == refIdc {
                        break;
                    }
                    aidc = (*aidc).next;
                }
                if aidc.is_null() {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaIDCRegisterMatchers\0" as *const u8
                            as *const i8,
                        b"Could not find an augmented IDC item for an IDC definition\0"
                            as *const u8 as *const i8,
                    );
                    return -(1 as i32);
                }
                if (*aidc).keyrefDepth == -(1 as i32)
                    || (*vctxt).depth < (*aidc).keyrefDepth
                {
                    (*aidc).keyrefDepth = (*vctxt).depth;
                }
            }
        }
        aidc = (*vctxt).aidcs;
        while !aidc.is_null() {
            if (*aidc).def == idc {
                break;
            }
            aidc = (*aidc).next;
        }
        if aidc.is_null() {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaIDCRegisterMatchers\0" as *const u8 as *const i8,
                b"Could not find an augmented IDC item for an IDC definition\0"
                    as *const u8 as *const i8,
            );
            return -(1 as i32);
        }
        if !((*vctxt).idcMatcherCache).is_null() {
            matcher = (*vctxt).idcMatcherCache;
            let fresh507 = &mut ((*vctxt).idcMatcherCache);
            *fresh507 = (*matcher).nextCached;
            let fresh508 = &mut ((*matcher).nextCached);
            *fresh508 = 0 as xmlSchemaIDCMatcherPtr;
        } else {
            matcher = xmlMalloc
                .expect(
                    "non-null function pointer",
                )(::std::mem::size_of::<xmlSchemaIDCMatcher>() as u64)
                as xmlSchemaIDCMatcherPtr;
            if matcher.is_null() {
                xmlSchemaVErrMemory(
                    vctxt,
                    b"allocating an IDC matcher\0" as *const u8 as *const i8,
                    0 as xmlNodePtr,
                );
                return -(1 as i32);
            }
            memset(
                matcher as *mut libc::c_void,
                0 as i32,
                ::std::mem::size_of::<xmlSchemaIDCMatcher>() as u64,
            );
        }
        if last.is_null() {
            let fresh509 = &mut ((*(*vctxt).inode).idcMatchers);
            *fresh509 = matcher;
        } else {
            let fresh510 = &mut ((*last).next);
            *fresh510 = matcher;
        }
        last = matcher;
        (*matcher).type_0 = 0 as i32;
        (*matcher).depth = (*vctxt).depth;
        let fresh511 = &mut ((*matcher).aidc);
        *fresh511 = aidc;
        (*matcher).idcType = (*(*aidc).def).type_0 as i32;
        if xmlSchemaIDCAddStateObject(vctxt, matcher, (*idc).selector, 1 as i32)
            == -(1 as i32)
        {
            return -(1 as i32);
        }
        idc = (*idc).next;
        if idc.is_null() {
            break;
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaIDCFillNodeTables(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut ielem: xmlSchemaNodeInfoPtr,
) -> i32 {
    let mut current_block: u64;
    let mut bind: xmlSchemaPSVIIDCBindingPtr = 0 as *mut xmlSchemaPSVIIDCBinding;
    let mut res: i32 = 0;
    let mut i: i32 = 0;
    let mut j: i32 = 0;
    let mut k: i32 = 0;
    let mut nbTargets: i32 = 0;
    let mut nbFields: i32 = 0;
    let mut nbDupls: i32 = 0;
    let mut nbNodeTable: i32 = 0;
    let mut keys: *mut xmlSchemaPSVIIDCKeyPtr = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
    let mut ntkeys: *mut xmlSchemaPSVIIDCKeyPtr = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
    let mut targets: *mut xmlSchemaPSVIIDCNodePtr = 0 as *mut xmlSchemaPSVIIDCNodePtr;
    let mut dupls: *mut xmlSchemaPSVIIDCNodePtr = 0 as *mut xmlSchemaPSVIIDCNodePtr;
    let mut matcher: xmlSchemaIDCMatcherPtr = (*ielem).idcMatchers;
    's_17: loop {
        if matcher.is_null() {
            current_block = 14541395414537699361;
            break;
        }
        if (*(*(*matcher).aidc).def).type_0 as u32
            == XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
            || (((*matcher).targets).is_null()
                || (*(*matcher).targets).nbItems == 0 as i32)
        {
            matcher = (*matcher).next;
        } else if (*vctxt).createIDCNodeTables == 0
                && ((*(*matcher).aidc).keyrefDepth == -(1 as i32)
                    || (*(*matcher).aidc).keyrefDepth > (*vctxt).depth)
            {
            matcher = (*matcher).next;
        } else {
            bind = xmlSchemaIDCAcquireBinding(vctxt, matcher);
            if bind.is_null() {
                current_block = 17119793500333090447;
                break;
            }
            if !(((*bind).dupls).is_null()
                || (*(*bind).dupls).nbItems == 0 as i32)
            {
                dupls = (*(*bind).dupls).items as *mut xmlSchemaPSVIIDCNodePtr;
                nbDupls = (*(*bind).dupls).nbItems;
            } else {
                dupls = 0 as *mut xmlSchemaPSVIIDCNodePtr;
                nbDupls = 0 as i32;
            }
            if !((*bind).nodeTable).is_null() {
                nbNodeTable = (*bind).nbNodes;
            } else {
                nbNodeTable = 0 as i32;
            }
            if nbNodeTable == 0 as i32 && nbDupls == 0 as i32 {
                let fresh512 = &mut ((*bind).nodeTable);
                *fresh512 = (*(*matcher).targets).items as *mut xmlSchemaPSVIIDCNodePtr;
                (*bind).sizeNodes = (*(*matcher).targets).sizeItems;
                (*bind).nbNodes = (*(*matcher).targets).nbItems;
                let fresh513 = &mut ((*(*matcher).targets).items);
                *fresh513 = 0 as *mut *mut libc::c_void;
                (*(*matcher).targets).sizeItems = 0 as i32;
                (*(*matcher).targets).nbItems = 0 as i32;
                if !((*matcher).htab).is_null() {
                    xmlHashFree(
                        (*matcher).htab,
                        Some(
                            xmlFreeIDCHashEntry
                                as unsafe extern "C" fn(
                                    *mut libc::c_void,
                                    *const xmlChar,
                                ) -> (),
                        ),
                    );
                    let fresh514 = &mut ((*matcher).htab);
                    *fresh514 = 0 as xmlHashTablePtr;
                }
            } else {
                nbTargets = (*(*matcher).targets).nbItems;
                targets = (*(*matcher).targets).items as *mut xmlSchemaPSVIIDCNodePtr;
                nbFields = (*(*(*matcher).aidc).def).nbFields;
                i = 0 as i32;
                loop {
                    keys = (**targets.offset(i as isize)).keys;
                    if nbDupls != 0 {
                        j = 0 as i32;
                        loop {
                            if nbFields == 1 as i32 {
                                res = xmlSchemaAreValuesEqual(
                                    (**keys.offset(0 as i32 as isize)).val,
                                    (**((**dupls.offset(j as isize)).keys)
                                        .offset(0 as i32 as isize))
                                        .val,
                                );
                                if res == -(1 as i32) {
                                    current_block = 17119793500333090447;
                                    break 's_17;
                                }
                                if res == 1 as i32 {
                                    current_block = 7654530974828906095;
                                    break;
                                }
                            } else {
                                res = 0 as i32;
                                ntkeys = (**dupls.offset(j as isize)).keys;
                                k = 0 as i32;
                                while k < nbFields {
                                    res = xmlSchemaAreValuesEqual(
                                        (**keys.offset(k as isize)).val,
                                        (**ntkeys.offset(k as isize)).val,
                                    );
                                    if res == -(1 as i32) {
                                        current_block = 17119793500333090447;
                                        break 's_17;
                                    }
                                    if res == 0 as i32 {
                                        break;
                                    }
                                    k += 1;
                                }
                                if res == 1 as i32 {
                                    current_block = 7654530974828906095;
                                    break;
                                }
                            }
                            j += 1;
                            if !(j < nbDupls) {
                                current_block = 9241535491006583629;
                                break;
                            }
                        }
                    } else {
                        current_block = 9241535491006583629;
                    }
                    match current_block {
                        9241535491006583629 => {
                            if nbNodeTable != 0 {
                                j = 0 as i32;
                                loop {
                                    if nbFields == 1 as i32 {
                                        res = xmlSchemaAreValuesEqual(
                                            (**keys.offset(0 as i32 as isize)).val,
                                            (**((**((*bind).nodeTable).offset(j as isize)).keys)
                                                .offset(0 as i32 as isize))
                                                .val,
                                        );
                                        if res == -(1 as i32) {
                                            current_block = 17119793500333090447;
                                            break 's_17;
                                        }
                                        if res == 0 as i32 {
                                            current_block = 6985438050701255290;
                                        } else {
                                            current_block = 2168227384378665163;
                                        }
                                    } else {
                                        res = 0 as i32;
                                        ntkeys = (**((*bind).nodeTable).offset(j as isize)).keys;
                                        k = 0 as i32;
                                        loop {
                                            if !(k < nbFields) {
                                                current_block = 2168227384378665163;
                                                break;
                                            }
                                            res = xmlSchemaAreValuesEqual(
                                                (**keys.offset(k as isize)).val,
                                                (**ntkeys.offset(k as isize)).val,
                                            );
                                            if res == -(1 as i32) {
                                                current_block = 17119793500333090447;
                                                break 's_17;
                                            }
                                            if res == 0 as i32 {
                                                current_block = 6985438050701255290;
                                                break;
                                            }
                                            k += 1;
                                        }
                                    }
                                    match current_block {
                                        6985438050701255290 => {
                                            j += 1;
                                            if !(j < nbNodeTable) {
                                                current_block = 15855550149339537395;
                                                break;
                                            }
                                        }
                                        _ => {
                                            if ((*bind).dupls).is_null() {
                                                let fresh515 = &mut ((*bind).dupls);
                                                *fresh515 = xmlSchemaItemListCreate();
                                                if ((*bind).dupls).is_null() {
                                                    current_block = 17119793500333090447;
                                                    break 's_17;
                                                }
                                            }
                                            if xmlSchemaItemListAdd(
                                                (*bind).dupls,
                                                *((*bind).nodeTable).offset(j as isize) as *mut libc::c_void,
                                            ) == -(1 as i32)
                                            {
                                                current_block = 17119793500333090447;
                                                break 's_17;
                                            }
                                            let fresh516 = &mut (*((*bind).nodeTable)
                                                .offset(j as isize));
                                            *fresh516 = *((*bind).nodeTable)
                                                .offset(((*bind).nbNodes - 1 as i32) as isize);
                                            let fresh517 = &mut ((*bind).nbNodes);
                                            *fresh517 -= 1;
                                            current_block = 7654530974828906095;
                                            break;
                                        }
                                    }
                                }
                            } else {
                                current_block = 15855550149339537395;
                            }
                            match current_block {
                                7654530974828906095 => {}
                                _ => {
                                    if xmlSchemaIDCAppendNodeTableItem(
                                        bind,
                                        *targets.offset(i as isize),
                                    ) == -(1 as i32)
                                    {
                                        current_block = 17119793500333090447;
                                        break 's_17;
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                    i += 1;
                    if !(i < nbTargets) {
                        break;
                    }
                }
            }
            matcher = (*matcher).next;
        }
    }
    match current_block {
        17119793500333090447 => return -(1 as i32),
        _ => return 0 as i32,
    };
}
unsafe extern "C" fn xmlSchemaBubbleIDCNodeTables(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> i32 {
    let mut current_block: u64;
    let mut bind: xmlSchemaPSVIIDCBindingPtr = 0 as *mut xmlSchemaPSVIIDCBinding;
    let mut parTable: *mut xmlSchemaPSVIIDCBindingPtr = 0
        as *mut xmlSchemaPSVIIDCBindingPtr;
    let mut parBind: xmlSchemaPSVIIDCBindingPtr = 0 as xmlSchemaPSVIIDCBindingPtr;
    let mut node: xmlSchemaPSVIIDCNodePtr = 0 as *mut xmlSchemaPSVIIDCNode;
    let mut parNode: xmlSchemaPSVIIDCNodePtr = 0 as xmlSchemaPSVIIDCNodePtr;
    let mut dupls: *mut xmlSchemaPSVIIDCNodePtr = 0 as *mut xmlSchemaPSVIIDCNodePtr;
    let mut parNodes: *mut xmlSchemaPSVIIDCNodePtr = 0 as *mut xmlSchemaPSVIIDCNodePtr;
    let mut aidc: xmlSchemaIDCAugPtr = 0 as *mut xmlSchemaIDCAug;
    let mut i: i32 = 0;
    let mut j: i32 = 0;
    let mut k: i32 = 0;
    let mut ret: i32 = 0 as i32;
    let mut nbFields: i32 = 0;
    let mut oldNum: i32 = 0;
    let mut oldDupls: i32 = 0;
    bind = (*(*vctxt).inode).idcTable;
    if bind.is_null() {
        return 0 as i32;
    }
    parTable = &mut (**((*vctxt).elemInfos)
        .offset(((*vctxt).depth - 1 as i32) as isize))
        .idcTable;
    's_37: loop {
        if bind.is_null() {
            current_block = 7157669805658135323;
            break;
        }
        if !((*bind).nbNodes == 0 as i32
            && (((*bind).dupls).is_null()
                || (*(*bind).dupls).nbItems == 0 as i32))
        {
            if (*vctxt).createIDCNodeTables == 0 {
                aidc = (*vctxt).aidcs;
                loop {
                    if (*aidc).def == (*bind).definition {
                        if (*aidc).keyrefDepth == -(1 as i32)
                            || (*aidc).keyrefDepth >= (*vctxt).depth
                        {
                            current_block = 1182060686398305565;
                            break;
                        } else {
                            current_block = 17833034027772472439;
                            break;
                        }
                    } else {
                        aidc = (*aidc).next;
                        if aidc.is_null() {
                            current_block = 17833034027772472439;
                            break;
                        }
                    }
                }
            } else {
                current_block = 17833034027772472439;
            }
            match current_block {
                1182060686398305565 => {}
                _ => {
                    if !parTable.is_null() {
                        parBind = *parTable;
                    }
                    while !parBind.is_null() {
                        if (*parBind).definition == (*bind).definition {
                            break;
                        }
                        parBind = (*parBind).next;
                    }
                    if !parBind.is_null() {
                        oldNum = (*parBind).nbNodes;
                        if !(((*parBind).dupls).is_null()
                            || (*(*parBind).dupls).nbItems == 0 as i32)
                        {
                            oldDupls = (*(*parBind).dupls).nbItems;
                            dupls = (*(*parBind).dupls).items
                                as *mut xmlSchemaPSVIIDCNodePtr;
                        } else {
                            dupls = 0 as *mut xmlSchemaPSVIIDCNodePtr;
                            oldDupls = 0 as i32;
                        }
                        parNodes = (*parBind).nodeTable;
                        nbFields = (*(*bind).definition).nbFields;
                        i = 0 as i32;
                        while i < (*bind).nbNodes {
                            node = *((*bind).nodeTable).offset(i as isize);
                            if !node.is_null() {
                                if oldDupls != 0 {
                                    j = 0 as i32;
                                    while j < oldDupls {
                                        if nbFields == 1 as i32 {
                                            ret = xmlSchemaAreValuesEqual(
                                                (**((*node).keys).offset(0 as i32 as isize)).val,
                                                (**((**dupls.offset(j as isize)).keys)
                                                    .offset(0 as i32 as isize))
                                                    .val,
                                            );
                                            if ret == -(1 as i32) {
                                                current_block = 8730031095742260322;
                                                break 's_37;
                                            }
                                            if ret == 0 as i32 {
                                                j += 1;
                                                continue;
                                            }
                                        } else {
                                            parNode = *dupls.offset(j as isize);
                                            k = 0 as i32;
                                            while k < nbFields {
                                                ret = xmlSchemaAreValuesEqual(
                                                    (**((*node).keys).offset(k as isize)).val,
                                                    (**((*parNode).keys).offset(k as isize)).val,
                                                );
                                                if ret == -(1 as i32) {
                                                    current_block = 8730031095742260322;
                                                    break 's_37;
                                                }
                                                if ret == 0 as i32 {
                                                    break;
                                                }
                                                k += 1;
                                            }
                                        }
                                        if ret == 1 as i32 {
                                            break;
                                        }
                                        j += 1;
                                    }
                                    if j != oldDupls {
                                        current_block = 14434620278749266018;
                                    } else {
                                        current_block = 6721012065216013753;
                                    }
                                } else {
                                    current_block = 6721012065216013753;
                                }
                                match current_block {
                                    14434620278749266018 => {}
                                    _ => {
                                        if oldNum != 0 {
                                            j = 0 as i32;
                                            while j < oldNum {
                                                parNode = *parNodes.offset(j as isize);
                                                if nbFields == 1 as i32 {
                                                    ret = xmlSchemaAreValuesEqual(
                                                        (**((*node).keys).offset(0 as i32 as isize)).val,
                                                        (**((*parNode).keys).offset(0 as i32 as isize)).val,
                                                    );
                                                    if ret == -(1 as i32) {
                                                        current_block = 8730031095742260322;
                                                        break 's_37;
                                                    }
                                                    if ret == 0 as i32 {
                                                        j += 1;
                                                        continue;
                                                    }
                                                } else {
                                                    k = 0 as i32;
                                                    while k < nbFields {
                                                        ret = xmlSchemaAreValuesEqual(
                                                            (**((*node).keys).offset(k as isize)).val,
                                                            (**((*parNode).keys).offset(k as isize)).val,
                                                        );
                                                        if ret == -(1 as i32) {
                                                            current_block = 8730031095742260322;
                                                            break 's_37;
                                                        }
                                                        if ret == 0 as i32 {
                                                            break;
                                                        }
                                                        k += 1;
                                                    }
                                                }
                                                if ret == 1 as i32 {
                                                    break;
                                                }
                                                j += 1;
                                            }
                                            if j != oldNum {
                                                oldNum -= 1;
                                                let fresh518 = &mut ((*parBind).nbNodes);
                                                *fresh518 -= 1;
                                                let fresh519 = &mut (*parNodes.offset(j as isize));
                                                *fresh519 = *parNodes.offset(oldNum as isize);
                                                if (*parBind).nbNodes != oldNum {
                                                    let fresh520 = &mut (*parNodes.offset(oldNum as isize));
                                                    *fresh520 = *parNodes.offset((*parBind).nbNodes as isize);
                                                }
                                                if ((*parBind).dupls).is_null() {
                                                    let fresh521 = &mut ((*parBind).dupls);
                                                    *fresh521 = xmlSchemaItemListCreate();
                                                    if ((*parBind).dupls).is_null() {
                                                        current_block = 8730031095742260322;
                                                        break 's_37;
                                                    }
                                                }
                                                xmlSchemaItemListAdd(
                                                    (*parBind).dupls,
                                                    parNode as *mut libc::c_void,
                                                );
                                            } else {
                                                if ((*parBind).nodeTable).is_null() {
                                                    let fresh522 = &mut ((*parBind).nodeTable);
                                                    *fresh522 = xmlMalloc
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(
                                                        (10 as i32 as u64)
                                                            .wrapping_mul(
                                                                ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>()
                                                                    as u64,
                                                            ),
                                                    ) as *mut xmlSchemaPSVIIDCNodePtr;
                                                    if ((*parBind).nodeTable).is_null() {
                                                        xmlSchemaVErrMemory(
                                                            0 as xmlSchemaValidCtxtPtr,
                                                            b"allocating IDC list of node-table items\0" as *const u8
                                                                as *const i8,
                                                            0 as xmlNodePtr,
                                                        );
                                                        current_block = 8730031095742260322;
                                                        break 's_37;
                                                    } else {
                                                        (*parBind).sizeNodes = 1 as i32;
                                                    }
                                                } else if (*parBind).nbNodes >= (*parBind).sizeNodes {
                                                    (*parBind).sizeNodes *= 2 as i32;
                                                    let fresh523 = &mut ((*parBind).nodeTable);
                                                    *fresh523 = xmlRealloc
                                                        .expect(
                                                            "non-null function pointer",
                                                        )(
                                                        (*parBind).nodeTable as *mut libc::c_void,
                                                        ((*parBind).sizeNodes as u64)
                                                            .wrapping_mul(
                                                                ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>()
                                                                    as u64,
                                                            ),
                                                    ) as *mut xmlSchemaPSVIIDCNodePtr;
                                                    if ((*parBind).nodeTable).is_null() {
                                                        xmlSchemaVErrMemory(
                                                            0 as xmlSchemaValidCtxtPtr,
                                                            b"re-allocating IDC list of node-table items\0" as *const u8
                                                                as *const i8,
                                                            0 as xmlNodePtr,
                                                        );
                                                        current_block = 8730031095742260322;
                                                        break 's_37;
                                                    }
                                                }
                                                parNodes = (*parBind).nodeTable;
                                                let fresh524 = &mut ((*parBind).nbNodes);
                                                let fresh525 = *fresh524;
                                                *fresh524 = *fresh524 + 1;
                                                let fresh526 = &mut (*parNodes.offset(fresh525 as isize));
                                                *fresh526 = node;
                                            }
                                        }
                                    }
                                }
                            }
                            i += 1;
                        }
                    } else {
                        parBind = xmlSchemaIDCNewBinding((*bind).definition);
                        if parBind.is_null() {
                            current_block = 8730031095742260322;
                            break;
                        }
                        if (*bind).nbNodes != 0 as i32 {
                            if (*vctxt).psviExposeIDCNodeTables == 0 {
                                let fresh527 = &mut ((*parBind).nodeTable);
                                *fresh527 = (*bind).nodeTable;
                                let fresh528 = &mut ((*bind).nodeTable);
                                *fresh528 = 0 as *mut xmlSchemaPSVIIDCNodePtr;
                                (*parBind).sizeNodes = (*bind).sizeNodes;
                                (*bind).sizeNodes = 0 as i32;
                                (*parBind).nbNodes = (*bind).nbNodes;
                                (*bind).nbNodes = 0 as i32;
                            } else {
                                let fresh529 = &mut ((*parBind).nodeTable);
                                *fresh529 = xmlMalloc
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    ((*bind).nbNodes as u64)
                                        .wrapping_mul(
                                            ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>()
                                                as u64,
                                        ),
                                ) as *mut xmlSchemaPSVIIDCNodePtr;
                                if ((*parBind).nodeTable).is_null() {
                                    xmlSchemaVErrMemory(
                                        0 as xmlSchemaValidCtxtPtr,
                                        b"allocating an array of IDC node-table items\0"
                                            as *const u8 as *const i8,
                                        0 as xmlNodePtr,
                                    );
                                    xmlSchemaIDCFreeBinding(parBind);
                                    current_block = 8730031095742260322;
                                    break;
                                } else {
                                    (*parBind).sizeNodes = (*bind).nbNodes;
                                    (*parBind).nbNodes = (*bind).nbNodes;
                                    memcpy(
                                        (*parBind).nodeTable as *mut libc::c_void,
                                        (*bind).nodeTable as *const libc::c_void,
                                        ((*bind).nbNodes as u64)
                                            .wrapping_mul(
                                                ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>()
                                                    as u64,
                                            ),
                                    );
                                }
                            }
                        }
                        if !((*bind).dupls).is_null() {
                            if !((*parBind).dupls).is_null() {
                                xmlSchemaItemListFree((*parBind).dupls);
                            }
                            let fresh530 = &mut ((*parBind).dupls);
                            *fresh530 = (*bind).dupls;
                            let fresh531 = &mut ((*bind).dupls);
                            *fresh531 = 0 as xmlSchemaItemListPtr;
                        }
                        if !parTable.is_null() {
                            if (*parTable).is_null() {
                                *parTable = parBind;
                            } else {
                                let fresh532 = &mut ((*parBind).next);
                                *fresh532 = *parTable;
                                *parTable = parBind;
                            }
                        }
                    }
                }
            }
        }
        bind = (*bind).next;
    }
    match current_block {
        8730031095742260322 => return -(1 as i32),
        _ => return 0 as i32,
    };
}
unsafe extern "C" fn xmlSchemaCheckCVCIDCKeyRef(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> i32 {
    let mut matcher: xmlSchemaIDCMatcherPtr = 0 as *mut xmlSchemaIDCMatcher;
    let mut bind: xmlSchemaPSVIIDCBindingPtr = 0 as *mut xmlSchemaPSVIIDCBinding;
    matcher = (*(*vctxt).inode).idcMatchers;
    while !matcher.is_null() {
        if (*matcher).idcType == XML_SCHEMA_TYPE_IDC_KEYREF as i32
            && !((*matcher).targets).is_null() && (*(*matcher).targets).nbItems != 0
        {
            let mut i: i32 = 0;
            let mut j: i32 = 0;
            let mut k: i32 = 0;
            let mut res: i32 = 0;
            let mut nbFields: i32 = 0;
            let mut hasDupls: i32 = 0;
            let mut refKeys: *mut xmlSchemaPSVIIDCKeyPtr = 0
                as *mut xmlSchemaPSVIIDCKeyPtr;
            let mut keys: *mut xmlSchemaPSVIIDCKeyPtr = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
            let mut refNode: xmlSchemaPSVIIDCNodePtr = 0 as xmlSchemaPSVIIDCNodePtr;
            let mut table: xmlHashTablePtr = 0 as xmlHashTablePtr;
            nbFields = (*(*(*matcher).aidc).def).nbFields;
            bind = (*(*vctxt).inode).idcTable;
            while !bind.is_null() {
                if (*(*(*(*matcher).aidc).def).ref_0).item as xmlSchemaIDCPtr
                    == (*bind).definition
                {
                    break;
                }
                bind = (*bind).next;
            }
            hasDupls = if !bind.is_null() && !((*bind).dupls).is_null()
                && (*(*bind).dupls).nbItems != 0
            {
                1 as i32
            } else {
                0 as i32
            };
            if !bind.is_null() {
                table = xmlHashCreate((*bind).nbNodes * 2 as i32);
                j = 0 as i32;
                while j < (*bind).nbNodes {
                    let mut value: *mut xmlChar = 0 as *mut xmlChar;
                    let mut r: xmlIDCHashEntryPtr = 0 as *mut xmlIDCHashEntry;
                    let mut e: xmlIDCHashEntryPtr = 0 as *mut xmlIDCHashEntry;
                    keys = (**((*bind).nodeTable).offset(j as isize)).keys;
                    xmlSchemaHashKeySequence(vctxt, &mut value, keys, nbFields);
                    e = xmlMalloc
                        .expect(
                            "non-null function pointer",
                        )(::std::mem::size_of::<xmlIDCHashEntry>() as u64)
                        as xmlIDCHashEntryPtr;
                    (*e).index = j;
                    r = xmlHashLookup(table, value) as xmlIDCHashEntryPtr;
                    if !r.is_null() {
                        let fresh533 = &mut ((*e).next);
                        *fresh533 = (*r).next;
                        let fresh534 = &mut ((*r).next);
                        *fresh534 = e;
                    } else {
                        let fresh535 = &mut ((*e).next);
                        *fresh535 = 0 as xmlIDCHashEntryPtr;
                        xmlHashAddEntry(table, value, e as *mut libc::c_void);
                    }
                    if !value.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(value as *mut libc::c_void);
                        value = 0 as *mut xmlChar;
                    }
                    j += 1;
                }
            }
            i = 0 as i32;
            while i < (*(*matcher).targets).nbItems {
                res = 0 as i32;
                refNode = *((*(*matcher).targets).items).offset(i as isize)
                    as xmlSchemaPSVIIDCNodePtr;
                if !bind.is_null() {
                    let mut value_0: *mut xmlChar = 0 as *mut xmlChar;
                    let mut e_0: xmlIDCHashEntryPtr = 0 as *mut xmlIDCHashEntry;
                    refKeys = (*refNode).keys;
                    xmlSchemaHashKeySequence(vctxt, &mut value_0, refKeys, nbFields);
                    e_0 = xmlHashLookup(table, value_0) as xmlIDCHashEntryPtr;
                    if !value_0.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(value_0 as *mut libc::c_void);
                        value_0 = 0 as *mut xmlChar;
                    }
                    res = 0 as i32;
                    while !e_0.is_null() {
                        keys = (**((*bind).nodeTable).offset((*e_0).index as isize))
                            .keys;
                        k = 0 as i32;
                        while k < nbFields {
                            res = xmlSchemaAreValuesEqual(
                                (**keys.offset(k as isize)).val,
                                (**refKeys.offset(k as isize)).val,
                            );
                            if res == 0 as i32 {
                                break;
                            }
                            if res == -(1 as i32) {
                                return -(1 as i32);
                            }
                            k += 1;
                        }
                        if res == 1 as i32 {
                            break;
                        }
                        e_0 = (*e_0).next;
                    }
                    if res == 0 as i32 && hasDupls != 0 {
                        j = 0 as i32;
                        while j < (*(*bind).dupls).nbItems {
                            keys = (*(*((*(*bind).dupls).items).offset(j as isize)
                                as xmlSchemaPSVIIDCNodePtr))
                                .keys;
                            k = 0 as i32;
                            while k < nbFields {
                                res = xmlSchemaAreValuesEqual(
                                    (**keys.offset(k as isize)).val,
                                    (**refKeys.offset(k as isize)).val,
                                );
                                if res == 0 as i32 {
                                    break;
                                }
                                if res == -(1 as i32) {
                                    return -(1 as i32);
                                }
                                k += 1;
                            }
                            if res == 1 as i32 {
                                let mut str: *mut xmlChar = 0 as *mut xmlChar;
                                let mut strB: *mut xmlChar = 0 as *mut xmlChar;
                                xmlSchemaKeyrefErr(
                                    vctxt,
                                    XML_SCHEMAV_CVC_IDC,
                                    refNode,
                                    (*(*matcher).aidc).def as xmlSchemaTypePtr,
                                    b"More than one match found for key-sequence %s of keyref '%s'\0"
                                        as *const u8 as *const i8,
                                    xmlSchemaFormatIDCKeySequence(
                                        vctxt,
                                        &mut str,
                                        (*refNode).keys,
                                        nbFields,
                                    ),
                                    xmlSchemaGetComponentQName(
                                        &mut strB,
                                        (*(*matcher).aidc).def as *mut libc::c_void,
                                    ),
                                );
                                if !str.is_null() {
                                    xmlFree
                                        .expect(
                                            "non-null function pointer",
                                        )(str as *mut libc::c_void);
                                    str = 0 as *mut xmlChar;
                                }
                                if !strB.is_null() {
                                    xmlFree
                                        .expect(
                                            "non-null function pointer",
                                        )(strB as *mut libc::c_void);
                                    strB = 0 as *mut xmlChar;
                                }
                                break;
                            } else {
                                j += 1;
                            }
                        }
                    }
                }
                if res == 0 as i32 {
                    let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                    let mut strB_0: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaKeyrefErr(
                        vctxt,
                        XML_SCHEMAV_CVC_IDC,
                        refNode,
                        (*(*matcher).aidc).def as xmlSchemaTypePtr,
                        b"No match found for key-sequence %s of keyref '%s'\0"
                            as *const u8 as *const i8,
                        xmlSchemaFormatIDCKeySequence(
                            vctxt,
                            &mut str_0,
                            (*refNode).keys,
                            nbFields,
                        ),
                        xmlSchemaGetComponentQName(
                            &mut strB_0,
                            (*(*matcher).aidc).def as *mut libc::c_void,
                        ),
                    );
                    if !str_0.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str_0 as *mut libc::c_void);
                        str_0 = 0 as *mut xmlChar;
                    }
                    if !strB_0.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(strB_0 as *mut libc::c_void);
                        strB_0 = 0 as *mut xmlChar;
                    }
                }
                i += 1;
            }
            if !table.is_null() {
                xmlHashFree(
                    table,
                    Some(
                        xmlFreeIDCHashEntry
                            as unsafe extern "C" fn(
                                *mut libc::c_void,
                                *const xmlChar,
                            ) -> (),
                    ),
                );
            }
        }
        matcher = (*matcher).next;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaGetFreshAttrInfo(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> xmlSchemaAttrInfoPtr {
    let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    if ((*vctxt).attrInfos).is_null() {
        let fresh536 = &mut ((*vctxt).attrInfos);
        *fresh536 = xmlMalloc
            .expect(
                "non-null function pointer",
            )(::std::mem::size_of::<xmlSchemaAttrInfoPtr>() as u64)
            as *mut xmlSchemaAttrInfoPtr;
        (*vctxt).sizeAttrInfos = 1 as i32;
        if ((*vctxt).attrInfos).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"allocating attribute info list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return 0 as xmlSchemaAttrInfoPtr;
        }
    } else if (*vctxt).sizeAttrInfos <= (*vctxt).nbAttrInfos {
        let fresh537 = &mut ((*vctxt).sizeAttrInfos);
        *fresh537 += 1;
        let fresh538 = &mut ((*vctxt).attrInfos);
        *fresh538 = xmlRealloc
            .expect(
                "non-null function pointer",
            )(
            (*vctxt).attrInfos as *mut libc::c_void,
            ((*vctxt).sizeAttrInfos as u64)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaAttrInfoPtr>() as u64,
                ),
        ) as *mut xmlSchemaAttrInfoPtr;
        if ((*vctxt).attrInfos).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"re-allocating attribute info list\0" as *const u8
                    as *const i8,
                0 as xmlNodePtr,
            );
            return 0 as xmlSchemaAttrInfoPtr;
        }
    } else {
        let fresh539 = &mut ((*vctxt).nbAttrInfos);
        let fresh540 = *fresh539;
        *fresh539 = *fresh539 + 1;
        iattr = *((*vctxt).attrInfos).offset(fresh540 as isize);
        if !((*iattr).localName).is_null() {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaGetFreshAttrInfo\0" as *const u8 as *const i8,
                b"attr info not cleared\0" as *const u8 as *const i8,
            );
            return 0 as xmlSchemaAttrInfoPtr;
        }
        (*iattr).nodeType = XML_ATTRIBUTE_NODE as i32;
        return iattr;
    }
    iattr = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaAttrInfo>() as u64)
        as xmlSchemaAttrInfoPtr;
    if iattr.is_null() {
        xmlSchemaVErrMemory(
            vctxt,
            b"creating new attribute info\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaAttrInfoPtr;
    }
    memset(
        iattr as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaAttrInfo>() as u64,
    );
    (*iattr).nodeType = XML_ATTRIBUTE_NODE as i32;
    let fresh541 = &mut ((*vctxt).nbAttrInfos);
    let fresh542 = *fresh541;
    *fresh541 = *fresh541 + 1;
    let fresh543 = &mut (*((*vctxt).attrInfos).offset(fresh542 as isize));
    *fresh543 = iattr;
    return iattr;
}
unsafe extern "C" fn xmlSchemaValidatorPushAttribute(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut attrNode: xmlNodePtr,
    mut nodeLine: i32,
    mut localName: *const xmlChar,
    mut nsName: *const xmlChar,
    mut ownedNames: i32,
    mut value: *mut xmlChar,
    mut ownedValue: i32,
) -> i32 {
    let mut attr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    attr = xmlSchemaGetFreshAttrInfo(vctxt);
    if attr.is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaPushAttribute\0" as *const u8 as *const i8,
            b"calling xmlSchemaGetFreshAttrInfo()\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    let fresh544 = &mut ((*attr).node);
    *fresh544 = attrNode;
    (*attr).nodeLine = nodeLine;
    (*attr).state = 1 as i32;
    let fresh545 = &mut ((*attr).localName);
    *fresh545 = localName;
    let fresh546 = &mut ((*attr).nsName);
    *fresh546 = nsName;
    if ownedNames != 0 {
        (*attr).flags |= (1 as i32) << 0 as i32;
    }
    if !nsName.is_null() {
        if xmlStrEqual(
            localName,
            b"nil\0" as *const u8 as *const i8 as *mut xmlChar,
        ) != 0
        {
            if xmlStrEqual((*attr).nsName, xmlSchemaInstanceNs) != 0 {
                (*attr).metaType = 2 as i32;
            }
        } else if xmlStrEqual(
                localName,
                b"type\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
            if xmlStrEqual((*attr).nsName, xmlSchemaInstanceNs) != 0 {
                (*attr).metaType = 1 as i32;
            }
        } else if xmlStrEqual(
                localName,
                b"schemaLocation\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
            if xmlStrEqual((*attr).nsName, xmlSchemaInstanceNs) != 0 {
                (*attr).metaType = 3 as i32;
            }
        } else if xmlStrEqual(
                localName,
                b"noNamespaceSchemaLocation\0" as *const u8 as *const i8
                    as *mut xmlChar,
            ) != 0
            {
            if xmlStrEqual((*attr).nsName, xmlSchemaInstanceNs) != 0 {
                (*attr).metaType = 4 as i32;
            }
        } else if xmlStrEqual((*attr).nsName, xmlNamespaceNs) != 0 {
            (*attr).metaType = 5 as i32;
        }
    }
    let fresh547 = &mut ((*attr).value);
    *fresh547 = value;
    if ownedValue != 0 {
        (*attr).flags |= (1 as i32) << 1 as i32;
    }
    if (*attr).metaType != 0 as i32 {
        (*attr).state = 17 as i32;
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaClearElemInfo(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut ielem: xmlSchemaNodeInfoPtr,
) {
    (*ielem).hasKeyrefs = 0 as i32;
    (*ielem).appliedXPath = 0 as i32;
    if (*ielem).flags & (1 as i32) << 0 as i32 != 0 {
        if !((*ielem).localName).is_null() {
            xmlFree
                .expect(
                    "non-null function pointer",
                )((*ielem).localName as *mut xmlChar as *mut libc::c_void);
            let fresh548 = &mut ((*ielem).localName);
            *fresh548 = 0 as *const xmlChar;
        }
        if !((*ielem).nsName).is_null() {
            xmlFree
                .expect(
                    "non-null function pointer",
                )((*ielem).nsName as *mut xmlChar as *mut libc::c_void);
            let fresh549 = &mut ((*ielem).nsName);
            *fresh549 = 0 as *const xmlChar;
        }
    } else {
        let fresh550 = &mut ((*ielem).localName);
        *fresh550 = 0 as *const xmlChar;
        let fresh551 = &mut ((*ielem).nsName);
        *fresh551 = 0 as *const xmlChar;
    }
    if (*ielem).flags & (1 as i32) << 1 as i32 != 0 {
        if !((*ielem).value).is_null() {
            xmlFree
                .expect(
                    "non-null function pointer",
                )((*ielem).value as *mut xmlChar as *mut libc::c_void);
            let fresh552 = &mut ((*ielem).value);
            *fresh552 = 0 as *const xmlChar;
        }
    } else {
        let fresh553 = &mut ((*ielem).value);
        *fresh553 = 0 as *const xmlChar;
    }
    if !((*ielem).val).is_null() {
        xmlSchemaFreeValue((*ielem).val);
        let fresh554 = &mut ((*ielem).val);
        *fresh554 = 0 as xmlSchemaValPtr;
    }
    if !((*ielem).idcMatchers).is_null() {
        xmlSchemaIDCReleaseMatcherList(vctxt, (*ielem).idcMatchers);
        let fresh555 = &mut ((*ielem).idcMatchers);
        *fresh555 = 0 as xmlSchemaIDCMatcherPtr;
    }
    if !((*ielem).idcTable).is_null() {
        xmlSchemaIDCFreeIDCTable((*ielem).idcTable);
        let fresh556 = &mut ((*ielem).idcTable);
        *fresh556 = 0 as xmlSchemaPSVIIDCBindingPtr;
    }
    if !((*ielem).regexCtxt).is_null() {
        xmlRegFreeExecCtxt((*ielem).regexCtxt);
        let fresh557 = &mut ((*ielem).regexCtxt);
        *fresh557 = 0 as xmlRegExecCtxtPtr;
    }
    if !((*ielem).nsBindings).is_null() {
        xmlFree
            .expect(
                "non-null function pointer",
            )((*ielem).nsBindings as *mut *mut xmlChar as *mut libc::c_void);
        let fresh558 = &mut ((*ielem).nsBindings);
        *fresh558 = 0 as *mut *const xmlChar;
        (*ielem).nbNsBindings = 0 as i32;
        (*ielem).sizeNsBindings = 0 as i32;
    }
}
unsafe extern "C" fn xmlSchemaGetFreshElemInfo(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> xmlSchemaNodeInfoPtr {
    let mut info: xmlSchemaNodeInfoPtr = 0 as xmlSchemaNodeInfoPtr;
    if (*vctxt).depth > (*vctxt).sizeElemInfos {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaGetFreshElemInfo\0" as *const u8 as *const i8,
            b"inconsistent depth encountered\0" as *const u8 as *const i8,
        );
        return 0 as xmlSchemaNodeInfoPtr;
    }
    if ((*vctxt).elemInfos).is_null() {
        let fresh559 = &mut ((*vctxt).elemInfos);
        *fresh559 = xmlMalloc
            .expect(
                "non-null function pointer",
            )(
            (10 as i32 as u64)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaNodeInfoPtr>() as u64,
                ),
        ) as *mut xmlSchemaNodeInfoPtr;
        if ((*vctxt).elemInfos).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"allocating the element info array\0" as *const u8
                    as *const i8,
                0 as xmlNodePtr,
            );
            return 0 as xmlSchemaNodeInfoPtr;
        }
        memset(
            (*vctxt).elemInfos as *mut libc::c_void,
            0 as i32,
            (10 as i32 as u64)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaNodeInfoPtr>() as u64,
                ),
        );
        (*vctxt).sizeElemInfos = 10 as i32;
    } else if (*vctxt).sizeElemInfos <= (*vctxt).depth {
        let mut i: i32 = (*vctxt).sizeElemInfos;
        (*vctxt).sizeElemInfos *= 2 as i32;
        let fresh560 = &mut ((*vctxt).elemInfos);
        *fresh560 = xmlRealloc
            .expect(
                "non-null function pointer",
            )(
            (*vctxt).elemInfos as *mut libc::c_void,
            ((*vctxt).sizeElemInfos as u64)
                .wrapping_mul(
                    ::std::mem::size_of::<xmlSchemaNodeInfoPtr>() as u64,
                ),
        ) as *mut xmlSchemaNodeInfoPtr;
        if ((*vctxt).elemInfos).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"re-allocating the element info array\0" as *const u8
                    as *const i8,
                0 as xmlNodePtr,
            );
            return 0 as xmlSchemaNodeInfoPtr;
        }
        while i < (*vctxt).sizeElemInfos {
            let fresh561 = &mut (*((*vctxt).elemInfos).offset(i as isize));
            *fresh561 = 0 as xmlSchemaNodeInfoPtr;
            i += 1;
        }
    } else {
        info = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
    }
    if info.is_null() {
        info = xmlMalloc
            .expect(
                "non-null function pointer",
            )(::std::mem::size_of::<xmlSchemaNodeInfo>() as u64)
            as xmlSchemaNodeInfoPtr;
        if info.is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"allocating an element info\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return 0 as xmlSchemaNodeInfoPtr;
        }
        let fresh562 = &mut (*((*vctxt).elemInfos).offset((*vctxt).depth as isize));
        *fresh562 = info;
    } else if !((*info).localName).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaGetFreshElemInfo\0" as *const u8 as *const i8,
            b"elem info has not been cleared\0" as *const u8 as *const i8,
        );
        return 0 as xmlSchemaNodeInfoPtr;
    }
    memset(
        info as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaNodeInfo>() as u64,
    );
    (*info).nodeType = XML_ELEMENT_NODE as i32;
    (*info).depth = (*vctxt).depth;
    return info;
}
unsafe extern "C" fn xmlSchemaValidateFacets(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut node: xmlNodePtr,
    mut type_0: xmlSchemaTypePtr,
    mut valType: xmlSchemaValType,
    mut value: *const xmlChar,
    mut val: xmlSchemaValPtr,
    mut length: u64,
    mut fireErrors: i32,
) -> i32 {
    let mut current_block: u64;
    let mut ret: i32 = 0;
    let mut error: i32 = 0 as i32;
    let mut found: i32 = 0;
    let mut tmpType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut facetLink: xmlSchemaFacetLinkPtr = 0 as *mut xmlSchemaFacetLink;
    let mut facet: xmlSchemaFacetPtr = 0 as *mut xmlSchemaFacet;
    let mut len: u64 = 0 as i32 as u64;
    let mut ws: xmlSchemaWhitespaceValueType = XML_SCHEMA_WHITESPACE_UNKNOWN;
    if (*type_0).type_0 as u32
        == XML_SCHEMA_TYPE_BASIC as i32 as u32
    {
        return 0 as i32;
    }
    if !((*type_0).facetSet).is_null() {
        if (*type_0).flags & (1 as i32) << 8 as i32 == 0 {
            if (*type_0).flags & (1 as i32) << 6 as i32 != 0 {
                current_block = 13331728595066369563;
            } else {
                current_block = 1410358537824353994;
            }
        } else {
            tmpType = xmlSchemaGetPrimitiveType(type_0);
            if (*tmpType).builtInType == XML_SCHEMAS_STRING as i32
                || (*tmpType).type_0 as u32
                    == XML_SCHEMA_TYPE_BASIC as i32 as u32
                    && (*tmpType).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as i32
            {
                ws = xmlSchemaGetWhiteSpaceFacetValue(type_0);
            } else {
                ws = XML_SCHEMA_WHITESPACE_COLLAPSE;
            }
            if !val.is_null() {
                valType = xmlSchemaGetValType(val);
            }
            ret = 0 as i32;
            let mut current_block_25: u64;
            facetLink = (*type_0).facetSet;
            while !facetLink.is_null() {
                match (*(*facetLink).facet).type_0 as u32 {
                    1008 | 1006 | 1007 => {
                        current_block_25 = 15652330335145281839;
                    }
                    1009 | 1011 | 1010 => {
                        ret = xmlSchemaValidateLengthFacetWhtsp(
                            (*facetLink).facet,
                            valType,
                            value,
                            val,
                            &mut len,
                            ws,
                        );
                        current_block_25 = 2719512138335094285;
                    }
                    _ => {
                        ret = xmlSchemaValidateFacetWhtsp(
                            (*facetLink).facet,
                            ws,
                            valType,
                            value,
                            val,
                            ws,
                        );
                        current_block_25 = 2719512138335094285;
                    }
                }
                match current_block_25 {
                    2719512138335094285 => {
                        if ret < 0 as i32 {
                            xmlSchemaInternalErr(
                                actxt,
                                b"xmlSchemaValidateFacets\0" as *const u8
                                    as *const i8,
                                b"validating against a atomic type facet\0" as *const u8
                                    as *const i8,
                            );
                            return -(1 as i32);
                        } else {
                            if ret > 0 as i32 {
                                if fireErrors != 0 {
                                    xmlSchemaFacetErr(
                                        actxt,
                                        ret as xmlParserErrors,
                                        node,
                                        value,
                                        len,
                                        type_0,
                                        (*facetLink).facet,
                                        0 as *const i8,
                                        0 as *const xmlChar,
                                        0 as *const xmlChar,
                                    );
                                } else {
                                    return ret
                                }
                                if error == 0 as i32 {
                                    error = ret;
                                }
                            }
                        }
                        ret = 0 as i32;
                    }
                    _ => {}
                }
                facetLink = (*facetLink).next;
            }
            current_block = 13331728595066369563;
        }
        match current_block {
            1410358537824353994 => {}
            _ => {
                if !((*type_0).flags & (1 as i32) << 6 as i32 == 0) {
                    ret = 0 as i32;
                    facetLink = (*type_0).facetSet;
                    while !facetLink.is_null() {
                        match (*(*facetLink).facet).type_0 as u32 {
                            1009 | 1011 | 1010 => {
                                ret = xmlSchemaValidateListSimpleTypeFacet(
                                    (*facetLink).facet,
                                    value,
                                    length,
                                    0 as *mut u64,
                                );
                                if ret < 0 as i32 {
                                    xmlSchemaInternalErr(
                                        actxt,
                                        b"xmlSchemaValidateFacets\0" as *const u8
                                            as *const i8,
                                        b"validating against a list type facet\0" as *const u8
                                            as *const i8,
                                    );
                                    return -(1 as i32);
                                } else {
                                    if ret > 0 as i32 {
                                        if fireErrors != 0 {
                                            xmlSchemaFacetErr(
                                                actxt,
                                                ret as xmlParserErrors,
                                                node,
                                                value,
                                                length,
                                                type_0,
                                                (*facetLink).facet,
                                                0 as *const i8,
                                                0 as *const xmlChar,
                                                0 as *const xmlChar,
                                            );
                                        } else {
                                            return ret
                                        }
                                        if error == 0 as i32 {
                                            error = ret;
                                        }
                                    }
                                }
                                ret = 0 as i32;
                            }
                            _ => {}
                        }
                        facetLink = (*facetLink).next;
                    }
                }
            }
        }
    }
    found = 0 as i32;
    ret = 0 as i32;
    tmpType = type_0;
    loop {
        facet = (*tmpType).facets;
        while !facet.is_null() {
            if !((*facet).type_0 as u32
                != XML_SCHEMA_FACET_ENUMERATION as i32 as u32)
            {
                found = 1 as i32;
                ret = xmlSchemaAreValuesEqual((*facet).val, val);
                if ret == 1 as i32 {
                    break;
                }
                if ret < 0 as i32 {
                    xmlSchemaInternalErr(
                        actxt,
                        b"xmlSchemaValidateFacets\0" as *const u8 as *const i8,
                        b"validating against an enumeration facet\0" as *const u8
                            as *const i8,
                    );
                    return -(1 as i32);
                }
            }
            facet = (*facet).next;
        }
        if ret != 0 as i32 {
            break;
        }
        if found != 0 {
            break;
        }
        tmpType = (*tmpType).baseType;
        if !(!tmpType.is_null()
            && (*tmpType).type_0 as u32
                != XML_SCHEMA_TYPE_BASIC as i32 as u32)
        {
            break;
        }
    }
    if found != 0 && ret == 0 as i32 {
        ret = XML_SCHEMAV_CVC_ENUMERATION_VALID as i32;
        if fireErrors != 0 {
            xmlSchemaFacetErr(
                actxt,
                ret as xmlParserErrors,
                node,
                value,
                0 as i32 as u64,
                type_0,
                0 as xmlSchemaFacetPtr,
                0 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
        } else {
            return ret
        }
        if error == 0 as i32 {
            error = ret;
        }
    }
    tmpType = type_0;
    facet = 0 as xmlSchemaFacetPtr;
    loop {
        found = 0 as i32;
        facetLink = (*tmpType).facetSet;
        while !facetLink.is_null() {
            if !((*(*facetLink).facet).type_0 as u32
                != XML_SCHEMA_FACET_PATTERN as i32 as u32)
            {
                found = 1 as i32;
                ret = xmlRegexpExec((*(*facetLink).facet).regexp, value);
                if ret == 1 as i32 {
                    break;
                }
                if ret < 0 as i32 {
                    xmlSchemaInternalErr(
                        actxt,
                        b"xmlSchemaValidateFacets\0" as *const u8 as *const i8,
                        b"validating against a pattern facet\0" as *const u8
                            as *const i8,
                    );
                    return -(1 as i32);
                } else {
                    facet = (*facetLink).facet;
                }
            }
            facetLink = (*facetLink).next;
        }
        if found != 0 && ret != 1 as i32 {
            ret = XML_SCHEMAV_CVC_PATTERN_VALID as i32;
            if fireErrors != 0 {
                xmlSchemaFacetErr(
                    actxt,
                    ret as xmlParserErrors,
                    node,
                    value,
                    0 as i32 as u64,
                    type_0,
                    facet,
                    0 as *const i8,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
            } else {
                return ret
            }
            if error == 0 as i32 {
                error = ret;
            }
            break;
        } else {
            tmpType = (*tmpType).baseType;
            if !(!tmpType.is_null()
                && (*tmpType).type_0 as u32
                    != XML_SCHEMA_TYPE_BASIC as i32 as u32)
            {
                break;
            }
        }
    }
    return error;
}
unsafe extern "C" fn xmlSchemaNormalizeValue(
    mut type_0: xmlSchemaTypePtr,
    mut value: *const xmlChar,
) -> *mut xmlChar {
    match xmlSchemaGetWhiteSpaceFacetValue(type_0) as u32 {
        3 => return xmlSchemaCollapseString(value),
        2 => return xmlSchemaWhiteSpaceReplace(value),
        _ => return 0 as *mut xmlChar,
    };
}
unsafe extern "C" fn xmlSchemaValidateQName(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut value: *const xmlChar,
    mut val: *mut xmlSchemaValPtr,
    mut valNeeded: i32,
) -> i32 {
    let mut ret: i32 = 0;
    let mut stripped: *mut xmlChar = 0 as *mut xmlChar;
    let mut nsName: *const xmlChar = 0 as *const xmlChar;
    let mut local: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    ret = xmlValidateQName(value, 1 as i32);
    if ret != 0 as i32 {
        if ret == -(1 as i32) {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaValidateQName\0" as *const u8 as *const i8,
                b"calling xmlValidateQName()\0" as *const u8 as *const i8,
            );
            return -(1 as i32);
        }
        return XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as i32;
    }
    stripped = xmlSchemaCollapseString(value);
    local = xmlSplitQName2(
        if !stripped.is_null() { stripped as *const xmlChar } else { value },
        &mut prefix,
    );
    xmlFree.expect("non-null function pointer")(stripped as *mut libc::c_void);
    if local.is_null() {
        local = xmlStrdup(value);
    }
    nsName = xmlSchemaLookupNamespace(vctxt, prefix);
    if !prefix.is_null() {
        xmlFree.expect("non-null function pointer")(prefix as *mut libc::c_void);
        if nsName.is_null() {
            ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as i32;
            xmlSchemaCustomErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                ret as xmlParserErrors,
                0 as xmlNodePtr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME) as xmlSchemaBasicItemPtr,
                b"The QName value '%s' has no corresponding namespace declaration in scope\0"
                    as *const u8 as *const i8,
                value,
                0 as *const xmlChar,
            );
            if !local.is_null() {
                xmlFree.expect("non-null function pointer")(local as *mut libc::c_void);
            }
            return ret;
        }
    }
    if valNeeded != 0 && !val.is_null() {
        if !nsName.is_null() {
            *val = xmlSchemaNewQNameValue(xmlStrdup(nsName), local);
        } else {
            *val = xmlSchemaNewQNameValue(0 as *const xmlChar, local);
        }
    } else {
        xmlFree.expect("non-null function pointer")(local as *mut libc::c_void);
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaVCheckCVCSimpleType(
    mut actxt: xmlSchemaAbstractCtxtPtr,
    mut node: xmlNodePtr,
    mut type_0: xmlSchemaTypePtr,
    mut value: *const xmlChar,
    mut retVal: *mut xmlSchemaValPtr,
    mut fireErrors: i32,
    mut normalize: i32,
    mut isNormalized: i32,
) -> i32 {
    let mut current_block: u64;
    let mut ret: i32 = 0 as i32;
    let mut valNeeded: i32 = if !retVal.is_null() {
        1 as i32
    } else {
        0 as i32
    };
    let mut val: xmlSchemaValPtr = 0 as xmlSchemaValPtr;
    let mut normValue: *mut xmlChar = 0 as *mut xmlChar;
    if !retVal.is_null() && !(*retVal).is_null() {
        xmlSchemaFreeValue(*retVal);
        *retVal = 0 as xmlSchemaValPtr;
    }
    if valNeeded == 0 && (*type_0).flags & (1 as i32) << 21 as i32 != 0 {
        valNeeded = 1 as i32;
    }
    if value.is_null() {
        value = b"\0" as *const u8 as *const i8 as *mut xmlChar;
    }
    if (*type_0).type_0 as u32
        == XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (*type_0).builtInType == XML_SCHEMAS_ANYSIMPLETYPE as i32
        || (*type_0).flags & (1 as i32) << 8 as i32 != 0
    {
        let mut biType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        if isNormalized == 0
            && (normalize != 0
                || (*type_0).flags & (1 as i32) << 28 as i32 != 0)
        {
            normValue = xmlSchemaNormalizeValue(type_0, value);
            if !normValue.is_null() {
                value = normValue;
            }
            isNormalized = 1 as i32;
        }
        if (*type_0).type_0 as u32
            != XML_SCHEMA_TYPE_BASIC as i32 as u32
        {
            biType = (*type_0).baseType;
            while !biType.is_null()
                && (*biType).type_0 as u32
                    != XML_SCHEMA_TYPE_BASIC as i32 as u32
            {
                biType = (*biType).baseType;
            }
            if biType.is_null() {
                xmlSchemaInternalErr(
                    actxt,
                    b"xmlSchemaVCheckCVCSimpleType\0" as *const u8
                        as *const i8,
                    b"could not get the built-in type\0" as *const u8
                        as *const i8,
                );
                current_block = 10711413107550680511;
            } else {
                current_block = 9828876828309294594;
            }
        } else {
            biType = type_0;
            current_block = 9828876828309294594;
        }
        match current_block {
            10711413107550680511 => {}
            _ => {
                if (*actxt).type_0 == 2 as i32 {
                    match (*biType).builtInType {
                        28 => {
                            ret = xmlSchemaValidateNotation(
                                actxt as xmlSchemaValidCtxtPtr,
                                (*(actxt as xmlSchemaValidCtxtPtr)).schema,
                                0 as xmlNodePtr,
                                value,
                                &mut val,
                                valNeeded,
                            );
                        }
                        21 => {
                            ret = xmlSchemaValidateQName(
                                actxt as xmlSchemaValidCtxtPtr,
                                value,
                                &mut val,
                                valNeeded,
                            );
                        }
                        _ => {
                            if valNeeded != 0 {
                                ret = xmlSchemaValPredefTypeNodeNoNorm(
                                    biType,
                                    value,
                                    &mut val,
                                    node,
                                );
                            } else {
                                ret = xmlSchemaValPredefTypeNodeNoNorm(
                                    biType,
                                    value,
                                    0 as *mut xmlSchemaValPtr,
                                    node,
                                );
                            }
                        }
                    }
                    current_block = 16799951812150840583;
                } else if (*actxt).type_0 == 1 as i32 {
                    match (*biType).builtInType {
                        28 => {
                            ret = xmlSchemaValidateNotation(
                                0 as xmlSchemaValidCtxtPtr,
                                (*(actxt as xmlSchemaParserCtxtPtr)).schema,
                                node,
                                value,
                                &mut val,
                                valNeeded,
                            );
                        }
                        _ => {
                            if valNeeded != 0 {
                                ret = xmlSchemaValPredefTypeNodeNoNorm(
                                    biType,
                                    value,
                                    &mut val,
                                    node,
                                );
                            } else {
                                ret = xmlSchemaValPredefTypeNodeNoNorm(
                                    biType,
                                    value,
                                    0 as *mut xmlSchemaValPtr,
                                    node,
                                );
                            }
                        }
                    }
                    current_block = 16799951812150840583;
                } else {
                    (*__xmlGenericError())
                        .expect(
                            "non-null function pointer",
                        )(
                        *__xmlGenericErrorContext(),
                        b"Unimplemented block at %s:%d\n\0" as *const u8
                            as *const i8,
                        b"xmlschemas.c\0" as *const u8 as *const i8,
                        24827 as i32,
                    );
                    current_block = 10711413107550680511;
                }
                match current_block {
                    10711413107550680511 => {}
                    _ => {
                        if ret != 0 as i32 {
                            if ret < 0 as i32 {
                                xmlSchemaInternalErr(
                                    actxt,
                                    b"xmlSchemaVCheckCVCSimpleType\0" as *const u8
                                        as *const i8,
                                    b"validating against a built-in type\0" as *const u8
                                        as *const i8,
                                );
                                current_block = 10711413107550680511;
                            } else {
                                if (*type_0).flags & (1 as i32) << 6 as i32
                                    != 0
                                {
                                    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as i32;
                                } else {
                                    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as i32;
                                }
                                current_block = 13826291924415791078;
                            }
                        } else {
                            current_block = 13826291924415791078;
                        }
                        match current_block {
                            10711413107550680511 => {}
                            _ => {
                                if ret == 0 as i32
                                    && (*type_0).flags & (1 as i32) << 27 as i32
                                        != 0
                                {
                                    ret = xmlSchemaValidateFacets(
                                        actxt,
                                        node,
                                        type_0,
                                        (*biType).builtInType as xmlSchemaValType,
                                        value,
                                        val,
                                        0 as i32 as u64,
                                        fireErrors,
                                    );
                                    if ret != 0 as i32 {
                                        if ret < 0 as i32 {
                                            xmlSchemaInternalErr(
                                                actxt,
                                                b"xmlSchemaVCheckCVCSimpleType\0" as *const u8
                                                    as *const i8,
                                                b"validating facets of atomic simple type\0" as *const u8
                                                    as *const i8,
                                            );
                                            current_block = 10711413107550680511;
                                        } else {
                                            if (*type_0).flags & (1 as i32) << 6 as i32
                                                != 0
                                            {
                                                ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as i32;
                                            } else {
                                                ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as i32;
                                            }
                                            current_block = 8953117030348968745;
                                        }
                                    } else {
                                        current_block = 8953117030348968745;
                                    }
                                } else {
                                    if fireErrors != 0 && ret > 0 as i32 {
                                        xmlSchemaSimpleTypeErr(
                                            actxt,
                                            ret as xmlParserErrors,
                                            node,
                                            value,
                                            type_0,
                                            1 as i32,
                                        );
                                    }
                                    current_block = 8953117030348968745;
                                }
                            }
                        }
                    }
                }
            }
        }
    } else if (*type_0).flags & (1 as i32) << 6 as i32 != 0 {
        let mut itemType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
        let mut cur: *const xmlChar = 0 as *const xmlChar;
        let mut end: *const xmlChar = 0 as *const xmlChar;
        let mut tmpValue: *mut xmlChar = 0 as *mut xmlChar;
        let mut len: u64 = 0 as i32 as u64;
        let mut prevVal: xmlSchemaValPtr = 0 as xmlSchemaValPtr;
        let mut curVal: xmlSchemaValPtr = 0 as xmlSchemaValPtr;
        if isNormalized == 0
            && (normalize != 0
                || (*type_0).flags & (1 as i32) << 28 as i32 != 0)
        {
            normValue = xmlSchemaNormalizeValue(type_0, value);
            if !normValue.is_null() {
                value = normValue;
            }
            isNormalized = 1 as i32;
        }
        itemType = (*type_0).subtypes;
        cur = value;
        loop {
            while *cur as i32 == 0x20 as i32
                || 0x9 as i32 <= *cur as i32
                    && *cur as i32 <= 0xa as i32
                || *cur as i32 == 0xd as i32
            {
                cur = cur.offset(1);
            }
            end = cur;
            while *end as i32 != 0 as i32
                && !(*end as i32 == 0x20 as i32
                    || 0x9 as i32 <= *end as i32
                        && *end as i32 <= 0xa as i32
                    || *end as i32 == 0xd as i32)
            {
                end = end.offset(1);
            }
            if end == cur {
                current_block = 4804377075063615140;
                break;
            }
            tmpValue = xmlStrndup(
                cur,
                end.offset_from(cur) as i64 as i32,
            );
            len = len.wrapping_add(1);
            if valNeeded != 0 {
                ret = xmlSchemaVCheckCVCSimpleType(
                    actxt,
                    node,
                    itemType,
                    tmpValue,
                    &mut curVal,
                    fireErrors,
                    0 as i32,
                    1 as i32,
                );
            } else {
                ret = xmlSchemaVCheckCVCSimpleType(
                    actxt,
                    node,
                    itemType,
                    tmpValue,
                    0 as *mut xmlSchemaValPtr,
                    fireErrors,
                    0 as i32,
                    1 as i32,
                );
            }
            if !tmpValue.is_null() {
                xmlFree
                    .expect("non-null function pointer")(tmpValue as *mut libc::c_void);
                tmpValue = 0 as *mut xmlChar;
            }
            if !curVal.is_null() {
                if val.is_null() {
                    val = curVal;
                } else {
                    xmlSchemaValueAppend(prevVal, curVal);
                }
                prevVal = curVal;
                curVal = 0 as xmlSchemaValPtr;
            }
            if ret != 0 as i32 {
                if ret < 0 as i32 {
                    xmlSchemaInternalErr(
                        actxt,
                        b"xmlSchemaVCheckCVCSimpleType\0" as *const u8
                            as *const i8,
                        b"validating an item of list simple type\0" as *const u8
                            as *const i8,
                    );
                    current_block = 10711413107550680511;
                    break;
                } else {
                    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as i32;
                    current_block = 4804377075063615140;
                    break;
                }
            } else {
                cur = end;
                if !(*cur as i32 != 0 as i32) {
                    current_block = 4804377075063615140;
                    break;
                }
            }
        }
        match current_block {
            10711413107550680511 => {}
            _ => {
                if !tmpValue.is_null() {
                    xmlFree
                        .expect(
                            "non-null function pointer",
                        )(tmpValue as *mut libc::c_void);
                    tmpValue = 0 as *mut xmlChar;
                }
                if ret == 0 as i32
                    && (*type_0).flags & (1 as i32) << 27 as i32 != 0
                {
                    ret = xmlSchemaValidateFacets(
                        actxt,
                        node,
                        type_0,
                        XML_SCHEMAS_UNKNOWN,
                        value,
                        val,
                        len,
                        fireErrors,
                    );
                    if ret != 0 as i32 {
                        if ret < 0 as i32 {
                            xmlSchemaInternalErr(
                                actxt,
                                b"xmlSchemaVCheckCVCSimpleType\0" as *const u8
                                    as *const i8,
                                b"validating facets of list simple type\0" as *const u8
                                    as *const i8,
                            );
                            current_block = 10711413107550680511;
                        } else {
                            ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as i32;
                            current_block = 8533724845731836612;
                        }
                    } else {
                        current_block = 8533724845731836612;
                    }
                } else {
                    current_block = 8533724845731836612;
                }
                match current_block {
                    10711413107550680511 => {}
                    _ => {
                        if fireErrors != 0 && ret > 0 as i32 {
                            normalize = 1 as i32;
                            if isNormalized == 0
                                && (normalize != 0
                                    || (*type_0).flags & (1 as i32) << 28 as i32
                                        != 0)
                            {
                                normValue = xmlSchemaNormalizeValue(type_0, value);
                                if !normValue.is_null() {
                                    value = normValue;
                                }
                                isNormalized = 1 as i32;
                            }
                            xmlSchemaSimpleTypeErr(
                                actxt,
                                ret as xmlParserErrors,
                                node,
                                value,
                                type_0,
                                1 as i32,
                            );
                        }
                        current_block = 8953117030348968745;
                    }
                }
            }
        }
    } else if (*type_0).flags & (1 as i32) << 7 as i32 != 0 {
        let mut memberLink: xmlSchemaTypeLinkPtr = 0 as *mut xmlSchemaTypeLink;
        memberLink = xmlSchemaGetUnionSimpleTypeMemberTypes(type_0);
        if memberLink.is_null() {
            xmlSchemaInternalErr(
                actxt,
                b"xmlSchemaVCheckCVCSimpleType\0" as *const u8 as *const i8,
                b"union simple type has no member types\0" as *const u8
                    as *const i8,
            );
            current_block = 10711413107550680511;
        } else {
            while !memberLink.is_null() {
                if valNeeded != 0 {
                    ret = xmlSchemaVCheckCVCSimpleType(
                        actxt,
                        node,
                        (*memberLink).type_0,
                        value,
                        &mut val,
                        0 as i32,
                        1 as i32,
                        0 as i32,
                    );
                } else {
                    ret = xmlSchemaVCheckCVCSimpleType(
                        actxt,
                        node,
                        (*memberLink).type_0,
                        value,
                        0 as *mut xmlSchemaValPtr,
                        0 as i32,
                        1 as i32,
                        0 as i32,
                    );
                }
                if ret <= 0 as i32 {
                    break;
                }
                memberLink = (*memberLink).next;
            }
            if ret != 0 as i32 {
                if ret < 0 as i32 {
                    xmlSchemaInternalErr(
                        actxt,
                        b"xmlSchemaVCheckCVCSimpleType\0" as *const u8
                            as *const i8,
                        b"validating members of union simple type\0" as *const u8
                            as *const i8,
                    );
                    current_block = 10711413107550680511;
                } else {
                    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3 as i32;
                    current_block = 4871270227279186910;
                }
            } else {
                current_block = 4871270227279186910;
            }
            match current_block {
                10711413107550680511 => {}
                _ => {
                    if ret == 0 as i32
                        && (*type_0).flags & (1 as i32) << 27 as i32 != 0
                    {
                        if isNormalized == 0
                            && (normalize != 0
                                || (*type_0).flags & (1 as i32) << 28 as i32
                                    != 0)
                        {
                            normValue = xmlSchemaNormalizeValue(
                                (*memberLink).type_0,
                                value,
                            );
                            if !normValue.is_null() {
                                value = normValue;
                            }
                            isNormalized = 1 as i32;
                        }
                        ret = xmlSchemaValidateFacets(
                            actxt,
                            node,
                            type_0,
                            XML_SCHEMAS_UNKNOWN,
                            value,
                            val,
                            0 as i32 as u64,
                            fireErrors,
                        );
                        if ret != 0 as i32 {
                            if ret < 0 as i32 {
                                xmlSchemaInternalErr(
                                    actxt,
                                    b"xmlSchemaVCheckCVCSimpleType\0" as *const u8
                                        as *const i8,
                                    b"validating facets of union simple type\0" as *const u8
                                        as *const i8,
                                );
                                current_block = 10711413107550680511;
                            } else {
                                ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3 as i32;
                                current_block = 7198204517578597543;
                            }
                        } else {
                            current_block = 7198204517578597543;
                        }
                    } else {
                        current_block = 7198204517578597543;
                    }
                    match current_block {
                        10711413107550680511 => {}
                        _ => {
                            if fireErrors != 0 && ret > 0 as i32 {
                                xmlSchemaSimpleTypeErr(
                                    actxt,
                                    ret as xmlParserErrors,
                                    node,
                                    value,
                                    type_0,
                                    1 as i32,
                                );
                            }
                            current_block = 8953117030348968745;
                        }
                    }
                }
            }
        }
    } else {
        current_block = 8953117030348968745;
    }
    match current_block {
        10711413107550680511 => {
            if !normValue.is_null() {
                xmlFree
                    .expect("non-null function pointer")(normValue as *mut libc::c_void);
            }
            if !val.is_null() {
                xmlSchemaFreeValue(val);
            }
            return -(1 as i32);
        }
        _ => {
            if !normValue.is_null() {
                xmlFree
                    .expect("non-null function pointer")(normValue as *mut libc::c_void);
            }
            if ret == 0 as i32 {
                if !retVal.is_null() {
                    *retVal = val;
                } else if !val.is_null() {
                    xmlSchemaFreeValue(val);
                }
            } else if !val.is_null() {
                xmlSchemaFreeValue(val);
            }
            return ret;
        }
    };
}
unsafe extern "C" fn xmlSchemaVExpandQName(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut value: *const xmlChar,
    mut nsName: *mut *const xmlChar,
    mut localName: *mut *const xmlChar,
) -> i32 {
    let mut ret: i32 = 0 as i32;
    if nsName.is_null() || localName.is_null() {
        return -(1 as i32);
    }
    *nsName = 0 as *const xmlChar;
    *localName = 0 as *const xmlChar;
    ret = xmlValidateQName(value, 1 as i32);
    if ret == -(1 as i32) {
        return -(1 as i32);
    }
    if ret > 0 as i32 {
        xmlSchemaSimpleTypeErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1,
            0 as xmlNodePtr,
            value,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),
            1 as i32,
        );
        return 1 as i32;
    }
    let mut local: *mut xmlChar = 0 as *mut xmlChar;
    let mut prefix: *mut xmlChar = 0 as *mut xmlChar;
    local = xmlSplitQName2(value, &mut prefix);
    if local.is_null() {
        *localName = xmlDictLookup((*vctxt).dict, value, -(1 as i32));
    } else {
        *localName = xmlDictLookup((*vctxt).dict, local, -(1 as i32));
        xmlFree.expect("non-null function pointer")(local as *mut libc::c_void);
    }
    *nsName = xmlSchemaLookupNamespace(vctxt, prefix);
    if !prefix.is_null() {
        xmlFree.expect("non-null function pointer")(prefix as *mut libc::c_void);
        if (*nsName).is_null() {
            xmlSchemaCustomErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1,
                0 as xmlNodePtr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME) as xmlSchemaBasicItemPtr,
                b"The QName value '%s' has no corresponding namespace declaration in scope\0"
                    as *const u8 as *const i8,
                value,
                0 as *const xmlChar,
            );
            return 2 as i32;
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaProcessXSIType(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut iattr: xmlSchemaAttrInfoPtr,
    mut localType: *mut xmlSchemaTypePtr,
    mut elemDecl: xmlSchemaElementPtr,
) -> i32 {
    let mut ret: i32 = 0 as i32;
    if localType.is_null() {
        return -(1 as i32);
    }
    *localType = 0 as xmlSchemaTypePtr;
    if iattr.is_null() {
        return 0 as i32
    } else {
        let mut nsName: *const xmlChar = 0 as *const xmlChar;
        let mut local: *const xmlChar = 0 as *const xmlChar;
        let fresh563 = &mut ((*vctxt).inode);
        *fresh563 = iattr as xmlSchemaNodeInfoPtr;
        ret = xmlSchemaVExpandQName(vctxt, (*iattr).value, &mut nsName, &mut local);
        if ret != 0 as i32 {
            if ret < 0 as i32 {
                xmlSchemaInternalErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaValidateElementByDeclaration\0" as *const u8
                        as *const i8,
                    b"calling xmlSchemaQNameExpand() to validate the attribute 'xsi:type'\0"
                        as *const u8 as *const i8,
                );
                let fresh565 = &mut ((*vctxt).inode);
                *fresh565 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
                return -(1 as i32);
            }
        } else {
            *localType = xmlSchemaGetType((*vctxt).schema, local, nsName);
            if (*localType).is_null() {
                let mut str: *mut xmlChar = 0 as *mut xmlChar;
                xmlSchemaCustomErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    XML_SCHEMAV_CVC_ELT_4_2,
                    0 as xmlNodePtr,
                    xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME) as xmlSchemaBasicItemPtr,
                    b"The QName value '%s' of the xsi:type attribute does not resolve to a type definition\0"
                        as *const u8 as *const i8,
                    xmlSchemaFormatQName(&mut str, nsName, local),
                    0 as *const xmlChar,
                );
                if !str.is_null() {
                    xmlFree
                        .expect("non-null function pointer")(str as *mut libc::c_void);
                    str = 0 as *mut xmlChar;
                }
                ret = (*vctxt).err;
            } else if !elemDecl.is_null() {
                let mut set: i32 = 0 as i32;
                if (*elemDecl).flags & (1 as i32) << 11 as i32 != 0
                    || (*(*elemDecl).subtypes).flags
                        & (1 as i32) << 18 as i32 != 0
                {
                    set |= (1 as i32) << 1 as i32;
                }
                if (*elemDecl).flags & (1 as i32) << 12 as i32 != 0
                    || (*(*elemDecl).subtypes).flags
                        & (1 as i32) << 19 as i32 != 0
                {
                    set |= (1 as i32) << 0 as i32;
                }
                if xmlSchemaCheckCOSDerivedOK(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    *localType,
                    (*elemDecl).subtypes,
                    set,
                ) != 0 as i32
                {
                    let mut str_0: *mut xmlChar = 0 as *mut xmlChar;
                    xmlSchemaCustomErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAV_CVC_ELT_4_3,
                        0 as xmlNodePtr,
                        0 as xmlSchemaBasicItemPtr,
                        b"The type definition '%s', specified by xsi:type, is blocked or not validly derived from the type definition of the element declaration\0"
                            as *const u8 as *const i8,
                        xmlSchemaFormatQName(
                            &mut str_0,
                            (**localType).targetNamespace,
                            (**localType).name,
                        ),
                        0 as *const xmlChar,
                    );
                    if !str_0.is_null() {
                        xmlFree
                            .expect(
                                "non-null function pointer",
                            )(str_0 as *mut libc::c_void);
                        str_0 = 0 as *mut xmlChar;
                    }
                    ret = (*vctxt).err;
                    *localType = 0 as xmlSchemaTypePtr;
                }
            }
        }
        let fresh564 = &mut ((*vctxt).inode);
        *fresh564 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
        return ret;
    };
}
unsafe extern "C" fn xmlSchemaValidateElemDecl(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> i32 {
    let mut elemDecl: xmlSchemaElementPtr = (*(*vctxt).inode).decl;
    let mut actualType: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    if elemDecl.is_null() {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_ELT_1,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"No matching declaration available\0" as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*vctxt).err;
    }
    actualType = (*elemDecl).subtypes;
    if (*elemDecl).flags & (1 as i32) << 4 as i32 != 0 {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_ELT_2,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"The element declaration is abstract\0" as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*vctxt).err;
    }
    if actualType.is_null() {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_TYPE_1,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"The type definition is absent\0" as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return XML_SCHEMAV_CVC_TYPE_1 as i32;
    }
    if (*vctxt).nbAttrInfos != 0 as i32 {
        let mut ret: i32 = 0;
        let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
        iattr = xmlSchemaGetMetaAttrInfo(vctxt, 2 as i32);
        if !iattr.is_null() {
            let fresh566 = &mut ((*vctxt).inode);
            *fresh566 = iattr as xmlSchemaNodeInfoPtr;
            ret = xmlSchemaVCheckCVCSimpleType(
                vctxt as xmlSchemaAbstractCtxtPtr,
                0 as xmlNodePtr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
                (*iattr).value,
                &mut (*iattr).val,
                1 as i32,
                0 as i32,
                0 as i32,
            );
            let fresh567 = &mut ((*vctxt).inode);
            *fresh567 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
            if ret < 0 as i32 {
                xmlSchemaInternalErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaValidateElemDecl\0" as *const u8 as *const i8,
                    b"calling xmlSchemaVCheckCVCSimpleType() to validate the attribute 'xsi:nil'\0"
                        as *const u8 as *const i8,
                );
                return -(1 as i32);
            }
            if ret == 0 as i32 {
                if (*elemDecl).flags & (1 as i32) << 0 as i32
                    == 0 as i32
                {
                    xmlSchemaCustomErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAV_CVC_ELT_3_1,
                        0 as xmlNodePtr,
                        0 as xmlSchemaBasicItemPtr,
                        b"The element is not 'nillable'\0" as *const u8
                            as *const i8,
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                } else if xmlSchemaValueGetAsBoolean((*iattr).val) != 0 {
                    if (*elemDecl).flags & (1 as i32) << 3 as i32 != 0
                        && !((*elemDecl).value).is_null()
                    {
                        xmlSchemaCustomErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            XML_SCHEMAV_CVC_ELT_3_2_2,
                            0 as xmlNodePtr,
                            0 as xmlSchemaBasicItemPtr,
                            b"The element cannot be 'nilled' because there is a fixed value constraint defined for it\0"
                                as *const u8 as *const i8,
                            0 as *const xmlChar,
                            0 as *const xmlChar,
                        );
                    } else {
                        (*(*vctxt).inode).flags
                            |= (1 as i32) << 2 as i32;
                    }
                }
            }
        }
        iattr = xmlSchemaGetMetaAttrInfo(vctxt, 1 as i32);
        if !iattr.is_null() {
            let mut localType: xmlSchemaTypePtr = 0 as xmlSchemaTypePtr;
            ret = xmlSchemaProcessXSIType(vctxt, iattr, &mut localType, elemDecl);
            if ret != 0 as i32 {
                if ret == -(1 as i32) {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaValidateElemDecl\0" as *const u8
                            as *const i8,
                        b"calling xmlSchemaProcessXSIType() to process the attribute 'xsi:type'\0"
                            as *const u8 as *const i8,
                    );
                    return -(1 as i32);
                }
            }
            if !localType.is_null() {
                (*(*vctxt).inode).flags |= (1 as i32) << 3 as i32;
                actualType = localType;
            }
        }
    }
    if !((*elemDecl).idcs).is_null()
        && xmlSchemaIDCRegisterMatchers(vctxt, elemDecl) == -(1 as i32)
    {
        return -(1 as i32);
    }
    if actualType.is_null() {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_TYPE_1,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"The type definition is absent\0" as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return XML_SCHEMAV_CVC_TYPE_1 as i32;
    }
    let fresh568 = &mut ((*(*vctxt).inode).typeDef);
    *fresh568 = actualType;
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaVAttributesSimple(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> i32 {
    let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    let mut ret: i32 = 0 as i32;
    let mut i: i32 = 0;
    if (*vctxt).nbAttrInfos == 0 as i32 {
        return 0 as i32;
    }
    i = 0 as i32;
    while i < (*vctxt).nbAttrInfos {
        iattr = *((*vctxt).attrInfos).offset(i as isize);
        if (*iattr).metaType == 0 {
            let fresh569 = &mut ((*vctxt).inode);
            *fresh569 = iattr as xmlSchemaNodeInfoPtr;
            xmlSchemaIllegalAttrErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAV_CVC_TYPE_3_1_1,
                iattr,
                0 as xmlNodePtr,
            );
            ret = XML_SCHEMAV_CVC_TYPE_3_1_1 as i32;
        }
        i += 1;
    }
    let fresh570 = &mut ((*vctxt).inode);
    *fresh570 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
    return ret;
}
unsafe extern "C" fn xmlSchemaClearAttrInfos(mut vctxt: xmlSchemaValidCtxtPtr) {
    let mut i: i32 = 0;
    let mut attr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    if (*vctxt).nbAttrInfos == 0 as i32 {
        return;
    }
    i = 0 as i32;
    while i < (*vctxt).nbAttrInfos {
        attr = *((*vctxt).attrInfos).offset(i as isize);
        if (*attr).flags & (1 as i32) << 0 as i32 != 0 {
            if !((*attr).localName).is_null() {
                xmlFree
                    .expect(
                        "non-null function pointer",
                    )((*attr).localName as *mut xmlChar as *mut libc::c_void);
            }
            if !((*attr).nsName).is_null() {
                xmlFree
                    .expect(
                        "non-null function pointer",
                    )((*attr).nsName as *mut xmlChar as *mut libc::c_void);
            }
        }
        if (*attr).flags & (1 as i32) << 1 as i32 != 0 {
            if !((*attr).value).is_null() {
                xmlFree
                    .expect(
                        "non-null function pointer",
                    )((*attr).value as *mut xmlChar as *mut libc::c_void);
            }
        }
        if !((*attr).val).is_null() {
            xmlSchemaFreeValue((*attr).val);
            let fresh571 = &mut ((*attr).val);
            *fresh571 = 0 as xmlSchemaValPtr;
        }
        memset(
            attr as *mut libc::c_void,
            0 as i32,
            ::std::mem::size_of::<xmlSchemaAttrInfo>() as u64,
        );
        i += 1;
    }
    (*vctxt).nbAttrInfos = 0 as i32;
}
unsafe extern "C" fn xmlSchemaVAttributesComplex(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> i32 {
    let mut current_block: u64;
    let mut type_0: xmlSchemaTypePtr = (*(*vctxt).inode).typeDef;
    let mut attrUseList: xmlSchemaItemListPtr = 0 as *mut xmlSchemaItemList;
    let mut attrUse: xmlSchemaAttributeUsePtr = 0 as xmlSchemaAttributeUsePtr;
    let mut attrDecl: xmlSchemaAttributePtr = 0 as xmlSchemaAttributePtr;
    let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    let mut tmpiattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
    let mut i: i32 = 0;
    let mut j: i32 = 0;
    let mut found: i32 = 0;
    let mut nbAttrs: i32 = 0;
    let mut nbUses: i32 = 0;
    let mut xpathRes: i32 = 0 as i32;
    let mut res: i32 = 0;
    let mut wildIDs: i32 = 0 as i32;
    let mut fixed: i32 = 0;
    let mut defAttrOwnerElem: xmlNodePtr = 0 as xmlNodePtr;
    attrUseList = (*type_0).attrUses as xmlSchemaItemListPtr;
    nbAttrs = (*vctxt).nbAttrInfos;
    if !attrUseList.is_null() {
        nbUses = (*attrUseList).nbItems;
    } else {
        nbUses = 0 as i32;
    }
    i = 0 as i32;
    while i < nbUses {
        found = 0 as i32;
        attrUse = *((*attrUseList).items).offset(i as isize) as xmlSchemaAttributeUsePtr;
        attrDecl = (*attrUse).attrDecl;
        j = 0 as i32;
        while j < nbAttrs {
            iattr = *((*vctxt).attrInfos).offset(j as isize);
            if !((*iattr).metaType != 0) {
                if !(*((*iattr).localName).offset(0 as i32 as isize)
                    as i32
                    != *((*attrDecl).name).offset(0 as i32 as isize)
                        as i32)
                {
                    if !(xmlStrEqual((*iattr).localName, (*attrDecl).name) == 0) {
                        if !(xmlStrEqual((*iattr).nsName, (*attrDecl).targetNamespace)
                            == 0)
                        {
                            found = 1 as i32;
                            (*iattr).state = 2 as i32;
                            let fresh572 = &mut ((*iattr).use_0);
                            *fresh572 = attrUse;
                            let fresh573 = &mut ((*iattr).decl);
                            *fresh573 = attrDecl;
                            let fresh574 = &mut ((*iattr).typeDef);
                            *fresh574 = (*attrDecl).subtypes;
                            break;
                        }
                    }
                }
            }
            j += 1;
        }
        if !(found != 0) {
            if (*attrUse).occurs == 1 as i32 {
                tmpiattr = xmlSchemaGetFreshAttrInfo(vctxt);
                if tmpiattr.is_null() {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaVAttributesComplex\0" as *const u8
                            as *const i8,
                        b"calling xmlSchemaGetFreshAttrInfo()\0" as *const u8
                            as *const i8,
                    );
                    return -(1 as i32);
                }
                (*tmpiattr).state = 4 as i32;
                let fresh575 = &mut ((*tmpiattr).use_0);
                *fresh575 = attrUse;
                let fresh576 = &mut ((*tmpiattr).decl);
                *fresh576 = attrDecl;
            } else if (*attrUse).occurs == 2 as i32
                    && (!((*attrUse).defValue).is_null()
                        || !((*attrDecl).defValue).is_null())
                {
                tmpiattr = xmlSchemaGetFreshAttrInfo(vctxt);
                if tmpiattr.is_null() {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaVAttributesComplex\0" as *const u8
                            as *const i8,
                        b"calling xmlSchemaGetFreshAttrInfo()\0" as *const u8
                            as *const i8,
                    );
                    return -(1 as i32);
                }
                (*tmpiattr).state = 8 as i32;
                let fresh577 = &mut ((*tmpiattr).use_0);
                *fresh577 = attrUse;
                let fresh578 = &mut ((*tmpiattr).decl);
                *fresh578 = attrDecl;
                let fresh579 = &mut ((*tmpiattr).typeDef);
                *fresh579 = (*attrDecl).subtypes;
                let fresh580 = &mut ((*tmpiattr).localName);
                *fresh580 = (*attrDecl).name;
                let fresh581 = &mut ((*tmpiattr).nsName);
                *fresh581 = (*attrDecl).targetNamespace;
            }
        }
        i += 1;
    }
    if (*vctxt).nbAttrInfos == 0 as i32 {
        return 0 as i32;
    }
    if !((*type_0).attributeWildcard).is_null() {
        i = 0 as i32;
        while i < nbAttrs {
            iattr = *((*vctxt).attrInfos).offset(i as isize);
            if !((*iattr).state != 1 as i32) {
                if xmlSchemaCheckCVCWildcardNamespace(
                    (*type_0).attributeWildcard,
                    (*iattr).nsName,
                ) == 0 as i32
                {
                    if (*(*type_0).attributeWildcard).processContents == 1 as i32
                    {
                        (*iattr).state = 13 as i32;
                    } else {
                        let fresh582 = &mut ((*iattr).decl);
                        *fresh582 = xmlSchemaGetAttributeDecl(
                            (*vctxt).schema,
                            (*iattr).localName,
                            (*iattr).nsName,
                        );
                        if !((*iattr).decl).is_null() {
                            (*iattr).state = 2 as i32;
                            let fresh583 = &mut ((*iattr).typeDef);
                            *fresh583 = (*(*iattr).decl).subtypes;
                            if xmlSchemaIsDerivedFromBuiltInType(
                                (*iattr).typeDef,
                                XML_SCHEMAS_ID as i32,
                            ) != 0
                            {
                                if wildIDs != 0 as i32 {
                                    (*iattr).state = 15 as i32;
                                    (*__xmlGenericError())
                                        .expect(
                                            "non-null function pointer",
                                        )(
                                        *__xmlGenericErrorContext(),
                                        b"Unimplemented block at %s:%d\n\0" as *const u8
                                            as *const i8,
                                        b"xmlschemas.c\0" as *const u8 as *const i8,
                                        25640 as i32,
                                    );
                                } else {
                                    wildIDs += 1;
                                    if !attrUseList.is_null() {
                                        j = 0 as i32;
                                        while j < (*attrUseList).nbItems {
                                            if xmlSchemaIsDerivedFromBuiltInType(
                                                (*(*(*((*attrUseList).items).offset(j as isize)
                                                    as xmlSchemaAttributeUsePtr))
                                                    .attrDecl)
                                                    .subtypes,
                                                XML_SCHEMAS_ID as i32,
                                            ) != 0
                                            {
                                                (*iattr).state = 16 as i32;
                                                (*__xmlGenericError())
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(
                                                    *__xmlGenericErrorContext(),
                                                    b"Unimplemented block at %s:%d\n\0" as *const u8
                                                        as *const i8,
                                                    b"xmlschemas.c\0" as *const u8 as *const i8,
                                                    25658 as i32,
                                                );
                                                break;
                                            } else {
                                                j += 1;
                                            }
                                        }
                                    }
                                }
                            }
                        } else if (*(*type_0).attributeWildcard).processContents
                                == 2 as i32
                            {
                            (*iattr).state = 14 as i32;
                        } else {
                            (*iattr).state = 10 as i32;
                        }
                    }
                }
            }
            i += 1;
        }
    }
    if (*vctxt).nbAttrInfos == 0 as i32 {
        return 0 as i32;
    }
    if (*vctxt).options & XML_SCHEMA_VAL_VC_I_CREATE as i32 != 0 {
        let mut ielem: xmlSchemaNodeInfoPtr = *((*vctxt).elemInfos)
            .offset((*vctxt).depth as isize);
        if !ielem.is_null() && !((*ielem).node).is_null()
            && !((*(*ielem).node).doc).is_null()
        {
            defAttrOwnerElem = (*ielem).node;
        }
    }
    i = 0 as i32;
    's_457: loop {
        if !(i < (*vctxt).nbAttrInfos) {
            current_block = 12463749970033092792;
            break;
        }
        iattr = *((*vctxt).attrInfos).offset(i as isize);
        if !((*iattr).state != 2 as i32 && (*iattr).state != 8 as i32) {
            if ((*iattr).typeDef).is_null() {
                (*iattr).state = 6 as i32;
            } else {
                let fresh584 = &mut ((*vctxt).inode);
                *fresh584 = iattr as xmlSchemaNodeInfoPtr;
                fixed = 0 as i32;
                xpathRes = 0 as i32;
                if !((*vctxt).xpathStates).is_null() {
                    xpathRes = xmlSchemaXPathEvaluate(vctxt, XML_ATTRIBUTE_NODE);
                    if xpathRes == -(1 as i32) {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaVAttributesComplex\0" as *const u8
                                as *const i8,
                            b"calling xmlSchemaXPathEvaluate()\0" as *const u8
                                as *const i8,
                        );
                        current_block = 16059426333721732591;
                        break;
                    }
                }
                if (*iattr).state == 8 as i32 {
                    if xpathRes != 0 || !defAttrOwnerElem.is_null() {
                        if !((*(*iattr).use_0).defValue).is_null() {
                            let fresh585 = &mut ((*iattr).value);
                            *fresh585 = (*(*iattr).use_0).defValue as *mut xmlChar;
                            let fresh586 = &mut ((*iattr).val);
                            *fresh586 = (*(*iattr).use_0).defVal;
                        } else {
                            let fresh587 = &mut ((*iattr).value);
                            *fresh587 = (*(*iattr).decl).defValue as *mut xmlChar;
                            let fresh588 = &mut ((*iattr).val);
                            *fresh588 = (*(*iattr).decl).defVal;
                        }
                        if ((*iattr).val).is_null() {
                            xmlSchemaInternalErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                b"xmlSchemaVAttributesComplex\0" as *const u8
                                    as *const i8,
                                b"default/fixed value on an attribute use was not precomputed\0"
                                    as *const u8 as *const i8,
                            );
                            current_block = 16059426333721732591;
                            break;
                        } else {
                            let fresh589 = &mut ((*iattr).val);
                            *fresh589 = xmlSchemaCopyValue((*iattr).val);
                            if ((*iattr).val).is_null() {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaVAttributesComplex\0" as *const u8
                                        as *const i8,
                                    b"calling xmlSchemaCopyValue()\0" as *const u8
                                        as *const i8,
                                );
                                current_block = 16059426333721732591;
                                break;
                            }
                        }
                    }
                    if !defAttrOwnerElem.is_null() {
                        let mut normValue: *mut xmlChar = 0 as *mut xmlChar;
                        let mut value: *const xmlChar = 0 as *const xmlChar;
                        value = (*iattr).value;
                        normValue = xmlSchemaNormalizeValue(
                            (*iattr).typeDef,
                            (*iattr).value,
                        );
                        if !normValue.is_null() {
                            value = normValue;
                        }
                        if ((*iattr).nsName).is_null() {
                            if (xmlNewProp(defAttrOwnerElem, (*iattr).localName, value))
                                .is_null()
                            {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaVAttributesComplex\0" as *const u8
                                        as *const i8,
                                    b"calling xmlNewProp()\0" as *const u8
                                        as *const i8,
                                );
                                if !normValue.is_null() {
                                    xmlFree
                                        .expect(
                                            "non-null function pointer",
                                        )(normValue as *mut libc::c_void);
                                }
                                current_block = 16059426333721732591;
                                break;
                            }
                        } else {
                            let mut ns: xmlNsPtr = 0 as *mut xmlNs;
                            ns = xmlSearchNsByHref(
                                (*defAttrOwnerElem).doc,
                                defAttrOwnerElem,
                                (*iattr).nsName,
                            );
                            if ns.is_null() {
                                let mut prefix: [xmlChar; 12] = [0; 12];
                                let mut counter: i32 = 0 as i32;
                                loop {
                                    let fresh590 = counter;
                                    counter = counter + 1;
                                    snprintf(
                                        prefix.as_mut_ptr() as *mut i8,
                                        12 as i32 as u64,
                                        b"p%d\0" as *const u8 as *const i8,
                                        fresh590,
                                    );
                                    ns = xmlSearchNs(
                                        (*defAttrOwnerElem).doc,
                                        defAttrOwnerElem,
                                        prefix.as_mut_ptr(),
                                    );
                                    if counter > 1000 as i32 {
                                        xmlSchemaInternalErr(
                                            vctxt as xmlSchemaAbstractCtxtPtr,
                                            b"xmlSchemaVAttributesComplex\0" as *const u8
                                                as *const i8,
                                            b"could not compute a ns prefix for a default/fixed attribute\0"
                                                as *const u8 as *const i8,
                                        );
                                        if !normValue.is_null() {
                                            xmlFree
                                                .expect(
                                                    "non-null function pointer",
                                                )(normValue as *mut libc::c_void);
                                        }
                                        current_block = 16059426333721732591;
                                        break 's_457;
                                    } else if ns.is_null() {
                                        break;
                                    }
                                }
                                ns = xmlNewNs(
                                    (*vctxt).validationRoot,
                                    (*iattr).nsName,
                                    prefix.as_mut_ptr(),
                                );
                            }
                            xmlNewNsProp(
                                defAttrOwnerElem,
                                ns,
                                (*iattr).localName,
                                value,
                            );
                        }
                        if !normValue.is_null() {
                            xmlFree
                                .expect(
                                    "non-null function pointer",
                                )(normValue as *mut libc::c_void);
                        }
                    }
                } else {
                    if !((*vctxt).value).is_null() {
                        xmlSchemaFreeValue((*vctxt).value);
                        let fresh591 = &mut ((*vctxt).value);
                        *fresh591 = 0 as xmlSchemaValPtr;
                    }
                    if (*(*iattr).decl).flags & (1 as i32) << 9 as i32
                        != 0
                        || !((*iattr).use_0).is_null()
                            && (*(*iattr).use_0).flags
                                & (1 as i32) << 9 as i32 != 0
                    {
                        fixed = 1 as i32;
                    } else {
                        fixed = 0 as i32;
                    }
                    if xpathRes != 0 || fixed != 0 {
                        (*iattr).flags |= (1 as i32) << 4 as i32;
                        res = xmlSchemaVCheckCVCSimpleType(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            (*iattr).node,
                            (*iattr).typeDef,
                            (*iattr).value,
                            &mut (*iattr).val,
                            1 as i32,
                            1 as i32,
                            0 as i32,
                        );
                    } else {
                        res = xmlSchemaVCheckCVCSimpleType(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            (*iattr).node,
                            (*iattr).typeDef,
                            (*iattr).value,
                            0 as *mut xmlSchemaValPtr,
                            1 as i32,
                            0 as i32,
                            0 as i32,
                        );
                    }
                    if res != 0 as i32 {
                        if res == -(1 as i32) {
                            xmlSchemaInternalErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                b"xmlSchemaVAttributesComplex\0" as *const u8
                                    as *const i8,
                                b"calling xmlSchemaStreamValidateSimpleTypeValue()\0"
                                    as *const u8 as *const i8,
                            );
                            current_block = 16059426333721732591;
                            break;
                        } else {
                            (*iattr).state = 5 as i32;
                        }
                    } else if fixed != 0 {
                        if ((*iattr).val).is_null() {
                            (*__xmlGenericError())
                                .expect(
                                    "non-null function pointer",
                                )(
                                *__xmlGenericErrorContext(),
                                b"Unimplemented block at %s:%d\n\0" as *const u8
                                    as *const i8,
                                b"xmlschemas.c\0" as *const u8 as *const i8,
                                25912 as i32,
                            );
                        } else if !((*iattr).use_0).is_null()
                                && !((*(*iattr).use_0).defValue).is_null()
                            {
                            if ((*(*iattr).use_0).defVal).is_null() {
                                (*__xmlGenericError())
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    *__xmlGenericErrorContext(),
                                    b"Unimplemented block at %s:%d\n\0" as *const u8
                                        as *const i8,
                                    b"xmlschemas.c\0" as *const u8 as *const i8,
                                    25919 as i32,
                                );
                            } else {
                                let fresh592 = &mut ((*iattr).vcValue);
                                *fresh592 = (*(*iattr).use_0).defValue;
                                if xmlSchemaAreValuesEqual(
                                    (*iattr).val,
                                    (*(*iattr).use_0).defVal,
                                ) == 0
                                {
                                    (*iattr).state = 7 as i32;
                                }
                            }
                        } else if ((*(*iattr).decl).defVal).is_null() {
                            (*__xmlGenericError())
                                .expect(
                                    "non-null function pointer",
                                )(
                                *__xmlGenericErrorContext(),
                                b"Unimplemented block at %s:%d\n\0" as *const u8
                                    as *const i8,
                                b"xmlschemas.c\0" as *const u8 as *const i8,
                                25934 as i32,
                            );
                        } else {
                            let fresh593 = &mut ((*iattr).vcValue);
                            *fresh593 = (*(*iattr).decl).defValue;
                            if xmlSchemaAreValuesEqual(
                                (*iattr).val,
                                (*(*iattr).decl).defVal,
                            ) == 0
                            {
                                (*iattr).state = 7 as i32;
                            }
                        }
                    }
                }
                if xpathRes != 0 {
                    if xmlSchemaXPathProcessHistory(
                        vctxt,
                        (*vctxt).depth + 1 as i32,
                    ) == -(1 as i32)
                    {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaVAttributesComplex\0" as *const u8
                                as *const i8,
                            b"calling xmlSchemaXPathEvaluate()\0" as *const u8
                                as *const i8,
                        );
                        current_block = 16059426333721732591;
                        break;
                    }
                } else if !((*vctxt).xpathStates).is_null() {
                    xmlSchemaXPathPop(vctxt);
                }
            }
        }
        i += 1;
    }
    match current_block {
        16059426333721732591 => {
            let fresh597 = &mut ((*vctxt).inode);
            *fresh597 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
            return -(1 as i32);
        }
        _ => {
            i = 0 as i32;
            while i < (*vctxt).nbAttrInfos {
                iattr = *((*vctxt).attrInfos).offset(i as isize);
                if !((*iattr).state == 17 as i32
                    || (*iattr).state == 2 as i32
                    || (*iattr).state == 13 as i32
                    || (*iattr).state == 14 as i32)
                {
                    let fresh594 = &mut ((*vctxt).inode);
                    *fresh594 = iattr as xmlSchemaNodeInfoPtr;
                    match (*iattr).state {
                        4 => {
                            let mut str: *mut xmlChar = 0 as *mut xmlChar;
                            let fresh595 = &mut ((*vctxt).inode);
                            *fresh595 = *((*vctxt).elemInfos)
                                .offset((*vctxt).depth as isize);
                            xmlSchemaCustomErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAV_CVC_COMPLEX_TYPE_4,
                                0 as xmlNodePtr,
                                0 as xmlSchemaBasicItemPtr,
                                b"The attribute '%s' is required but missing\0" as *const u8
                                    as *const i8,
                                xmlSchemaFormatQName(
                                    &mut str,
                                    (*(*iattr).decl).targetNamespace,
                                    (*(*iattr).decl).name,
                                ),
                                0 as *const xmlChar,
                            );
                            if !str.is_null() {
                                xmlFree
                                    .expect(
                                        "non-null function pointer",
                                    )(str as *mut libc::c_void);
                                str = 0 as *mut xmlChar;
                            }
                        }
                        6 => {
                            xmlSchemaCustomErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAV_CVC_ATTRIBUTE_2,
                                0 as xmlNodePtr,
                                0 as xmlSchemaBasicItemPtr,
                                b"The type definition is absent\0" as *const u8
                                    as *const i8,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        }
                        7 => {
                            xmlSchemaCustomErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAV_CVC_AU,
                                0 as xmlNodePtr,
                                0 as xmlSchemaBasicItemPtr,
                                b"The value '%s' does not match the fixed value constraint '%s'\0"
                                    as *const u8 as *const i8,
                                (*iattr).value,
                                (*iattr).vcValue,
                            );
                        }
                        10 => {
                            xmlSchemaCustomErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAV_CVC_WILDCARD,
                                0 as xmlNodePtr,
                                0 as xmlSchemaBasicItemPtr,
                                b"No matching global attribute declaration available, but demanded by the strict wildcard\0"
                                    as *const u8 as *const i8,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        }
                        1 => {
                            if !((*iattr).metaType != 0) {
                                if ((*type_0).attributeWildcard).is_null() {
                                    xmlSchemaIllegalAttrErr(
                                        vctxt as xmlSchemaAbstractCtxtPtr,
                                        XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1,
                                        iattr,
                                        0 as xmlNodePtr,
                                    );
                                } else {
                                    xmlSchemaIllegalAttrErr(
                                        vctxt as xmlSchemaAbstractCtxtPtr,
                                        XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2,
                                        iattr,
                                        0 as xmlNodePtr,
                                    );
                                }
                            }
                        }
                        _ => {}
                    }
                }
                i += 1;
            }
            let fresh596 = &mut ((*vctxt).inode);
            *fresh596 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
            return 0 as i32;
        }
    };
}
unsafe extern "C" fn xmlSchemaValidateElemWildcard(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut skip: *mut i32,
) -> i32 {
    let mut wild: xmlSchemaWildcardPtr = (*(*vctxt).inode).decl as xmlSchemaWildcardPtr;
    if skip.is_null() || wild.is_null()
        || (*wild).type_0 as u32
            != XML_SCHEMA_TYPE_ANY as i32 as u32
    {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaValidateElemWildcard\0" as *const u8 as *const i8,
            b"bad arguments\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    *skip = 0 as i32;
    if (*wild).processContents == 1 as i32 {
        *skip = 1 as i32;
        return 0 as i32;
    }
    let mut decl: xmlSchemaElementPtr = 0 as xmlSchemaElementPtr;
    decl = xmlSchemaGetElem(
        (*vctxt).schema,
        (*(*vctxt).inode).localName,
        (*(*vctxt).inode).nsName,
    );
    if !decl.is_null() {
        let fresh598 = &mut ((*(*vctxt).inode).decl);
        *fresh598 = decl;
        return 0 as i32;
    }
    if (*wild).processContents == 3 as i32 {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_ELT_1,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"No matching global element declaration available, but demanded by the strict wildcard\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*vctxt).err;
    }
    if (*vctxt).nbAttrInfos != 0 as i32 {
        let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
        iattr = xmlSchemaGetMetaAttrInfo(vctxt, 1 as i32);
        if !iattr.is_null() {
            if xmlSchemaProcessXSIType(
                vctxt,
                iattr,
                &mut (*(*vctxt).inode).typeDef,
                0 as xmlSchemaElementPtr,
            ) == -(1 as i32)
            {
                xmlSchemaInternalErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaValidateElemWildcard\0" as *const u8
                        as *const i8,
                    b"calling xmlSchemaProcessXSIType() to process the attribute 'xsi:nil'\0"
                        as *const u8 as *const i8,
                );
                return -(1 as i32);
            }
            return 0 as i32;
        }
    }
    let fresh599 = &mut ((*(*vctxt).inode).typeDef);
    *fresh599 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaCheckCOSValidDefault(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut value: *const xmlChar,
    mut val: *mut xmlSchemaValPtr,
) -> i32 {
    let mut ret: i32 = 0 as i32;
    let mut inode: xmlSchemaNodeInfoPtr = (*vctxt).inode;
    if (*(*inode).typeDef).type_0 as u32
        == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        || (*(*inode).typeDef).builtInType == XML_SCHEMAS_ANYTYPE as i32
    {
        if !((*(*inode).typeDef).contentType as u32
            == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
            || (*(*inode).typeDef).contentType as u32
                == XML_SCHEMA_CONTENT_BASIC as i32 as u32)
            && (!((*(*inode).typeDef).contentType as u32
                == XML_SCHEMA_CONTENT_MIXED as i32 as u32)
                || xmlSchemaIsParticleEmptiable(
                    (*(*inode).typeDef).subtypes as xmlSchemaParticlePtr,
                ) == 0)
        {
            ret = XML_SCHEMAP_COS_VALID_DEFAULT_2_1 as i32;
            xmlSchemaCustomErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                ret as xmlParserErrors,
                0 as xmlNodePtr,
                0 as xmlSchemaBasicItemPtr,
                b"For a string to be a valid default, the type definition must be a simple type or a complex type with simple content or mixed content and a particle emptiable\0"
                    as *const u8 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return ret;
        }
    }
    if (*(*inode).typeDef).type_0 as u32
        == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
        || (*(*inode).typeDef).type_0 as u32
            == XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (*(*inode).typeDef).builtInType != XML_SCHEMAS_ANYTYPE as i32
    {
        ret = xmlSchemaVCheckCVCSimpleType(
            vctxt as xmlSchemaAbstractCtxtPtr,
            0 as xmlNodePtr,
            (*inode).typeDef,
            value,
            val,
            1 as i32,
            1 as i32,
            0 as i32,
        );
    } else if (*(*inode).typeDef).contentType as u32
            == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
            || (*(*inode).typeDef).contentType as u32
                == XML_SCHEMA_CONTENT_BASIC as i32 as u32
        {
        ret = xmlSchemaVCheckCVCSimpleType(
            vctxt as xmlSchemaAbstractCtxtPtr,
            0 as xmlNodePtr,
            (*(*inode).typeDef).contentTypeDef,
            value,
            val,
            1 as i32,
            1 as i32,
            0 as i32,
        );
    }
    if ret < 0 as i32 {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaCheckCOSValidDefault\0" as *const u8 as *const i8,
            b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8
                as *const i8,
        );
    }
    return ret;
}
unsafe extern "C" fn xmlSchemaVContentModelCallback(
    mut exec: xmlRegExecCtxtPtr,
    mut name: *const xmlChar,
    mut transdata: *mut libc::c_void,
    mut inputdata: *mut libc::c_void,
) {
    let mut item: xmlSchemaElementPtr = transdata as xmlSchemaElementPtr;
    let mut inode: xmlSchemaNodeInfoPtr = inputdata as xmlSchemaNodeInfoPtr;
    let fresh600 = &mut ((*inode).decl);
    *fresh600 = item;
}
unsafe extern "C" fn xmlSchemaValidatorPushElem(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> i32 {
    let fresh601 = &mut ((*vctxt).inode);
    *fresh601 = xmlSchemaGetFreshElemInfo(vctxt);
    if ((*vctxt).inode).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaValidatorPushElem\0" as *const u8 as *const i8,
            b"calling xmlSchemaGetFreshElemInfo()\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    (*vctxt).nbAttrInfos = 0 as i32;
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaVCheckINodeDataType(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut inode: xmlSchemaNodeInfoPtr,
    mut type_0: xmlSchemaTypePtr,
    mut value: *const xmlChar,
) -> i32 {
    if (*inode).flags & (1 as i32) << 4 as i32 != 0 {
        return xmlSchemaVCheckCVCSimpleType(
            vctxt as xmlSchemaAbstractCtxtPtr,
            0 as xmlNodePtr,
            type_0,
            value,
            &mut (*inode).val,
            1 as i32,
            1 as i32,
            0 as i32,
        )
    } else {
        return xmlSchemaVCheckCVCSimpleType(
            vctxt as xmlSchemaAbstractCtxtPtr,
            0 as xmlNodePtr,
            type_0,
            value,
            0 as *mut xmlSchemaValPtr,
            1 as i32,
            0 as i32,
            0 as i32,
        )
    };
}
unsafe extern "C" fn xmlSchemaValidatorPopElem(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> i32 {
    let mut current_block: u64;
    let mut ret: i32 = 0 as i32;
    let mut inode: xmlSchemaNodeInfoPtr = (*vctxt).inode;
    if (*vctxt).nbAttrInfos != 0 as i32 {
        xmlSchemaClearAttrInfos(vctxt);
    }
    if (*inode).flags & (1 as i32) << 9 as i32 != 0 {
        (*vctxt).skipDepth = (*vctxt).depth - 1 as i32;
        current_block = 13159517723375190530;
    } else if ((*inode).typeDef).is_null()
            || (*inode).flags & (1 as i32) << 10 as i32 != 0
        {
        current_block = 13159517723375190530;
    } else {
        if (*(*inode).typeDef).contentType as u32
            == XML_SCHEMA_CONTENT_MIXED as i32 as u32
            || (*(*inode).typeDef).contentType as u32
                == XML_SCHEMA_CONTENT_ELEMENTS as i32 as u32
        {
            if (*(*inode).typeDef).builtInType == XML_SCHEMAS_ANYTYPE as i32 {
                current_block = 8993999215443021867;
            } else if (*inode).flags & (1 as i32) << 8 as i32
                    == 0 as i32
                {
                let mut values: [*mut xmlChar; 10] = [0 as *mut xmlChar; 10];
                let mut terminal: i32 = 0;
                let mut nbval: i32 = 10 as i32;
                let mut nbneg: i32 = 0;
                if ((*inode).regexCtxt).is_null() {
                    let fresh602 = &mut ((*inode).regexCtxt);
                    *fresh602 = xmlRegNewExecCtxt(
                        (*(*inode).typeDef).contModel,
                        Some(
                            xmlSchemaVContentModelCallback
                                as unsafe extern "C" fn(
                                    xmlRegExecCtxtPtr,
                                    *const xmlChar,
                                    *mut libc::c_void,
                                    *mut libc::c_void,
                                ) -> (),
                        ),
                        vctxt as *mut libc::c_void,
                    );
                    if ((*inode).regexCtxt).is_null() {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaValidatorPopElem\0" as *const u8
                                as *const i8,
                            b"failed to create a regex context\0" as *const u8
                                as *const i8,
                        );
                        current_block = 3454747893076357924;
                    } else {
                        current_block = 15976848397966268834;
                    }
                } else {
                    current_block = 15976848397966268834;
                }
                match current_block {
                    3454747893076357924 => {}
                    _ => {
                        if (*inode).flags & (1 as i32) << 2 as i32 != 0 {
                            ret = 0 as i32;
                        } else {
                            xmlRegExecNextValues(
                                (*inode).regexCtxt,
                                &mut nbval,
                                &mut nbneg,
                                &mut *values.as_mut_ptr().offset(0 as i32 as isize),
                                &mut terminal,
                            );
                            ret = xmlRegExecPushString(
                                (*inode).regexCtxt,
                                0 as *const xmlChar,
                                0 as *mut libc::c_void,
                            );
                            if ret < 0 as i32
                                || ret == 0 as i32
                                    && (*inode).flags & (1 as i32) << 2 as i32
                                        == 0
                            {
                                ret = 1 as i32;
                                (*inode).flags |= (1 as i32) << 8 as i32;
                                xmlSchemaComplexTypeErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    XML_SCHEMAV_ELEMENT_CONTENT,
                                    0 as xmlNodePtr,
                                    0 as xmlSchemaTypePtr,
                                    b"Missing child element(s)\0" as *const u8
                                        as *const i8,
                                    nbval,
                                    nbneg,
                                    values.as_mut_ptr(),
                                );
                            } else {
                                ret = 0 as i32;
                            }
                        }
                        current_block = 10035050265139717661;
                    }
                }
            } else {
                current_block = 10035050265139717661;
            }
        } else {
            current_block = 10035050265139717661;
        }
        match current_block {
            3454747893076357924 => {}
            _ => {
                match current_block {
                    10035050265139717661 => {
                        if (*(*inode).typeDef).contentType as u32
                            == XML_SCHEMA_CONTENT_ELEMENTS as i32 as u32
                        {
                            current_block = 13159517723375190530;
                        } else {
                            current_block = 8993999215443021867;
                        }
                    }
                    _ => {}
                }
                match current_block {
                    13159517723375190530 => {}
                    _ => {
                        if !((*vctxt).value).is_null() {
                            xmlSchemaFreeValue((*vctxt).value);
                            let fresh603 = &mut ((*vctxt).value);
                            *fresh603 = 0 as xmlSchemaValPtr;
                        }
                        if ((*inode).decl).is_null() {
                            if (*(*inode).typeDef).type_0 as u32
                                == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                                || (*(*inode).typeDef).type_0 as u32
                                    == XML_SCHEMA_TYPE_BASIC as i32 as u32
                                    && (*(*inode).typeDef).builtInType
                                        != XML_SCHEMAS_ANYTYPE as i32
                            {
                                ret = xmlSchemaVCheckINodeDataType(
                                    vctxt,
                                    inode,
                                    (*inode).typeDef,
                                    (*inode).value,
                                );
                            } else if (*(*inode).typeDef).contentType as u32
                                    == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
                                    || (*(*inode).typeDef).contentType as u32
                                        == XML_SCHEMA_CONTENT_BASIC as i32 as u32
                                {
                                ret = xmlSchemaVCheckINodeDataType(
                                    vctxt,
                                    inode,
                                    (*(*inode).typeDef).contentTypeDef,
                                    (*inode).value,
                                );
                            }
                            if ret < 0 as i32 {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaValidatorPopElem\0" as *const u8
                                        as *const i8,
                                    b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8
                                        as *const i8,
                                );
                                current_block = 3454747893076357924;
                            } else {
                                current_block = 13159517723375190530;
                            }
                        } else if !((*(*inode).decl).value).is_null()
                                && (*inode).flags & (1 as i32) << 5 as i32
                                    != 0
                                && (*inode).flags & (1 as i32) << 2 as i32
                                    == 0
                            {
                            if (*inode).flags & (1 as i32) << 3 as i32
                                != 0
                            {
                                ret = xmlSchemaCheckCOSValidDefault(
                                    vctxt,
                                    (*(*inode).decl).value,
                                    &mut (*inode).val,
                                );
                                if ret != 0 as i32 {
                                    if ret < 0 as i32 {
                                        xmlSchemaInternalErr(
                                            vctxt as xmlSchemaAbstractCtxtPtr,
                                            b"xmlSchemaValidatorPopElem\0" as *const u8
                                                as *const i8,
                                            b"calling xmlSchemaCheckCOSValidDefault()\0" as *const u8
                                                as *const i8,
                                        );
                                        current_block = 3454747893076357924;
                                    } else {
                                        current_block = 13159517723375190530;
                                    }
                                } else {
                                    current_block = 15766311179120147566;
                                }
                            } else {
                                if (*(*inode).typeDef).type_0 as u32
                                    == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                                    || (*(*inode).typeDef).type_0 as u32
                                        == XML_SCHEMA_TYPE_BASIC as i32 as u32
                                        && (*(*inode).typeDef).builtInType
                                            != XML_SCHEMAS_ANYTYPE as i32
                                {
                                    ret = xmlSchemaVCheckINodeDataType(
                                        vctxt,
                                        inode,
                                        (*inode).typeDef,
                                        (*(*inode).decl).value,
                                    );
                                } else if (*(*inode).typeDef).contentType as u32
                                        == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
                                        || (*(*inode).typeDef).contentType as u32
                                            == XML_SCHEMA_CONTENT_BASIC as i32 as u32
                                    {
                                    ret = xmlSchemaVCheckINodeDataType(
                                        vctxt,
                                        inode,
                                        (*(*inode).typeDef).contentTypeDef,
                                        (*(*inode).decl).value,
                                    );
                                }
                                if ret != 0 as i32 {
                                    if ret < 0 as i32 {
                                        xmlSchemaInternalErr(
                                            vctxt as xmlSchemaAbstractCtxtPtr,
                                            b"xmlSchemaValidatorPopElem\0" as *const u8
                                                as *const i8,
                                            b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8
                                                as *const i8,
                                        );
                                        current_block = 3454747893076357924;
                                    } else {
                                        current_block = 13159517723375190530;
                                    }
                                } else {
                                    current_block = 15766311179120147566;
                                }
                            }
                            match current_block {
                                13159517723375190530 => {}
                                3454747893076357924 => {}
                                _ => {
                                    if (*vctxt).options
                                        & XML_SCHEMA_VAL_VC_I_CREATE as i32 != 0
                                        && !((*inode).node).is_null()
                                    {
                                        let mut textChild: xmlNodePtr = 0 as *mut xmlNode;
                                        let mut normValue: *mut xmlChar = 0 as *mut xmlChar;
                                        normValue = xmlSchemaNormalizeValue(
                                            (*inode).typeDef,
                                            (*(*inode).decl).value,
                                        );
                                        if !normValue.is_null() {
                                            textChild = xmlNewDocText((*(*inode).node).doc, normValue);
                                            xmlFree
                                                .expect(
                                                    "non-null function pointer",
                                                )(normValue as *mut libc::c_void);
                                        } else {
                                            textChild = xmlNewDocText(
                                                (*(*inode).node).doc,
                                                (*(*inode).decl).value,
                                            );
                                        }
                                        if textChild.is_null() {
                                            xmlSchemaInternalErr(
                                                vctxt as xmlSchemaAbstractCtxtPtr,
                                                b"xmlSchemaValidatorPopElem\0" as *const u8
                                                    as *const i8,
                                                b"calling xmlNewDocText()\0" as *const u8
                                                    as *const i8,
                                            );
                                            current_block = 3454747893076357924;
                                        } else {
                                            xmlAddChild((*inode).node, textChild);
                                            current_block = 13159517723375190530;
                                        }
                                    } else {
                                        current_block = 13159517723375190530;
                                    }
                                }
                            }
                        } else if (*inode).flags & (1 as i32) << 2 as i32
                                == 0
                            {
                            if (*(*inode).typeDef).type_0 as u32
                                == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                                || (*(*inode).typeDef).type_0 as u32
                                    == XML_SCHEMA_TYPE_BASIC as i32 as u32
                                    && (*(*inode).typeDef).builtInType
                                        != XML_SCHEMAS_ANYTYPE as i32
                            {
                                ret = xmlSchemaVCheckINodeDataType(
                                    vctxt,
                                    inode,
                                    (*inode).typeDef,
                                    (*inode).value,
                                );
                            } else if (*(*inode).typeDef).contentType as u32
                                    == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
                                    || (*(*inode).typeDef).contentType as u32
                                        == XML_SCHEMA_CONTENT_BASIC as i32 as u32
                                {
                                ret = xmlSchemaVCheckINodeDataType(
                                    vctxt,
                                    inode,
                                    (*(*inode).typeDef).contentTypeDef,
                                    (*inode).value,
                                );
                            }
                            if ret != 0 as i32 {
                                if ret < 0 as i32 {
                                    xmlSchemaInternalErr(
                                        vctxt as xmlSchemaAbstractCtxtPtr,
                                        b"xmlSchemaValidatorPopElem\0" as *const u8
                                            as *const i8,
                                        b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8
                                            as *const i8,
                                    );
                                    current_block = 3454747893076357924;
                                } else {
                                    current_block = 13159517723375190530;
                                }
                            } else if !((*(*inode).decl).value).is_null()
                                    && (*(*inode).decl).flags
                                        & (1 as i32) << 3 as i32 != 0
                                {
                                if (*inode).flags & (1 as i32) << 7 as i32
                                    != 0
                                {
                                    ret = XML_SCHEMAV_CVC_ELT_5_2_2_1 as i32;
                                    xmlSchemaCustomErr(
                                        vctxt as xmlSchemaAbstractCtxtPtr,
                                        ret as xmlParserErrors,
                                        0 as xmlNodePtr,
                                        0 as xmlSchemaBasicItemPtr,
                                        b"The content must not contain element nodes since there is a fixed value constraint\0"
                                            as *const u8 as *const i8,
                                        0 as *const xmlChar,
                                        0 as *const xmlChar,
                                    );
                                } else if (*(*inode).typeDef).contentType as u32
                                        == XML_SCHEMA_CONTENT_MIXED as i32 as u32
                                    {
                                    if xmlStrEqual((*inode).value, (*(*inode).decl).value) == 0
                                    {
                                        ret = XML_SCHEMAV_CVC_ELT_5_2_2_2_1 as i32;
                                        xmlSchemaCustomErr(
                                            vctxt as xmlSchemaAbstractCtxtPtr,
                                            ret as xmlParserErrors,
                                            0 as xmlNodePtr,
                                            0 as xmlSchemaBasicItemPtr,
                                            b"The initial value '%s' does not match the fixed value constraint '%s'\0"
                                                as *const u8 as *const i8,
                                            (*inode).value,
                                            (*(*inode).decl).value,
                                        );
                                    }
                                } else if (*(*inode).typeDef).contentType as u32
                                        == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
                                        || (*(*inode).typeDef).contentType as u32
                                            == XML_SCHEMA_CONTENT_BASIC as i32 as u32
                                    {
                                    if xmlStrEqual((*inode).value, (*(*inode).decl).value) == 0
                                    {
                                        ret = XML_SCHEMAV_CVC_ELT_5_2_2_2_2 as i32;
                                        xmlSchemaCustomErr(
                                            vctxt as xmlSchemaAbstractCtxtPtr,
                                            ret as xmlParserErrors,
                                            0 as xmlNodePtr,
                                            0 as xmlSchemaBasicItemPtr,
                                            b"The actual value '%s' does not match the fixed value constraint '%s'\0"
                                                as *const u8 as *const i8,
                                            (*inode).value,
                                            (*(*inode).decl).value,
                                        );
                                    }
                                }
                                current_block = 13159517723375190530;
                            } else {
                                current_block = 13159517723375190530;
                            }
                        } else {
                            current_block = 13159517723375190530;
                        }
                    }
                }
            }
        }
    }
    match current_block {
        13159517723375190530 => {
            if (*vctxt).depth < 0 as i32 {
                return 0 as i32;
            }
            if (*vctxt).depth == (*vctxt).skipDepth {
                (*vctxt).skipDepth = -(1 as i32);
            }
            if !((*inode).appliedXPath != 0
                && xmlSchemaXPathProcessHistory(vctxt, (*vctxt).depth)
                    == -(1 as i32))
            {
                if !((*inode).idcMatchers).is_null()
                    && ((*vctxt).hasKeyrefs != 0 || (*vctxt).createIDCNodeTables != 0)
                {
                    if xmlSchemaIDCFillNodeTables(vctxt, inode) == -(1 as i32) {
                        current_block = 3454747893076357924;
                    } else {
                        current_block = 6665878751423064961;
                    }
                } else {
                    current_block = 6665878751423064961;
                }
                match current_block {
                    3454747893076357924 => {}
                    _ => {
                        if (*(*vctxt).inode).hasKeyrefs != 0 {
                            if xmlSchemaCheckCVCIDCKeyRef(vctxt) == -(1 as i32) {
                                current_block = 3454747893076357924;
                            } else {
                                current_block = 8225018548522317130;
                            }
                        } else {
                            current_block = 8225018548522317130;
                        }
                        match current_block {
                            3454747893076357924 => {}
                            _ => {
                                if !((*inode).idcTable).is_null() {
                                    if (*vctxt).depth > 0 as i32
                                        && ((*vctxt).hasKeyrefs != 0
                                            || (*vctxt).createIDCNodeTables != 0)
                                    {
                                        if xmlSchemaBubbleIDCNodeTables(vctxt)
                                            == -(1 as i32)
                                        {
                                            current_block = 3454747893076357924;
                                        } else {
                                            current_block = 5636883459695696059;
                                        }
                                    } else {
                                        current_block = 5636883459695696059;
                                    }
                                } else {
                                    current_block = 5636883459695696059;
                                }
                                match current_block {
                                    3454747893076357924 => {}
                                    _ => {
                                        xmlSchemaClearElemInfo(vctxt, inode);
                                        if (*vctxt).depth == 0 as i32 {
                                            let fresh604 = &mut ((*vctxt).depth);
                                            *fresh604 -= 1;
                                            let fresh605 = &mut ((*vctxt).inode);
                                            *fresh605 = 0 as xmlSchemaNodeInfoPtr;
                                            return 0 as i32;
                                        }
                                        if !((*vctxt).aidcs).is_null() {
                                            let mut aidc: xmlSchemaIDCAugPtr = (*vctxt).aidcs;
                                            loop {
                                                if (*aidc).keyrefDepth == (*vctxt).depth {
                                                    (*aidc).keyrefDepth = -(1 as i32);
                                                }
                                                aidc = (*aidc).next;
                                                if aidc.is_null() {
                                                    break;
                                                }
                                            }
                                        }
                                        let fresh606 = &mut ((*vctxt).depth);
                                        *fresh606 -= 1;
                                        let fresh607 = &mut ((*vctxt).inode);
                                        *fresh607 = *((*vctxt).elemInfos)
                                            .offset((*vctxt).depth as isize);
                                        return ret;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    (*vctxt).err = -(1 as i32);
    return -(1 as i32);
}
unsafe extern "C" fn xmlSchemaValidateChildElem(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> i32 {
    let mut current_block: u64;
    let mut pielem: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
    let mut ptype: xmlSchemaTypePtr = 0 as *mut xmlSchemaType;
    let mut ret: i32 = 0 as i32;
    if (*vctxt).depth <= 0 as i32 {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaValidateChildElem\0" as *const u8 as *const i8,
            b"not intended for the validation root\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    pielem = *((*vctxt).elemInfos).offset(((*vctxt).depth - 1 as i32) as isize);
    if (*pielem).flags & (1 as i32) << 5 as i32 != 0 {
        (*pielem).flags ^= (1 as i32) << 5 as i32;
    }
    if (*pielem).flags & (1 as i32) << 2 as i32 != 0 {
        let fresh608 = &mut ((*vctxt).inode);
        *fresh608 = *((*vctxt).elemInfos)
            .offset(((*vctxt).depth - 1 as i32) as isize);
        ret = XML_SCHEMAV_CVC_ELT_3_2_1 as i32;
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            ret as xmlParserErrors,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"Neither character nor element content is allowed, because the element was 'nilled'\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        let fresh609 = &mut ((*vctxt).inode);
        *fresh609 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
    } else {
        ptype = (*pielem).typeDef;
        if (*ptype).builtInType == XML_SCHEMAS_ANYTYPE as i32 {
            let fresh610 = &mut ((*(*vctxt).inode).decl);
            *fresh610 = xmlSchemaGetElem(
                (*vctxt).schema,
                (*(*vctxt).inode).localName,
                (*(*vctxt).inode).nsName,
            );
            if ((*(*vctxt).inode).decl).is_null() {
                let mut iattr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
                iattr = xmlSchemaGetMetaAttrInfo(vctxt, 1 as i32);
                if !iattr.is_null() {
                    ret = xmlSchemaProcessXSIType(
                        vctxt,
                        iattr,
                        &mut (*(*vctxt).inode).typeDef,
                        0 as xmlSchemaElementPtr,
                    );
                    if ret != 0 as i32 {
                        if ret == -(1 as i32) {
                            xmlSchemaInternalErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                b"xmlSchemaValidateChildElem\0" as *const u8
                                    as *const i8,
                                b"calling xmlSchemaProcessXSIType() to process the attribute 'xsi:nil'\0"
                                    as *const u8 as *const i8,
                            );
                            return -(1 as i32);
                        }
                        return ret;
                    }
                } else {
                    let fresh611 = &mut ((*(*vctxt).inode).typeDef);
                    *fresh611 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
                }
            }
            return 0 as i32;
        }
        match (*ptype).contentType as u32 {
            1 => {
                let fresh612 = &mut ((*vctxt).inode);
                *fresh612 = *((*vctxt).elemInfos)
                    .offset(((*vctxt).depth - 1 as i32) as isize);
                ret = XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1 as i32;
                xmlSchemaCustomErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    ret as xmlParserErrors,
                    0 as xmlNodePtr,
                    0 as xmlSchemaBasicItemPtr,
                    b"Element content is not allowed, because the content type is empty\0"
                        as *const u8 as *const i8,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
                let fresh613 = &mut ((*vctxt).inode);
                *fresh613 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
                current_block = 16160522325362342750;
            }
            3 | 2 => {
                let mut regexCtxt: xmlRegExecCtxtPtr = 0 as *mut xmlRegExecCtxt;
                let mut values: [*mut xmlChar; 10] = [0 as *mut xmlChar; 10];
                let mut terminal: i32 = 0;
                let mut nbval: i32 = 10 as i32;
                let mut nbneg: i32 = 0;
                if ((*ptype).contModel).is_null() {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaValidateChildElem\0" as *const u8
                            as *const i8,
                        b"type has elem content but no content model\0" as *const u8
                            as *const i8,
                    );
                    return -(1 as i32);
                }
                if (*pielem).flags & (1 as i32) << 8 as i32 != 0 {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaValidateChildElem\0" as *const u8
                            as *const i8,
                        b"validating elem, but elem content is already invalid\0"
                            as *const u8 as *const i8,
                    );
                    return -(1 as i32);
                }
                regexCtxt = (*pielem).regexCtxt;
                if regexCtxt.is_null() {
                    regexCtxt = xmlRegNewExecCtxt(
                        (*ptype).contModel,
                        Some(
                            xmlSchemaVContentModelCallback
                                as unsafe extern "C" fn(
                                    xmlRegExecCtxtPtr,
                                    *const xmlChar,
                                    *mut libc::c_void,
                                    *mut libc::c_void,
                                ) -> (),
                        ),
                        vctxt as *mut libc::c_void,
                    );
                    if regexCtxt.is_null() {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaValidateChildElem\0" as *const u8
                                as *const i8,
                            b"failed to create a regex context\0" as *const u8
                                as *const i8,
                        );
                        return -(1 as i32);
                    }
                    let fresh614 = &mut ((*pielem).regexCtxt);
                    *fresh614 = regexCtxt;
                }
                ret = xmlRegExecPushString2(
                    regexCtxt,
                    (*(*vctxt).inode).localName,
                    (*(*vctxt).inode).nsName,
                    (*vctxt).inode as *mut libc::c_void,
                );
                if (*vctxt).err == XML_SCHEMAV_INTERNAL as i32 {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaValidateChildElem\0" as *const u8
                            as *const i8,
                        b"calling xmlRegExecPushString2()\0" as *const u8
                            as *const i8,
                    );
                    return -(1 as i32);
                }
                if ret < 0 as i32 {
                    xmlRegExecErrInfo(
                        regexCtxt,
                        0 as *mut *const xmlChar,
                        &mut nbval,
                        &mut nbneg,
                        &mut *values.as_mut_ptr().offset(0 as i32 as isize),
                        &mut terminal,
                    );
                    xmlSchemaComplexTypeErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAV_ELEMENT_CONTENT,
                        0 as xmlNodePtr,
                        0 as xmlSchemaTypePtr,
                        b"This element is not expected\0" as *const u8
                            as *const i8,
                        nbval,
                        nbneg,
                        values.as_mut_ptr(),
                    );
                    ret = (*vctxt).err;
                    current_block = 16160522325362342750;
                } else {
                    ret = 0 as i32;
                    current_block = 3879520548144599102;
                }
            }
            4 | 6 => {
                let fresh615 = &mut ((*vctxt).inode);
                *fresh615 = *((*vctxt).elemInfos)
                    .offset(((*vctxt).depth - 1 as i32) as isize);
                if (*ptype).type_0 as u32
                    == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                    || (*ptype).builtInType == XML_SCHEMAS_ANYTYPE as i32
                {
                    ret = XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2 as i32;
                    xmlSchemaCustomErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        ret as xmlParserErrors,
                        0 as xmlNodePtr,
                        0 as xmlSchemaBasicItemPtr,
                        b"Element content is not allowed, because the content type is a simple type definition\0"
                            as *const u8 as *const i8,
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                } else {
                    ret = XML_SCHEMAV_CVC_TYPE_3_1_2 as i32;
                    xmlSchemaCustomErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        ret as xmlParserErrors,
                        0 as xmlNodePtr,
                        0 as xmlSchemaBasicItemPtr,
                        b"Element content is not allowed, because the type definition is simple\0"
                            as *const u8 as *const i8,
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                }
                let fresh616 = &mut ((*vctxt).inode);
                *fresh616 = *((*vctxt).elemInfos).offset((*vctxt).depth as isize);
                ret = (*vctxt).err;
                current_block = 16160522325362342750;
            }
            _ => {
                current_block = 3879520548144599102;
            }
        }
        match current_block {
            16160522325362342750 => {}
            _ => return ret,
        }
    }
    (*vctxt).skipDepth = (*vctxt).depth;
    (*(*vctxt).inode).flags |= (1 as i32) << 9 as i32;
    (*pielem).flags |= (1 as i32) << 8 as i32;
    return ret;
}
unsafe extern "C" fn xmlSchemaVPushText(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut nodeType: i32,
    mut value: *const xmlChar,
    mut len: i32,
    mut mode: i32,
    mut consumed: *mut i32,
) -> i32 {
    if !consumed.is_null() {
        *consumed = 0 as i32;
    }
    if (*(*vctxt).inode).flags & (1 as i32) << 2 as i32 != 0 {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_ELT_3_2_1,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"Neither character nor element content is allowed because the element is 'nilled'\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*vctxt).err;
    }
    if (*(*(*vctxt).inode).typeDef).contentType as u32
        == XML_SCHEMA_CONTENT_EMPTY as i32 as u32
    {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"Character content is not allowed, because the content type is empty\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*vctxt).err;
    }
    if (*(*(*vctxt).inode).typeDef).contentType as u32
        == XML_SCHEMA_CONTENT_ELEMENTS as i32 as u32
    {
        if nodeType != XML_TEXT_NODE as i32
            || xmlSchemaIsBlank(value as *mut xmlChar, len) == 0
        {
            xmlSchemaCustomErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3,
                0 as xmlNodePtr,
                0 as xmlSchemaBasicItemPtr,
                b"Character content other than whitespace is not allowed because the content type is 'element-only'\0"
                    as *const u8 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return (*vctxt).err;
        }
        return 0 as i32;
    }
    if value.is_null()
        || *value.offset(0 as i32 as isize) as i32 == 0 as i32
    {
        return 0 as i32;
    }
    if (*(*(*vctxt).inode).typeDef).contentType as u32
        == XML_SCHEMA_CONTENT_MIXED as i32 as u32
        && (((*(*vctxt).inode).decl).is_null()
            || ((*(*(*vctxt).inode).decl).value).is_null())
    {
        return 0 as i32;
    }
    if ((*(*vctxt).inode).value).is_null() {
        match mode {
            1 => {
                let fresh617 = &mut ((*(*vctxt).inode).value);
                *fresh617 = value;
            }
            2 => {
                let fresh618 = &mut ((*(*vctxt).inode).value);
                *fresh618 = value;
                if !consumed.is_null() {
                    *consumed = 1 as i32;
                }
                (*(*vctxt).inode).flags |= (1 as i32) << 1 as i32;
            }
            3 => {
                if len != -(1 as i32) {
                    let fresh619 = &mut ((*(*vctxt).inode).value);
                    *fresh619 = xmlStrndup(value, len);
                } else {
                    let fresh620 = &mut ((*(*vctxt).inode).value);
                    *fresh620 = xmlStrdup(value);
                }
                (*(*vctxt).inode).flags |= (1 as i32) << 1 as i32;
            }
            _ => {}
        }
    } else {
        if len < 0 as i32 {
            len = xmlStrlen(value);
        }
        if (*(*vctxt).inode).flags & (1 as i32) << 1 as i32 != 0 {
            let fresh621 = &mut ((*(*vctxt).inode).value);
            *fresh621 = xmlStrncat((*(*vctxt).inode).value as *mut xmlChar, value, len);
        } else {
            let fresh622 = &mut ((*(*vctxt).inode).value);
            *fresh622 = xmlStrncatNew((*(*vctxt).inode).value, value, len);
            (*(*vctxt).inode).flags |= (1 as i32) << 1 as i32;
        }
    }
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaValidateElem(
    mut vctxt: xmlSchemaValidCtxtPtr,
) -> i32 {
    let mut current_block: u64;
    let mut ret: i32 = 0 as i32;
    if (*vctxt).skipDepth != -(1 as i32) && (*vctxt).depth >= (*vctxt).skipDepth
    {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaValidateElem\0" as *const u8 as *const i8,
            b"in skip-state\0" as *const u8 as *const i8,
        );
    } else {
        if (*vctxt).xsiAssemble != 0 {
            ret = xmlSchemaAssembleByXSI(vctxt);
            if ret != 0 as i32 {
                if ret == -(1 as i32) {
                    current_block = 17069188355963176026;
                } else {
                    (*vctxt).skipDepth = 0 as i32;
                    return ret;
                }
            } else {
                xmlHashScan(
                    (*(*vctxt).schema).schemasImports,
                    Some(
                        xmlSchemaAugmentImportedIDC
                            as unsafe extern "C" fn(
                                *mut libc::c_void,
                                *mut libc::c_void,
                                *const xmlChar,
                            ) -> (),
                    ),
                    vctxt as *mut libc::c_void,
                );
                current_block = 13536709405535804910;
            }
        } else {
            current_block = 13536709405535804910;
        }
        match current_block {
            17069188355963176026 => {}
            _ => {
                if (*vctxt).depth > 0 as i32 {
                    ret = xmlSchemaValidateChildElem(vctxt);
                    if ret != 0 as i32 {
                        if ret < 0 as i32 {
                            xmlSchemaInternalErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                b"xmlSchemaValidateElem\0" as *const u8
                                    as *const i8,
                                b"calling xmlSchemaStreamValidateChildElement()\0"
                                    as *const u8 as *const i8,
                            );
                            current_block = 17069188355963176026;
                        } else {
                            current_block = 6848767425915334727;
                        }
                    } else if (*vctxt).depth == (*vctxt).skipDepth {
                        current_block = 6848767425915334727;
                    } else if ((*(*vctxt).inode).decl).is_null()
                            && ((*(*vctxt).inode).typeDef).is_null()
                        {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaValidateElem\0" as *const u8
                                as *const i8,
                            b"the child element was valid but neither the declaration nor the type was set\0"
                                as *const u8 as *const i8,
                        );
                        current_block = 17069188355963176026;
                    } else {
                        current_block = 16924917904204750491;
                    }
                } else {
                    let fresh623 = &mut ((*(*vctxt).inode).decl);
                    *fresh623 = xmlSchemaGetElem(
                        (*vctxt).schema,
                        (*(*vctxt).inode).localName,
                        (*(*vctxt).inode).nsName,
                    );
                    if ((*(*vctxt).inode).decl).is_null() {
                        ret = XML_SCHEMAV_CVC_ELT_1 as i32;
                        xmlSchemaCustomErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            ret as xmlParserErrors,
                            0 as xmlNodePtr,
                            0 as xmlSchemaBasicItemPtr,
                            b"No matching global declaration available for the validation root\0"
                                as *const u8 as *const i8,
                            0 as *const xmlChar,
                            0 as *const xmlChar,
                        );
                        current_block = 6848767425915334727;
                    } else {
                        current_block = 16924917904204750491;
                    }
                }
                match current_block {
                    17069188355963176026 => {}
                    _ => {
                        match current_block {
                            16924917904204750491 => {
                                if ((*(*vctxt).inode).decl).is_null() {
                                    current_block = 10371967630163830273;
                                } else {
                                    if (*(*(*vctxt).inode).decl).type_0 as u32
                                        == XML_SCHEMA_TYPE_ANY as i32 as u32
                                    {
                                        let mut skip: i32 = 0;
                                        ret = xmlSchemaValidateElemWildcard(vctxt, &mut skip);
                                        if ret != 0 as i32 {
                                            if ret < 0 as i32 {
                                                xmlSchemaInternalErr(
                                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                                    b"xmlSchemaValidateElem\0" as *const u8
                                                        as *const i8,
                                                    b"calling xmlSchemaValidateElemWildcard()\0" as *const u8
                                                        as *const i8,
                                                );
                                                current_block = 17069188355963176026;
                                            } else {
                                                current_block = 6848767425915334727;
                                            }
                                        } else if skip != 0 {
                                            (*vctxt).skipDepth = (*vctxt).depth;
                                            current_block = 6848767425915334727;
                                        } else if (*(*(*vctxt).inode).decl).type_0 as u32
                                                != XML_SCHEMA_TYPE_ELEMENT as i32 as u32
                                            {
                                            let fresh624 = &mut ((*(*vctxt).inode).decl);
                                            *fresh624 = 0 as xmlSchemaElementPtr;
                                            current_block = 10371967630163830273;
                                        } else {
                                            current_block = 790185930182612747;
                                        }
                                    } else {
                                        current_block = 790185930182612747;
                                    }
                                    match current_block {
                                        6848767425915334727 => {}
                                        17069188355963176026 => {}
                                        10371967630163830273 => {}
                                        _ => {
                                            ret = xmlSchemaValidateElemDecl(vctxt);
                                            if ret != 0 as i32 {
                                                if ret < 0 as i32 {
                                                    xmlSchemaInternalErr(
                                                        vctxt as xmlSchemaAbstractCtxtPtr,
                                                        b"xmlSchemaValidateElem\0" as *const u8
                                                            as *const i8,
                                                        b"calling xmlSchemaValidateElemDecl()\0" as *const u8
                                                            as *const i8,
                                                    );
                                                    current_block = 17069188355963176026;
                                                } else {
                                                    current_block = 6848767425915334727;
                                                }
                                            } else {
                                                current_block = 10371967630163830273;
                                            }
                                        }
                                    }
                                }
                                match current_block {
                                    6848767425915334727 => {}
                                    17069188355963176026 => {}
                                    _ => {
                                        if ((*(*vctxt).inode).typeDef).is_null() {
                                            (*(*vctxt).inode).flags
                                                |= (1 as i32) << 10 as i32;
                                            ret = XML_SCHEMAV_CVC_TYPE_1 as i32;
                                            xmlSchemaCustomErr(
                                                vctxt as xmlSchemaAbstractCtxtPtr,
                                                ret as xmlParserErrors,
                                                0 as xmlNodePtr,
                                                0 as xmlSchemaBasicItemPtr,
                                                b"The type definition is absent\0" as *const u8
                                                    as *const i8,
                                                0 as *const xmlChar,
                                                0 as *const xmlChar,
                                            );
                                            current_block = 6848767425915334727;
                                        } else if (*(*(*vctxt).inode).typeDef).flags
                                                & (1 as i32) << 20 as i32 != 0
                                            {
                                            (*(*vctxt).inode).flags
                                                |= (1 as i32) << 10 as i32;
                                            ret = XML_SCHEMAV_CVC_TYPE_2 as i32;
                                            xmlSchemaCustomErr(
                                                vctxt as xmlSchemaAbstractCtxtPtr,
                                                ret as xmlParserErrors,
                                                0 as xmlNodePtr,
                                                0 as xmlSchemaBasicItemPtr,
                                                b"The type definition is abstract\0" as *const u8
                                                    as *const i8,
                                                0 as *const xmlChar,
                                                0 as *const xmlChar,
                                            );
                                            current_block = 6848767425915334727;
                                        } else {
                                            if !((*vctxt).xpathStates).is_null() {
                                                ret = xmlSchemaXPathEvaluate(vctxt, XML_ELEMENT_NODE);
                                                (*(*vctxt).inode).appliedXPath = 1 as i32;
                                                if ret == -(1 as i32) {
                                                    xmlSchemaInternalErr(
                                                        vctxt as xmlSchemaAbstractCtxtPtr,
                                                        b"xmlSchemaValidateElem\0" as *const u8
                                                            as *const i8,
                                                        b"calling xmlSchemaXPathEvaluate()\0" as *const u8
                                                            as *const i8,
                                                    );
                                                    current_block = 17069188355963176026;
                                                } else {
                                                    current_block = 1874315696050160458;
                                                }
                                            } else {
                                                current_block = 1874315696050160458;
                                            }
                                            match current_block {
                                                17069188355963176026 => {}
                                                _ => {
                                                    if (*(*(*vctxt).inode).typeDef).type_0 as u32
                                                        == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                                                        || (*(*(*vctxt).inode).typeDef).builtInType
                                                            == XML_SCHEMAS_ANYTYPE as i32
                                                    {
                                                        if (*vctxt).nbAttrInfos != 0 as i32
                                                            || !((*(*(*vctxt).inode).typeDef).attrUses).is_null()
                                                        {
                                                            ret = xmlSchemaVAttributesComplex(vctxt);
                                                        }
                                                    } else if (*vctxt).nbAttrInfos != 0 as i32 {
                                                        ret = xmlSchemaVAttributesSimple(vctxt);
                                                    }
                                                    if (*vctxt).nbAttrInfos != 0 as i32 {
                                                        xmlSchemaClearAttrInfos(vctxt);
                                                    }
                                                    if ret == -(1 as i32) {
                                                        xmlSchemaInternalErr(
                                                            vctxt as xmlSchemaAbstractCtxtPtr,
                                                            b"xmlSchemaValidateElem\0" as *const u8
                                                                as *const i8,
                                                            b"calling attributes validation\0" as *const u8
                                                                as *const i8,
                                                        );
                                                        current_block = 17069188355963176026;
                                                    } else {
                                                        ret = 0 as i32;
                                                        current_block = 6848767425915334727;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                        match current_block {
                            17069188355963176026 => {}
                            _ => {
                                if ret != 0 as i32 {
                                    (*vctxt).skipDepth = (*vctxt).depth;
                                }
                                return ret;
                            }
                        }
                    }
                }
            }
        }
    }
    return -(1 as i32);
}
unsafe extern "C" fn xmlSchemaSAXHandleText(
    mut ctx: *mut libc::c_void,
    mut ch: *const xmlChar,
    mut len: i32,
) {
    let mut vctxt: xmlSchemaValidCtxtPtr = ctx as xmlSchemaValidCtxtPtr;
    if (*vctxt).depth < 0 as i32 {
        return;
    }
    if (*vctxt).skipDepth != -(1 as i32) && (*vctxt).depth >= (*vctxt).skipDepth
    {
        return;
    }
    if (*(*vctxt).inode).flags & (1 as i32) << 5 as i32 != 0 {
        (*(*vctxt).inode).flags ^= (1 as i32) << 5 as i32;
    }
    if xmlSchemaVPushText(
        vctxt,
        XML_TEXT_NODE as i32,
        ch,
        len,
        3 as i32,
        0 as *mut i32,
    ) == -(1 as i32)
    {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaSAXHandleCDataSection\0" as *const u8 as *const i8,
            b"calling xmlSchemaVPushText()\0" as *const u8 as *const i8,
        );
        (*vctxt).err = -(1 as i32);
        xmlStopParser((*vctxt).parserCtxt);
    }
}
unsafe extern "C" fn xmlSchemaSAXHandleCDataSection(
    mut ctx: *mut libc::c_void,
    mut ch: *const xmlChar,
    mut len: i32,
) {
    let mut vctxt: xmlSchemaValidCtxtPtr = ctx as xmlSchemaValidCtxtPtr;
    if (*vctxt).depth < 0 as i32 {
        return;
    }
    if (*vctxt).skipDepth != -(1 as i32) && (*vctxt).depth >= (*vctxt).skipDepth
    {
        return;
    }
    if (*(*vctxt).inode).flags & (1 as i32) << 5 as i32 != 0 {
        (*(*vctxt).inode).flags ^= (1 as i32) << 5 as i32;
    }
    if xmlSchemaVPushText(
        vctxt,
        XML_CDATA_SECTION_NODE as i32,
        ch,
        len,
        3 as i32,
        0 as *mut i32,
    ) == -(1 as i32)
    {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaSAXHandleCDataSection\0" as *const u8 as *const i8,
            b"calling xmlSchemaVPushText()\0" as *const u8 as *const i8,
        );
        (*vctxt).err = -(1 as i32);
        xmlStopParser((*vctxt).parserCtxt);
    }
}
unsafe extern "C" fn xmlSchemaSAXHandleReference(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
) {
    let mut vctxt: xmlSchemaValidCtxtPtr = ctx as xmlSchemaValidCtxtPtr;
    if (*vctxt).depth < 0 as i32 {
        return;
    }
    if (*vctxt).skipDepth != -(1 as i32) && (*vctxt).depth >= (*vctxt).skipDepth
    {
        return;
    }
    (*__xmlGenericError())
        .expect(
            "non-null function pointer",
        )(
        *__xmlGenericErrorContext(),
        b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
        b"xmlschemas.c\0" as *const u8 as *const i8,
        27517 as i32,
    );
}
unsafe extern "C" fn xmlSchemaSAXHandleStartElementNs(
    mut ctx: *mut libc::c_void,
    mut localname: *const xmlChar,
    mut prefix: *const xmlChar,
    mut URI: *const xmlChar,
    mut nb_namespaces: i32,
    mut namespaces: *mut *const xmlChar,
    mut nb_attributes: i32,
    mut nb_defaulted: i32,
    mut attributes: *mut *const xmlChar,
) {
    let mut current_block: u64;
    let mut vctxt: xmlSchemaValidCtxtPtr = ctx as xmlSchemaValidCtxtPtr;
    let mut ret: i32 = 0;
    let mut ielem: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
    let mut i: i32 = 0;
    let mut j: i32 = 0;
    let fresh625 = &mut ((*vctxt).depth);
    *fresh625 += 1;
    if (*vctxt).skipDepth != -(1 as i32) && (*vctxt).depth >= (*vctxt).skipDepth
    {
        return;
    }
    if xmlSchemaValidatorPushElem(vctxt) == -(1 as i32) {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaSAXHandleStartElementNs\0" as *const u8 as *const i8,
            b"calling xmlSchemaValidatorPushElem()\0" as *const u8 as *const i8,
        );
    } else {
        ielem = (*vctxt).inode;
        (*ielem)
            .nodeLine = xmlSAX2GetLineNumber((*vctxt).parserCtxt as *mut libc::c_void);
        let fresh626 = &mut ((*ielem).localName);
        *fresh626 = localname;
        let fresh627 = &mut ((*ielem).nsName);
        *fresh627 = URI;
        (*ielem).flags |= (1 as i32) << 5 as i32;
        if nb_namespaces != 0 as i32 {
            i = 0 as i32;
            j = 0 as i32;
            loop {
                if !(i < nb_namespaces) {
                    current_block = 14434620278749266018;
                    break;
                }
                if ((*ielem).nsBindings).is_null() {
                    let fresh628 = &mut ((*ielem).nsBindings);
                    *fresh628 = xmlMalloc
                        .expect(
                            "non-null function pointer",
                        )(
                        (10 as i32 as u64)
                            .wrapping_mul(
                                ::std::mem::size_of::<*const xmlChar>() as u64,
                            ),
                    ) as *mut *const xmlChar;
                    if ((*ielem).nsBindings).is_null() {
                        xmlSchemaVErrMemory(
                            vctxt,
                            b"allocating namespace bindings for SAX validation\0"
                                as *const u8 as *const i8,
                            0 as xmlNodePtr,
                        );
                        current_block = 757928548486660075;
                        break;
                    } else {
                        (*ielem).nbNsBindings = 0 as i32;
                        (*ielem).sizeNsBindings = 5 as i32;
                    }
                } else if (*ielem).sizeNsBindings <= (*ielem).nbNsBindings {
                    (*ielem).sizeNsBindings *= 2 as i32;
                    let fresh629 = &mut ((*ielem).nsBindings);
                    *fresh629 = xmlRealloc
                        .expect(
                            "non-null function pointer",
                        )(
                        (*ielem).nsBindings as *mut libc::c_void,
                        (((*ielem).sizeNsBindings * 2 as i32) as u64)
                            .wrapping_mul(
                                ::std::mem::size_of::<*const xmlChar>() as u64,
                            ),
                    ) as *mut *const xmlChar;
                    if ((*ielem).nsBindings).is_null() {
                        xmlSchemaVErrMemory(
                            vctxt,
                            b"re-allocating namespace bindings for SAX validation\0"
                                as *const u8 as *const i8,
                            0 as xmlNodePtr,
                        );
                        current_block = 757928548486660075;
                        break;
                    }
                }
                let fresh630 = &mut (*((*ielem).nsBindings)
                    .offset(((*ielem).nbNsBindings * 2 as i32) as isize));
                *fresh630 = *namespaces.offset(j as isize);
                if *(*namespaces.offset((j + 1 as i32) as isize))
                    .offset(0 as i32 as isize) as i32 == 0 as i32
                {
                    let fresh631 = &mut (*((*ielem).nsBindings)
                        .offset(
                            ((*ielem).nbNsBindings * 2 as i32 + 1 as i32)
                                as isize,
                        ));
                    *fresh631 = 0 as *const xmlChar;
                } else {
                    let fresh632 = &mut (*((*ielem).nsBindings)
                        .offset(
                            ((*ielem).nbNsBindings * 2 as i32 + 1 as i32)
                                as isize,
                        ));
                    *fresh632 = *namespaces.offset((j + 1 as i32) as isize);
                }
                let fresh633 = &mut ((*ielem).nbNsBindings);
                *fresh633 += 1;
                i += 1;
                j += 2 as i32;
            }
        } else {
            current_block = 14434620278749266018;
        }
        match current_block {
            757928548486660075 => {}
            _ => {
                if nb_attributes != 0 as i32 {
                    let mut valueLen: i32 = 0;
                    let mut k: i32 = 0;
                    let mut l: i32 = 0;
                    let mut value: *mut xmlChar = 0 as *mut xmlChar;
                    j = 0 as i32;
                    i = 0 as i32;
                    loop {
                        if !(i < nb_attributes) {
                            current_block = 9241535491006583629;
                            break;
                        }
                        valueLen = (*attributes.offset((j + 4 as i32) as isize))
                            .offset_from(
                                *attributes.offset((j + 3 as i32) as isize),
                            ) as i64 as i32;
                        value = xmlMallocAtomic
                            .expect(
                                "non-null function pointer",
                            )((valueLen + 1 as i32) as size_t) as *mut xmlChar;
                        if value.is_null() {
                            xmlSchemaVErrMemory(
                                vctxt,
                                b"allocating string for decoded attribute\0" as *const u8
                                    as *const i8,
                                0 as xmlNodePtr,
                            );
                            current_block = 757928548486660075;
                            break;
                        } else {
                            k = 0 as i32;
                            l = 0 as i32;
                            while k < valueLen {
                                if k < valueLen - 4 as i32
                                    && *(*attributes.offset((j + 3 as i32) as isize))
                                        .offset((k + 0 as i32) as isize) as i32
                                        == '&' as i32
                                    && *(*attributes.offset((j + 3 as i32) as isize))
                                        .offset((k + 1 as i32) as isize) as i32
                                        == '#' as i32
                                    && *(*attributes.offset((j + 3 as i32) as isize))
                                        .offset((k + 2 as i32) as isize) as i32
                                        == '3' as i32
                                    && *(*attributes.offset((j + 3 as i32) as isize))
                                        .offset((k + 3 as i32) as isize) as i32
                                        == '8' as i32
                                    && *(*attributes.offset((j + 3 as i32) as isize))
                                        .offset((k + 4 as i32) as isize) as i32
                                        == ';' as i32
                                {
                                    *value.offset(l as isize) = '&' as i32 as xmlChar;
                                    k += 5 as i32;
                                } else {
                                    *value
                                        .offset(
                                            l as isize,
                                        ) = *(*attributes.offset((j + 3 as i32) as isize))
                                        .offset(k as isize);
                                    k += 1;
                                }
                                l += 1;
                            }
                            *value.offset(l as isize) = '\u{0}' as i32 as xmlChar;
                            ret = xmlSchemaValidatorPushAttribute(
                                vctxt,
                                0 as xmlNodePtr,
                                (*ielem).nodeLine,
                                *attributes.offset(j as isize),
                                *attributes.offset((j + 2 as i32) as isize),
                                0 as i32,
                                value,
                                1 as i32,
                            );
                            if ret == -(1 as i32) {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaSAXHandleStartElementNs\0" as *const u8
                                        as *const i8,
                                    b"calling xmlSchemaValidatorPushAttribute()\0" as *const u8
                                        as *const i8,
                                );
                                current_block = 757928548486660075;
                                break;
                            } else {
                                i += 1;
                                j += 5 as i32;
                            }
                        }
                    }
                } else {
                    current_block = 9241535491006583629;
                }
                match current_block {
                    757928548486660075 => {}
                    _ => {
                        ret = xmlSchemaValidateElem(vctxt);
                        if ret != 0 as i32 {
                            if ret == -(1 as i32) {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaSAXHandleStartElementNs\0" as *const u8
                                        as *const i8,
                                    b"calling xmlSchemaValidateElem()\0" as *const u8
                                        as *const i8,
                                );
                                current_block = 757928548486660075;
                            } else {
                                current_block = 2482997575520911882;
                            }
                        } else {
                            current_block = 2482997575520911882;
                        }
                        match current_block {
                            757928548486660075 => {}
                            _ => return,
                        }
                    }
                }
            }
        }
    }
    (*vctxt).err = -(1 as i32);
    xmlStopParser((*vctxt).parserCtxt);
}
unsafe extern "C" fn xmlSchemaSAXHandleEndElementNs(
    mut ctx: *mut libc::c_void,
    mut localname: *const xmlChar,
    mut prefix: *const xmlChar,
    mut URI: *const xmlChar,
) {
    let mut vctxt: xmlSchemaValidCtxtPtr = ctx as xmlSchemaValidCtxtPtr;
    let mut res: i32 = 0;
    if (*vctxt).skipDepth != -(1 as i32) {
        if (*vctxt).depth > (*vctxt).skipDepth {
            let fresh634 = &mut ((*vctxt).depth);
            *fresh634 -= 1;
            return;
        } else {
            (*vctxt).skipDepth = -(1 as i32);
        }
    }
    if xmlStrEqual((*(*vctxt).inode).localName, localname) == 0
        || xmlStrEqual((*(*vctxt).inode).nsName, URI) == 0
    {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaSAXHandleEndElementNs\0" as *const u8 as *const i8,
            b"elem pop mismatch\0" as *const u8 as *const i8,
        );
    }
    res = xmlSchemaValidatorPopElem(vctxt);
    if res != 0 as i32 {
        if res < 0 as i32 {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaSAXHandleEndElementNs\0" as *const u8 as *const i8,
                b"calling xmlSchemaValidatorPopElem()\0" as *const u8
                    as *const i8,
            );
            (*vctxt).err = -(1 as i32);
            xmlStopParser((*vctxt).parserCtxt);
            return;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaNewValidCtxt(
    mut schema: xmlSchemaPtr,
) -> xmlSchemaValidCtxtPtr {
    let mut ret: xmlSchemaValidCtxtPtr = 0 as *mut xmlSchemaValidCtxt;
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaValidCtxt>() as u64)
        as xmlSchemaValidCtxtPtr;
    if ret.is_null() {
        xmlSchemaVErrMemory(
            0 as xmlSchemaValidCtxtPtr,
            b"allocating validation context\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaValidCtxtPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaValidCtxt>() as u64,
    );
    (*ret).type_0 = 2 as i32;
    let fresh635 = &mut ((*ret).dict);
    *fresh635 = xmlDictCreate();
    let fresh636 = &mut ((*ret).nodeQNames);
    *fresh636 = xmlSchemaItemListCreate();
    let fresh637 = &mut ((*ret).schema);
    *fresh637 = schema;
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateSetFilename(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut filename: *const i8,
) {
    if vctxt.is_null() {
        return;
    }
    if !((*vctxt).filename).is_null() {
        xmlFree
            .expect("non-null function pointer")((*vctxt).filename as *mut libc::c_void);
    }
    if !filename.is_null() {
        let fresh638 = &mut ((*vctxt).filename);
        *fresh638 = xmlStrdup(filename as *const xmlChar) as *mut i8;
    } else {
        let fresh639 = &mut ((*vctxt).filename);
        *fresh639 = 0 as *mut i8;
    };
}
unsafe extern "C" fn xmlSchemaClearValidCtxt(mut vctxt: xmlSchemaValidCtxtPtr) {
    if vctxt.is_null() {
        return;
    }
    (*vctxt).flags = 0 as i32;
    let fresh640 = &mut ((*vctxt).validationRoot);
    *fresh640 = 0 as xmlNodePtr;
    let fresh641 = &mut ((*vctxt).doc);
    *fresh641 = 0 as xmlDocPtr;
    let fresh642 = &mut ((*vctxt).reader);
    *fresh642 = 0 as xmlTextReaderPtr;
    (*vctxt).hasKeyrefs = 0 as i32;
    if !((*vctxt).value).is_null() {
        xmlSchemaFreeValue((*vctxt).value);
        let fresh643 = &mut ((*vctxt).value);
        *fresh643 = 0 as xmlSchemaValPtr;
    }
    if !((*vctxt).aidcs).is_null() {
        let mut cur: xmlSchemaIDCAugPtr = (*vctxt).aidcs;
        let mut next: xmlSchemaIDCAugPtr = 0 as *mut xmlSchemaIDCAug;
        loop {
            next = (*cur).next;
            xmlFree.expect("non-null function pointer")(cur as *mut libc::c_void);
            cur = next;
            if cur.is_null() {
                break;
            }
        }
        let fresh644 = &mut ((*vctxt).aidcs);
        *fresh644 = 0 as xmlSchemaIDCAugPtr;
    }
    if !((*vctxt).idcNodes).is_null() {
        let mut i: i32 = 0;
        let mut item: xmlSchemaPSVIIDCNodePtr = 0 as *mut xmlSchemaPSVIIDCNode;
        i = 0 as i32;
        while i < (*vctxt).nbIdcNodes {
            item = *((*vctxt).idcNodes).offset(i as isize);
            xmlFree
                .expect("non-null function pointer")((*item).keys as *mut libc::c_void);
            xmlFree.expect("non-null function pointer")(item as *mut libc::c_void);
            i += 1;
        }
        xmlFree
            .expect("non-null function pointer")((*vctxt).idcNodes as *mut libc::c_void);
        let fresh645 = &mut ((*vctxt).idcNodes);
        *fresh645 = 0 as *mut xmlSchemaPSVIIDCNodePtr;
        (*vctxt).nbIdcNodes = 0 as i32;
        (*vctxt).sizeIdcNodes = 0 as i32;
    }
    if !((*vctxt).idcKeys).is_null() {
        let mut i_0: i32 = 0;
        i_0 = 0 as i32;
        while i_0 < (*vctxt).nbIdcKeys {
            xmlSchemaIDCFreeKey(*((*vctxt).idcKeys).offset(i_0 as isize));
            i_0 += 1;
        }
        xmlFree
            .expect("non-null function pointer")((*vctxt).idcKeys as *mut libc::c_void);
        let fresh646 = &mut ((*vctxt).idcKeys);
        *fresh646 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
        (*vctxt).nbIdcKeys = 0 as i32;
        (*vctxt).sizeIdcKeys = 0 as i32;
    }
    if !((*vctxt).xpathStates).is_null() {
        xmlSchemaFreeIDCStateObjList((*vctxt).xpathStates);
        let fresh647 = &mut ((*vctxt).xpathStates);
        *fresh647 = 0 as xmlSchemaIDCStateObjPtr;
    }
    if (*vctxt).nbAttrInfos != 0 as i32 {
        xmlSchemaClearAttrInfos(vctxt);
    }
    if !((*vctxt).elemInfos).is_null() {
        let mut i_1: i32 = 0;
        let mut ei: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
        i_1 = 0 as i32;
        while i_1 < (*vctxt).sizeElemInfos {
            ei = *((*vctxt).elemInfos).offset(i_1 as isize);
            if ei.is_null() {
                break;
            }
            xmlSchemaClearElemInfo(vctxt, ei);
            i_1 += 1;
        }
    }
    xmlSchemaItemListClear((*vctxt).nodeQNames);
    xmlDictFree((*vctxt).dict);
    let fresh648 = &mut ((*vctxt).dict);
    *fresh648 = xmlDictCreate();
    if !((*vctxt).filename).is_null() {
        xmlFree
            .expect("non-null function pointer")((*vctxt).filename as *mut libc::c_void);
        let fresh649 = &mut ((*vctxt).filename);
        *fresh649 = 0 as *mut i8;
    }
    if !((*vctxt).idcMatcherCache).is_null() {
        let mut matcher: xmlSchemaIDCMatcherPtr = (*vctxt).idcMatcherCache;
        let mut tmp: xmlSchemaIDCMatcherPtr = 0 as *mut xmlSchemaIDCMatcher;
        while !matcher.is_null() {
            tmp = matcher;
            matcher = (*matcher).nextCached;
            xmlSchemaIDCFreeMatcherList(tmp);
        }
        let fresh650 = &mut ((*vctxt).idcMatcherCache);
        *fresh650 = 0 as xmlSchemaIDCMatcherPtr;
    }
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaFreeValidCtxt(mut ctxt: xmlSchemaValidCtxtPtr) {
    if ctxt.is_null() {
        return;
    }
    if !((*ctxt).value).is_null() {
        xmlSchemaFreeValue((*ctxt).value);
    }
    if !((*ctxt).pctxt).is_null() {
        xmlSchemaFreeParserCtxt((*ctxt).pctxt);
    }
    if !((*ctxt).idcNodes).is_null() {
        let mut i: i32 = 0;
        let mut item: xmlSchemaPSVIIDCNodePtr = 0 as *mut xmlSchemaPSVIIDCNode;
        i = 0 as i32;
        while i < (*ctxt).nbIdcNodes {
            item = *((*ctxt).idcNodes).offset(i as isize);
            xmlFree
                .expect("non-null function pointer")((*item).keys as *mut libc::c_void);
            xmlFree.expect("non-null function pointer")(item as *mut libc::c_void);
            i += 1;
        }
        xmlFree
            .expect("non-null function pointer")((*ctxt).idcNodes as *mut libc::c_void);
    }
    if !((*ctxt).idcKeys).is_null() {
        let mut i_0: i32 = 0;
        i_0 = 0 as i32;
        while i_0 < (*ctxt).nbIdcKeys {
            xmlSchemaIDCFreeKey(*((*ctxt).idcKeys).offset(i_0 as isize));
            i_0 += 1;
        }
        xmlFree
            .expect("non-null function pointer")((*ctxt).idcKeys as *mut libc::c_void);
    }
    if !((*ctxt).xpathStates).is_null() {
        xmlSchemaFreeIDCStateObjList((*ctxt).xpathStates);
        let fresh651 = &mut ((*ctxt).xpathStates);
        *fresh651 = 0 as xmlSchemaIDCStateObjPtr;
    }
    if !((*ctxt).xpathStatePool).is_null() {
        xmlSchemaFreeIDCStateObjList((*ctxt).xpathStatePool);
        let fresh652 = &mut ((*ctxt).xpathStatePool);
        *fresh652 = 0 as xmlSchemaIDCStateObjPtr;
    }
    if !((*ctxt).aidcs).is_null() {
        let mut cur: xmlSchemaIDCAugPtr = (*ctxt).aidcs;
        let mut next: xmlSchemaIDCAugPtr = 0 as *mut xmlSchemaIDCAug;
        loop {
            next = (*cur).next;
            xmlFree.expect("non-null function pointer")(cur as *mut libc::c_void);
            cur = next;
            if cur.is_null() {
                break;
            }
        }
    }
    if !((*ctxt).attrInfos).is_null() {
        let mut i_1: i32 = 0;
        let mut attr: xmlSchemaAttrInfoPtr = 0 as *mut xmlSchemaAttrInfo;
        if (*ctxt).nbAttrInfos != 0 as i32 {
            xmlSchemaClearAttrInfos(ctxt);
        }
        i_1 = 0 as i32;
        while i_1 < (*ctxt).sizeAttrInfos {
            attr = *((*ctxt).attrInfos).offset(i_1 as isize);
            xmlFree.expect("non-null function pointer")(attr as *mut libc::c_void);
            i_1 += 1;
        }
        xmlFree
            .expect("non-null function pointer")((*ctxt).attrInfos as *mut libc::c_void);
    }
    if !((*ctxt).elemInfos).is_null() {
        let mut i_2: i32 = 0;
        let mut ei: xmlSchemaNodeInfoPtr = 0 as *mut xmlSchemaNodeInfo;
        i_2 = 0 as i32;
        while i_2 < (*ctxt).sizeElemInfos {
            ei = *((*ctxt).elemInfos).offset(i_2 as isize);
            if ei.is_null() {
                break;
            }
            xmlSchemaClearElemInfo(ctxt, ei);
            xmlFree.expect("non-null function pointer")(ei as *mut libc::c_void);
            i_2 += 1;
        }
        xmlFree
            .expect("non-null function pointer")((*ctxt).elemInfos as *mut libc::c_void);
    }
    if !((*ctxt).nodeQNames).is_null() {
        xmlSchemaItemListFree((*ctxt).nodeQNames);
    }
    if !((*ctxt).dict).is_null() {
        xmlDictFree((*ctxt).dict);
    }
    if !((*ctxt).filename).is_null() {
        xmlFree
            .expect("non-null function pointer")((*ctxt).filename as *mut libc::c_void);
    }
    xmlFree.expect("non-null function pointer")(ctxt as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaIsValid(
    mut ctxt: xmlSchemaValidCtxtPtr,
) -> i32 {
    if ctxt.is_null() {
        return -(1 as i32);
    }
    return ((*ctxt).err == 0 as i32) as i32;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSetValidErrors(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut err: xmlSchemaValidityErrorFunc,
    mut warn: xmlSchemaValidityWarningFunc,
    mut ctx: *mut libc::c_void,
) {
    if ctxt.is_null() {
        return;
    }
    let fresh653 = &mut ((*ctxt).error);
    *fresh653 = err;
    let fresh654 = &mut ((*ctxt).warning);
    *fresh654 = warn;
    let fresh655 = &mut ((*ctxt).errCtxt);
    *fresh655 = ctx;
    if !((*ctxt).pctxt).is_null() {
        xmlSchemaSetParserErrors((*ctxt).pctxt, err, warn, ctx);
    }
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSetValidStructuredErrors(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut serror: xmlStructuredErrorFunc,
    mut ctx: *mut libc::c_void,
) {
    if ctxt.is_null() {
        return;
    }
    let fresh656 = &mut ((*ctxt).serror);
    *fresh656 = serror;
    let fresh657 = &mut ((*ctxt).error);
    *fresh657 = None;
    let fresh658 = &mut ((*ctxt).warning);
    *fresh658 = None;
    let fresh659 = &mut ((*ctxt).errCtxt);
    *fresh659 = ctx;
    if !((*ctxt).pctxt).is_null() {
        xmlSchemaSetParserStructuredErrors((*ctxt).pctxt, serror, ctx);
    }
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaGetValidErrors(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut err: *mut xmlSchemaValidityErrorFunc,
    mut warn: *mut xmlSchemaValidityWarningFunc,
    mut ctx: *mut *mut libc::c_void,
) -> i32 {
    if ctxt.is_null() {
        return -(1 as i32);
    }
    if !err.is_null() {
        *err = (*ctxt).error;
    }
    if !warn.is_null() {
        *warn = (*ctxt).warning;
    }
    if !ctx.is_null() {
        *ctx = (*ctxt).errCtxt;
    }
    return 0 as i32;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSetValidOptions(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut options: i32,
) -> i32 {
    let mut i: i32 = 0;
    if ctxt.is_null() {
        return -(1 as i32);
    }
    i = 1 as i32;
    while i
        < ::std::mem::size_of::<i32>() as u64 as i32
            * 8 as i32
    {
        if options & (1 as i32) << i != 0 {
            return -(1 as i32);
        }
        i += 1;
    }
    (*ctxt).options = options;
    return 0 as i32;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidCtxtGetOptions(
    mut ctxt: xmlSchemaValidCtxtPtr,
) -> i32 {
    if ctxt.is_null() { return -(1 as i32) } else { return (*ctxt).options };
}
unsafe extern "C" fn xmlSchemaVDocWalk(mut vctxt: xmlSchemaValidCtxtPtr) -> i32 {
    let mut current_block: u64;
    let mut attr: xmlAttrPtr = 0 as *mut xmlAttr;
    let mut ret: i32 = 0 as i32;
    let mut ielem: xmlSchemaNodeInfoPtr = 0 as xmlSchemaNodeInfoPtr;
    let mut node: xmlNodePtr = 0 as *mut xmlNode;
    let mut valRoot: xmlNodePtr = 0 as *mut xmlNode;
    let mut nsName: *const xmlChar = 0 as *const xmlChar;
    if !((*vctxt).validationRoot).is_null() {
        valRoot = (*vctxt).validationRoot;
    } else {
        valRoot = xmlDocGetRootElement((*vctxt).doc as *const xmlDoc);
    }
    if valRoot.is_null() {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_ERR_INTERNAL_ERROR,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"The document has no document element\0" as *const u8
                as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return 1 as i32;
    }
    (*vctxt).depth = -(1 as i32);
    let fresh660 = &mut ((*vctxt).validationRoot);
    *fresh660 = valRoot;
    node = valRoot;
    's_62: loop {
        if node.is_null() {
            current_block = 17798826982086638848;
            break;
        }
        if (*vctxt).skipDepth != -(1 as i32)
            && (*vctxt).depth >= (*vctxt).skipDepth
        {
            current_block = 14755719952959066985;
        } else {
            if (*node).type_0 as u32
                == XML_ELEMENT_NODE as i32 as u32
            {
                let fresh661 = &mut ((*vctxt).depth);
                *fresh661 += 1;
                if xmlSchemaValidatorPushElem(vctxt) == -(1 as i32) {
                    current_block = 1349865872602754158;
                    break;
                }
                ielem = (*vctxt).inode;
                let fresh662 = &mut ((*ielem).node);
                *fresh662 = node;
                (*ielem).nodeLine = (*node).line as i32;
                let fresh663 = &mut ((*ielem).localName);
                *fresh663 = (*node).name;
                if !((*node).ns).is_null() {
                    let fresh664 = &mut ((*ielem).nsName);
                    *fresh664 = (*(*node).ns).href;
                }
                (*ielem).flags |= (1 as i32) << 5 as i32;
                (*vctxt).nbAttrInfos = 0 as i32;
                if !((*node).properties).is_null() {
                    attr = (*node).properties;
                    loop {
                        if !((*attr).ns).is_null() {
                            nsName = (*(*attr).ns).href;
                        } else {
                            nsName = 0 as *const xmlChar;
                        }
                        ret = xmlSchemaValidatorPushAttribute(
                            vctxt,
                            attr as xmlNodePtr,
                            (*ielem).nodeLine,
                            (*attr).name,
                            nsName,
                            0 as i32,
                            xmlNodeListGetString(
                                (*attr).doc,
                                (*attr).children,
                                1 as i32,
                            ),
                            1 as i32,
                        );
                        if ret == -(1 as i32) {
                            xmlSchemaInternalErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                b"xmlSchemaDocWalk\0" as *const u8 as *const i8,
                                b"calling xmlSchemaValidatorPushAttribute()\0" as *const u8
                                    as *const i8,
                            );
                            current_block = 1349865872602754158;
                            break 's_62;
                        } else {
                            attr = (*attr).next;
                            if attr.is_null() {
                                break;
                            }
                        }
                    }
                }
                ret = xmlSchemaValidateElem(vctxt);
                if ret != 0 as i32 {
                    if ret == -(1 as i32) {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaDocWalk\0" as *const u8 as *const i8,
                            b"calling xmlSchemaValidateElem()\0" as *const u8
                                as *const i8,
                        );
                        current_block = 1349865872602754158;
                        break;
                    }
                    current_block = 15505510009722066756;
                } else if (*vctxt).skipDepth != -(1 as i32)
                        && (*vctxt).depth >= (*vctxt).skipDepth
                    {
                    current_block = 15505510009722066756;
                } else {
                    current_block = 17233182392562552756;
                }
            } else if (*node).type_0 as u32
                    == XML_TEXT_NODE as i32 as u32
                    || (*node).type_0 as u32
                        == XML_CDATA_SECTION_NODE as i32 as u32
                {
                if !ielem.is_null()
                    && (*ielem).flags & (1 as i32) << 5 as i32 != 0
                {
                    (*ielem).flags ^= (1 as i32) << 5 as i32;
                }
                ret = xmlSchemaVPushText(
                    vctxt,
                    (*node).type_0 as i32,
                    (*node).content,
                    -(1 as i32),
                    1 as i32,
                    0 as *mut i32,
                );
                if ret < 0 as i32 {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaVDocWalk\0" as *const u8 as *const i8,
                        b"calling xmlSchemaVPushText()\0" as *const u8
                            as *const i8,
                    );
                    current_block = 1349865872602754158;
                    break;
                } else {
                    current_block = 17233182392562552756;
                }
            } else if (*node).type_0 as u32
                    == XML_ENTITY_NODE as i32 as u32
                    || (*node).type_0 as u32
                        == XML_ENTITY_REF_NODE as i32 as u32
                {
                xmlSchemaInternalErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaVDocWalk\0" as *const u8 as *const i8,
                    b"there is at least one entity reference in the node-tree currently being validated. Processing of entities with this XML Schema processor is not supported (yet). Please substitute entities before validation.\0"
                        as *const u8 as *const i8,
                );
                current_block = 1349865872602754158;
                break;
            } else {
                current_block = 15505510009722066756;
            }
            match current_block {
                15505510009722066756 => {}
                _ => {
                    if !((*node).children).is_null() {
                        node = (*node).children;
                        continue;
                    } else {
                        current_block = 15505510009722066756;
                    }
                }
            }
        }
        loop {
            match current_block {
                14755719952959066985 => {
                    if !((*node).next).is_null() {
                        node = (*node).next;
                        break;
                    } else {
                        node = (*node).parent;
                        current_block = 15505510009722066756;
                    }
                }
                _ => {
                    if !((*node).type_0 as u32
                        == XML_ELEMENT_NODE as i32 as u32)
                    {
                        current_block = 14755719952959066985;
                        continue;
                    }
                    if node != (*(*vctxt).inode).node {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaVDocWalk\0" as *const u8 as *const i8,
                            b"element position mismatch\0" as *const u8
                                as *const i8,
                        );
                        current_block = 1349865872602754158;
                        break 's_62;
                    } else {
                        ret = xmlSchemaValidatorPopElem(vctxt);
                        if ret != 0 as i32 {
                            if ret < 0 as i32 {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaVDocWalk\0" as *const u8 as *const i8,
                                    b"calling xmlSchemaValidatorPopElem()\0" as *const u8
                                        as *const i8,
                                );
                                current_block = 1349865872602754158;
                                break 's_62;
                            }
                        }
                        if node == valRoot {
                            current_block = 17798826982086638848;
                            break 's_62;
                        } else {
                            current_block = 14755719952959066985;
                        }
                    }
                }
            }
        }
    }
    match current_block {
        1349865872602754158 => return -(1 as i32),
        _ => return ret,
    };
}
unsafe extern "C" fn xmlSchemaPreRun(mut vctxt: xmlSchemaValidCtxtPtr) -> i32 {
    (*vctxt).err = 0 as i32;
    (*vctxt).nberrors = 0 as i32;
    (*vctxt).depth = -(1 as i32);
    (*vctxt).skipDepth = -(1 as i32);
    (*vctxt).hasKeyrefs = 0 as i32;
    (*vctxt).createIDCNodeTables = 0 as i32;
    if ((*vctxt).schema).is_null() {
        let mut pctxt: xmlSchemaParserCtxtPtr = 0 as *mut xmlSchemaParserCtxt;
        (*vctxt).xsiAssemble = 1 as i32;
        if ((*vctxt).pctxt).is_null()
            && xmlSchemaCreatePCtxtOnVCtxt(vctxt) == -(1 as i32)
        {
            return -(1 as i32);
        }
        pctxt = (*vctxt).pctxt;
        (*pctxt).xsiAssemble = 1 as i32;
        let fresh665 = &mut ((*vctxt).schema);
        *fresh665 = xmlSchemaNewSchema(pctxt);
        if ((*vctxt).schema).is_null() {
            return -(1 as i32);
        }
        let fresh666 = &mut ((*pctxt).constructor);
        *fresh666 = xmlSchemaConstructionCtxtCreate((*pctxt).dict);
        if ((*pctxt).constructor).is_null() {
            return -(1 as i32);
        }
        let fresh667 = &mut ((*(*pctxt).constructor).mainSchema);
        *fresh667 = (*vctxt).schema;
        (*pctxt).ownsConstructor = 1 as i32;
    }
    xmlHashScan(
        (*(*vctxt).schema).schemasImports,
        Some(
            xmlSchemaAugmentImportedIDC
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *mut libc::c_void,
                    *const xmlChar,
                ) -> (),
        ),
        vctxt as *mut libc::c_void,
    );
    return 0 as i32;
}
unsafe extern "C" fn xmlSchemaPostRun(mut vctxt: xmlSchemaValidCtxtPtr) {
    if (*vctxt).xsiAssemble != 0 {
        if !((*vctxt).schema).is_null() {
            xmlSchemaFree((*vctxt).schema);
            let fresh668 = &mut ((*vctxt).schema);
            *fresh668 = 0 as xmlSchemaPtr;
        }
    }
    xmlSchemaClearValidCtxt(vctxt);
}
unsafe extern "C" fn xmlSchemaVStart(mut vctxt: xmlSchemaValidCtxtPtr) -> i32 {
    let mut ret: i32 = 0 as i32;
    if xmlSchemaPreRun(vctxt) < 0 as i32 {
        return -(1 as i32);
    }
    if !((*vctxt).doc).is_null() {
        ret = xmlSchemaVDocWalk(vctxt);
    } else if ((*vctxt).reader).is_null() {
        if !((*vctxt).sax).is_null() && !((*vctxt).parserCtxt).is_null() {
            ret = xmlParseDocument((*vctxt).parserCtxt);
        } else {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaVStart\0" as *const u8 as *const i8,
                b"no instance to validate\0" as *const u8 as *const i8,
            );
            ret = -(1 as i32);
        }
    }
    xmlSchemaPostRun(vctxt);
    if ret == 0 as i32 {
        ret = (*vctxt).err;
    }
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateOneElement(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut elem: xmlNodePtr,
) -> i32 {
    if ctxt.is_null() || elem.is_null()
        || (*elem).type_0 as u32
            != XML_ELEMENT_NODE as i32 as u32
    {
        return -(1 as i32);
    }
    if ((*ctxt).schema).is_null() {
        return -(1 as i32);
    }
    let fresh669 = &mut ((*ctxt).doc);
    *fresh669 = (*elem).doc;
    let fresh670 = &mut ((*ctxt).node);
    *fresh670 = elem;
    let fresh671 = &mut ((*ctxt).validationRoot);
    *fresh671 = elem;
    return xmlSchemaVStart(ctxt);
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateDoc(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut doc: xmlDocPtr,
) -> i32 {
    if ctxt.is_null() || doc.is_null() {
        return -(1 as i32);
    }
    let fresh672 = &mut ((*ctxt).doc);
    *fresh672 = doc;
    let fresh673 = &mut ((*ctxt).node);
    *fresh673 = xmlDocGetRootElement(doc as *const xmlDoc);
    if ((*ctxt).node).is_null() {
        xmlSchemaCustomErr(
            ctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING,
            doc as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"The document has no document element\0" as *const u8
                as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return (*ctxt).err;
    }
    let fresh674 = &mut ((*ctxt).validationRoot);
    *fresh674 = (*ctxt).node;
    return xmlSchemaVStart(ctxt);
}
unsafe extern "C" fn internalSubsetSplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
    mut ExternalID: *const xmlChar,
    mut SystemID: *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).internalSubset).is_some()
    {
        ((*(*ctxt).user_sax).internalSubset)
            .expect(
                "non-null function pointer",
            )((*ctxt).user_data, name, ExternalID, SystemID);
    }
}
unsafe extern "C" fn isStandaloneSplit(mut ctx: *mut libc::c_void) -> i32 {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).isStandalone).is_some()
    {
        return ((*(*ctxt).user_sax).isStandalone)
            .expect("non-null function pointer")((*ctxt).user_data);
    }
    return 0 as i32;
}
unsafe extern "C" fn hasInternalSubsetSplit(mut ctx: *mut libc::c_void) -> i32 {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).hasInternalSubset).is_some()
    {
        return ((*(*ctxt).user_sax).hasInternalSubset)
            .expect("non-null function pointer")((*ctxt).user_data);
    }
    return 0 as i32;
}
unsafe extern "C" fn hasExternalSubsetSplit(mut ctx: *mut libc::c_void) -> i32 {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).hasExternalSubset).is_some()
    {
        return ((*(*ctxt).user_sax).hasExternalSubset)
            .expect("non-null function pointer")((*ctxt).user_data);
    }
    return 0 as i32;
}
unsafe extern "C" fn externalSubsetSplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
    mut ExternalID: *const xmlChar,
    mut SystemID: *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).externalSubset).is_some()
    {
        ((*(*ctxt).user_sax).externalSubset)
            .expect(
                "non-null function pointer",
            )((*ctxt).user_data, name, ExternalID, SystemID);
    }
}
unsafe extern "C" fn resolveEntitySplit(
    mut ctx: *mut libc::c_void,
    mut publicId: *const xmlChar,
    mut systemId: *const xmlChar,
) -> xmlParserInputPtr {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).resolveEntity).is_some()
    {
        return ((*(*ctxt).user_sax).resolveEntity)
            .expect("non-null function pointer")((*ctxt).user_data, publicId, systemId);
    }
    return 0 as xmlParserInputPtr;
}
unsafe extern "C" fn getEntitySplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
) -> xmlEntityPtr {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).getEntity).is_some()
    {
        return ((*(*ctxt).user_sax).getEntity)
            .expect("non-null function pointer")((*ctxt).user_data, name);
    }
    return 0 as xmlEntityPtr;
}
unsafe extern "C" fn getParameterEntitySplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
) -> xmlEntityPtr {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).getParameterEntity).is_some()
    {
        return ((*(*ctxt).user_sax).getParameterEntity)
            .expect("non-null function pointer")((*ctxt).user_data, name);
    }
    return 0 as xmlEntityPtr;
}
unsafe extern "C" fn entityDeclSplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
    mut type_0: i32,
    mut publicId: *const xmlChar,
    mut systemId: *const xmlChar,
    mut content: *mut xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).entityDecl).is_some()
    {
        ((*(*ctxt).user_sax).entityDecl)
            .expect(
                "non-null function pointer",
            )((*ctxt).user_data, name, type_0, publicId, systemId, content);
    }
}
unsafe extern "C" fn attributeDeclSplit(
    mut ctx: *mut libc::c_void,
    mut elem: *const xmlChar,
    mut name: *const xmlChar,
    mut type_0: i32,
    mut def: i32,
    mut defaultValue: *const xmlChar,
    mut tree: xmlEnumerationPtr,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).attributeDecl).is_some()
    {
        ((*(*ctxt).user_sax).attributeDecl)
            .expect(
                "non-null function pointer",
            )((*ctxt).user_data, elem, name, type_0, def, defaultValue, tree);
    } else {
        xmlFreeEnumeration(tree);
    };
}
unsafe extern "C" fn elementDeclSplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
    mut type_0: i32,
    mut content: xmlElementContentPtr,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).elementDecl).is_some()
    {
        ((*(*ctxt).user_sax).elementDecl)
            .expect(
                "non-null function pointer",
            )((*ctxt).user_data, name, type_0, content);
    }
}
unsafe extern "C" fn notationDeclSplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
    mut publicId: *const xmlChar,
    mut systemId: *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).notationDecl).is_some()
    {
        ((*(*ctxt).user_sax).notationDecl)
            .expect(
                "non-null function pointer",
            )((*ctxt).user_data, name, publicId, systemId);
    }
}
unsafe extern "C" fn unparsedEntityDeclSplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
    mut publicId: *const xmlChar,
    mut systemId: *const xmlChar,
    mut notationName: *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).unparsedEntityDecl).is_some()
    {
        ((*(*ctxt).user_sax).unparsedEntityDecl)
            .expect(
                "non-null function pointer",
            )((*ctxt).user_data, name, publicId, systemId, notationName);
    }
}
unsafe extern "C" fn setDocumentLocatorSplit(
    mut ctx: *mut libc::c_void,
    mut loc: xmlSAXLocatorPtr,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).setDocumentLocator).is_some()
    {
        ((*(*ctxt).user_sax).setDocumentLocator)
            .expect("non-null function pointer")((*ctxt).user_data, loc);
    }
}
unsafe extern "C" fn startDocumentSplit(mut ctx: *mut libc::c_void) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).startDocument).is_some()
    {
        ((*(*ctxt).user_sax).startDocument)
            .expect("non-null function pointer")((*ctxt).user_data);
    }
}
unsafe extern "C" fn endDocumentSplit(mut ctx: *mut libc::c_void) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).endDocument).is_some()
    {
        ((*(*ctxt).user_sax).endDocument)
            .expect("non-null function pointer")((*ctxt).user_data);
    }
}
unsafe extern "C" fn processingInstructionSplit(
    mut ctx: *mut libc::c_void,
    mut target: *const xmlChar,
    mut data: *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).processingInstruction).is_some()
    {
        ((*(*ctxt).user_sax).processingInstruction)
            .expect("non-null function pointer")((*ctxt).user_data, target, data);
    }
}
unsafe extern "C" fn commentSplit(
    mut ctx: *mut libc::c_void,
    mut value: *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).comment).is_some()
    {
        ((*(*ctxt).user_sax).comment)
            .expect("non-null function pointer")((*ctxt).user_data, value);
    }
}
unsafe extern "C" fn warningSplit(
    mut ctx: *mut libc::c_void,
    mut msg: *const i8,
    mut args: ...
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).warning).is_some()
    {
        (*__xmlGenericError())
            .expect(
                "non-null function pointer",
            )(
            *__xmlGenericErrorContext(),
            b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
            b"xmlschemas.c\0" as *const u8 as *const i8,
            28699 as i32,
        );
    }
}
unsafe extern "C" fn errorSplit(
    mut ctx: *mut libc::c_void,
    mut msg: *const i8,
    mut args: ...
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).error).is_some()
    {
        (*__xmlGenericError())
            .expect(
                "non-null function pointer",
            )(
            *__xmlGenericErrorContext(),
            b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
            b"xmlschemas.c\0" as *const u8 as *const i8,
            28707 as i32,
        );
    }
}
unsafe extern "C" fn fatalErrorSplit(
    mut ctx: *mut libc::c_void,
    mut msg: *const i8,
    mut args: ...
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).fatalError).is_some()
    {
        (*__xmlGenericError())
            .expect(
                "non-null function pointer",
            )(
            *__xmlGenericErrorContext(),
            b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
            b"xmlschemas.c\0" as *const u8 as *const i8,
            28715 as i32,
        );
    }
}
unsafe extern "C" fn charactersSplit(
    mut ctx: *mut libc::c_void,
    mut ch: *const xmlChar,
    mut len: i32,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !((*ctxt).user_sax).is_null() && ((*(*ctxt).user_sax).characters).is_some() {
        ((*(*ctxt).user_sax).characters)
            .expect("non-null function pointer")((*ctxt).user_data, ch, len);
    }
    if !((*ctxt).ctxt).is_null() {
        xmlSchemaSAXHandleText((*ctxt).ctxt as *mut libc::c_void, ch, len);
    }
}
unsafe extern "C" fn ignorableWhitespaceSplit(
    mut ctx: *mut libc::c_void,
    mut ch: *const xmlChar,
    mut len: i32,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).ignorableWhitespace).is_some()
    {
        ((*(*ctxt).user_sax).ignorableWhitespace)
            .expect("non-null function pointer")((*ctxt).user_data, ch, len);
    }
    if !((*ctxt).ctxt).is_null() {
        xmlSchemaSAXHandleText((*ctxt).ctxt as *mut libc::c_void, ch, len);
    }
}
unsafe extern "C" fn cdataBlockSplit(
    mut ctx: *mut libc::c_void,
    mut value: *const xmlChar,
    mut len: i32,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !((*ctxt).user_sax).is_null() && ((*(*ctxt).user_sax).cdataBlock).is_some() {
        ((*(*ctxt).user_sax).cdataBlock)
            .expect("non-null function pointer")((*ctxt).user_data, value, len);
    }
    if !((*ctxt).ctxt).is_null() {
        xmlSchemaSAXHandleCDataSection((*ctxt).ctxt as *mut libc::c_void, value, len);
    }
}
unsafe extern "C" fn referenceSplit(
    mut ctx: *mut libc::c_void,
    mut name: *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).reference).is_some()
    {
        ((*(*ctxt).user_sax).reference)
            .expect("non-null function pointer")((*ctxt).user_data, name);
    }
    if !((*ctxt).ctxt).is_null() {
        xmlSchemaSAXHandleReference((*ctxt).user_data, name);
    }
}
unsafe extern "C" fn startElementNsSplit(
    mut ctx: *mut libc::c_void,
    mut localname: *const xmlChar,
    mut prefix: *const xmlChar,
    mut URI: *const xmlChar,
    mut nb_namespaces: i32,
    mut namespaces: *mut *const xmlChar,
    mut nb_attributes: i32,
    mut nb_defaulted: i32,
    mut attributes: *mut *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !((*ctxt).user_sax).is_null() && ((*(*ctxt).user_sax).startElementNs).is_some() {
        ((*(*ctxt).user_sax).startElementNs)
            .expect(
                "non-null function pointer",
            )(
            (*ctxt).user_data,
            localname,
            prefix,
            URI,
            nb_namespaces,
            namespaces,
            nb_attributes,
            nb_defaulted,
            attributes,
        );
    }
    if !((*ctxt).ctxt).is_null() {
        xmlSchemaSAXHandleStartElementNs(
            (*ctxt).ctxt as *mut libc::c_void,
            localname,
            prefix,
            URI,
            nb_namespaces,
            namespaces,
            nb_attributes,
            nb_defaulted,
            attributes,
        );
    }
}
unsafe extern "C" fn endElementNsSplit(
    mut ctx: *mut libc::c_void,
    mut localname: *const xmlChar,
    mut prefix: *const xmlChar,
    mut URI: *const xmlChar,
) {
    let mut ctxt: xmlSchemaSAXPlugPtr = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !((*ctxt).user_sax).is_null() && ((*(*ctxt).user_sax).endElementNs).is_some() {
        ((*(*ctxt).user_sax).endElementNs)
            .expect(
                "non-null function pointer",
            )((*ctxt).user_data, localname, prefix, URI);
    }
    if !((*ctxt).ctxt).is_null() {
        xmlSchemaSAXHandleEndElementNs(
            (*ctxt).ctxt as *mut libc::c_void,
            localname,
            prefix,
            URI,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSAXPlug(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut sax: *mut xmlSAXHandlerPtr,
    mut user_data: *mut *mut libc::c_void,
) -> xmlSchemaSAXPlugPtr {
    let mut ret: xmlSchemaSAXPlugPtr = 0 as *mut xmlSchemaSAXPlugStruct;
    let mut old_sax: xmlSAXHandlerPtr = 0 as *mut xmlSAXHandler;
    if ctxt.is_null() || sax.is_null() || user_data.is_null() {
        return 0 as xmlSchemaSAXPlugPtr;
    }
    old_sax = *sax;
    if !old_sax.is_null() && (*old_sax).initialized != 0xdeedbeaf as u32 {
        return 0 as xmlSchemaSAXPlugPtr;
    }
    if !old_sax.is_null() && ((*old_sax).startElementNs).is_none()
        && ((*old_sax).endElementNs).is_none()
        && (((*old_sax).startElement).is_some() || ((*old_sax).endElement).is_some())
    {
        return 0 as xmlSchemaSAXPlugPtr;
    }
    ret = xmlMalloc
        .expect(
            "non-null function pointer",
        )(::std::mem::size_of::<xmlSchemaSAXPlugStruct>() as u64)
        as xmlSchemaSAXPlugPtr;
    if ret.is_null() {
        return 0 as xmlSchemaSAXPlugPtr;
    }
    memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaSAXPlugStruct>() as u64,
    );
    (*ret).magic = 0xdc43ba21 as u32;
    (*ret).schemas_sax.initialized = 0xdeedbeaf as u32;
    let fresh675 = &mut ((*ret).ctxt);
    *fresh675 = ctxt;
    let fresh676 = &mut ((*ret).user_sax_ptr);
    *fresh676 = sax;
    let fresh677 = &mut ((*ret).user_sax);
    *fresh677 = old_sax;
    if old_sax.is_null() {
        let fresh678 = &mut ((*ret).schemas_sax.startElementNs);
        *fresh678 = Some(
            xmlSchemaSAXHandleStartElementNs
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    *const xmlChar,
                    *const xmlChar,
                    i32,
                    *mut *const xmlChar,
                    i32,
                    i32,
                    *mut *const xmlChar,
                ) -> (),
        );
        let fresh679 = &mut ((*ret).schemas_sax.endElementNs);
        *fresh679 = Some(
            xmlSchemaSAXHandleEndElementNs
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    *const xmlChar,
                    *const xmlChar,
                ) -> (),
        );
        let fresh680 = &mut ((*ret).schemas_sax.ignorableWhitespace);
        *fresh680 = Some(
            xmlSchemaSAXHandleText
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    i32,
                ) -> (),
        );
        let fresh681 = &mut ((*ret).schemas_sax.characters);
        *fresh681 = Some(
            xmlSchemaSAXHandleText
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    i32,
                ) -> (),
        );
        let fresh682 = &mut ((*ret).schemas_sax.cdataBlock);
        *fresh682 = Some(
            xmlSchemaSAXHandleCDataSection
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    i32,
                ) -> (),
        );
        let fresh683 = &mut ((*ret).schemas_sax.reference);
        *fresh683 = Some(
            xmlSchemaSAXHandleReference
                as unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
        );
        let fresh684 = &mut ((*ret).user_data);
        *fresh684 = ctxt as *mut libc::c_void;
        *user_data = ctxt as *mut libc::c_void;
    } else {
        if ((*old_sax).internalSubset).is_some() {
            let fresh685 = &mut ((*ret).schemas_sax.internalSubset);
            *fresh685 = Some(
                internalSubsetSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        *const xmlChar,
                        *const xmlChar,
                    ) -> (),
            );
        }
        if ((*old_sax).isStandalone).is_some() {
            let fresh686 = &mut ((*ret).schemas_sax.isStandalone);
            *fresh686 = Some(
                isStandaloneSplit
                    as unsafe extern "C" fn(*mut libc::c_void) -> i32,
            );
        }
        if ((*old_sax).hasInternalSubset).is_some() {
            let fresh687 = &mut ((*ret).schemas_sax.hasInternalSubset);
            *fresh687 = Some(
                hasInternalSubsetSplit
                    as unsafe extern "C" fn(*mut libc::c_void) -> i32,
            );
        }
        if ((*old_sax).hasExternalSubset).is_some() {
            let fresh688 = &mut ((*ret).schemas_sax.hasExternalSubset);
            *fresh688 = Some(
                hasExternalSubsetSplit
                    as unsafe extern "C" fn(*mut libc::c_void) -> i32,
            );
        }
        if ((*old_sax).resolveEntity).is_some() {
            let fresh689 = &mut ((*ret).schemas_sax.resolveEntity);
            *fresh689 = Some(
                resolveEntitySplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        *const xmlChar,
                    ) -> xmlParserInputPtr,
            );
        }
        if ((*old_sax).getEntity).is_some() {
            let fresh690 = &mut ((*ret).schemas_sax.getEntity);
            *fresh690 = Some(
                getEntitySplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                    ) -> xmlEntityPtr,
            );
        }
        if ((*old_sax).entityDecl).is_some() {
            let fresh691 = &mut ((*ret).schemas_sax.entityDecl);
            *fresh691 = Some(
                entityDeclSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        i32,
                        *const xmlChar,
                        *const xmlChar,
                        *mut xmlChar,
                    ) -> (),
            );
        }
        if ((*old_sax).notationDecl).is_some() {
            let fresh692 = &mut ((*ret).schemas_sax.notationDecl);
            *fresh692 = Some(
                notationDeclSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        *const xmlChar,
                        *const xmlChar,
                    ) -> (),
            );
        }
        if ((*old_sax).attributeDecl).is_some() {
            let fresh693 = &mut ((*ret).schemas_sax.attributeDecl);
            *fresh693 = Some(
                attributeDeclSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        *const xmlChar,
                        i32,
                        i32,
                        *const xmlChar,
                        xmlEnumerationPtr,
                    ) -> (),
            );
        }
        if ((*old_sax).elementDecl).is_some() {
            let fresh694 = &mut ((*ret).schemas_sax.elementDecl);
            *fresh694 = Some(
                elementDeclSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        i32,
                        xmlElementContentPtr,
                    ) -> (),
            );
        }
        if ((*old_sax).unparsedEntityDecl).is_some() {
            let fresh695 = &mut ((*ret).schemas_sax.unparsedEntityDecl);
            *fresh695 = Some(
                unparsedEntityDeclSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        *const xmlChar,
                        *const xmlChar,
                        *const xmlChar,
                    ) -> (),
            );
        }
        if ((*old_sax).setDocumentLocator).is_some() {
            let fresh696 = &mut ((*ret).schemas_sax.setDocumentLocator);
            *fresh696 = Some(
                setDocumentLocatorSplit
                    as unsafe extern "C" fn(*mut libc::c_void, xmlSAXLocatorPtr) -> (),
            );
        }
        if ((*old_sax).startDocument).is_some() {
            let fresh697 = &mut ((*ret).schemas_sax.startDocument);
            *fresh697 = Some(
                startDocumentSplit as unsafe extern "C" fn(*mut libc::c_void) -> (),
            );
        }
        if ((*old_sax).endDocument).is_some() {
            let fresh698 = &mut ((*ret).schemas_sax.endDocument);
            *fresh698 = Some(
                endDocumentSplit as unsafe extern "C" fn(*mut libc::c_void) -> (),
            );
        }
        if ((*old_sax).processingInstruction).is_some() {
            let fresh699 = &mut ((*ret).schemas_sax.processingInstruction);
            *fresh699 = Some(
                processingInstructionSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        *const xmlChar,
                    ) -> (),
            );
        }
        if ((*old_sax).comment).is_some() {
            let fresh700 = &mut ((*ret).schemas_sax.comment);
            *fresh700 = Some(
                commentSplit
                    as unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
            );
        }
        if ((*old_sax).warning).is_some() {
            let fresh701 = &mut ((*ret).schemas_sax.warning);
            *fresh701 = Some(
                warningSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const i8,
                        ...
                    ) -> (),
            );
        }
        if ((*old_sax).error).is_some() {
            let fresh702 = &mut ((*ret).schemas_sax.error);
            *fresh702 = Some(
                errorSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const i8,
                        ...
                    ) -> (),
            );
        }
        if ((*old_sax).fatalError).is_some() {
            let fresh703 = &mut ((*ret).schemas_sax.fatalError);
            *fresh703 = Some(
                fatalErrorSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const i8,
                        ...
                    ) -> (),
            );
        }
        if ((*old_sax).getParameterEntity).is_some() {
            let fresh704 = &mut ((*ret).schemas_sax.getParameterEntity);
            *fresh704 = Some(
                getParameterEntitySplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                    ) -> xmlEntityPtr,
            );
        }
        if ((*old_sax).externalSubset).is_some() {
            let fresh705 = &mut ((*ret).schemas_sax.externalSubset);
            *fresh705 = Some(
                externalSubsetSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        *const xmlChar,
                        *const xmlChar,
                    ) -> (),
            );
        }
        let fresh706 = &mut ((*ret).schemas_sax.characters);
        *fresh706 = Some(
            charactersSplit
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    i32,
                ) -> (),
        );
        if ((*old_sax).ignorableWhitespace).is_some()
            && (*old_sax).ignorableWhitespace != (*old_sax).characters
        {
            let fresh707 = &mut ((*ret).schemas_sax.ignorableWhitespace);
            *fresh707 = Some(
                ignorableWhitespaceSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        i32,
                    ) -> (),
            );
        } else {
            let fresh708 = &mut ((*ret).schemas_sax.ignorableWhitespace);
            *fresh708 = Some(
                charactersSplit
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        *const xmlChar,
                        i32,
                    ) -> (),
            );
        }
        let fresh709 = &mut ((*ret).schemas_sax.cdataBlock);
        *fresh709 = Some(
            cdataBlockSplit
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    i32,
                ) -> (),
        );
        let fresh710 = &mut ((*ret).schemas_sax.reference);
        *fresh710 = Some(
            referenceSplit
                as unsafe extern "C" fn(*mut libc::c_void, *const xmlChar) -> (),
        );
        let fresh711 = &mut ((*ret).schemas_sax.startElementNs);
        *fresh711 = Some(
            startElementNsSplit
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    *const xmlChar,
                    *const xmlChar,
                    i32,
                    *mut *const xmlChar,
                    i32,
                    i32,
                    *mut *const xmlChar,
                ) -> (),
        );
        let fresh712 = &mut ((*ret).schemas_sax.endElementNs);
        *fresh712 = Some(
            endElementNsSplit
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const xmlChar,
                    *const xmlChar,
                    *const xmlChar,
                ) -> (),
        );
        let fresh713 = &mut ((*ret).user_data_ptr);
        *fresh713 = user_data;
        let fresh714 = &mut ((*ret).user_data);
        *fresh714 = *user_data;
        *user_data = ret as *mut libc::c_void;
    }
    *sax = &mut (*ret).schemas_sax;
    let fresh715 = &mut ((*ctxt).sax);
    *fresh715 = *sax;
    (*ctxt).flags |= 1 as i32;
    xmlSchemaPreRun(ctxt);
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaSAXUnplug(
    mut plug: xmlSchemaSAXPlugPtr,
) -> i32 {
    let mut sax: *mut xmlSAXHandlerPtr = 0 as *mut xmlSAXHandlerPtr;
    let mut user_data: *mut *mut libc::c_void = 0 as *mut *mut libc::c_void;
    if plug.is_null() || (*plug).magic != 0xdc43ba21 as u32 {
        return -(1 as i32);
    }
    (*plug).magic = 0 as i32 as u32;
    xmlSchemaPostRun((*plug).ctxt);
    sax = (*plug).user_sax_ptr;
    *sax = (*plug).user_sax;
    if !((*plug).user_sax).is_null() {
        user_data = (*plug).user_data_ptr;
        *user_data = (*plug).user_data;
    }
    xmlFree.expect("non-null function pointer")(plug as *mut libc::c_void);
    return 0 as i32;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateSetLocator(
    mut vctxt: xmlSchemaValidCtxtPtr,
    mut f: xmlSchemaValidityLocatorFunc,
    mut ctxt: *mut libc::c_void,
) {
    if vctxt.is_null() {
        return;
    }
    let fresh716 = &mut ((*vctxt).locFunc);
    *fresh716 = f;
    let fresh717 = &mut ((*vctxt).locCtxt);
    *fresh717 = ctxt;
}
unsafe extern "C" fn xmlSchemaValidateStreamLocator(
    mut ctx: *mut libc::c_void,
    mut file: *mut *const i8,
    mut line: *mut u64,
) -> i32 {
    let mut ctxt: xmlParserCtxtPtr = 0 as *mut xmlParserCtxt;
    if ctx.is_null() || file.is_null() && line.is_null() {
        return -(1 as i32);
    }
    if !file.is_null() {
        *file = 0 as *const i8;
    }
    if !line.is_null() {
        *line = 0 as i32 as u64;
    }
    ctxt = ctx as xmlParserCtxtPtr;
    if !((*ctxt).input).is_null() {
        if !file.is_null() {
            *file = (*(*ctxt).input).filename;
        }
        if !line.is_null() {
            *line = (*(*ctxt).input).line as u64;
        }
        return 0 as i32;
    }
    return -(1 as i32);
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateStream(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut input: xmlParserInputBufferPtr,
    mut enc: xmlCharEncoding,
    mut sax: xmlSAXHandlerPtr,
    mut user_data: *mut libc::c_void,
) -> i32 {
    let mut plug: xmlSchemaSAXPlugPtr = 0 as xmlSchemaSAXPlugPtr;
    let mut old_sax: xmlSAXHandlerPtr = 0 as xmlSAXHandlerPtr;
    let mut pctxt: xmlParserCtxtPtr = 0 as xmlParserCtxtPtr;
    let mut inputStream: xmlParserInputPtr = 0 as xmlParserInputPtr;
    let mut ret: i32 = 0;
    if ctxt.is_null() || input.is_null() {
        return -(1 as i32);
    }
    pctxt = xmlNewParserCtxt();
    if pctxt.is_null() {
        return -(1 as i32);
    }
    old_sax = (*pctxt).sax;
    let fresh718 = &mut ((*pctxt).sax);
    *fresh718 = sax;
    let fresh719 = &mut ((*pctxt).userData);
    *fresh719 = user_data;
    (*pctxt).linenumbers = 1 as i32;
    xmlSchemaValidateSetLocator(
        ctxt,
        Some(
            xmlSchemaValidateStreamLocator
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *mut *const i8,
                    *mut u64,
                ) -> i32,
        ),
        pctxt as *mut libc::c_void,
    );
    inputStream = xmlNewIOInputStream(pctxt, input, enc);
    if inputStream.is_null() {
        ret = -(1 as i32);
    } else {
        inputPush(pctxt, inputStream);
        let fresh720 = &mut ((*ctxt).parserCtxt);
        *fresh720 = pctxt;
        let fresh721 = &mut ((*ctxt).input);
        *fresh721 = input;
        plug = xmlSchemaSAXPlug(ctxt, &mut (*pctxt).sax, &mut (*pctxt).userData);
        if plug.is_null() {
            ret = -(1 as i32);
        } else {
            let fresh722 = &mut ((*ctxt).input);
            *fresh722 = input;
            (*ctxt).enc = enc;
            let fresh723 = &mut ((*ctxt).sax);
            *fresh723 = (*pctxt).sax;
            (*ctxt).flags |= 1 as i32;
            ret = xmlSchemaVStart(ctxt);
            if ret == 0 as i32 && (*(*ctxt).parserCtxt).wellFormed == 0 {
                ret = (*(*ctxt).parserCtxt).errNo;
                if ret == 0 as i32 {
                    ret = 1 as i32;
                }
            }
        }
    }
    let fresh724 = &mut ((*ctxt).parserCtxt);
    *fresh724 = 0 as xmlParserCtxtPtr;
    let fresh725 = &mut ((*ctxt).sax);
    *fresh725 = 0 as xmlSAXHandlerPtr;
    let fresh726 = &mut ((*ctxt).input);
    *fresh726 = 0 as xmlParserInputBufferPtr;
    if !plug.is_null() {
        xmlSchemaSAXUnplug(plug);
    }
    if !pctxt.is_null() {
        let fresh727 = &mut ((*pctxt).sax);
        *fresh727 = old_sax;
        xmlFreeParserCtxt(pctxt);
    }
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidateFile(
    mut ctxt: xmlSchemaValidCtxtPtr,
    mut filename: *const i8,
    mut options: i32,
) -> i32 {
    let mut ret: i32 = 0;
    let mut input: xmlParserInputBufferPtr = 0 as *mut xmlParserInputBuffer;
    if ctxt.is_null() || filename.is_null() {
        return -(1 as i32);
    }
    input = xmlParserInputBufferCreateFilename(filename, XML_CHAR_ENCODING_NONE);
    if input.is_null() {
        return -(1 as i32);
    }
    ret = xmlSchemaValidateStream(
        ctxt,
        input,
        XML_CHAR_ENCODING_NONE,
        0 as xmlSAXHandlerPtr,
        0 as *mut libc::c_void,
    );
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn xmlSchemaValidCtxtGetParserCtxt(
    mut ctxt: xmlSchemaValidCtxtPtr,
) -> xmlParserCtxtPtr {
    if ctxt.is_null() {
        return 0 as xmlParserCtxtPtr;
    }
    return (*ctxt).parserCtxt;
}

use :: libc;
extern "C" {
    fn fprintf(_: *mut crate::src::tree::_IO_FILE, _: *const i8, _: ...) -> i32;
    fn snprintf(_: *mut i8, _: u64, _: *const i8, _: ...) -> i32;
    fn memset(_: *mut core::ffi::c_void, _: i32, _: u64) -> *mut core::ffi::c_void;
    fn strchr(_: *const i8, _: i32) -> *mut i8;
    fn memcpy(
        _: *mut core::ffi::c_void,
        _: *const core::ffi::c_void,
        _: u64,
    ) -> *mut core::ffi::c_void;
    fn xmlDictCreate() -> *mut crate::src::xpointer::_xmlDict;
    fn xmlDictReference(dict: *mut crate::src::xpointer::_xmlDict) -> i32;
    fn xmlDictFree(dict: *mut crate::src::xpointer::_xmlDict);
    fn xmlDictLookup(
        dict: *mut crate::src::xpointer::_xmlDict,
        name: *const u8,
        len: i32,
    ) -> *const u8;
    fn xmlHashCreate(size: i32) -> *mut crate::src::xmlsave::_xmlHashTable;
    fn xmlHashCreateDict(
        size: i32,
        dict: *mut crate::src::xpointer::_xmlDict,
    ) -> *mut crate::src::xmlsave::_xmlHashTable;
    fn xmlHashFree(
        table: *mut crate::src::xmlsave::_xmlHashTable,
        f: Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const u8) -> ()>,
    );
    fn xmlHashAddEntry(
        table: *mut crate::src::xmlsave::_xmlHashTable,
        name: *const u8,
        userdata: *mut core::ffi::c_void,
    ) -> i32;
    fn xmlHashAddEntry2(
        table: *mut crate::src::xmlsave::_xmlHashTable,
        name: *const u8,
        name2: *const u8,
        userdata: *mut core::ffi::c_void,
    ) -> i32;
    fn xmlHashLookup(
        table: *mut crate::src::xmlsave::_xmlHashTable,
        name: *const u8,
    ) -> *mut core::ffi::c_void;
    fn xmlHashLookup2(
        table: *mut crate::src::xmlsave::_xmlHashTable,
        name: *const u8,
        name2: *const u8,
    ) -> *mut core::ffi::c_void;
    fn xmlHashSize(table: *mut crate::src::xmlsave::_xmlHashTable) -> i32;
    fn xmlHashScan(
        table: *mut crate::src::xmlsave::_xmlHashTable,
        f: Option<
            unsafe extern "C" fn(
                _: *mut core::ffi::c_void,
                _: *mut core::ffi::c_void,
                _: *const u8,
            ) -> (),
        >,
        data: *mut core::ffi::c_void,
    );
    fn xmlHashScanFull(
        table: *mut crate::src::xmlsave::_xmlHashTable,
        f: Option<
            unsafe extern "C" fn(
                _: *mut core::ffi::c_void,
                _: *mut core::ffi::c_void,
                _: *const u8,
                _: *const u8,
                _: *const u8,
            ) -> (),
        >,
        data: *mut core::ffi::c_void,
    );
    fn xmlGetLastError() -> *mut crate::src::threads::_xmlError;
    fn __xmlRaiseError(
        schannel: Option<
            unsafe extern "C" fn(
                _: *mut core::ffi::c_void,
                _: *mut crate::src::threads::_xmlError,
            ) -> (),
        >,
        channel: Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>,
        data: *mut core::ffi::c_void,
        ctx: *mut core::ffi::c_void,
        node: *mut core::ffi::c_void,
        domain: i32,
        code: i32,
        level: u32,
        file: *const i8,
        line: i32,
        str1: *const i8,
        str2: *const i8,
        str3: *const i8,
        int1: i32,
        col: i32,
        msg: *const i8,
        _: ...
    );
    fn __xmlSimpleError(
        domain: i32,
        code: i32,
        node: *mut crate::src::threads::_xmlNode,
        msg: *const i8,
        extra: *const i8,
    );
    fn xmlStopParser(ctxt: *mut crate::src::tree::_xmlParserCtxt);
    fn xmlParseDocument(ctxt: *mut crate::src::tree::_xmlParserCtxt) -> i32;
    fn xmlNewParserCtxt() -> *mut crate::src::tree::_xmlParserCtxt;
    fn xmlFreeParserCtxt(ctxt: *mut crate::src::tree::_xmlParserCtxt);
    fn xmlNewIOInputStream(
        ctxt: *mut crate::src::tree::_xmlParserCtxt,
        input: *mut crate::src::threads::_xmlParserInputBuffer,
        enc: i32,
    ) -> *mut crate::src::threads::_xmlParserInput;
    fn xmlCtxtReadFile(
        ctxt: *mut crate::src::tree::_xmlParserCtxt,
        filename: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> *mut crate::src::threads::_xmlDoc;
    fn xmlCtxtReadMemory(
        ctxt: *mut crate::src::tree::_xmlParserCtxt,
        buffer: *const i8,
        size: i32,
        URL: *const i8,
        encoding: *const i8,
        options: i32,
    ) -> *mut crate::src::threads::_xmlDoc;
    fn xmlSAX2GetLineNumber(ctx: *mut core::ffi::c_void) -> i32;
    static mut xmlMalloc: Option<unsafe extern "C" fn(_: u64) -> *mut core::ffi::c_void>;
    static mut xmlMallocAtomic: Option<unsafe extern "C" fn(_: u64) -> *mut core::ffi::c_void>;
    static mut xmlRealloc:
        Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: u64) -> *mut core::ffi::c_void>;
    static mut xmlFree: Option<unsafe extern "C" fn(_: *mut core::ffi::c_void) -> ()>;
    fn __xmlGenericError()
    -> *mut Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>;
    fn __xmlGenericErrorContext() -> *mut *mut core::ffi::c_void;
    fn inputPush(
        ctxt: *mut crate::src::tree::_xmlParserCtxt,
        value: *mut crate::src::threads::_xmlParserInput,
    ) -> i32;
    fn xmlFreePattern(comp: *mut crate::src::xmlreader::_xmlPattern);
    fn xmlPatterncompile(
        pattern: *const u8,
        dict: *mut crate::src::xpointer::_xmlDict,
        flags: i32,
        namespaces: *mut *const u8,
    ) -> *mut crate::src::xmlreader::_xmlPattern;
    fn xmlPatternGetStreamCtxt(
        comp: *mut crate::src::xmlreader::_xmlPattern,
    ) -> *mut crate::src::xmllint::_xmlStreamCtxt;
    fn xmlFreeStreamCtxt(stream: *mut crate::src::xmllint::_xmlStreamCtxt);
    fn xmlStreamPush(
        stream: *mut crate::src::xmllint::_xmlStreamCtxt,
        name: *const u8,
        ns: *const u8,
    ) -> i32;
    fn xmlStreamPushAttr(
        stream: *mut crate::src::xmllint::_xmlStreamCtxt,
        name: *const u8,
        ns: *const u8,
    ) -> i32;
    fn xmlStreamPop(stream: *mut crate::src::xmllint::_xmlStreamCtxt) -> i32;
}
pub use crate::src::{
    tree::{
        xmlAddChild, xmlDocGetRootElement, xmlFreeDoc, xmlFreeNode, xmlGetNoNsProp, xmlGetNsList,
        xmlHasProp, xmlNewDocText, xmlNewNs, xmlNewNsProp, xmlNewProp, xmlNodeGetBase,
        xmlNodeGetContent, xmlNodeGetSpacePreserve, xmlNodeListGetString, xmlSearchNs,
        xmlSearchNsByHref, xmlSplitQName2, xmlSplitQName3, xmlUnlinkNode, xmlValidateNCName,
        xmlValidateQName,
    },
    uri::xmlBuildURI,
    valid::{_xmlValidState, xmlAddID, xmlFreeEnumeration},
    xmlIO::xmlParserInputBufferCreateFilename,
    xmllint::{_IO_marker, _xmlStreamCtxt},
    xmlmemory::_IO_wide_data,
    xmlreader::{_xmlPattern, _xmlTextReader, xmlTextReaderLookupNamespace},
    xmlregexp::{
        _xmlAutomata, _xmlAutomataState, _xmlRegExecCtxt, _xmlRegexp, xmlAutomataCompile,
        xmlAutomataGetInitState, xmlAutomataNewAllTrans, xmlAutomataNewCountTrans2,
        xmlAutomataNewCountedTrans, xmlAutomataNewCounter, xmlAutomataNewCounterTrans,
        xmlAutomataNewEpsilon, xmlAutomataNewNegTrans, xmlAutomataNewOnceTrans2,
        xmlAutomataNewState, xmlAutomataNewTransition2, xmlAutomataSetFinalState, xmlFreeAutomata,
        xmlNewAutomata, xmlRegExecErrInfo, xmlRegExecNextValues, xmlRegExecPushString,
        xmlRegExecPushString2, xmlRegFreeExecCtxt, xmlRegFreeRegexp, xmlRegNewExecCtxt,
        xmlRegexpCompile, xmlRegexpExec, xmlRegexpIsDeterminist,
    },
    xmlsave::{_IO_codecvt, _xmlHashTable},
    xmlschemastypes::{
        _xmlSchemaVal, xmlSchemaCollapseString, xmlSchemaCompareValues,
        xmlSchemaCompareValuesWhtsp, xmlSchemaCopyValue, xmlSchemaFreeValue,
        xmlSchemaGetBuiltInType, xmlSchemaGetCanonValue, xmlSchemaGetFacetValueAsULong,
        xmlSchemaGetPredefinedType, xmlSchemaGetValType, xmlSchemaInitTypes,
        xmlSchemaIsBuiltInTypeFacet, xmlSchemaNewNOTATIONValue, xmlSchemaNewQNameValue,
        xmlSchemaValPredefTypeNode, xmlSchemaValPredefTypeNodeNoNorm, xmlSchemaValidateFacetWhtsp,
        xmlSchemaValidateLengthFacetWhtsp, xmlSchemaValidateListSimpleTypeFacet,
        xmlSchemaValidatePredefinedType, xmlSchemaValueAppend, xmlSchemaValueGetAsBoolean,
        xmlSchemaValueGetAsString, xmlSchemaValueGetNext, xmlSchemaWhiteSpaceReplace,
    },
    xmlstring::{
        _xmlBuf, _xmlStartTag, xmlCharStrdup, xmlEscapeFormatString, xmlStrEqual, xmlStrcat,
        xmlStrdup, xmlStrlen, xmlStrncat, xmlStrncatNew, xmlStrndup,
    },
    xpointer::_xmlDict,
};
pub type xmlChar = u8;
pub type size_t = u64;
pub type __off_t = i64;
pub type __off64_t = i64;
pub type _IO_FILE = crate::src::tree::_IO_FILE;
pub type _IO_lock_t = ();
pub type FILE = crate::src::tree::_IO_FILE;
pub type xmlFreeFunc = Option<unsafe extern "C" fn(_: *mut core::ffi::c_void) -> ()>;
pub type xmlMallocFunc = Option<unsafe extern "C" fn(_: u64) -> *mut core::ffi::c_void>;
pub type xmlReallocFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: u64) -> *mut core::ffi::c_void>;
pub type _xmlParserInputBuffer = crate::src::threads::_xmlParserInputBuffer;
pub type xmlBufPtr = *mut crate::src::xmlstring::_xmlBuf;
pub type xmlBuf = crate::src::xmlstring::_xmlBuf;
pub type xmlCharEncodingHandlerPtr = *mut crate::src::threads::_xmlCharEncodingHandler;
pub type xmlCharEncodingHandler = crate::src::threads::_xmlCharEncodingHandler;
pub type _xmlCharEncodingHandler = crate::src::threads::_xmlCharEncodingHandler;
pub type iconv_t = *mut core::ffi::c_void;
pub type xmlCharEncodingOutputFunc =
    Option<unsafe extern "C" fn(_: *mut u8, _: *mut i32, _: *const u8, _: *mut i32) -> i32>;
pub type xmlCharEncodingInputFunc =
    Option<unsafe extern "C" fn(_: *mut u8, _: *mut i32, _: *const u8, _: *mut i32) -> i32>;
pub type xmlInputCloseCallback = Option<unsafe extern "C" fn(_: *mut core::ffi::c_void) -> i32>;
pub type xmlInputReadCallback =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *mut i8, _: i32) -> i32>;
pub type xmlParserInputBuffer = crate::src::threads::_xmlParserInputBuffer;
pub type xmlParserInputBufferPtr = *mut crate::src::threads::_xmlParserInputBuffer;
pub type _xmlParserInput = crate::src::threads::_xmlParserInput;
pub type xmlParserInputDeallocate = Option<unsafe extern "C" fn(_: *mut u8) -> ()>;
pub type xmlParserInput = crate::src::threads::_xmlParserInput;
pub type xmlParserInputPtr = *mut crate::src::threads::_xmlParserInput;
pub type _xmlParserCtxt = crate::src::tree::_xmlParserCtxt;
pub type xmlParserNodeInfo = crate::src::tree::_xmlParserNodeInfo;
pub type _xmlParserNodeInfo = crate::src::tree::_xmlParserNodeInfo;
pub type _xmlNode = crate::src::threads::_xmlNode;
pub type xmlNs = crate::src::threads::_xmlNs;
pub type _xmlNs = crate::src::threads::_xmlNs;
pub type _xmlDoc = crate::src::threads::_xmlDoc;
pub type _xmlDtd = crate::src::threads::_xmlDtd;
pub type xmlElementType = u32;
pub const XML_XINCLUDE_END: xmlElementType = 20;
pub const XML_XINCLUDE_START: xmlElementType = 19;
pub const XML_NAMESPACE_DECL: xmlElementType = 18;
pub const XML_ENTITY_DECL: xmlElementType = 17;
pub const XML_ATTRIBUTE_DECL: xmlElementType = 16;
pub const XML_ELEMENT_DECL: xmlElementType = 15;
pub const XML_DTD_NODE: xmlElementType = 14;
pub const XML_HTML_DOCUMENT_NODE: xmlElementType = 13;
pub const XML_NOTATION_NODE: xmlElementType = 12;
pub const XML_DOCUMENT_FRAG_NODE: xmlElementType = 11;
pub const XML_DOCUMENT_TYPE_NODE: xmlElementType = 10;
pub const XML_DOCUMENT_NODE: xmlElementType = 9;
pub const XML_COMMENT_NODE: xmlElementType = 8;
pub const XML_PI_NODE: xmlElementType = 7;
pub const XML_ENTITY_NODE: xmlElementType = 6;
pub const XML_ENTITY_REF_NODE: xmlElementType = 5;
pub const XML_CDATA_SECTION_NODE: xmlElementType = 4;
pub const XML_TEXT_NODE: xmlElementType = 3;
pub const XML_ATTRIBUTE_NODE: xmlElementType = 2;
pub const XML_ELEMENT_NODE: xmlElementType = 1;
pub type xmlNsType = u32;
pub type _xmlAttr = crate::src::threads::_xmlAttr;
pub type xmlAttributeType = u32;
pub const XML_ATTRIBUTE_NOTATION: xmlAttributeType = 10;
pub const XML_ATTRIBUTE_ENUMERATION: xmlAttributeType = 9;
pub const XML_ATTRIBUTE_NMTOKENS: xmlAttributeType = 8;
pub const XML_ATTRIBUTE_NMTOKEN: xmlAttributeType = 7;
pub const XML_ATTRIBUTE_ENTITIES: xmlAttributeType = 6;
pub const XML_ATTRIBUTE_ENTITY: xmlAttributeType = 5;
pub const XML_ATTRIBUTE_IDREFS: xmlAttributeType = 4;
pub const XML_ATTRIBUTE_IDREF: xmlAttributeType = 3;
pub const XML_ATTRIBUTE_ID: xmlAttributeType = 2;
pub const XML_ATTRIBUTE_CDATA: xmlAttributeType = 1;
pub type xmlParserMode = u32;
pub const XML_PARSE_READER: xmlParserMode = 5;
pub const XML_PARSE_PUSH_SAX: xmlParserMode = 4;
pub const XML_PARSE_PUSH_DOM: xmlParserMode = 3;
pub const XML_PARSE_SAX: xmlParserMode = 2;
pub const XML_PARSE_DOM: xmlParserMode = 1;
pub const XML_PARSE_UNKNOWN: xmlParserMode = 0;
pub type xmlError = crate::src::threads::_xmlError;
pub type _xmlError = crate::src::threads::_xmlError;
pub type xmlErrorLevel = u32;
pub const XML_ERR_FATAL: xmlErrorLevel = 3;
pub const XML_ERR_ERROR: xmlErrorLevel = 2;
pub const XML_ERR_WARNING: xmlErrorLevel = 1;
pub const XML_ERR_NONE: xmlErrorLevel = 0;
pub type xmlAttrPtr = *mut crate::src::threads::_xmlAttr;
pub type xmlAttr = crate::src::threads::_xmlAttr;
pub type xmlNodePtr = *mut crate::src::threads::_xmlNode;
pub type xmlNode = crate::src::threads::_xmlNode;
pub type xmlHashTablePtr = *mut crate::src::xmlsave::_xmlHashTable;
pub type xmlHashTable = crate::src::xmlsave::_xmlHashTable;
pub type xmlStartTag = crate::src::xmlstring::_xmlStartTag;
pub type xmlDictPtr = *mut crate::src::xpointer::_xmlDict;
pub type xmlDict = crate::src::xpointer::_xmlDict;
pub type xmlParserInputState = i32;
pub const XML_PARSER_PUBLIC_LITERAL: xmlParserInputState = 16;
pub const XML_PARSER_IGNORE: xmlParserInputState = 15;
pub const XML_PARSER_EPILOG: xmlParserInputState = 14;
pub const XML_PARSER_SYSTEM_LITERAL: xmlParserInputState = 13;
pub const XML_PARSER_ATTRIBUTE_VALUE: xmlParserInputState = 12;
pub const XML_PARSER_ENTITY_VALUE: xmlParserInputState = 11;
pub const XML_PARSER_ENTITY_DECL: xmlParserInputState = 10;
pub const XML_PARSER_END_TAG: xmlParserInputState = 9;
pub const XML_PARSER_CDATA_SECTION: xmlParserInputState = 8;
pub const XML_PARSER_CONTENT: xmlParserInputState = 7;
pub const XML_PARSER_START_TAG: xmlParserInputState = 6;
pub const XML_PARSER_COMMENT: xmlParserInputState = 5;
pub const XML_PARSER_PROLOG: xmlParserInputState = 4;
pub const XML_PARSER_DTD: xmlParserInputState = 3;
pub const XML_PARSER_PI: xmlParserInputState = 2;
pub const XML_PARSER_MISC: xmlParserInputState = 1;
pub const XML_PARSER_START: xmlParserInputState = 0;
pub const XML_PARSER_EOF: xmlParserInputState = -1;
pub type xmlValidCtxt = crate::src::tree::_xmlValidCtxt;
pub type _xmlValidCtxt = crate::src::tree::_xmlValidCtxt;
pub type xmlAutomataStatePtr = *mut crate::src::xmlregexp::_xmlAutomataState;
pub type xmlAutomataState = crate::src::xmlregexp::_xmlAutomataState;
pub type xmlAutomataPtr = *mut crate::src::xmlregexp::_xmlAutomata;
pub type xmlAutomata = crate::src::xmlregexp::_xmlAutomata;
pub type xmlValidState = crate::src::valid::_xmlValidState;
pub type xmlDocPtr = *mut crate::src::threads::_xmlDoc;
pub type xmlDoc = crate::src::threads::_xmlDoc;
pub type xmlValidityWarningFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>;
pub type xmlValidityErrorFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>;
pub type xmlParserNodeInfoSeq = crate::src::tree::_xmlParserNodeInfoSeq;
pub type _xmlParserNodeInfoSeq = crate::src::tree::_xmlParserNodeInfoSeq;
pub type _xmlSAXHandler = crate::src::tree::_xmlSAXHandler;
pub type xmlStructuredErrorFunc = Option<
    unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *mut crate::src::threads::_xmlError) -> (),
>;
pub type xmlErrorPtr = *mut crate::src::threads::_xmlError;
pub type endElementNsSAX2Func = Option<
    unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const u8, _: *const u8, _: *const u8) -> (),
>;
pub type startElementNsSAX2Func = Option<
    unsafe extern "C" fn(
        _: *mut core::ffi::c_void,
        _: *const u8,
        _: *const u8,
        _: *const u8,
        _: i32,
        _: *mut *const u8,
        _: i32,
        _: i32,
        _: *mut *const u8,
    ) -> (),
>;
pub type externalSubsetSAXFunc = Option<
    unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const u8, _: *const u8, _: *const u8) -> (),
>;
pub type cdataBlockSAXFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const u8, _: i32) -> ()>;
pub type getParameterEntitySAXFunc = Option<
    unsafe extern "C" fn(
        _: *mut core::ffi::c_void,
        _: *const u8,
    ) -> *mut crate::src::threads::_xmlEntity,
>;
pub type xmlEntityPtr = *mut crate::src::threads::_xmlEntity;
pub type xmlEntity = crate::src::threads::_xmlEntity;
pub type _xmlEntity = crate::src::threads::_xmlEntity;
pub type xmlEntityType = u32;
pub const XML_INTERNAL_PREDEFINED_ENTITY: xmlEntityType = 6;
pub const XML_EXTERNAL_PARAMETER_ENTITY: xmlEntityType = 5;
pub const XML_INTERNAL_PARAMETER_ENTITY: xmlEntityType = 4;
pub const XML_EXTERNAL_GENERAL_UNPARSED_ENTITY: xmlEntityType = 3;
pub const XML_EXTERNAL_GENERAL_PARSED_ENTITY: xmlEntityType = 2;
pub const XML_INTERNAL_GENERAL_ENTITY: xmlEntityType = 1;
pub type fatalErrorSAXFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>;
pub type errorSAXFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>;
pub type warningSAXFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>;
pub type commentSAXFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const u8) -> ()>;
pub type processingInstructionSAXFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const u8, _: *const u8) -> ()>;
pub type ignorableWhitespaceSAXFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const u8, _: i32) -> ()>;
pub type charactersSAXFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const u8, _: i32) -> ()>;
pub type referenceSAXFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const u8) -> ()>;
pub type endElementSAXFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const u8) -> ()>;
pub type startElementSAXFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const u8, _: *mut *const u8) -> ()>;
pub type endDocumentSAXFunc = Option<unsafe extern "C" fn(_: *mut core::ffi::c_void) -> ()>;
pub type startDocumentSAXFunc = Option<unsafe extern "C" fn(_: *mut core::ffi::c_void) -> ()>;
pub type setDocumentLocatorSAXFunc = Option<
    unsafe extern "C" fn(
        _: *mut core::ffi::c_void,
        _: *mut crate::src::threads::_xmlSAXLocator,
    ) -> (),
>;
pub type xmlSAXLocatorPtr = *mut crate::src::threads::_xmlSAXLocator;
pub type xmlSAXLocator = crate::src::threads::_xmlSAXLocator;
pub type _xmlSAXLocator = crate::src::threads::_xmlSAXLocator;
pub type unparsedEntityDeclSAXFunc = Option<
    unsafe extern "C" fn(
        _: *mut core::ffi::c_void,
        _: *const u8,
        _: *const u8,
        _: *const u8,
        _: *const u8,
    ) -> (),
>;
pub type elementDeclSAXFunc = Option<
    unsafe extern "C" fn(
        _: *mut core::ffi::c_void,
        _: *const u8,
        _: i32,
        _: *mut crate::src::threads::_xmlElementContent,
    ) -> (),
>;
pub type xmlElementContentPtr = *mut crate::src::threads::_xmlElementContent;
pub type xmlElementContent = crate::src::threads::_xmlElementContent;
pub type _xmlElementContent = crate::src::threads::_xmlElementContent;
pub type xmlElementContentOccur = u32;
pub const XML_ELEMENT_CONTENT_PLUS: xmlElementContentOccur = 4;
pub const XML_ELEMENT_CONTENT_MULT: xmlElementContentOccur = 3;
pub const XML_ELEMENT_CONTENT_OPT: xmlElementContentOccur = 2;
pub const XML_ELEMENT_CONTENT_ONCE: xmlElementContentOccur = 1;
pub type xmlElementContentType = u32;
pub const XML_ELEMENT_CONTENT_OR: xmlElementContentType = 4;
pub const XML_ELEMENT_CONTENT_SEQ: xmlElementContentType = 3;
pub const XML_ELEMENT_CONTENT_ELEMENT: xmlElementContentType = 2;
pub const XML_ELEMENT_CONTENT_PCDATA: xmlElementContentType = 1;
pub type attributeDeclSAXFunc = Option<
    unsafe extern "C" fn(
        _: *mut core::ffi::c_void,
        _: *const u8,
        _: *const u8,
        _: i32,
        _: i32,
        _: *const u8,
        _: *mut crate::src::threads::_xmlEnumeration,
    ) -> (),
>;
pub type xmlEnumerationPtr = *mut crate::src::threads::_xmlEnumeration;
pub type xmlEnumeration = crate::src::threads::_xmlEnumeration;
pub type _xmlEnumeration = crate::src::threads::_xmlEnumeration;
pub type notationDeclSAXFunc = Option<
    unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const u8, _: *const u8, _: *const u8) -> (),
>;
pub type entityDeclSAXFunc = Option<
    unsafe extern "C" fn(
        _: *mut core::ffi::c_void,
        _: *const u8,
        _: i32,
        _: *const u8,
        _: *const u8,
        _: *mut u8,
    ) -> (),
>;
pub type getEntitySAXFunc = Option<
    unsafe extern "C" fn(
        _: *mut core::ffi::c_void,
        _: *const u8,
    ) -> *mut crate::src::threads::_xmlEntity,
>;
pub type resolveEntitySAXFunc = Option<
    unsafe extern "C" fn(
        _: *mut core::ffi::c_void,
        _: *const u8,
        _: *const u8,
    ) -> *mut crate::src::threads::_xmlParserInput,
>;
pub type hasExternalSubsetSAXFunc = Option<unsafe extern "C" fn(_: *mut core::ffi::c_void) -> i32>;
pub type hasInternalSubsetSAXFunc = Option<unsafe extern "C" fn(_: *mut core::ffi::c_void) -> i32>;
pub type isStandaloneSAXFunc = Option<unsafe extern "C" fn(_: *mut core::ffi::c_void) -> i32>;
pub type internalSubsetSAXFunc = Option<
    unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const u8, _: *const u8, _: *const u8) -> (),
>;
pub type xmlParserCtxt = crate::src::tree::_xmlParserCtxt;
pub type xmlParserCtxtPtr = *mut crate::src::tree::_xmlParserCtxt;
pub type xmlSAXHandler = crate::src::tree::_xmlSAXHandler;
pub type xmlSAXHandlerPtr = *mut crate::src::tree::_xmlSAXHandler;
pub type xmlRegexp = crate::src::xmlregexp::_xmlRegexp;
pub type xmlRegexpPtr = *mut crate::src::xmlregexp::_xmlRegexp;
pub type xmlRegExecCtxt = crate::src::xmlregexp::_xmlRegExecCtxt;
pub type xmlRegExecCtxtPtr = *mut crate::src::xmlregexp::_xmlRegExecCtxt;
pub type xmlRegExecCallbacks = Option<
    unsafe extern "C" fn(
        _: *mut crate::src::xmlregexp::_xmlRegExecCtxt,
        _: *const u8,
        _: *mut core::ffi::c_void,
        _: *mut core::ffi::c_void,
    ) -> (),
>;
pub type xmlNsPtr = *mut crate::src::threads::_xmlNs;
pub type _xmlID<'a> = crate::src::tree::_xmlID<'a>;
pub type xmlID<'a> = crate::src::tree::_xmlID<'a>;
pub type xmlIDPtr<'a> = *mut crate::src::tree::_xmlID<'a>;
pub type xmlHashDeallocator =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const u8) -> ()>;
pub type xmlHashScanner = Option<
    unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *mut core::ffi::c_void, _: *const u8) -> (),
>;
pub type xmlHashScannerFull = Option<
    unsafe extern "C" fn(
        _: *mut core::ffi::c_void,
        _: *mut core::ffi::c_void,
        _: *const u8,
        _: *const u8,
        _: *const u8,
    ) -> (),
>;
pub type C2RustUnnamed = u32;
pub const XML_FROM_URI: C2RustUnnamed = 30;
pub const XML_FROM_BUFFER: C2RustUnnamed = 29;
pub const XML_FROM_SCHEMATRONV: C2RustUnnamed = 28;
pub const XML_FROM_I18N: C2RustUnnamed = 27;
pub const XML_FROM_MODULE: C2RustUnnamed = 26;
pub const XML_FROM_WRITER: C2RustUnnamed = 25;
pub const XML_FROM_CHECK: C2RustUnnamed = 24;
pub const XML_FROM_VALID: C2RustUnnamed = 23;
pub const XML_FROM_XSLT: C2RustUnnamed = 22;
pub const XML_FROM_C14N: C2RustUnnamed = 21;
pub const XML_FROM_CATALOG: C2RustUnnamed = 20;
pub const XML_FROM_RELAXNGV: C2RustUnnamed = 19;
pub const XML_FROM_RELAXNGP: C2RustUnnamed = 18;
pub const XML_FROM_SCHEMASV: C2RustUnnamed = 17;
pub const XML_FROM_SCHEMASP: C2RustUnnamed = 16;
pub const XML_FROM_DATATYPE: C2RustUnnamed = 15;
pub const XML_FROM_REGEXP: C2RustUnnamed = 14;
pub const XML_FROM_XPOINTER: C2RustUnnamed = 13;
pub const XML_FROM_XPATH: C2RustUnnamed = 12;
pub const XML_FROM_XINCLUDE: C2RustUnnamed = 11;
pub const XML_FROM_HTTP: C2RustUnnamed = 10;
pub const XML_FROM_FTP: C2RustUnnamed = 9;
pub const XML_FROM_IO: C2RustUnnamed = 8;
pub const XML_FROM_OUTPUT: C2RustUnnamed = 7;
pub const XML_FROM_MEMORY: C2RustUnnamed = 6;
pub const XML_FROM_HTML: C2RustUnnamed = 5;
pub const XML_FROM_DTD: C2RustUnnamed = 4;
pub const XML_FROM_NAMESPACE: C2RustUnnamed = 3;
pub const XML_FROM_TREE: C2RustUnnamed = 2;
pub const XML_FROM_PARSER: C2RustUnnamed = 1;
pub const XML_FROM_NONE: C2RustUnnamed = 0;
pub type xmlParserErrors = u32;
pub const XML_BUF_OVERFLOW: xmlParserErrors = 7000;
pub const XML_I18N_NO_OUTPUT: xmlParserErrors = 6004;
pub const XML_I18N_CONV_FAILED: xmlParserErrors = 6003;
pub const XML_I18N_EXCESS_HANDLER: xmlParserErrors = 6002;
pub const XML_I18N_NO_HANDLER: xmlParserErrors = 6001;
pub const XML_I18N_NO_NAME: xmlParserErrors = 6000;
pub const XML_CHECK_NAME_NOT_NULL: xmlParserErrors = 5037;
pub const XML_CHECK_WRONG_NAME: xmlParserErrors = 5036;
pub const XML_CHECK_OUTSIDE_DICT: xmlParserErrors = 5035;
pub const XML_CHECK_NOT_NCNAME: xmlParserErrors = 5034;
pub const XML_CHECK_NO_DICT: xmlParserErrors = 5033;
pub const XML_CHECK_NOT_UTF8: xmlParserErrors = 5032;
pub const XML_CHECK_NS_ANCESTOR: xmlParserErrors = 5031;
pub const XML_CHECK_NS_SCOPE: xmlParserErrors = 5030;
pub const XML_CHECK_WRONG_PARENT: xmlParserErrors = 5029;
pub const XML_CHECK_NO_HREF: xmlParserErrors = 5028;
pub const XML_CHECK_NOT_NS_DECL: xmlParserErrors = 5027;
pub const XML_CHECK_NOT_ENTITY_DECL: xmlParserErrors = 5026;
pub const XML_CHECK_NOT_ELEM_DECL: xmlParserErrors = 5025;
pub const XML_CHECK_NOT_ATTR_DECL: xmlParserErrors = 5024;
pub const XML_CHECK_NOT_ATTR: xmlParserErrors = 5023;
pub const XML_CHECK_NOT_DTD: xmlParserErrors = 5022;
pub const XML_CHECK_WRONG_NEXT: xmlParserErrors = 5021;
pub const XML_CHECK_NO_NEXT: xmlParserErrors = 5020;
pub const XML_CHECK_WRONG_PREV: xmlParserErrors = 5019;
pub const XML_CHECK_NO_PREV: xmlParserErrors = 5018;
pub const XML_CHECK_WRONG_DOC: xmlParserErrors = 5017;
pub const XML_CHECK_NO_ELEM: xmlParserErrors = 5016;
pub const XML_CHECK_NO_NAME: xmlParserErrors = 5015;
pub const XML_CHECK_NO_DOC: xmlParserErrors = 5014;
pub const XML_CHECK_NO_PARENT: xmlParserErrors = 5013;
pub const XML_CHECK_ENTITY_TYPE: xmlParserErrors = 5012;
pub const XML_CHECK_UNKNOWN_NODE: xmlParserErrors = 5011;
pub const XML_CHECK_FOUND_NOTATION: xmlParserErrors = 5010;
pub const XML_CHECK_FOUND_FRAGMENT: xmlParserErrors = 5009;
pub const XML_CHECK_FOUND_DOCTYPE: xmlParserErrors = 5008;
pub const XML_CHECK_FOUND_COMMENT: xmlParserErrors = 5007;
pub const XML_CHECK_FOUND_PI: xmlParserErrors = 5006;
pub const XML_CHECK_FOUND_ENTITY: xmlParserErrors = 5005;
pub const XML_CHECK_FOUND_ENTITYREF: xmlParserErrors = 5004;
pub const XML_CHECK_FOUND_CDATA: xmlParserErrors = 5003;
pub const XML_CHECK_FOUND_TEXT: xmlParserErrors = 5002;
pub const XML_CHECK_FOUND_ATTRIBUTE: xmlParserErrors = 5001;
pub const XML_CHECK_FOUND_ELEMENT: xmlParserErrors = 5000;
pub const XML_MODULE_CLOSE: xmlParserErrors = 4901;
pub const XML_MODULE_OPEN: xmlParserErrors = 4900;
pub const XML_SCHEMATRONV_REPORT: xmlParserErrors = 4001;
pub const XML_SCHEMATRONV_ASSERT: xmlParserErrors = 4000;
pub const XML_SCHEMAP_COS_ALL_LIMITED: xmlParserErrors = 3091;
pub const XML_SCHEMAP_A_PROPS_CORRECT_3: xmlParserErrors = 3090;
pub const XML_SCHEMAP_AU_PROPS_CORRECT: xmlParserErrors = 3089;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_2: xmlParserErrors = 3088;
pub const XML_SCHEMAP_AG_PROPS_CORRECT: xmlParserErrors = 3087;
pub const XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH: xmlParserErrors = 3086;
pub const XML_SCHEMAP_WARN_ATTR_REDECL_PROH: xmlParserErrors = 3085;
pub const XML_SCHEMAP_WARN_UNLOCATED_SCHEMA: xmlParserErrors = 3084;
pub const XML_SCHEMAP_WARN_SKIP_SCHEMA: xmlParserErrors = 3083;
pub const XML_SCHEMAP_SRC_IMPORT: xmlParserErrors = 3082;
pub const XML_SCHEMAP_SRC_REDEFINE: xmlParserErrors = 3081;
pub const XML_SCHEMAP_C_PROPS_CORRECT: xmlParserErrors = 3080;
pub const XML_SCHEMAP_A_PROPS_CORRECT_2: xmlParserErrors = 3079;
pub const XML_SCHEMAP_AU_PROPS_CORRECT_2: xmlParserErrors = 3078;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3: xmlParserErrors = 3077;
pub const XML_SCHEMAP_SRC_CT_1: xmlParserErrors = 3076;
pub const XML_SCHEMAP_MG_PROPS_CORRECT_2: xmlParserErrors = 3075;
pub const XML_SCHEMAP_MG_PROPS_CORRECT_1: xmlParserErrors = 3074;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3: xmlParserErrors = 3073;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2: xmlParserErrors = 3072;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1: xmlParserErrors = 3071;
pub const XML_SCHEMAP_NOT_DETERMINISTIC: xmlParserErrors = 3070;
pub const XML_SCHEMAP_INTERNAL: xmlParserErrors = 3069;
pub const XML_SCHEMAP_SRC_IMPORT_2_2: xmlParserErrors = 3068;
pub const XML_SCHEMAP_SRC_IMPORT_2_1: xmlParserErrors = 3067;
pub const XML_SCHEMAP_SRC_IMPORT_2: xmlParserErrors = 3066;
pub const XML_SCHEMAP_SRC_IMPORT_1_2: xmlParserErrors = 3065;
pub const XML_SCHEMAP_SRC_IMPORT_1_1: xmlParserErrors = 3064;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_1: xmlParserErrors = 3063;
pub const XML_SCHEMAP_CVC_SIMPLE_TYPE: xmlParserErrors = 3062;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2: xmlParserErrors = 3061;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1: xmlParserErrors = 3060;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_2_1: xmlParserErrors = 3059;
pub const XML_SCHEMAP_COS_VALID_DEFAULT_1: xmlParserErrors = 3058;
pub const XML_SCHEMAP_NO_XSI: xmlParserErrors = 3057;
pub const XML_SCHEMAP_NO_XMLNS: xmlParserErrors = 3056;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_4: xmlParserErrors = 3055;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_3_2: xmlParserErrors = 3054;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_3_1: xmlParserErrors = 3053;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_2: xmlParserErrors = 3052;
pub const XML_SCHEMAP_SRC_ATTRIBUTE_1: xmlParserErrors = 3051;
pub const XML_SCHEMAP_SRC_INCLUDE: xmlParserErrors = 3050;
pub const XML_SCHEMAP_E_PROPS_CORRECT_6: xmlParserErrors = 3049;
pub const XML_SCHEMAP_E_PROPS_CORRECT_5: xmlParserErrors = 3048;
pub const XML_SCHEMAP_E_PROPS_CORRECT_4: xmlParserErrors = 3047;
pub const XML_SCHEMAP_E_PROPS_CORRECT_3: xmlParserErrors = 3046;
pub const XML_SCHEMAP_E_PROPS_CORRECT_2: xmlParserErrors = 3045;
pub const XML_SCHEMAP_P_PROPS_CORRECT_2_2: xmlParserErrors = 3044;
pub const XML_SCHEMAP_P_PROPS_CORRECT_2_1: xmlParserErrors = 3043;
pub const XML_SCHEMAP_P_PROPS_CORRECT_1: xmlParserErrors = 3042;
pub const XML_SCHEMAP_SRC_ELEMENT_3: xmlParserErrors = 3041;
pub const XML_SCHEMAP_SRC_ELEMENT_2_2: xmlParserErrors = 3040;
pub const XML_SCHEMAP_SRC_ELEMENT_2_1: xmlParserErrors = 3039;
pub const XML_SCHEMAP_SRC_ELEMENT_1: xmlParserErrors = 3038;
pub const XML_SCHEMAP_S4S_ATTR_INVALID_VALUE: xmlParserErrors = 3037;
pub const XML_SCHEMAP_S4S_ATTR_MISSING: xmlParserErrors = 3036;
pub const XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED: xmlParserErrors = 3035;
pub const XML_SCHEMAP_S4S_ELEM_MISSING: xmlParserErrors = 3034;
pub const XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED: xmlParserErrors = 3033;
pub const XML_SCHEMAP_COS_ST_DERIVED_OK_2_2: xmlParserErrors = 3032;
pub const XML_SCHEMAP_COS_ST_DERIVED_OK_2_1: xmlParserErrors = 3031;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5: xmlParserErrors = 3030;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4: xmlParserErrors = 3029;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3: xmlParserErrors = 3028;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1: xmlParserErrors = 3027;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2: xmlParserErrors = 3026;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2: xmlParserErrors = 3025;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1: xmlParserErrors = 3024;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_3_1: xmlParserErrors = 3023;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5: xmlParserErrors = 3022;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4: xmlParserErrors = 3021;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3: xmlParserErrors = 3020;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2: xmlParserErrors = 3019;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1: xmlParserErrors = 3018;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2: xmlParserErrors = 3017;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1: xmlParserErrors = 3016;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_2_1: xmlParserErrors = 3015;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2: xmlParserErrors = 3014;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1: xmlParserErrors = 3013;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_2: xmlParserErrors = 3012;
pub const XML_SCHEMAP_COS_ST_RESTRICTS_1_1: xmlParserErrors = 3011;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_3: xmlParserErrors = 3010;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_2: xmlParserErrors = 3009;
pub const XML_SCHEMAP_ST_PROPS_CORRECT_1: xmlParserErrors = 3008;
pub const XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES: xmlParserErrors = 3007;
pub const XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE: xmlParserErrors = 3006;
pub const XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE: xmlParserErrors = 3005;
pub const XML_SCHEMAP_SRC_RESOLVE: xmlParserErrors = 3004;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_4: xmlParserErrors = 3003;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_3: xmlParserErrors = 3002;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_2: xmlParserErrors = 3001;
pub const XML_SCHEMAP_SRC_SIMPLE_TYPE_1: xmlParserErrors = 3000;
pub const XML_HTTP_UNKNOWN_HOST: xmlParserErrors = 2022;
pub const XML_HTTP_USE_IP: xmlParserErrors = 2021;
pub const XML_HTTP_URL_SYNTAX: xmlParserErrors = 2020;
pub const XML_FTP_URL_SYNTAX: xmlParserErrors = 2003;
pub const XML_FTP_ACCNT: xmlParserErrors = 2002;
pub const XML_FTP_EPSV_ANSWER: xmlParserErrors = 2001;
pub const XML_FTP_PASV_ANSWER: xmlParserErrors = 2000;
pub const XML_C14N_RELATIVE_NAMESPACE: xmlParserErrors = 1955;
pub const XML_C14N_UNKNOW_NODE: xmlParserErrors = 1954;
pub const XML_C14N_INVALID_NODE: xmlParserErrors = 1953;
pub const XML_C14N_CREATE_STACK: xmlParserErrors = 1952;
pub const XML_C14N_REQUIRES_UTF8: xmlParserErrors = 1951;
pub const XML_C14N_CREATE_CTXT: xmlParserErrors = 1950;
pub const XML_XPTR_EXTRA_OBJECTS: xmlParserErrors = 1903;
pub const XML_XPTR_EVAL_FAILED: xmlParserErrors = 1902;
pub const XML_XPTR_CHILDSEQ_START: xmlParserErrors = 1901;
pub const XML_XPTR_UNKNOWN_SCHEME: xmlParserErrors = 1900;
pub const XML_SCHEMAV_MISC: xmlParserErrors = 1879;
pub const XML_SCHEMAV_CVC_WILDCARD: xmlParserErrors = 1878;
pub const XML_SCHEMAV_CVC_IDC: xmlParserErrors = 1877;
pub const XML_SCHEMAV_CVC_TYPE_2: xmlParserErrors = 1876;
pub const XML_SCHEMAV_CVC_TYPE_1: xmlParserErrors = 1875;
pub const XML_SCHEMAV_CVC_AU: xmlParserErrors = 1874;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_1: xmlParserErrors = 1873;
pub const XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING: xmlParserErrors = 1872;
pub const XML_SCHEMAV_ELEMENT_CONTENT: xmlParserErrors = 1871;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2: xmlParserErrors = 1870;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1: xmlParserErrors = 1869;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_4: xmlParserErrors = 1868;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2: xmlParserErrors = 1867;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1: xmlParserErrors = 1866;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1: xmlParserErrors = 1865;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_4: xmlParserErrors = 1864;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_3: xmlParserErrors = 1863;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_2: xmlParserErrors = 1862;
pub const XML_SCHEMAV_CVC_ATTRIBUTE_1: xmlParserErrors = 1861;
pub const XML_SCHEMAV_CVC_ELT_7: xmlParserErrors = 1860;
pub const XML_SCHEMAV_CVC_ELT_6: xmlParserErrors = 1859;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_2_2: xmlParserErrors = 1858;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_2_1: xmlParserErrors = 1857;
pub const XML_SCHEMAV_CVC_ELT_5_2_2_1: xmlParserErrors = 1856;
pub const XML_SCHEMAV_CVC_ELT_5_2_1: xmlParserErrors = 1855;
pub const XML_SCHEMAV_CVC_ELT_5_1_2: xmlParserErrors = 1854;
pub const XML_SCHEMAV_CVC_ELT_5_1_1: xmlParserErrors = 1853;
pub const XML_SCHEMAV_CVC_ELT_4_3: xmlParserErrors = 1852;
pub const XML_SCHEMAV_CVC_ELT_4_2: xmlParserErrors = 1851;
pub const XML_SCHEMAV_CVC_ELT_4_1: xmlParserErrors = 1850;
pub const XML_SCHEMAV_CVC_ELT_3_2_2: xmlParserErrors = 1849;
pub const XML_SCHEMAV_CVC_ELT_3_2_1: xmlParserErrors = 1848;
pub const XML_SCHEMAV_CVC_ELT_3_1: xmlParserErrors = 1847;
pub const XML_SCHEMAV_CVC_ELT_2: xmlParserErrors = 1846;
pub const XML_SCHEMAV_CVC_ELT_1: xmlParserErrors = 1845;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4: xmlParserErrors = 1844;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3: xmlParserErrors = 1843;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2: xmlParserErrors = 1842;
pub const XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1: xmlParserErrors = 1841;
pub const XML_SCHEMAV_CVC_ENUMERATION_VALID: xmlParserErrors = 1840;
pub const XML_SCHEMAV_CVC_PATTERN_VALID: xmlParserErrors = 1839;
pub const XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID: xmlParserErrors = 1838;
pub const XML_SCHEMAV_CVC_TOTALDIGITS_VALID: xmlParserErrors = 1837;
pub const XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID: xmlParserErrors = 1836;
pub const XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID: xmlParserErrors = 1835;
pub const XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID: xmlParserErrors = 1834;
pub const XML_SCHEMAV_CVC_MININCLUSIVE_VALID: xmlParserErrors = 1833;
pub const XML_SCHEMAV_CVC_MAXLENGTH_VALID: xmlParserErrors = 1832;
pub const XML_SCHEMAV_CVC_MINLENGTH_VALID: xmlParserErrors = 1831;
pub const XML_SCHEMAV_CVC_LENGTH_VALID: xmlParserErrors = 1830;
pub const XML_SCHEMAV_CVC_FACET_VALID: xmlParserErrors = 1829;
pub const XML_SCHEMAV_CVC_TYPE_3_1_2: xmlParserErrors = 1828;
pub const XML_SCHEMAV_CVC_TYPE_3_1_1: xmlParserErrors = 1827;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3: xmlParserErrors = 1826;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2: xmlParserErrors = 1825;
pub const XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1: xmlParserErrors = 1824;
pub const XML_SCHEMAV_FACET: xmlParserErrors = 1823;
pub const XML_SCHEMAV_VALUE: xmlParserErrors = 1822;
pub const XML_SCHEMAV_ATTRINVALID: xmlParserErrors = 1821;
pub const XML_SCHEMAV_ATTRUNKNOWN: xmlParserErrors = 1820;
pub const XML_SCHEMAV_NOTSIMPLE: xmlParserErrors = 1819;
pub const XML_SCHEMAV_INTERNAL: xmlParserErrors = 1818;
pub const XML_SCHEMAV_CONSTRUCT: xmlParserErrors = 1817;
pub const XML_SCHEMAV_NOTDETERMINIST: xmlParserErrors = 1816;
pub const XML_SCHEMAV_INVALIDELEM: xmlParserErrors = 1815;
pub const XML_SCHEMAV_INVALIDATTR: xmlParserErrors = 1814;
pub const XML_SCHEMAV_EXTRACONTENT: xmlParserErrors = 1813;
pub const XML_SCHEMAV_NOTNILLABLE: xmlParserErrors = 1812;
pub const XML_SCHEMAV_HAVEDEFAULT: xmlParserErrors = 1811;
pub const XML_SCHEMAV_ELEMCONT: xmlParserErrors = 1810;
pub const XML_SCHEMAV_NOTEMPTY: xmlParserErrors = 1809;
pub const XML_SCHEMAV_ISABSTRACT: xmlParserErrors = 1808;
pub const XML_SCHEMAV_NOROLLBACK: xmlParserErrors = 1807;
pub const XML_SCHEMAV_NOTYPE: xmlParserErrors = 1806;
pub const XML_SCHEMAV_WRONGELEM: xmlParserErrors = 1805;
pub const XML_SCHEMAV_MISSING: xmlParserErrors = 1804;
pub const XML_SCHEMAV_NOTTOPLEVEL: xmlParserErrors = 1803;
pub const XML_SCHEMAV_UNDECLAREDELEM: xmlParserErrors = 1802;
pub const XML_SCHEMAV_NOROOT: xmlParserErrors = 1801;
pub const XML_SCHEMAP_COS_CT_EXTENDS_1_3: xmlParserErrors = 1800;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3: xmlParserErrors = 1799;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2: xmlParserErrors = 1798;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1: xmlParserErrors = 1797;
pub const XML_SCHEMAP_SRC_IMPORT_3_2: xmlParserErrors = 1796;
pub const XML_SCHEMAP_SRC_IMPORT_3_1: xmlParserErrors = 1795;
pub const XML_SCHEMAP_UNION_NOT_EXPRESSIBLE: xmlParserErrors = 1794;
pub const XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE: xmlParserErrors = 1793;
pub const XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER: xmlParserErrors = 1792;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3: xmlParserErrors = 1791;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2: xmlParserErrors = 1790;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2: xmlParserErrors = 1789;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1: xmlParserErrors = 1788;
pub const XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1: xmlParserErrors = 1787;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_5: xmlParserErrors = 1786;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_4: xmlParserErrors = 1785;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_3: xmlParserErrors = 1784;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_2: xmlParserErrors = 1783;
pub const XML_SCHEMAP_CT_PROPS_CORRECT_1: xmlParserErrors = 1782;
pub const XML_SCHEMAP_REF_AND_CONTENT: xmlParserErrors = 1781;
pub const XML_SCHEMAP_INVALID_ATTR_NAME: xmlParserErrors = 1780;
pub const XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD: xmlParserErrors = 1779;
pub const XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION: xmlParserErrors = 1778;
pub const XML_SCHEMAP_INVALID_ATTR_COMBINATION: xmlParserErrors = 1777;
pub const XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE: xmlParserErrors = 1776;
pub const XML_SCHEMAP_RECURSIVE: xmlParserErrors = 1775;
pub const XML_SCHEMAP_INVALID_ATTR_USE: xmlParserErrors = 1774;
pub const XML_SCHEMAP_UNKNOWN_MEMBER_TYPE: xmlParserErrors = 1773;
pub const XML_SCHEMAP_NOT_SCHEMA: xmlParserErrors = 1772;
pub const XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI: xmlParserErrors = 1771;
pub const XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI: xmlParserErrors = 1770;
pub const XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD: xmlParserErrors = 1769;
pub const XML_SCHEMAP_DEF_AND_PREFIX: xmlParserErrors = 1768;
pub const XML_SCHEMAP_UNKNOWN_PREFIX: xmlParserErrors = 1767;
pub const XML_SCHEMAP_FAILED_PARSE: xmlParserErrors = 1766;
pub const XML_SCHEMAP_REDEFINED_NOTATION: xmlParserErrors = 1765;
pub const XML_SCHEMAP_REDEFINED_ATTR: xmlParserErrors = 1764;
pub const XML_SCHEMAP_REDEFINED_ATTRGROUP: xmlParserErrors = 1763;
pub const XML_SCHEMAP_REDEFINED_ELEMENT: xmlParserErrors = 1762;
pub const XML_SCHEMAP_REDEFINED_TYPE: xmlParserErrors = 1761;
pub const XML_SCHEMAP_REDEFINED_GROUP: xmlParserErrors = 1760;
pub const XML_SCHEMAP_NOROOT: xmlParserErrors = 1759;
pub const XML_SCHEMAP_NOTHING_TO_PARSE: xmlParserErrors = 1758;
pub const XML_SCHEMAP_FAILED_LOAD: xmlParserErrors = 1757;
pub const XML_SCHEMAP_REGEXP_INVALID: xmlParserErrors = 1756;
pub const XML_SCHEMAP_ELEM_DEFAULT_FIXED: xmlParserErrors = 1755;
pub const XML_SCHEMAP_UNKNOWN_UNION_CHILD: xmlParserErrors = 1754;
pub const XML_SCHEMAP_UNKNOWN_TYPE: xmlParserErrors = 1753;
pub const XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD: xmlParserErrors = 1752;
pub const XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD: xmlParserErrors = 1751;
pub const XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD: xmlParserErrors = 1750;
pub const XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD: xmlParserErrors = 1749;
pub const XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD: xmlParserErrors = 1748;
pub const XML_SCHEMAP_UNKNOWN_REF: xmlParserErrors = 1747;
pub const XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD: xmlParserErrors = 1746;
pub const XML_SCHEMAP_UNKNOWN_NOTATION_CHILD: xmlParserErrors = 1745;
pub const XML_SCHEMAP_UNKNOWN_LIST_CHILD: xmlParserErrors = 1744;
pub const XML_SCHEMAP_UNKNOWN_IMPORT_CHILD: xmlParserErrors = 1743;
pub const XML_SCHEMAP_UNKNOWN_GROUP_CHILD: xmlParserErrors = 1742;
pub const XML_SCHEMAP_UNKNOWN_FACET_TYPE: xmlParserErrors = 1741;
pub const XML_SCHEMAP_UNKNOWN_FACET_CHILD: xmlParserErrors = 1740;
pub const XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD: xmlParserErrors = 1739;
pub const XML_SCHEMAP_UNKNOWN_ELEM_CHILD: xmlParserErrors = 1738;
pub const XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD: xmlParserErrors = 1737;
pub const XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD: xmlParserErrors = 1736;
pub const XML_SCHEMAP_UNKNOWN_CHOICE_CHILD: xmlParserErrors = 1735;
pub const XML_SCHEMAP_UNKNOWN_BASE_TYPE: xmlParserErrors = 1734;
pub const XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP: xmlParserErrors = 1733;
pub const XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD: xmlParserErrors = 1732;
pub const XML_SCHEMAP_UNKNOWN_ATTR_CHILD: xmlParserErrors = 1731;
pub const XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD: xmlParserErrors = 1730;
pub const XML_SCHEMAP_UNKNOWN_ALL_CHILD: xmlParserErrors = 1729;
pub const XML_SCHEMAP_TYPE_AND_SUBTYPE: xmlParserErrors = 1728;
pub const XML_SCHEMAP_SIMPLETYPE_NONAME: xmlParserErrors = 1727;
pub const XML_SCHEMAP_RESTRICTION_NONAME_NOREF: xmlParserErrors = 1726;
pub const XML_SCHEMAP_REF_AND_SUBTYPE: xmlParserErrors = 1725;
pub const XML_SCHEMAP_NOTYPE_NOREF: xmlParserErrors = 1724;
pub const XML_SCHEMAP_NOTATION_NO_NAME: xmlParserErrors = 1723;
pub const XML_SCHEMAP_NOATTR_NOREF: xmlParserErrors = 1722;
pub const XML_SCHEMAP_INVALID_WHITE_SPACE: xmlParserErrors = 1721;
pub const XML_SCHEMAP_INVALID_REF_AND_SUBTYPE: xmlParserErrors = 1720;
pub const XML_SCHEMAP_INVALID_MINOCCURS: xmlParserErrors = 1719;
pub const XML_SCHEMAP_INVALID_MAXOCCURS: xmlParserErrors = 1718;
pub const XML_SCHEMAP_INVALID_FACET_VALUE: xmlParserErrors = 1717;
pub const XML_SCHEMAP_INVALID_FACET: xmlParserErrors = 1716;
pub const XML_SCHEMAP_INVALID_ENUM: xmlParserErrors = 1715;
pub const XML_SCHEMAP_INVALID_BOOLEAN: xmlParserErrors = 1714;
pub const XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI: xmlParserErrors = 1713;
pub const XML_SCHEMAP_IMPORT_REDEFINE_NSNAME: xmlParserErrors = 1712;
pub const XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI: xmlParserErrors = 1711;
pub const XML_SCHEMAP_GROUP_NONAME_NOREF: xmlParserErrors = 1710;
pub const XML_SCHEMAP_FAILED_BUILD_IMPORT: xmlParserErrors = 1709;
pub const XML_SCHEMAP_FACET_NO_VALUE: xmlParserErrors = 1708;
pub const XML_SCHEMAP_EXTENSION_NO_BASE: xmlParserErrors = 1707;
pub const XML_SCHEMAP_ELEM_NONAME_NOREF: xmlParserErrors = 1706;
pub const XML_SCHEMAP_ELEMFORMDEFAULT_VALUE: xmlParserErrors = 1705;
pub const XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF: xmlParserErrors = 1704;
pub const XML_SCHEMAP_ATTR_NONAME_NOREF: xmlParserErrors = 1703;
pub const XML_SCHEMAP_ATTRGRP_NONAME_NOREF: xmlParserErrors = 1702;
pub const XML_SCHEMAP_ATTRFORMDEFAULT_VALUE: xmlParserErrors = 1701;
pub const XML_SCHEMAP_PREFIX_UNDEFINED: xmlParserErrors = 1700;
pub const XML_CATALOG_RECURSION: xmlParserErrors = 1654;
pub const XML_CATALOG_NOT_CATALOG: xmlParserErrors = 1653;
pub const XML_CATALOG_PREFER_VALUE: xmlParserErrors = 1652;
pub const XML_CATALOG_ENTRY_BROKEN: xmlParserErrors = 1651;
pub const XML_CATALOG_MISSING_ATTR: xmlParserErrors = 1650;
pub const XML_XINCLUDE_FRAGMENT_ID: xmlParserErrors = 1618;
pub const XML_XINCLUDE_DEPRECATED_NS: xmlParserErrors = 1617;
pub const XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE: xmlParserErrors = 1616;
pub const XML_XINCLUDE_FALLBACKS_IN_INCLUDE: xmlParserErrors = 1615;
pub const XML_XINCLUDE_INCLUDE_IN_INCLUDE: xmlParserErrors = 1614;
pub const XML_XINCLUDE_XPTR_RESULT: xmlParserErrors = 1613;
pub const XML_XINCLUDE_XPTR_FAILED: xmlParserErrors = 1612;
pub const XML_XINCLUDE_MULTIPLE_ROOT: xmlParserErrors = 1611;
pub const XML_XINCLUDE_UNKNOWN_ENCODING: xmlParserErrors = 1610;
pub const XML_XINCLUDE_BUILD_FAILED: xmlParserErrors = 1609;
pub const XML_XINCLUDE_INVALID_CHAR: xmlParserErrors = 1608;
pub const XML_XINCLUDE_TEXT_DOCUMENT: xmlParserErrors = 1607;
pub const XML_XINCLUDE_TEXT_FRAGMENT: xmlParserErrors = 1606;
pub const XML_XINCLUDE_HREF_URI: xmlParserErrors = 1605;
pub const XML_XINCLUDE_NO_FALLBACK: xmlParserErrors = 1604;
pub const XML_XINCLUDE_NO_HREF: xmlParserErrors = 1603;
pub const XML_XINCLUDE_ENTITY_DEF_MISMATCH: xmlParserErrors = 1602;
pub const XML_XINCLUDE_PARSE_VALUE: xmlParserErrors = 1601;
pub const XML_XINCLUDE_RECURSION: xmlParserErrors = 1600;
pub const XML_IO_EAFNOSUPPORT: xmlParserErrors = 1556;
pub const XML_IO_EALREADY: xmlParserErrors = 1555;
pub const XML_IO_EADDRINUSE: xmlParserErrors = 1554;
pub const XML_IO_ENETUNREACH: xmlParserErrors = 1553;
pub const XML_IO_ECONNREFUSED: xmlParserErrors = 1552;
pub const XML_IO_EISCONN: xmlParserErrors = 1551;
pub const XML_IO_ENOTSOCK: xmlParserErrors = 1550;
pub const XML_IO_LOAD_ERROR: xmlParserErrors = 1549;
pub const XML_IO_BUFFER_FULL: xmlParserErrors = 1548;
pub const XML_IO_NO_INPUT: xmlParserErrors = 1547;
pub const XML_IO_WRITE: xmlParserErrors = 1546;
pub const XML_IO_FLUSH: xmlParserErrors = 1545;
pub const XML_IO_ENCODER: xmlParserErrors = 1544;
pub const XML_IO_NETWORK_ATTEMPT: xmlParserErrors = 1543;
pub const XML_IO_EXDEV: xmlParserErrors = 1542;
pub const XML_IO_ETIMEDOUT: xmlParserErrors = 1541;
pub const XML_IO_ESRCH: xmlParserErrors = 1540;
pub const XML_IO_ESPIPE: xmlParserErrors = 1539;
pub const XML_IO_EROFS: xmlParserErrors = 1538;
pub const XML_IO_ERANGE: xmlParserErrors = 1537;
pub const XML_IO_EPIPE: xmlParserErrors = 1536;
pub const XML_IO_EPERM: xmlParserErrors = 1535;
pub const XML_IO_ENXIO: xmlParserErrors = 1534;
pub const XML_IO_ENOTTY: xmlParserErrors = 1533;
pub const XML_IO_ENOTSUP: xmlParserErrors = 1532;
pub const XML_IO_ENOTEMPTY: xmlParserErrors = 1531;
pub const XML_IO_ENOTDIR: xmlParserErrors = 1530;
pub const XML_IO_ENOSYS: xmlParserErrors = 1529;
pub const XML_IO_ENOSPC: xmlParserErrors = 1528;
pub const XML_IO_ENOMEM: xmlParserErrors = 1527;
pub const XML_IO_ENOLCK: xmlParserErrors = 1526;
pub const XML_IO_ENOEXEC: xmlParserErrors = 1525;
pub const XML_IO_ENOENT: xmlParserErrors = 1524;
pub const XML_IO_ENODEV: xmlParserErrors = 1523;
pub const XML_IO_ENFILE: xmlParserErrors = 1522;
pub const XML_IO_ENAMETOOLONG: xmlParserErrors = 1521;
pub const XML_IO_EMSGSIZE: xmlParserErrors = 1520;
pub const XML_IO_EMLINK: xmlParserErrors = 1519;
pub const XML_IO_EMFILE: xmlParserErrors = 1518;
pub const XML_IO_EISDIR: xmlParserErrors = 1517;
pub const XML_IO_EIO: xmlParserErrors = 1516;
pub const XML_IO_EINVAL: xmlParserErrors = 1515;
pub const XML_IO_EINTR: xmlParserErrors = 1514;
pub const XML_IO_EINPROGRESS: xmlParserErrors = 1513;
pub const XML_IO_EFBIG: xmlParserErrors = 1512;
pub const XML_IO_EFAULT: xmlParserErrors = 1511;
pub const XML_IO_EEXIST: xmlParserErrors = 1510;
pub const XML_IO_EDOM: xmlParserErrors = 1509;
pub const XML_IO_EDEADLK: xmlParserErrors = 1508;
pub const XML_IO_ECHILD: xmlParserErrors = 1507;
pub const XML_IO_ECANCELED: xmlParserErrors = 1506;
pub const XML_IO_EBUSY: xmlParserErrors = 1505;
pub const XML_IO_EBADMSG: xmlParserErrors = 1504;
pub const XML_IO_EBADF: xmlParserErrors = 1503;
pub const XML_IO_EAGAIN: xmlParserErrors = 1502;
pub const XML_IO_EACCES: xmlParserErrors = 1501;
pub const XML_IO_UNKNOWN: xmlParserErrors = 1500;
pub const XML_REGEXP_COMPILE_ERROR: xmlParserErrors = 1450;
pub const XML_SAVE_UNKNOWN_ENCODING: xmlParserErrors = 1403;
pub const XML_SAVE_NO_DOCTYPE: xmlParserErrors = 1402;
pub const XML_SAVE_CHAR_INVALID: xmlParserErrors = 1401;
pub const XML_SAVE_NOT_UTF8: xmlParserErrors = 1400;
pub const XML_TREE_NOT_UTF8: xmlParserErrors = 1303;
pub const XML_TREE_UNTERMINATED_ENTITY: xmlParserErrors = 1302;
pub const XML_TREE_INVALID_DEC: xmlParserErrors = 1301;
pub const XML_TREE_INVALID_HEX: xmlParserErrors = 1300;
pub const XML_XPATH_INVALID_CHAR_ERROR: xmlParserErrors = 1221;
pub const XML_XPATH_ENCODING_ERROR: xmlParserErrors = 1220;
pub const XML_XPATH_UNDEF_PREFIX_ERROR: xmlParserErrors = 1219;
pub const XML_XPTR_SUB_RESOURCE_ERROR: xmlParserErrors = 1218;
pub const XML_XPTR_RESOURCE_ERROR: xmlParserErrors = 1217;
pub const XML_XPTR_SYNTAX_ERROR: xmlParserErrors = 1216;
pub const XML_XPATH_MEMORY_ERROR: xmlParserErrors = 1215;
pub const XML_XPATH_INVALID_CTXT_POSITION: xmlParserErrors = 1214;
pub const XML_XPATH_INVALID_CTXT_SIZE: xmlParserErrors = 1213;
pub const XML_XPATH_INVALID_ARITY: xmlParserErrors = 1212;
pub const XML_XPATH_INVALID_TYPE: xmlParserErrors = 1211;
pub const XML_XPATH_INVALID_OPERAND: xmlParserErrors = 1210;
pub const XML_XPATH_UNKNOWN_FUNC_ERROR: xmlParserErrors = 1209;
pub const XML_XPATH_UNCLOSED_ERROR: xmlParserErrors = 1208;
pub const XML_XPATH_EXPR_ERROR: xmlParserErrors = 1207;
pub const XML_XPATH_INVALID_PREDICATE_ERROR: xmlParserErrors = 1206;
pub const XML_XPATH_UNDEF_VARIABLE_ERROR: xmlParserErrors = 1205;
pub const XML_XPATH_VARIABLE_REF_ERROR: xmlParserErrors = 1204;
pub const XML_XPATH_START_LITERAL_ERROR: xmlParserErrors = 1203;
pub const XML_XPATH_UNFINISHED_LITERAL_ERROR: xmlParserErrors = 1202;
pub const XML_XPATH_NUMBER_ERROR: xmlParserErrors = 1201;
pub const XML_XPATH_EXPRESSION_OK: xmlParserErrors = 1200;
pub const XML_RNGP_XML_NS: xmlParserErrors = 1122;
pub const XML_RNGP_XMLNS_NAME: xmlParserErrors = 1121;
pub const XML_RNGP_VALUE_NO_CONTENT: xmlParserErrors = 1120;
pub const XML_RNGP_VALUE_EMPTY: xmlParserErrors = 1119;
pub const XML_RNGP_URI_NOT_ABSOLUTE: xmlParserErrors = 1118;
pub const XML_RNGP_URI_FRAGMENT: xmlParserErrors = 1117;
pub const XML_RNGP_UNKNOWN_TYPE_LIB: xmlParserErrors = 1116;
pub const XML_RNGP_UNKNOWN_CONSTRUCT: xmlParserErrors = 1115;
pub const XML_RNGP_UNKNOWN_COMBINE: xmlParserErrors = 1114;
pub const XML_RNGP_UNKNOWN_ATTRIBUTE: xmlParserErrors = 1113;
pub const XML_RNGP_TYPE_VALUE: xmlParserErrors = 1112;
pub const XML_RNGP_TYPE_NOT_FOUND: xmlParserErrors = 1111;
pub const XML_RNGP_TYPE_MISSING: xmlParserErrors = 1110;
pub const XML_RNGP_TEXT_HAS_CHILD: xmlParserErrors = 1109;
pub const XML_RNGP_TEXT_EXPECTED: xmlParserErrors = 1108;
pub const XML_RNGP_START_MISSING: xmlParserErrors = 1107;
pub const XML_RNGP_START_EMPTY: xmlParserErrors = 1106;
pub const XML_RNGP_START_CONTENT: xmlParserErrors = 1105;
pub const XML_RNGP_START_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1104;
pub const XML_RNGP_REF_NOT_EMPTY: xmlParserErrors = 1103;
pub const XML_RNGP_REF_NO_NAME: xmlParserErrors = 1102;
pub const XML_RNGP_REF_NO_DEF: xmlParserErrors = 1101;
pub const XML_RNGP_REF_NAME_INVALID: xmlParserErrors = 1100;
pub const XML_RNGP_REF_CYCLE: xmlParserErrors = 1099;
pub const XML_RNGP_REF_CREATE_FAILED: xmlParserErrors = 1098;
pub const XML_RNGP_PREFIX_UNDEFINED: xmlParserErrors = 1097;
pub const XML_RNGP_PAT_START_VALUE: xmlParserErrors = 1096;
pub const XML_RNGP_PAT_START_TEXT: xmlParserErrors = 1095;
pub const XML_RNGP_PAT_START_ONEMORE: xmlParserErrors = 1094;
pub const XML_RNGP_PAT_START_LIST: xmlParserErrors = 1093;
pub const XML_RNGP_PAT_START_INTERLEAVE: xmlParserErrors = 1092;
pub const XML_RNGP_PAT_START_GROUP: xmlParserErrors = 1091;
pub const XML_RNGP_PAT_START_EMPTY: xmlParserErrors = 1090;
pub const XML_RNGP_PAT_START_DATA: xmlParserErrors = 1089;
pub const XML_RNGP_PAT_START_ATTR: xmlParserErrors = 1088;
pub const XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR: xmlParserErrors = 1087;
pub const XML_RNGP_PAT_ONEMORE_GROUP_ATTR: xmlParserErrors = 1086;
pub const XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME: xmlParserErrors = 1085;
pub const XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME: xmlParserErrors = 1084;
pub const XML_RNGP_PAT_LIST_TEXT: xmlParserErrors = 1083;
pub const XML_RNGP_PAT_LIST_REF: xmlParserErrors = 1082;
pub const XML_RNGP_PAT_LIST_LIST: xmlParserErrors = 1081;
pub const XML_RNGP_PAT_LIST_INTERLEAVE: xmlParserErrors = 1080;
pub const XML_RNGP_PAT_LIST_ELEM: xmlParserErrors = 1079;
pub const XML_RNGP_PAT_LIST_ATTR: xmlParserErrors = 1078;
pub const XML_RNGP_PAT_DATA_EXCEPT_TEXT: xmlParserErrors = 1077;
pub const XML_RNGP_PAT_DATA_EXCEPT_REF: xmlParserErrors = 1076;
pub const XML_RNGP_PAT_DATA_EXCEPT_ONEMORE: xmlParserErrors = 1075;
pub const XML_RNGP_PAT_DATA_EXCEPT_LIST: xmlParserErrors = 1074;
pub const XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE: xmlParserErrors = 1073;
pub const XML_RNGP_PAT_DATA_EXCEPT_GROUP: xmlParserErrors = 1072;
pub const XML_RNGP_PAT_DATA_EXCEPT_EMPTY: xmlParserErrors = 1071;
pub const XML_RNGP_PAT_DATA_EXCEPT_ELEM: xmlParserErrors = 1070;
pub const XML_RNGP_PAT_DATA_EXCEPT_ATTR: xmlParserErrors = 1069;
pub const XML_RNGP_PAT_ATTR_ELEM: xmlParserErrors = 1068;
pub const XML_RNGP_PAT_ATTR_ATTR: xmlParserErrors = 1067;
pub const XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME: xmlParserErrors = 1066;
pub const XML_RNGP_PARSE_ERROR: xmlParserErrors = 1065;
pub const XML_RNGP_PARENTREF_NOT_EMPTY: xmlParserErrors = 1064;
pub const XML_RNGP_PARENTREF_NO_PARENT: xmlParserErrors = 1063;
pub const XML_RNGP_PARENTREF_NO_NAME: xmlParserErrors = 1062;
pub const XML_RNGP_PARENTREF_NAME_INVALID: xmlParserErrors = 1061;
pub const XML_RNGP_PARENTREF_CREATE_FAILED: xmlParserErrors = 1060;
pub const XML_RNGP_PARAM_NAME_MISSING: xmlParserErrors = 1059;
pub const XML_RNGP_PARAM_FORBIDDEN: xmlParserErrors = 1058;
pub const XML_RNGP_NSNAME_NO_NS: xmlParserErrors = 1057;
pub const XML_RNGP_NSNAME_ATTR_ANCESTOR: xmlParserErrors = 1056;
pub const XML_RNGP_NOTALLOWED_NOT_EMPTY: xmlParserErrors = 1055;
pub const XML_RNGP_NEED_COMBINE: xmlParserErrors = 1054;
pub const XML_RNGP_NAME_MISSING: xmlParserErrors = 1053;
pub const XML_RNGP_MISSING_HREF: xmlParserErrors = 1052;
pub const XML_RNGP_INVALID_VALUE: xmlParserErrors = 1051;
pub const XML_RNGP_INVALID_URI: xmlParserErrors = 1050;
pub const XML_RNGP_INVALID_DEFINE_NAME: xmlParserErrors = 1049;
pub const XML_RNGP_INTERLEAVE_NO_CONTENT: xmlParserErrors = 1048;
pub const XML_RNGP_INTERLEAVE_EMPTY: xmlParserErrors = 1047;
pub const XML_RNGP_INTERLEAVE_CREATE_FAILED: xmlParserErrors = 1046;
pub const XML_RNGP_INTERLEAVE_ADD: xmlParserErrors = 1045;
pub const XML_RNGP_INCLUDE_RECURSE: xmlParserErrors = 1044;
pub const XML_RNGP_INCLUDE_FAILURE: xmlParserErrors = 1043;
pub const XML_RNGP_INCLUDE_EMPTY: xmlParserErrors = 1042;
pub const XML_RNGP_HREF_ERROR: xmlParserErrors = 1041;
pub const XML_RNGP_GROUP_ATTR_CONFLICT: xmlParserErrors = 1040;
pub const XML_RNGP_GRAMMAR_NO_START: xmlParserErrors = 1039;
pub const XML_RNGP_GRAMMAR_MISSING: xmlParserErrors = 1038;
pub const XML_RNGP_GRAMMAR_EMPTY: xmlParserErrors = 1037;
pub const XML_RNGP_GRAMMAR_CONTENT: xmlParserErrors = 1036;
pub const XML_RNGP_FOREIGN_ELEMENT: xmlParserErrors = 1035;
pub const XML_RNGP_FORBIDDEN_ATTRIBUTE: xmlParserErrors = 1034;
pub const XML_RNGP_EXTERNALREF_RECURSE: xmlParserErrors = 1033;
pub const XML_RNGP_EXTERNAL_REF_FAILURE: xmlParserErrors = 1032;
pub const XML_RNGP_EXTERNALREF_EMTPY: xmlParserErrors = 1031;
pub const XML_RNGP_EXCEPT_NO_CONTENT: xmlParserErrors = 1030;
pub const XML_RNGP_EXCEPT_MULTIPLE: xmlParserErrors = 1029;
pub const XML_RNGP_EXCEPT_MISSING: xmlParserErrors = 1028;
pub const XML_RNGP_EXCEPT_EMPTY: xmlParserErrors = 1027;
pub const XML_RNGP_ERROR_TYPE_LIB: xmlParserErrors = 1026;
pub const XML_RNGP_EMPTY_NOT_EMPTY: xmlParserErrors = 1025;
pub const XML_RNGP_EMPTY_CONTENT: xmlParserErrors = 1024;
pub const XML_RNGP_EMPTY_CONSTRUCT: xmlParserErrors = 1023;
pub const XML_RNGP_EMPTY: xmlParserErrors = 1022;
pub const XML_RNGP_ELEM_TEXT_CONFLICT: xmlParserErrors = 1021;
pub const XML_RNGP_ELEMENT_NO_CONTENT: xmlParserErrors = 1020;
pub const XML_RNGP_ELEMENT_NAME: xmlParserErrors = 1019;
pub const XML_RNGP_ELEMENT_CONTENT: xmlParserErrors = 1018;
pub const XML_RNGP_ELEMENT_EMPTY: xmlParserErrors = 1017;
pub const XML_RNGP_ELEM_CONTENT_ERROR: xmlParserErrors = 1016;
pub const XML_RNGP_ELEM_CONTENT_EMPTY: xmlParserErrors = 1015;
pub const XML_RNGP_DEFINE_NAME_MISSING: xmlParserErrors = 1014;
pub const XML_RNGP_DEFINE_MISSING: xmlParserErrors = 1013;
pub const XML_RNGP_DEFINE_EMPTY: xmlParserErrors = 1012;
pub const XML_RNGP_DEFINE_CREATE_FAILED: xmlParserErrors = 1011;
pub const XML_RNGP_DEF_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1010;
pub const XML_RNGP_DATA_CONTENT: xmlParserErrors = 1009;
pub const XML_RNGP_CREATE_FAILURE: xmlParserErrors = 1008;
pub const XML_RNGP_CHOICE_EMPTY: xmlParserErrors = 1007;
pub const XML_RNGP_CHOICE_CONTENT: xmlParserErrors = 1006;
pub const XML_RNGP_ATTRIBUTE_NOOP: xmlParserErrors = 1005;
pub const XML_RNGP_ATTRIBUTE_EMPTY: xmlParserErrors = 1004;
pub const XML_RNGP_ATTRIBUTE_CONTENT: xmlParserErrors = 1003;
pub const XML_RNGP_ATTRIBUTE_CHILDREN: xmlParserErrors = 1002;
pub const XML_RNGP_ATTR_CONFLICT: xmlParserErrors = 1001;
pub const XML_RNGP_ANYNAME_ATTR_ANCESTOR: xmlParserErrors = 1000;
pub const XML_HTML_INCORRECTLY_OPENED_COMMENT: xmlParserErrors = 802;
pub const XML_HTML_UNKNOWN_TAG: xmlParserErrors = 801;
pub const XML_HTML_STRUCURE_ERROR: xmlParserErrors = 800;
pub const XML_DTD_DUP_TOKEN: xmlParserErrors = 541;
pub const XML_DTD_XMLID_TYPE: xmlParserErrors = 540;
pub const XML_DTD_XMLID_VALUE: xmlParserErrors = 539;
pub const XML_DTD_STANDALONE_DEFAULTED: xmlParserErrors = 538;
pub const XML_DTD_UNKNOWN_NOTATION: xmlParserErrors = 537;
pub const XML_DTD_UNKNOWN_ID: xmlParserErrors = 536;
pub const XML_DTD_UNKNOWN_ENTITY: xmlParserErrors = 535;
pub const XML_DTD_UNKNOWN_ELEM: xmlParserErrors = 534;
pub const XML_DTD_UNKNOWN_ATTRIBUTE: xmlParserErrors = 533;
pub const XML_DTD_STANDALONE_WHITE_SPACE: xmlParserErrors = 532;
pub const XML_DTD_ROOT_NAME: xmlParserErrors = 531;
pub const XML_DTD_NOT_STANDALONE: xmlParserErrors = 530;
pub const XML_DTD_NOT_PCDATA: xmlParserErrors = 529;
pub const XML_DTD_NOT_EMPTY: xmlParserErrors = 528;
pub const XML_DTD_NOTATION_VALUE: xmlParserErrors = 527;
pub const XML_DTD_NOTATION_REDEFINED: xmlParserErrors = 526;
pub const XML_DTD_NO_ROOT: xmlParserErrors = 525;
pub const XML_DTD_NO_PREFIX: xmlParserErrors = 524;
pub const XML_DTD_NO_ELEM_NAME: xmlParserErrors = 523;
pub const XML_DTD_NO_DTD: xmlParserErrors = 522;
pub const XML_DTD_NO_DOC: xmlParserErrors = 521;
pub const XML_DTD_MULTIPLE_ID: xmlParserErrors = 520;
pub const XML_DTD_MIXED_CORRUPT: xmlParserErrors = 519;
pub const XML_DTD_MISSING_ATTRIBUTE: xmlParserErrors = 518;
pub const XML_DTD_LOAD_ERROR: xmlParserErrors = 517;
pub const XML_DTD_INVALID_DEFAULT: xmlParserErrors = 516;
pub const XML_DTD_INVALID_CHILD: xmlParserErrors = 515;
pub const XML_DTD_ID_SUBSET: xmlParserErrors = 514;
pub const XML_DTD_ID_REDEFINED: xmlParserErrors = 513;
pub const XML_DTD_ID_FIXED: xmlParserErrors = 512;
pub const XML_DTD_ENTITY_TYPE: xmlParserErrors = 511;
pub const XML_DTD_EMPTY_NOTATION: xmlParserErrors = 510;
pub const XML_DTD_ELEM_REDEFINED: xmlParserErrors = 509;
pub const XML_DTD_ELEM_NAMESPACE: xmlParserErrors = 508;
pub const XML_DTD_ELEM_DEFAULT_NAMESPACE: xmlParserErrors = 507;
pub const XML_DTD_DIFFERENT_PREFIX: xmlParserErrors = 506;
pub const XML_DTD_CONTENT_NOT_DETERMINIST: xmlParserErrors = 505;
pub const XML_DTD_CONTENT_MODEL: xmlParserErrors = 504;
pub const XML_DTD_CONTENT_ERROR: xmlParserErrors = 503;
pub const XML_DTD_ATTRIBUTE_VALUE: xmlParserErrors = 502;
pub const XML_DTD_ATTRIBUTE_REDEFINED: xmlParserErrors = 501;
pub const XML_DTD_ATTRIBUTE_DEFAULT: xmlParserErrors = 500;
pub const XML_NS_ERR_COLON: xmlParserErrors = 205;
pub const XML_NS_ERR_EMPTY: xmlParserErrors = 204;
pub const XML_NS_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 203;
pub const XML_NS_ERR_QNAME: xmlParserErrors = 202;
pub const XML_NS_ERR_UNDEFINED_NAMESPACE: xmlParserErrors = 201;
pub const XML_NS_ERR_XML_NAMESPACE: xmlParserErrors = 200;
pub const XML_ERR_COMMENT_ABRUPTLY_ENDED: xmlParserErrors = 112;
pub const XML_ERR_USER_STOP: xmlParserErrors = 111;
pub const XML_ERR_NAME_TOO_LONG: xmlParserErrors = 110;
pub const XML_ERR_VERSION_MISMATCH: xmlParserErrors = 109;
pub const XML_ERR_UNKNOWN_VERSION: xmlParserErrors = 108;
pub const XML_WAR_ENTITY_REDEFINED: xmlParserErrors = 107;
pub const XML_WAR_NS_COLUMN: xmlParserErrors = 106;
pub const XML_ERR_NOTATION_PROCESSING: xmlParserErrors = 105;
pub const XML_ERR_ENTITY_PROCESSING: xmlParserErrors = 104;
pub const XML_ERR_NOT_STANDALONE: xmlParserErrors = 103;
pub const XML_WAR_SPACE_VALUE: xmlParserErrors = 102;
pub const XML_ERR_MISSING_ENCODING: xmlParserErrors = 101;
pub const XML_WAR_NS_URI_RELATIVE: xmlParserErrors = 100;
pub const XML_WAR_NS_URI: xmlParserErrors = 99;
pub const XML_WAR_LANG_VALUE: xmlParserErrors = 98;
pub const XML_WAR_UNKNOWN_VERSION: xmlParserErrors = 97;
pub const XML_ERR_VERSION_MISSING: xmlParserErrors = 96;
pub const XML_ERR_CONDSEC_INVALID_KEYWORD: xmlParserErrors = 95;
pub const XML_ERR_NO_DTD: xmlParserErrors = 94;
pub const XML_WAR_CATALOG_PI: xmlParserErrors = 93;
pub const XML_ERR_URI_FRAGMENT: xmlParserErrors = 92;
pub const XML_ERR_INVALID_URI: xmlParserErrors = 91;
pub const XML_ERR_ENTITY_BOUNDARY: xmlParserErrors = 90;
pub const XML_ERR_ENTITY_LOOP: xmlParserErrors = 89;
pub const XML_ERR_ENTITY_PE_INTERNAL: xmlParserErrors = 88;
pub const XML_ERR_ENTITY_CHAR_ERROR: xmlParserErrors = 87;
pub const XML_ERR_EXTRA_CONTENT: xmlParserErrors = 86;
pub const XML_ERR_NOT_WELL_BALANCED: xmlParserErrors = 85;
pub const XML_ERR_VALUE_REQUIRED: xmlParserErrors = 84;
pub const XML_ERR_CONDSEC_INVALID: xmlParserErrors = 83;
pub const XML_ERR_EXT_ENTITY_STANDALONE: xmlParserErrors = 82;
pub const XML_ERR_INVALID_ENCODING: xmlParserErrors = 81;
pub const XML_ERR_HYPHEN_IN_COMMENT: xmlParserErrors = 80;
pub const XML_ERR_ENCODING_NAME: xmlParserErrors = 79;
pub const XML_ERR_STANDALONE_VALUE: xmlParserErrors = 78;
pub const XML_ERR_TAG_NOT_FINISHED: xmlParserErrors = 77;
pub const XML_ERR_TAG_NAME_MISMATCH: xmlParserErrors = 76;
pub const XML_ERR_EQUAL_REQUIRED: xmlParserErrors = 75;
pub const XML_ERR_LTSLASH_REQUIRED: xmlParserErrors = 74;
pub const XML_ERR_GT_REQUIRED: xmlParserErrors = 73;
pub const XML_ERR_LT_REQUIRED: xmlParserErrors = 72;
pub const XML_ERR_PUBID_REQUIRED: xmlParserErrors = 71;
pub const XML_ERR_URI_REQUIRED: xmlParserErrors = 70;
pub const XML_ERR_PCDATA_REQUIRED: xmlParserErrors = 69;
pub const XML_ERR_NAME_REQUIRED: xmlParserErrors = 68;
pub const XML_ERR_NMTOKEN_REQUIRED: xmlParserErrors = 67;
pub const XML_ERR_SEPARATOR_REQUIRED: xmlParserErrors = 66;
pub const XML_ERR_SPACE_REQUIRED: xmlParserErrors = 65;
pub const XML_ERR_RESERVED_XML_NAME: xmlParserErrors = 64;
pub const XML_ERR_CDATA_NOT_FINISHED: xmlParserErrors = 63;
pub const XML_ERR_MISPLACED_CDATA_END: xmlParserErrors = 62;
pub const XML_ERR_DOCTYPE_NOT_FINISHED: xmlParserErrors = 61;
pub const XML_ERR_EXT_SUBSET_NOT_FINISHED: xmlParserErrors = 60;
pub const XML_ERR_CONDSEC_NOT_FINISHED: xmlParserErrors = 59;
pub const XML_ERR_CONDSEC_NOT_STARTED: xmlParserErrors = 58;
pub const XML_ERR_XMLDECL_NOT_FINISHED: xmlParserErrors = 57;
pub const XML_ERR_XMLDECL_NOT_STARTED: xmlParserErrors = 56;
pub const XML_ERR_ELEMCONTENT_NOT_FINISHED: xmlParserErrors = 55;
pub const XML_ERR_ELEMCONTENT_NOT_STARTED: xmlParserErrors = 54;
pub const XML_ERR_MIXED_NOT_FINISHED: xmlParserErrors = 53;
pub const XML_ERR_MIXED_NOT_STARTED: xmlParserErrors = 52;
pub const XML_ERR_ATTLIST_NOT_FINISHED: xmlParserErrors = 51;
pub const XML_ERR_ATTLIST_NOT_STARTED: xmlParserErrors = 50;
pub const XML_ERR_NOTATION_NOT_FINISHED: xmlParserErrors = 49;
pub const XML_ERR_NOTATION_NOT_STARTED: xmlParserErrors = 48;
pub const XML_ERR_PI_NOT_FINISHED: xmlParserErrors = 47;
pub const XML_ERR_PI_NOT_STARTED: xmlParserErrors = 46;
pub const XML_ERR_COMMENT_NOT_FINISHED: xmlParserErrors = 45;
pub const XML_ERR_LITERAL_NOT_FINISHED: xmlParserErrors = 44;
pub const XML_ERR_LITERAL_NOT_STARTED: xmlParserErrors = 43;
pub const XML_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 42;
pub const XML_ERR_ATTRIBUTE_WITHOUT_VALUE: xmlParserErrors = 41;
pub const XML_ERR_ATTRIBUTE_NOT_FINISHED: xmlParserErrors = 40;
pub const XML_ERR_ATTRIBUTE_NOT_STARTED: xmlParserErrors = 39;
pub const XML_ERR_LT_IN_ATTRIBUTE: xmlParserErrors = 38;
pub const XML_ERR_ENTITY_NOT_FINISHED: xmlParserErrors = 37;
pub const XML_ERR_ENTITY_NOT_STARTED: xmlParserErrors = 36;
pub const XML_ERR_NS_DECL_ERROR: xmlParserErrors = 35;
pub const XML_ERR_STRING_NOT_CLOSED: xmlParserErrors = 34;
pub const XML_ERR_STRING_NOT_STARTED: xmlParserErrors = 33;
pub const XML_ERR_UNSUPPORTED_ENCODING: xmlParserErrors = 32;
pub const XML_ERR_UNKNOWN_ENCODING: xmlParserErrors = 31;
pub const XML_ERR_ENTITY_IS_PARAMETER: xmlParserErrors = 30;
pub const XML_ERR_ENTITY_IS_EXTERNAL: xmlParserErrors = 29;
pub const XML_ERR_UNPARSED_ENTITY: xmlParserErrors = 28;
pub const XML_WAR_UNDECLARED_ENTITY: xmlParserErrors = 27;
pub const XML_ERR_UNDECLARED_ENTITY: xmlParserErrors = 26;
pub const XML_ERR_PEREF_SEMICOL_MISSING: xmlParserErrors = 25;
pub const XML_ERR_PEREF_NO_NAME: xmlParserErrors = 24;
pub const XML_ERR_ENTITYREF_SEMICOL_MISSING: xmlParserErrors = 23;
pub const XML_ERR_ENTITYREF_NO_NAME: xmlParserErrors = 22;
pub const XML_ERR_PEREF_IN_INT_SUBSET: xmlParserErrors = 21;
pub const XML_ERR_PEREF_IN_EPILOG: xmlParserErrors = 20;
pub const XML_ERR_PEREF_IN_PROLOG: xmlParserErrors = 19;
pub const XML_ERR_PEREF_AT_EOF: xmlParserErrors = 18;
pub const XML_ERR_ENTITYREF_IN_DTD: xmlParserErrors = 17;
pub const XML_ERR_ENTITYREF_IN_EPILOG: xmlParserErrors = 16;
pub const XML_ERR_ENTITYREF_IN_PROLOG: xmlParserErrors = 15;
pub const XML_ERR_ENTITYREF_AT_EOF: xmlParserErrors = 14;
pub const XML_ERR_CHARREF_IN_DTD: xmlParserErrors = 13;
pub const XML_ERR_CHARREF_IN_EPILOG: xmlParserErrors = 12;
pub const XML_ERR_CHARREF_IN_PROLOG: xmlParserErrors = 11;
pub const XML_ERR_CHARREF_AT_EOF: xmlParserErrors = 10;
pub const XML_ERR_INVALID_CHAR: xmlParserErrors = 9;
pub const XML_ERR_INVALID_CHARREF: xmlParserErrors = 8;
pub const XML_ERR_INVALID_DEC_CHARREF: xmlParserErrors = 7;
pub const XML_ERR_INVALID_HEX_CHARREF: xmlParserErrors = 6;
pub const XML_ERR_DOCUMENT_END: xmlParserErrors = 5;
pub const XML_ERR_DOCUMENT_EMPTY: xmlParserErrors = 4;
pub const XML_ERR_DOCUMENT_START: xmlParserErrors = 3;
pub const XML_ERR_NO_MEMORY: xmlParserErrors = 2;
pub const XML_ERR_INTERNAL_ERROR: xmlParserErrors = 1;
pub const XML_ERR_OK: xmlParserErrors = 0;
pub type xmlGenericErrorFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>;
pub type xmlValidCtxtPtr = *mut crate::src::tree::_xmlValidCtxt;
pub type xmlCharEncoding = i32;
pub const XML_CHAR_ENCODING_ASCII: xmlCharEncoding = 22;
pub const XML_CHAR_ENCODING_EUC_JP: xmlCharEncoding = 21;
pub const XML_CHAR_ENCODING_SHIFT_JIS: xmlCharEncoding = 20;
pub const XML_CHAR_ENCODING_2022_JP: xmlCharEncoding = 19;
pub const XML_CHAR_ENCODING_8859_9: xmlCharEncoding = 18;
pub const XML_CHAR_ENCODING_8859_8: xmlCharEncoding = 17;
pub const XML_CHAR_ENCODING_8859_7: xmlCharEncoding = 16;
pub const XML_CHAR_ENCODING_8859_6: xmlCharEncoding = 15;
pub const XML_CHAR_ENCODING_8859_5: xmlCharEncoding = 14;
pub const XML_CHAR_ENCODING_8859_4: xmlCharEncoding = 13;
pub const XML_CHAR_ENCODING_8859_3: xmlCharEncoding = 12;
pub const XML_CHAR_ENCODING_8859_2: xmlCharEncoding = 11;
pub const XML_CHAR_ENCODING_8859_1: xmlCharEncoding = 10;
pub const XML_CHAR_ENCODING_UCS2: xmlCharEncoding = 9;
pub const XML_CHAR_ENCODING_UCS4_3412: xmlCharEncoding = 8;
pub const XML_CHAR_ENCODING_UCS4_2143: xmlCharEncoding = 7;
pub const XML_CHAR_ENCODING_EBCDIC: xmlCharEncoding = 6;
pub const XML_CHAR_ENCODING_UCS4BE: xmlCharEncoding = 5;
pub const XML_CHAR_ENCODING_UCS4LE: xmlCharEncoding = 4;
pub const XML_CHAR_ENCODING_UTF16BE: xmlCharEncoding = 3;
pub const XML_CHAR_ENCODING_UTF16LE: xmlCharEncoding = 2;
pub const XML_CHAR_ENCODING_UTF8: xmlCharEncoding = 1;
pub const XML_CHAR_ENCODING_NONE: xmlCharEncoding = 0;
pub const XML_CHAR_ENCODING_ERROR: xmlCharEncoding = -1;
pub type C2RustUnnamed_0 = u32;
pub const XML_PARSE_BIG_LINES: C2RustUnnamed_0 = 4194304;
pub const XML_PARSE_IGNORE_ENC: C2RustUnnamed_0 = 2097152;
pub const XML_PARSE_OLDSAX: C2RustUnnamed_0 = 1048576;
pub const XML_PARSE_HUGE: C2RustUnnamed_0 = 524288;
pub const XML_PARSE_NOBASEFIX: C2RustUnnamed_0 = 262144;
pub const XML_PARSE_OLD10: C2RustUnnamed_0 = 131072;
pub const XML_PARSE_COMPACT: C2RustUnnamed_0 = 65536;
pub const XML_PARSE_NOXINCNODE: C2RustUnnamed_0 = 32768;
pub const XML_PARSE_NOCDATA: C2RustUnnamed_0 = 16384;
pub const XML_PARSE_NSCLEAN: C2RustUnnamed_0 = 8192;
pub const XML_PARSE_NODICT: C2RustUnnamed_0 = 4096;
pub const XML_PARSE_NONET: C2RustUnnamed_0 = 2048;
pub const XML_PARSE_XINCLUDE: C2RustUnnamed_0 = 1024;
pub const XML_PARSE_SAX1: C2RustUnnamed_0 = 512;
pub const XML_PARSE_NOBLANKS: C2RustUnnamed_0 = 256;
pub const XML_PARSE_PEDANTIC: C2RustUnnamed_0 = 128;
pub const XML_PARSE_NOWARNING: C2RustUnnamed_0 = 64;
pub const XML_PARSE_NOERROR: C2RustUnnamed_0 = 32;
pub const XML_PARSE_DTDVALID: C2RustUnnamed_0 = 16;
pub const XML_PARSE_DTDATTR: C2RustUnnamed_0 = 8;
pub const XML_PARSE_DTDLOAD: C2RustUnnamed_0 = 4;
pub const XML_PARSE_NOENT: C2RustUnnamed_0 = 2;
pub const XML_PARSE_RECOVER: C2RustUnnamed_0 = 1;
pub type C2RustUnnamed_1 = u32;
pub const XML_SCHEMA_VAL_VC_I_CREATE: C2RustUnnamed_1 = 1;
#[repr(C)]
pub struct _xmlSchema<'a> {
    pub name: *const u8,
    pub targetNamespace: *const u8,
    pub version: Option<&'a u8>,
    pub id: Option<&'a u8>,
    pub doc: *mut crate::src::threads::_xmlDoc,
    pub annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
    pub flags: i32,
    pub typeDecl: *mut crate::src::xmlsave::_xmlHashTable,
    pub attrDecl: *mut crate::src::xmlsave::_xmlHashTable,
    pub attrgrpDecl: *mut crate::src::xmlsave::_xmlHashTable,
    pub elemDecl: *mut crate::src::xmlsave::_xmlHashTable,
    pub notaDecl: *mut crate::src::xmlsave::_xmlHashTable,
    pub schemasImports: *mut crate::src::xmlsave::_xmlHashTable,
    pub _private: Option<&'a mut core::ffi::c_void>,
    pub groupDecl: *mut crate::src::xmlsave::_xmlHashTable,
    pub dict: *mut crate::src::xpointer::_xmlDict,
    pub includes: *mut core::ffi::c_void,
    pub preserve: i32,
    pub counter: i32,
    pub idcDef: *mut crate::src::xmlsave::_xmlHashTable,
    pub volatiles: *mut core::ffi::c_void,
}
impl<'a> _xmlSchema<'a> {
    pub const fn new() -> Self {
        _xmlSchema {
            name: (0 as *const u8),
            targetNamespace: (0 as *const u8),
            version: None,
            id: None,
            doc: (0 as *mut crate::src::threads::_xmlDoc),
            annot: (0 as *mut crate::src::xmlschemas::_xmlSchemaAnnot),
            flags: 0,
            typeDecl: (0 as *mut crate::src::xmlsave::_xmlHashTable),
            attrDecl: (0 as *mut crate::src::xmlsave::_xmlHashTable),
            attrgrpDecl: (0 as *mut crate::src::xmlsave::_xmlHashTable),
            elemDecl: (0 as *mut crate::src::xmlsave::_xmlHashTable),
            notaDecl: (0 as *mut crate::src::xmlsave::_xmlHashTable),
            schemasImports: (0 as *mut crate::src::xmlsave::_xmlHashTable),
            _private: None,
            groupDecl: (0 as *mut crate::src::xmlsave::_xmlHashTable),
            dict: (0 as *mut crate::src::xpointer::_xmlDict),
            includes: (0 as *mut core::ffi::c_void),
            preserve: 0,
            counter: 0,
            idcDef: (0 as *mut crate::src::xmlsave::_xmlHashTable),
            volatiles: (0 as *mut core::ffi::c_void),
        }
    }
}
impl<'a> std::default::Default for _xmlSchema<'a> {
    fn default() -> Self {
        _xmlSchema::new()
    }
}
pub type xmlSchemaAnnotPtr = *mut crate::src::xmlschemas::_xmlSchemaAnnot;
pub type xmlSchemaAnnot = crate::src::xmlschemas::_xmlSchemaAnnot;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAnnot {
    pub next: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
    pub content: *mut crate::src::threads::_xmlNode,
}
impl _xmlSchemaAnnot {
    pub const fn new() -> Self {
        _xmlSchemaAnnot {
            next: (0 as *mut crate::src::xmlschemas::_xmlSchemaAnnot),
            content: (0 as *mut crate::src::threads::_xmlNode),
        }
    }
}
impl std::default::Default for _xmlSchemaAnnot {
    fn default() -> Self {
        _xmlSchemaAnnot::new()
    }
}
pub type xmlSchema<'a> = crate::src::xmlschemas::_xmlSchema<'a>;
pub type xmlSchemaPtr<'a> = *mut crate::src::xmlschemas::_xmlSchema<'a>;
pub type xmlSchemaValidityErrorFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>;
pub type xmlSchemaValidityWarningFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>;
#[repr(C)]
pub struct _xmlSchemaParserCtxt<'a> {
    pub type_0: i32,
    pub errCtxt: *mut core::ffi::c_void,
    pub error: Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>,
    pub warning: Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>,
    pub err: i32,
    pub nberrors: i32,
    pub serror: Option<
        unsafe extern "C" fn(
            _: *mut core::ffi::c_void,
            _: *mut crate::src::threads::_xmlError,
        ) -> (),
    >,
    pub constructor: *mut crate::src::xmlschemas::_xmlSchemaConstructionCtxt<'a>,
    pub ownsConstructor: i32,
    pub schema: *mut crate::src::xmlschemas::_xmlSchema<'a>,
    pub counter: i32,
    pub URL: *const u8,
    pub doc: *mut crate::src::threads::_xmlDoc,
    pub preserve: i32,
    pub buffer: *const i8,
    pub size: i32,
    pub am: *mut crate::src::xmlregexp::_xmlAutomata,
    pub start: Option<&'a mut crate::src::xmlregexp::_xmlAutomataState>,
    pub end: Option<&'a mut crate::src::xmlregexp::_xmlAutomataState>,
    pub state: *mut crate::src::xmlregexp::_xmlAutomataState,
    pub dict: *mut crate::src::xpointer::_xmlDict,
    pub ctxtType: *mut crate::src::xmlschemas::_xmlSchemaType<'a>,
    pub options: i32,
    pub vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a>,
    pub isS4S: i32,
    pub isRedefine: i32,
    pub xsiAssemble: i32,
    pub stop: i32,
    pub targetNamespace: *const u8,
    pub redefined: *mut crate::src::xmlschemas::_xmlSchemaBucket,
    pub redef: *mut crate::src::xmlschemas::_xmlSchemaRedef<'a>,
    pub redefCounter: i32,
    pub attrProhibs: *mut crate::src::xmlschemas::_xmlSchemaItemList,
}
impl<'a> _xmlSchemaParserCtxt<'a> {
    pub const fn new() -> Self {
        _xmlSchemaParserCtxt {
            type_0: 0,
            errCtxt: (0 as *mut core::ffi::c_void),
            error: None,
            warning: None,
            err: 0,
            nberrors: 0,
            serror: None,
            constructor: (0 as *mut crate::src::xmlschemas::_xmlSchemaConstructionCtxt<'a>),
            ownsConstructor: 0,
            schema: (0 as *mut crate::src::xmlschemas::_xmlSchema<'a>),
            counter: 0,
            URL: (0 as *const u8),
            doc: (0 as *mut crate::src::threads::_xmlDoc),
            preserve: 0,
            buffer: (0 as *const i8),
            size: 0,
            am: (0 as *mut crate::src::xmlregexp::_xmlAutomata),
            start: None,
            end: None,
            state: (0 as *mut crate::src::xmlregexp::_xmlAutomataState),
            dict: (0 as *mut crate::src::xpointer::_xmlDict),
            ctxtType: (0 as *mut crate::src::xmlschemas::_xmlSchemaType<'a>),
            options: 0,
            vctxt: (0 as *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a>),
            isS4S: 0,
            isRedefine: 0,
            xsiAssemble: 0,
            stop: 0,
            targetNamespace: (0 as *const u8),
            redefined: (0 as *mut crate::src::xmlschemas::_xmlSchemaBucket),
            redef: (0 as *mut crate::src::xmlschemas::_xmlSchemaRedef<'a>),
            redefCounter: 0,
            attrProhibs: (0 as *mut crate::src::xmlschemas::_xmlSchemaItemList),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaParserCtxt<'a> {
    fn default() -> Self {
        _xmlSchemaParserCtxt::new()
    }
}
pub type xmlSchemaItemListPtr = *mut crate::src::xmlschemas::_xmlSchemaItemList;
pub type xmlSchemaItemList = crate::src::xmlschemas::_xmlSchemaItemList;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaItemList {
    pub items: *mut *mut core::ffi::c_void,
    pub nbItems: i32,
    pub sizeItems: i32,
}
impl _xmlSchemaItemList {
    pub const fn new() -> Self {
        _xmlSchemaItemList {
            items: (0 as *mut *mut core::ffi::c_void),
            nbItems: 0,
            sizeItems: 0,
        }
    }
}
impl std::default::Default for _xmlSchemaItemList {
    fn default() -> Self {
        _xmlSchemaItemList::new()
    }
}
pub type xmlSchemaRedefPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaRedef<'a>;
pub type xmlSchemaRedef<'a> = crate::src::xmlschemas::_xmlSchemaRedef<'a>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaRedef<'a> {
    pub next: *mut crate::src::xmlschemas::_xmlSchemaRedef<'a>,
    pub item: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a>,
    pub reference: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a>,
    pub target: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a>,
    pub refName: *const u8,
    pub refTargetNs: *const u8,
    pub targetBucket: *mut crate::src::xmlschemas::_xmlSchemaBucket,
}
impl<'a> _xmlSchemaRedef<'a> {
    pub const fn new() -> Self {
        _xmlSchemaRedef {
            next: (0 as *mut crate::src::xmlschemas::_xmlSchemaRedef<'a>),
            item: (0 as *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a>),
            reference: (0 as *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a>),
            target: (0 as *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a>),
            refName: (0 as *const u8),
            refTargetNs: (0 as *const u8),
            targetBucket: (0 as *mut crate::src::xmlschemas::_xmlSchemaBucket),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaRedef<'a> {
    fn default() -> Self {
        _xmlSchemaRedef::new()
    }
}
pub type xmlSchemaBucketPtr = *mut crate::src::xmlschemas::_xmlSchemaBucket;
pub type xmlSchemaBucket = crate::src::xmlschemas::_xmlSchemaBucket;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaBucket {
    pub type_0: i32,
    pub flags: i32,
    pub schemaLocation: *const u8,
    pub origTargetNamespace: *const u8,
    pub targetNamespace: *const u8,
    pub doc: *mut crate::src::threads::_xmlDoc,
    pub relations: *mut crate::src::xmlschemas::_xmlSchemaSchemaRelation,
    pub located: i32,
    pub parsed: i32,
    pub imported: i32,
    pub preserveDoc: i32,
    pub globals: *mut crate::src::xmlschemas::_xmlSchemaItemList,
    pub locals: *mut crate::src::xmlschemas::_xmlSchemaItemList,
}
impl _xmlSchemaBucket {
    pub const fn new() -> Self {
        _xmlSchemaBucket {
            type_0: 0,
            flags: 0,
            schemaLocation: (0 as *const u8),
            origTargetNamespace: (0 as *const u8),
            targetNamespace: (0 as *const u8),
            doc: (0 as *mut crate::src::threads::_xmlDoc),
            relations: (0 as *mut crate::src::xmlschemas::_xmlSchemaSchemaRelation),
            located: 0,
            parsed: 0,
            imported: 0,
            preserveDoc: 0,
            globals: (0 as *mut crate::src::xmlschemas::_xmlSchemaItemList),
            locals: (0 as *mut crate::src::xmlschemas::_xmlSchemaItemList),
        }
    }
}
impl std::default::Default for _xmlSchemaBucket {
    fn default() -> Self {
        _xmlSchemaBucket::new()
    }
}
pub type xmlSchemaSchemaRelationPtr = *mut crate::src::xmlschemas::_xmlSchemaSchemaRelation;
pub type xmlSchemaSchemaRelation = crate::src::xmlschemas::_xmlSchemaSchemaRelation;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaSchemaRelation {
    pub next: *mut crate::src::xmlschemas::_xmlSchemaSchemaRelation,
    pub type_0: i32,
    pub importNamespace: *const u8,
    pub bucket: *mut crate::src::xmlschemas::_xmlSchemaBucket,
}
impl _xmlSchemaSchemaRelation {
    pub const fn new() -> Self {
        _xmlSchemaSchemaRelation {
            next: (0 as *mut crate::src::xmlschemas::_xmlSchemaSchemaRelation),
            type_0: 0,
            importNamespace: (0 as *const u8),
            bucket: (0 as *mut crate::src::xmlschemas::_xmlSchemaBucket),
        }
    }
}
impl std::default::Default for _xmlSchemaSchemaRelation {
    fn default() -> Self {
        _xmlSchemaSchemaRelation::new()
    }
}
pub type xmlSchemaBasicItemPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a>;
pub type xmlSchemaBasicItem<'a> = crate::src::xmlschemas::_xmlSchemaBasicItem<'a>;
#[repr(C)]
pub struct _xmlSchemaBasicItem<'a> {
    pub type_0: u32,
    pub dummy: Option<&'a mut core::ffi::c_void>,
}
impl<'a> _xmlSchemaBasicItem<'a> {
    pub const fn new() -> Self {
        _xmlSchemaBasicItem {
            type_0: 0,
            dummy: None,
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaBasicItem<'a> {
    fn default() -> Self {
        _xmlSchemaBasicItem::new()
    }
}
pub type xmlSchemaTypeType = u32;
pub const XML_SCHEMA_EXTRA_ATTR_USE_PROHIB: xmlSchemaTypeType = 2001;
pub const XML_SCHEMA_EXTRA_QNAMEREF: xmlSchemaTypeType = 2000;
pub const XML_SCHEMA_FACET_MINLENGTH: xmlSchemaTypeType = 1011;
pub const XML_SCHEMA_FACET_MAXLENGTH: xmlSchemaTypeType = 1010;
pub const XML_SCHEMA_FACET_LENGTH: xmlSchemaTypeType = 1009;
pub const XML_SCHEMA_FACET_WHITESPACE: xmlSchemaTypeType = 1008;
pub const XML_SCHEMA_FACET_ENUMERATION: xmlSchemaTypeType = 1007;
pub const XML_SCHEMA_FACET_PATTERN: xmlSchemaTypeType = 1006;
pub const XML_SCHEMA_FACET_FRACTIONDIGITS: xmlSchemaTypeType = 1005;
pub const XML_SCHEMA_FACET_TOTALDIGITS: xmlSchemaTypeType = 1004;
pub const XML_SCHEMA_FACET_MAXEXCLUSIVE: xmlSchemaTypeType = 1003;
pub const XML_SCHEMA_FACET_MAXINCLUSIVE: xmlSchemaTypeType = 1002;
pub const XML_SCHEMA_FACET_MINEXCLUSIVE: xmlSchemaTypeType = 1001;
pub const XML_SCHEMA_FACET_MININCLUSIVE: xmlSchemaTypeType = 1000;
pub const XML_SCHEMA_TYPE_ATTRIBUTE_USE: xmlSchemaTypeType = 26;
pub const XML_SCHEMA_TYPE_PARTICLE: xmlSchemaTypeType = 25;
pub const XML_SCHEMA_TYPE_IDC_KEYREF: xmlSchemaTypeType = 24;
pub const XML_SCHEMA_TYPE_IDC_KEY: xmlSchemaTypeType = 23;
pub const XML_SCHEMA_TYPE_IDC_UNIQUE: xmlSchemaTypeType = 22;
pub const XML_SCHEMA_TYPE_ANY_ATTRIBUTE: xmlSchemaTypeType = 21;
pub const XML_SCHEMA_TYPE_UNION: xmlSchemaTypeType = 20;
pub const XML_SCHEMA_TYPE_LIST: xmlSchemaTypeType = 19;
pub const XML_SCHEMA_TYPE_NOTATION: xmlSchemaTypeType = 18;
pub const XML_SCHEMA_TYPE_GROUP: xmlSchemaTypeType = 17;
pub const XML_SCHEMA_TYPE_ATTRIBUTEGROUP: xmlSchemaTypeType = 16;
pub const XML_SCHEMA_TYPE_ATTRIBUTE: xmlSchemaTypeType = 15;
pub const XML_SCHEMA_TYPE_ELEMENT: xmlSchemaTypeType = 14;
pub const XML_SCHEMA_TYPE_EXTENSION: xmlSchemaTypeType = 13;
pub const XML_SCHEMA_TYPE_RESTRICTION: xmlSchemaTypeType = 12;
pub const XML_SCHEMA_TYPE_UR: xmlSchemaTypeType = 11;
pub const XML_SCHEMA_TYPE_COMPLEX_CONTENT: xmlSchemaTypeType = 10;
pub const XML_SCHEMA_TYPE_SIMPLE_CONTENT: xmlSchemaTypeType = 9;
pub const XML_SCHEMA_TYPE_ALL: xmlSchemaTypeType = 8;
pub const XML_SCHEMA_TYPE_CHOICE: xmlSchemaTypeType = 7;
pub const XML_SCHEMA_TYPE_SEQUENCE: xmlSchemaTypeType = 6;
pub const XML_SCHEMA_TYPE_COMPLEX: xmlSchemaTypeType = 5;
pub const XML_SCHEMA_TYPE_SIMPLE: xmlSchemaTypeType = 4;
pub const XML_SCHEMA_TYPE_FACET: xmlSchemaTypeType = 3;
pub const XML_SCHEMA_TYPE_ANY: xmlSchemaTypeType = 2;
pub const XML_SCHEMA_TYPE_BASIC: xmlSchemaTypeType = 1;
pub type xmlSchemaValidCtxtPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a>;
pub type xmlSchemaValidCtxt<'a> = crate::src::xmlschemas::_xmlSchemaValidCtxt<'a>;
#[repr(C)]
pub struct _xmlSchemaValidCtxt<'a> {
    pub type_0: i32,
    pub errCtxt: *mut core::ffi::c_void,
    pub error: Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>,
    pub warning: Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>,
    pub serror: Option<
        unsafe extern "C" fn(
            _: *mut core::ffi::c_void,
            _: *mut crate::src::threads::_xmlError,
        ) -> (),
    >,
    pub schema: *mut crate::src::xmlschemas::_xmlSchema<'a>,
    pub doc: *mut crate::src::threads::_xmlDoc,
    pub input: *mut crate::src::threads::_xmlParserInputBuffer,
    pub enc: i32,
    pub sax: *mut crate::src::tree::_xmlSAXHandler,
    pub parserCtxt: *mut crate::src::tree::_xmlParserCtxt,
    pub user_data: Option<&'a mut core::ffi::c_void>,
    pub filename: *mut i8,
    pub err: i32,
    pub nberrors: i32,
    pub node: *mut crate::src::threads::_xmlNode,
    pub cur: Option<&'a mut crate::src::threads::_xmlNode>,
    pub regexp: Option<&'a mut crate::src::xmlregexp::_xmlRegExecCtxt>,
    pub value: *mut crate::src::xmlschemastypes::_xmlSchemaVal,
    pub valueWS: i32,
    pub options: i32,
    pub validationRoot: *mut crate::src::threads::_xmlNode,
    pub pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a>,
    pub xsiAssemble: i32,
    pub depth: i32,
    pub elemInfos: *mut *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'a>,
    pub sizeElemInfos: i32,
    pub inode: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'a>,
    pub aidcs: *mut crate::src::xmlschemas::_xmlSchemaIDCAug<'a>,
    pub xpathStates: *mut crate::src::xmlschemas::_xmlSchemaIDCStateObj<'a>,
    pub xpathStatePool: *mut crate::src::xmlschemas::_xmlSchemaIDCStateObj<'a>,
    pub idcMatcherCache: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'a>,
    pub idcNodes: *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'a>,
    pub nbIdcNodes: i32,
    pub sizeIdcNodes: i32,
    pub idcKeys: *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'a>,
    pub nbIdcKeys: i32,
    pub sizeIdcKeys: i32,
    pub flags: i32,
    pub dict: *mut crate::src::xpointer::_xmlDict,
    pub reader: Option<&'a mut crate::src::xmlreader::_xmlTextReader<'a>>,
    pub attrInfos: *mut *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'a>,
    pub nbAttrInfos: i32,
    pub sizeAttrInfos: i32,
    pub skipDepth: i32,
    pub nodeQNames: *mut crate::src::xmlschemas::_xmlSchemaItemList,
    pub hasKeyrefs: i32,
    pub createIDCNodeTables: i32,
    pub psviExposeIDCNodeTables: i32,
    pub locFunc: Option<
        unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *mut *const i8, _: *mut u64) -> i32,
    >,
    pub locCtxt: *mut core::ffi::c_void,
}
impl<'a> _xmlSchemaValidCtxt<'a> {
    pub const fn new() -> Self {
        _xmlSchemaValidCtxt {
            type_0: 0,
            errCtxt: (0 as *mut core::ffi::c_void),
            error: None,
            warning: None,
            serror: None,
            schema: (0 as *mut crate::src::xmlschemas::_xmlSchema<'a>),
            doc: (0 as *mut crate::src::threads::_xmlDoc),
            input: (0 as *mut crate::src::threads::_xmlParserInputBuffer),
            enc: 0,
            sax: (0 as *mut crate::src::tree::_xmlSAXHandler),
            parserCtxt: (0 as *mut crate::src::tree::_xmlParserCtxt),
            user_data: None,
            filename: (0 as *mut i8),
            err: 0,
            nberrors: 0,
            node: (0 as *mut crate::src::threads::_xmlNode),
            cur: None,
            regexp: None,
            value: (0 as *mut crate::src::xmlschemastypes::_xmlSchemaVal),
            valueWS: 0,
            options: 0,
            validationRoot: (0 as *mut crate::src::threads::_xmlNode),
            pctxt: (0 as *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a>),
            xsiAssemble: 0,
            depth: 0,
            elemInfos: (0 as *mut *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'a>),
            sizeElemInfos: 0,
            inode: (0 as *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'a>),
            aidcs: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDCAug<'a>),
            xpathStates: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDCStateObj<'a>),
            xpathStatePool: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDCStateObj<'a>),
            idcMatcherCache: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'a>),
            idcNodes: (0 as *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'a>),
            nbIdcNodes: 0,
            sizeIdcNodes: 0,
            idcKeys: (0 as *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'a>),
            nbIdcKeys: 0,
            sizeIdcKeys: 0,
            flags: 0,
            dict: (0 as *mut crate::src::xpointer::_xmlDict),
            reader: None,
            attrInfos: (0 as *mut *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'a>),
            nbAttrInfos: 0,
            sizeAttrInfos: 0,
            skipDepth: 0,
            nodeQNames: (0 as *mut crate::src::xmlschemas::_xmlSchemaItemList),
            hasKeyrefs: 0,
            createIDCNodeTables: 0,
            psviExposeIDCNodeTables: 0,
            locFunc: None,
            locCtxt: (0 as *mut core::ffi::c_void),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaValidCtxt<'a> {
    fn default() -> Self {
        _xmlSchemaValidCtxt::new()
    }
}
pub type xmlSchemaValidityLocatorFunc =
    Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *mut *const i8, _: *mut u64) -> i32>;
pub type xmlSchemaAttrInfoPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'a>;
pub type xmlSchemaAttrInfo<'a> = crate::src::xmlschemas::_xmlSchemaAttrInfo<'a>;
#[repr(C)]
pub struct _xmlSchemaAttrInfo<'a> {
    pub nodeType: i32,
    pub node: *mut crate::src::threads::_xmlNode,
    pub nodeLine: i32,
    pub localName: *const u8,
    pub nsName: *const u8,
    pub value: *const u8,
    pub val: *mut crate::src::xmlschemastypes::_xmlSchemaVal,
    pub typeDef: *mut crate::src::xmlschemas::_xmlSchemaType<'a>,
    pub flags: i32,
    pub decl: *mut crate::src::xmlschemas::_xmlSchemaAttribute<'a>,
    pub use_0: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'a>,
    pub state: i32,
    pub metaType: i32,
    pub vcValue: *const u8,
    pub parent: Option<&'a mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'a>>,
}
impl<'a> _xmlSchemaAttrInfo<'a> {
    pub const fn new() -> Self {
        _xmlSchemaAttrInfo {
            nodeType: 0,
            node: (0 as *mut crate::src::threads::_xmlNode),
            nodeLine: 0,
            localName: (0 as *const u8),
            nsName: (0 as *const u8),
            value: (0 as *const u8),
            val: (0 as *mut crate::src::xmlschemastypes::_xmlSchemaVal),
            typeDef: (0 as *mut crate::src::xmlschemas::_xmlSchemaType<'a>),
            flags: 0,
            decl: (0 as *mut crate::src::xmlschemas::_xmlSchemaAttribute<'a>),
            use_0: (0 as *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'a>),
            state: 0,
            metaType: 0,
            vcValue: (0 as *const u8),
            parent: None,
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaAttrInfo<'a> {
    fn default() -> Self {
        _xmlSchemaAttrInfo::new()
    }
}
pub type xmlSchemaNodeInfoPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'a>;
pub type xmlSchemaNodeInfo<'a> = crate::src::xmlschemas::_xmlSchemaNodeInfo<'a>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaNodeInfo<'a> {
    pub nodeType: i32,
    pub node: *mut crate::src::threads::_xmlNode,
    pub nodeLine: i32,
    pub localName: *const u8,
    pub nsName: *const u8,
    pub value: *const u8,
    pub val: *mut crate::src::xmlschemastypes::_xmlSchemaVal,
    pub typeDef: *mut crate::src::xmlschemas::_xmlSchemaType<'a>,
    pub flags: i32,
    pub valNeeded: i32,
    pub normVal: i32,
    pub decl: *mut crate::src::xmlschemas::_xmlSchemaElement<'a>,
    pub depth: i32,
    pub idcTable: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'a>,
    pub idcMatchers: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'a>,
    pub regexCtxt: *mut crate::src::xmlregexp::_xmlRegExecCtxt,
    pub nsBindings: *mut *const u8,
    pub nbNsBindings: i32,
    pub sizeNsBindings: i32,
    pub hasKeyrefs: i32,
    pub appliedXPath: i32,
}
impl<'a> _xmlSchemaNodeInfo<'a> {
    pub const fn new() -> Self {
        _xmlSchemaNodeInfo {
            nodeType: 0,
            node: (0 as *mut crate::src::threads::_xmlNode),
            nodeLine: 0,
            localName: (0 as *const u8),
            nsName: (0 as *const u8),
            value: (0 as *const u8),
            val: (0 as *mut crate::src::xmlschemastypes::_xmlSchemaVal),
            typeDef: (0 as *mut crate::src::xmlschemas::_xmlSchemaType<'a>),
            flags: 0,
            valNeeded: 0,
            normVal: 0,
            decl: (0 as *mut crate::src::xmlschemas::_xmlSchemaElement<'a>),
            depth: 0,
            idcTable: (0 as *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'a>),
            idcMatchers: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'a>),
            regexCtxt: (0 as *mut crate::src::xmlregexp::_xmlRegExecCtxt),
            nsBindings: (0 as *mut *const u8),
            nbNsBindings: 0,
            sizeNsBindings: 0,
            hasKeyrefs: 0,
            appliedXPath: 0,
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaNodeInfo<'a> {
    fn default() -> Self {
        _xmlSchemaNodeInfo::new()
    }
}
pub type xmlSchemaIDCMatcherPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'a>;
pub type xmlSchemaIDCMatcher<'a> = crate::src::xmlschemas::_xmlSchemaIDCMatcher<'a>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDCMatcher<'a> {
    pub type_0: i32,
    pub depth: i32,
    pub next: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'a>,
    pub nextCached: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'a>,
    pub aidc: *mut crate::src::xmlschemas::_xmlSchemaIDCAug<'a>,
    pub idcType: i32,
    pub keySeqs: *mut *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'a>,
    pub sizeKeySeqs: i32,
    pub targets: *mut crate::src::xmlschemas::_xmlSchemaItemList,
    pub htab: *mut crate::src::xmlsave::_xmlHashTable,
}
impl<'a> _xmlSchemaIDCMatcher<'a> {
    pub const fn new() -> Self {
        _xmlSchemaIDCMatcher {
            type_0: 0,
            depth: 0,
            next: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'a>),
            nextCached: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'a>),
            aidc: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDCAug<'a>),
            idcType: 0,
            keySeqs: (0 as *mut *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'a>),
            sizeKeySeqs: 0,
            targets: (0 as *mut crate::src::xmlschemas::_xmlSchemaItemList),
            htab: (0 as *mut crate::src::xmlsave::_xmlHashTable),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaIDCMatcher<'a> {
    fn default() -> Self {
        _xmlSchemaIDCMatcher::new()
    }
}
pub type xmlSchemaPSVIIDCKeyPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'a>;
pub type xmlSchemaPSVIIDCKey<'a> = crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'a>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaPSVIIDCKey<'a> {
    pub type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a>,
    pub val: *mut crate::src::xmlschemastypes::_xmlSchemaVal,
}
impl<'a> _xmlSchemaPSVIIDCKey<'a> {
    pub const fn new() -> Self {
        _xmlSchemaPSVIIDCKey {
            type_0: (0 as *mut crate::src::xmlschemas::_xmlSchemaType<'a>),
            val: (0 as *mut crate::src::xmlschemastypes::_xmlSchemaVal),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaPSVIIDCKey<'a> {
    fn default() -> Self {
        _xmlSchemaPSVIIDCKey::new()
    }
}
pub type xmlSchemaValPtr = *mut crate::src::xmlschemastypes::_xmlSchemaVal;
pub type xmlSchemaVal = crate::src::xmlschemastypes::_xmlSchemaVal;
pub type xmlSchemaTypePtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaType<'a>;
pub type xmlSchemaType<'a> = crate::src::xmlschemas::_xmlSchemaType<'a>;
#[repr(C)]
pub struct _xmlSchemaType<'a> {
    pub type_0: u32,
    pub next: *mut crate::src::xmlschemas::_xmlSchemaType<'a>,
    pub name: *const u8,
    pub id: Option<&'a u8>,
    pub ref_0: Option<&'a u8>,
    pub refNs: Option<&'a u8>,
    pub annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
    pub subtypes: *mut crate::src::xmlschemas::_xmlSchemaType<'a>,
    pub attributes: Option<&'a mut crate::src::xmlschemas::_xmlSchemaAttribute<'a>>,
    pub node: *mut crate::src::threads::_xmlNode,
    pub minOccurs: i32,
    pub maxOccurs: i32,
    pub flags: i32,
    pub contentType: u32,
    pub base: *const u8,
    pub baseNs: *const u8,
    pub baseType: *mut crate::src::xmlschemas::_xmlSchemaType<'a>,
    pub facets: *mut crate::src::xmlschemas::_xmlSchemaFacet<'a>,
    pub redef: Option<&'a mut crate::src::xmlschemas::_xmlSchemaType<'a>>,
    pub recurse: i32,
    pub attributeUses:
        Option<&'a mut Option<&'a mut crate::src::xmlschemas::_xmlSchemaAttributeLink<'a>>>,
    pub attributeWildcard: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a>,
    pub builtInType: i32,
    pub memberTypes: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'a>,
    pub facetSet: *mut crate::src::xmlschemas::_xmlSchemaFacetLink<'a>,
    pub refPrefix: Option<&'a u8>,
    pub contentTypeDef: *mut crate::src::xmlschemas::_xmlSchemaType<'a>,
    pub contModel: *mut crate::src::xmlregexp::_xmlRegexp,
    pub targetNamespace: *const u8,
    pub attrUses: *mut core::ffi::c_void,
}
impl<'a> _xmlSchemaType<'a> {
    pub const fn new() -> Self {
        _xmlSchemaType {
            type_0: 0,
            next: (0 as *mut crate::src::xmlschemas::_xmlSchemaType<'a>),
            name: (0 as *const u8),
            id: None,
            ref_0: None,
            refNs: None,
            annot: (0 as *mut crate::src::xmlschemas::_xmlSchemaAnnot),
            subtypes: (0 as *mut crate::src::xmlschemas::_xmlSchemaType<'a>),
            attributes: None,
            node: (0 as *mut crate::src::threads::_xmlNode),
            minOccurs: 0,
            maxOccurs: 0,
            flags: 0,
            contentType: 0,
            base: (0 as *const u8),
            baseNs: (0 as *const u8),
            baseType: (0 as *mut crate::src::xmlschemas::_xmlSchemaType<'a>),
            facets: (0 as *mut crate::src::xmlschemas::_xmlSchemaFacet<'a>),
            redef: None,
            recurse: 0,
            attributeUses: None,
            attributeWildcard: (0 as *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a>),
            builtInType: 0,
            memberTypes: (0 as *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'a>),
            facetSet: (0 as *mut crate::src::xmlschemas::_xmlSchemaFacetLink<'a>),
            refPrefix: None,
            contentTypeDef: (0 as *mut crate::src::xmlschemas::_xmlSchemaType<'a>),
            contModel: (0 as *mut crate::src::xmlregexp::_xmlRegexp),
            targetNamespace: (0 as *const u8),
            attrUses: (0 as *mut core::ffi::c_void),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaType<'a> {
    fn default() -> Self {
        _xmlSchemaType::new()
    }
}
pub type xmlSchemaFacetLinkPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaFacetLink<'a>;
pub type xmlSchemaFacetLink<'a> = crate::src::xmlschemas::_xmlSchemaFacetLink<'a>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaFacetLink<'a> {
    pub next: *mut crate::src::xmlschemas::_xmlSchemaFacetLink<'a>,
    pub facet: *mut crate::src::xmlschemas::_xmlSchemaFacet<'a>,
}
impl<'a> _xmlSchemaFacetLink<'a> {
    pub const fn new() -> Self {
        _xmlSchemaFacetLink {
            next: (0 as *mut crate::src::xmlschemas::_xmlSchemaFacetLink<'a>),
            facet: (0 as *mut crate::src::xmlschemas::_xmlSchemaFacet<'a>),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaFacetLink<'a> {
    fn default() -> Self {
        _xmlSchemaFacetLink::new()
    }
}
pub type xmlSchemaFacetPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaFacet<'a>;
pub type xmlSchemaFacet<'a> = crate::src::xmlschemas::_xmlSchemaFacet<'a>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaFacet<'a> {
    pub type_0: u32,
    pub next: *mut crate::src::xmlschemas::_xmlSchemaFacet<'a>,
    pub value: *const u8,
    pub id: Option<&'a u8>,
    pub annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
    pub node: *mut crate::src::threads::_xmlNode,
    pub fixed: i32,
    pub whitespace: i32,
    pub val: *mut crate::src::xmlschemastypes::_xmlSchemaVal,
    pub regexp: *mut crate::src::xmlregexp::_xmlRegexp,
}
impl<'a> _xmlSchemaFacet<'a> {
    pub const fn new() -> Self {
        _xmlSchemaFacet {
            type_0: 0,
            next: (0 as *mut crate::src::xmlschemas::_xmlSchemaFacet<'a>),
            value: (0 as *const u8),
            id: None,
            annot: (0 as *mut crate::src::xmlschemas::_xmlSchemaAnnot),
            node: (0 as *mut crate::src::threads::_xmlNode),
            fixed: 0,
            whitespace: 0,
            val: (0 as *mut crate::src::xmlschemastypes::_xmlSchemaVal),
            regexp: (0 as *mut crate::src::xmlregexp::_xmlRegexp),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaFacet<'a> {
    fn default() -> Self {
        _xmlSchemaFacet::new()
    }
}
pub type xmlSchemaTypeLinkPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'a>;
pub type xmlSchemaTypeLink<'a> = crate::src::xmlschemas::_xmlSchemaTypeLink<'a>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaTypeLink<'a> {
    pub next: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'a>,
    pub type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a>,
}
impl<'a> _xmlSchemaTypeLink<'a> {
    pub const fn new() -> Self {
        _xmlSchemaTypeLink {
            next: (0 as *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'a>),
            type_0: (0 as *mut crate::src::xmlschemas::_xmlSchemaType<'a>),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaTypeLink<'a> {
    fn default() -> Self {
        _xmlSchemaTypeLink::new()
    }
}
pub type xmlSchemaWildcardPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a>;
pub type xmlSchemaWildcard<'a> = crate::src::xmlschemas::_xmlSchemaWildcard<'a>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaWildcard<'a> {
    pub type_0: u32,
    pub id: Option<&'a u8>,
    pub annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
    pub node: *mut crate::src::threads::_xmlNode,
    pub minOccurs: i32,
    pub maxOccurs: i32,
    pub processContents: i32,
    pub any: i32,
    pub nsSet: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs,
    pub negNsSet: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs,
    pub flags: i32,
}
impl<'a> _xmlSchemaWildcard<'a> {
    pub const fn new() -> Self {
        _xmlSchemaWildcard {
            type_0: 0,
            id: None,
            annot: (0 as *mut crate::src::xmlschemas::_xmlSchemaAnnot),
            node: (0 as *mut crate::src::threads::_xmlNode),
            minOccurs: 0,
            maxOccurs: 0,
            processContents: 0,
            any: 0,
            nsSet: (0 as *mut crate::src::xmlschemas::_xmlSchemaWildcardNs),
            negNsSet: (0 as *mut crate::src::xmlschemas::_xmlSchemaWildcardNs),
            flags: 0,
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaWildcard<'a> {
    fn default() -> Self {
        _xmlSchemaWildcard::new()
    }
}
pub type xmlSchemaWildcardNsPtr = *mut crate::src::xmlschemas::_xmlSchemaWildcardNs;
pub type xmlSchemaWildcardNs = crate::src::xmlschemas::_xmlSchemaWildcardNs;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaWildcardNs {
    pub next: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs,
    pub value: *const u8,
}
impl _xmlSchemaWildcardNs {
    pub const fn new() -> Self {
        _xmlSchemaWildcardNs {
            next: (0 as *mut crate::src::xmlschemas::_xmlSchemaWildcardNs),
            value: (0 as *const u8),
        }
    }
}
impl std::default::Default for _xmlSchemaWildcardNs {
    fn default() -> Self {
        _xmlSchemaWildcardNs::new()
    }
}
pub type xmlSchemaAttributeLinkPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaAttributeLink<'a>;
pub type xmlSchemaAttributeLink<'a> = crate::src::xmlschemas::_xmlSchemaAttributeLink<'a>;
#[repr(C)]
pub struct _xmlSchemaAttributeLink<'a> {
    pub next: Option<&'a mut crate::src::xmlschemas::_xmlSchemaAttributeLink<'a>>,
    pub attr: Option<&'a mut crate::src::xmlschemas::_xmlSchemaAttribute<'a>>,
}
impl<'a> _xmlSchemaAttributeLink<'a> {
    pub const fn new() -> Self {
        _xmlSchemaAttributeLink {
            next: None,
            attr: None,
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaAttributeLink<'a> {
    fn default() -> Self {
        _xmlSchemaAttributeLink::new()
    }
}
#[repr(C)]
pub struct _xmlSchemaAttribute<'a> {
    pub type_0: u32,
    pub next: Option<&'a mut crate::src::xmlschemas::_xmlSchemaAttribute<'a>>,
    pub name: *const u8,
    pub id: Option<&'a u8>,
    pub ref_0: Option<&'a u8>,
    pub refNs: Option<&'a u8>,
    pub typeName: *const u8,
    pub typeNs: *const u8,
    pub annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
    pub base: Option<&'a mut crate::src::xmlschemas::_xmlSchemaType<'a>>,
    pub occurs: i32,
    pub defValue: *const u8,
    pub subtypes: *mut crate::src::xmlschemas::_xmlSchemaType<'a>,
    pub node: *mut crate::src::threads::_xmlNode,
    pub targetNamespace: *const u8,
    pub flags: i32,
    pub refPrefix: Option<&'a u8>,
    pub defVal: *mut crate::src::xmlschemastypes::_xmlSchemaVal,
    pub refDecl: Option<&'a mut crate::src::xmlschemas::_xmlSchemaAttribute<'a>>,
}
impl<'a> _xmlSchemaAttribute<'a> {
    pub const fn new() -> Self {
        _xmlSchemaAttribute {
            type_0: 0,
            next: None,
            name: (0 as *const u8),
            id: None,
            ref_0: None,
            refNs: None,
            typeName: (0 as *const u8),
            typeNs: (0 as *const u8),
            annot: (0 as *mut crate::src::xmlschemas::_xmlSchemaAnnot),
            base: None,
            occurs: 0,
            defValue: (0 as *const u8),
            subtypes: (0 as *mut crate::src::xmlschemas::_xmlSchemaType<'a>),
            node: (0 as *mut crate::src::threads::_xmlNode),
            targetNamespace: (0 as *const u8),
            flags: 0,
            refPrefix: None,
            defVal: (0 as *mut crate::src::xmlschemastypes::_xmlSchemaVal),
            refDecl: None,
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaAttribute<'a> {
    fn default() -> Self {
        _xmlSchemaAttribute::new()
    }
}
pub type xmlSchemaAttributePtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaAttribute<'a>;
pub type xmlSchemaAttribute<'a> = crate::src::xmlschemas::_xmlSchemaAttribute<'a>;
pub type xmlSchemaContentType = u32;
pub const XML_SCHEMA_CONTENT_ANY: xmlSchemaContentType = 7;
pub const XML_SCHEMA_CONTENT_BASIC: xmlSchemaContentType = 6;
pub const XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS: xmlSchemaContentType = 5;
pub const XML_SCHEMA_CONTENT_SIMPLE: xmlSchemaContentType = 4;
pub const XML_SCHEMA_CONTENT_MIXED: xmlSchemaContentType = 3;
pub const XML_SCHEMA_CONTENT_ELEMENTS: xmlSchemaContentType = 2;
pub const XML_SCHEMA_CONTENT_EMPTY: xmlSchemaContentType = 1;
pub const XML_SCHEMA_CONTENT_UNKNOWN: xmlSchemaContentType = 0;
pub type xmlSchemaIDCAugPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaIDCAug<'a>;
pub type xmlSchemaIDCAug<'a> = crate::src::xmlschemas::_xmlSchemaIDCAug<'a>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDCAug<'a> {
    pub next: *mut crate::src::xmlschemas::_xmlSchemaIDCAug<'a>,
    pub def: *mut crate::src::xmlschemas::_xmlSchemaIDC<'a>,
    pub keyrefDepth: i32,
}
impl<'a> _xmlSchemaIDCAug<'a> {
    pub const fn new() -> Self {
        _xmlSchemaIDCAug {
            next: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDCAug<'a>),
            def: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDC<'a>),
            keyrefDepth: 0,
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaIDCAug<'a> {
    fn default() -> Self {
        _xmlSchemaIDCAug::new()
    }
}
pub type xmlSchemaIDCPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaIDC<'a>;
pub type xmlSchemaIDC<'a> = crate::src::xmlschemas::_xmlSchemaIDC<'a>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDC<'a> {
    pub type_0: u32,
    pub annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
    pub next: *mut crate::src::xmlschemas::_xmlSchemaIDC<'a>,
    pub node: *mut crate::src::threads::_xmlNode,
    pub name: *const u8,
    pub targetNamespace: *const u8,
    pub selector: *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'a>,
    pub fields: *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'a>,
    pub nbFields: i32,
    pub ref_0: *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'a>,
}
impl<'a> _xmlSchemaIDC<'a> {
    pub const fn new() -> Self {
        _xmlSchemaIDC {
            type_0: 0,
            annot: (0 as *mut crate::src::xmlschemas::_xmlSchemaAnnot),
            next: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDC<'a>),
            node: (0 as *mut crate::src::threads::_xmlNode),
            name: (0 as *const u8),
            targetNamespace: (0 as *const u8),
            selector: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'a>),
            fields: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'a>),
            nbFields: 0,
            ref_0: (0 as *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'a>),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaIDC<'a> {
    fn default() -> Self {
        _xmlSchemaIDC::new()
    }
}
pub type xmlSchemaQNameRefPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'a>;
pub type xmlSchemaQNameRef<'a> = crate::src::xmlschemas::_xmlSchemaQNameRef<'a>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaQNameRef<'a> {
    pub type_0: u32,
    pub item: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a>,
    pub itemType: u32,
    pub name: *const u8,
    pub targetNamespace: *const u8,
    pub node: *mut crate::src::threads::_xmlNode,
}
impl<'a> _xmlSchemaQNameRef<'a> {
    pub const fn new() -> Self {
        _xmlSchemaQNameRef {
            type_0: 0,
            item: (0 as *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a>),
            itemType: 0,
            name: (0 as *const u8),
            targetNamespace: (0 as *const u8),
            node: (0 as *mut crate::src::threads::_xmlNode),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaQNameRef<'a> {
    fn default() -> Self {
        _xmlSchemaQNameRef::new()
    }
}
pub type xmlSchemaIDCSelectPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'a>;
pub type xmlSchemaIDCSelect<'a> = crate::src::xmlschemas::_xmlSchemaIDCSelect<'a>;
#[repr(C)]
pub struct _xmlSchemaIDCSelect<'a> {
    pub next: *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'a>,
    pub idc: Option<&'a mut crate::src::xmlschemas::_xmlSchemaIDC<'a>>,
    pub index: i32,
    pub xpath: *const u8,
    pub xpathComp: *mut core::ffi::c_void,
}
impl<'a> _xmlSchemaIDCSelect<'a> {
    pub const fn new() -> Self {
        _xmlSchemaIDCSelect {
            next: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'a>),
            idc: None,
            index: 0,
            xpath: (0 as *const u8),
            xpathComp: (0 as *mut core::ffi::c_void),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaIDCSelect<'a> {
    fn default() -> Self {
        _xmlSchemaIDCSelect::new()
    }
}
pub type xmlSchemaPSVIIDCBindingPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'a>;
pub type xmlSchemaPSVIIDCBinding<'a> = crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'a>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaPSVIIDCBinding<'a> {
    pub next: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'a>,
    pub definition: *mut crate::src::xmlschemas::_xmlSchemaIDC<'a>,
    pub nodeTable: *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'a>,
    pub nbNodes: i32,
    pub sizeNodes: i32,
    pub dupls: *mut crate::src::xmlschemas::_xmlSchemaItemList,
}
impl<'a> _xmlSchemaPSVIIDCBinding<'a> {
    pub const fn new() -> Self {
        _xmlSchemaPSVIIDCBinding {
            next: (0 as *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'a>),
            definition: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDC<'a>),
            nodeTable: (0 as *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'a>),
            nbNodes: 0,
            sizeNodes: 0,
            dupls: (0 as *mut crate::src::xmlschemas::_xmlSchemaItemList),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaPSVIIDCBinding<'a> {
    fn default() -> Self {
        _xmlSchemaPSVIIDCBinding::new()
    }
}
pub type xmlSchemaPSVIIDCNodePtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'a>;
pub type xmlSchemaPSVIIDCNode<'a> = crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'a>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaPSVIIDCNode<'a> {
    pub node: *mut crate::src::threads::_xmlNode,
    pub keys: *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'a>,
    pub nodeLine: i32,
    pub nodeQNameID: i32,
}
impl<'a> _xmlSchemaPSVIIDCNode<'a> {
    pub const fn new() -> Self {
        _xmlSchemaPSVIIDCNode {
            node: (0 as *mut crate::src::threads::_xmlNode),
            keys: (0 as *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'a>),
            nodeLine: 0,
            nodeQNameID: 0,
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaPSVIIDCNode<'a> {
    fn default() -> Self {
        _xmlSchemaPSVIIDCNode::new()
    }
}
pub type xmlSchemaElementPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaElement<'a>;
pub type xmlSchemaElement<'a> = crate::src::xmlschemas::_xmlSchemaElement<'a>;
#[repr(C)]
pub struct _xmlSchemaElement<'a> {
    pub type_0: u32,
    pub next: Option<&'a mut crate::src::xmlschemas::_xmlSchemaType<'a>>,
    pub name: *const u8,
    pub id: Option<&'a u8>,
    pub ref_0: Option<&'a u8>,
    pub refNs: Option<&'a u8>,
    pub annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
    pub subtypes: *mut crate::src::xmlschemas::_xmlSchemaType<'a>,
    pub attributes: Option<&'a mut crate::src::xmlschemas::_xmlSchemaAttribute<'a>>,
    pub node: *mut crate::src::threads::_xmlNode,
    pub minOccurs: i32,
    pub maxOccurs: i32,
    pub flags: i32,
    pub targetNamespace: *const u8,
    pub namedType: *const u8,
    pub namedTypeNs: *const u8,
    pub substGroup: *const u8,
    pub substGroupNs: *const u8,
    pub scope: Option<&'a u8>,
    pub value: *const u8,
    pub refDecl: *mut crate::src::xmlschemas::_xmlSchemaElement<'a>,
    pub contModel: *mut crate::src::xmlregexp::_xmlRegexp,
    pub contentType: u32,
    pub refPrefix: Option<&'a u8>,
    pub defVal: *mut crate::src::xmlschemastypes::_xmlSchemaVal,
    pub idcs: *mut core::ffi::c_void,
}
impl<'a> _xmlSchemaElement<'a> {
    pub const fn new() -> Self {
        _xmlSchemaElement {
            type_0: 0,
            next: None,
            name: (0 as *const u8),
            id: None,
            ref_0: None,
            refNs: None,
            annot: (0 as *mut crate::src::xmlschemas::_xmlSchemaAnnot),
            subtypes: (0 as *mut crate::src::xmlschemas::_xmlSchemaType<'a>),
            attributes: None,
            node: (0 as *mut crate::src::threads::_xmlNode),
            minOccurs: 0,
            maxOccurs: 0,
            flags: 0,
            targetNamespace: (0 as *const u8),
            namedType: (0 as *const u8),
            namedTypeNs: (0 as *const u8),
            substGroup: (0 as *const u8),
            substGroupNs: (0 as *const u8),
            scope: None,
            value: (0 as *const u8),
            refDecl: (0 as *mut crate::src::xmlschemas::_xmlSchemaElement<'a>),
            contModel: (0 as *mut crate::src::xmlregexp::_xmlRegexp),
            contentType: 0,
            refPrefix: None,
            defVal: (0 as *mut crate::src::xmlschemastypes::_xmlSchemaVal),
            idcs: (0 as *mut core::ffi::c_void),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaElement<'a> {
    fn default() -> Self {
        _xmlSchemaElement::new()
    }
}
pub type xmlSchemaAttributeUsePtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'a>;
pub type xmlSchemaAttributeUse<'a> = crate::src::xmlschemas::_xmlSchemaAttributeUse<'a>;
#[repr(C)]
pub struct _xmlSchemaAttributeUse<'a> {
    pub type_0: u32,
    pub annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
    pub next: Option<&'a mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'a>>,
    pub attrDecl: *mut crate::src::xmlschemas::_xmlSchemaAttribute<'a>,
    pub flags: i32,
    pub node: *mut crate::src::threads::_xmlNode,
    pub occurs: i32,
    pub defValue: *const u8,
    pub defVal: *mut crate::src::xmlschemastypes::_xmlSchemaVal,
}
impl<'a> _xmlSchemaAttributeUse<'a> {
    pub const fn new() -> Self {
        _xmlSchemaAttributeUse {
            type_0: 0,
            annot: (0 as *mut crate::src::xmlschemas::_xmlSchemaAnnot),
            next: None,
            attrDecl: (0 as *mut crate::src::xmlschemas::_xmlSchemaAttribute<'a>),
            flags: 0,
            node: (0 as *mut crate::src::threads::_xmlNode),
            occurs: 0,
            defValue: (0 as *const u8),
            defVal: (0 as *mut crate::src::xmlschemastypes::_xmlSchemaVal),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaAttributeUse<'a> {
    fn default() -> Self {
        _xmlSchemaAttributeUse::new()
    }
}
pub type xmlTextReaderPtr<'a> = *mut crate::src::xmlreader::_xmlTextReader<'a>;
pub type xmlTextReader<'a> = crate::src::xmlreader::_xmlTextReader<'a>;
pub type xmlSchemaIDCStateObjPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaIDCStateObj<'a>;
pub type xmlSchemaIDCStateObj<'a> = crate::src::xmlschemas::_xmlSchemaIDCStateObj<'a>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaIDCStateObj<'a> {
    pub type_0: i32,
    pub next: *mut crate::src::xmlschemas::_xmlSchemaIDCStateObj<'a>,
    pub depth: i32,
    pub history: *mut i32,
    pub nbHistory: i32,
    pub sizeHistory: i32,
    pub matcher: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'a>,
    pub sel: *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'a>,
    pub xpathCtxt: *mut core::ffi::c_void,
}
impl<'a> _xmlSchemaIDCStateObj<'a> {
    pub const fn new() -> Self {
        _xmlSchemaIDCStateObj {
            type_0: 0,
            next: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDCStateObj<'a>),
            depth: 0,
            history: (0 as *mut i32),
            nbHistory: 0,
            sizeHistory: 0,
            matcher: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'a>),
            sel: (0 as *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'a>),
            xpathCtxt: (0 as *mut core::ffi::c_void),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaIDCStateObj<'a> {
    fn default() -> Self {
        _xmlSchemaIDCStateObj::new()
    }
}
pub type xmlSchemaParserCtxtPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a>;
pub type xmlSchemaParserCtxt<'a> = crate::src::xmlschemas::_xmlSchemaParserCtxt<'a>;
pub type xmlSchemaConstructionCtxtPtr<'a> =
    *mut crate::src::xmlschemas::_xmlSchemaConstructionCtxt<'a>;
pub type xmlSchemaConstructionCtxt<'a> = crate::src::xmlschemas::_xmlSchemaConstructionCtxt<'a>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaConstructionCtxt<'a> {
    pub mainSchema: *mut crate::src::xmlschemas::_xmlSchema<'a>,
    pub mainBucket: *mut crate::src::xmlschemas::_xmlSchemaBucket,
    pub dict: *mut crate::src::xpointer::_xmlDict,
    pub buckets: *mut crate::src::xmlschemas::_xmlSchemaItemList,
    pub bucket: *mut crate::src::xmlschemas::_xmlSchemaBucket,
    pub pending: *mut crate::src::xmlschemas::_xmlSchemaItemList,
    pub substGroups: *mut crate::src::xmlsave::_xmlHashTable,
    pub redefs: *mut crate::src::xmlschemas::_xmlSchemaRedef<'a>,
    pub lastRedef: *mut crate::src::xmlschemas::_xmlSchemaRedef<'a>,
}
impl<'a> _xmlSchemaConstructionCtxt<'a> {
    pub const fn new() -> Self {
        _xmlSchemaConstructionCtxt {
            mainSchema: (0 as *mut crate::src::xmlschemas::_xmlSchema<'a>),
            mainBucket: (0 as *mut crate::src::xmlschemas::_xmlSchemaBucket),
            dict: (0 as *mut crate::src::xpointer::_xmlDict),
            buckets: (0 as *mut crate::src::xmlschemas::_xmlSchemaItemList),
            bucket: (0 as *mut crate::src::xmlschemas::_xmlSchemaBucket),
            pending: (0 as *mut crate::src::xmlschemas::_xmlSchemaItemList),
            substGroups: (0 as *mut crate::src::xmlsave::_xmlHashTable),
            redefs: (0 as *mut crate::src::xmlschemas::_xmlSchemaRedef<'a>),
            lastRedef: (0 as *mut crate::src::xmlschemas::_xmlSchemaRedef<'a>),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaConstructionCtxt<'a> {
    fn default() -> Self {
        _xmlSchemaConstructionCtxt::new()
    }
}
pub type xmlSchemaSubstGroupPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaSubstGroup<'a>;
pub type xmlSchemaSubstGroup<'a> = crate::src::xmlschemas::_xmlSchemaSubstGroup<'a>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaSubstGroup<'a> {
    pub head: *mut crate::src::xmlschemas::_xmlSchemaElement<'a>,
    pub members: *mut crate::src::xmlschemas::_xmlSchemaItemList,
}
impl<'a> _xmlSchemaSubstGroup<'a> {
    pub const fn new() -> Self {
        _xmlSchemaSubstGroup {
            head: (0 as *mut crate::src::xmlschemas::_xmlSchemaElement<'a>),
            members: (0 as *mut crate::src::xmlschemas::_xmlSchemaItemList),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaSubstGroup<'a> {
    fn default() -> Self {
        _xmlSchemaSubstGroup::new()
    }
}
pub type xmlIDCHashEntryPtr = *mut crate::src::xmlschemas::_xmlIDCHashEntry;
pub type xmlIDCHashEntry = crate::src::xmlschemas::_xmlIDCHashEntry;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlIDCHashEntry {
    pub next: *mut crate::src::xmlschemas::_xmlIDCHashEntry,
    pub index: i32,
}
impl _xmlIDCHashEntry {
    pub const fn new() -> Self {
        _xmlIDCHashEntry {
            next: (0 as *mut crate::src::xmlschemas::_xmlIDCHashEntry),
            index: 0,
        }
    }
}
impl std::default::Default for _xmlIDCHashEntry {
    fn default() -> Self {
        _xmlIDCHashEntry::new()
    }
}
pub type xmlStreamCtxtPtr = *mut crate::src::xmllint::_xmlStreamCtxt;
pub type xmlStreamCtxt = crate::src::xmllint::_xmlStreamCtxt;
pub type xmlSchemaAbstractCtxtPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a>;
pub type xmlSchemaAbstractCtxt<'a> = crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a>;
#[repr(C)]
pub struct _xmlSchemaAbstractCtxt<'a> {
    pub type_0: i32,
    pub dummy: Option<&'a mut core::ffi::c_void>,
}
impl<'a> _xmlSchemaAbstractCtxt<'a> {
    pub const fn new() -> Self {
        _xmlSchemaAbstractCtxt {
            type_0: 0,
            dummy: None,
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaAbstractCtxt<'a> {
    fn default() -> Self {
        _xmlSchemaAbstractCtxt::new()
    }
}
pub type xmlSchemaImportPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaImport<'a>;
pub type xmlSchemaImport<'a> = crate::src::xmlschemas::_xmlSchemaImport<'a>;
#[repr(C)]
pub struct _xmlSchemaImport<'a> {
    pub type_0: i32,
    pub flags: i32,
    pub schemaLocation: Option<&'a u8>,
    pub origTargetNamespace: Option<&'a u8>,
    pub targetNamespace: Option<&'a u8>,
    pub doc: Option<&'a mut crate::src::threads::_xmlDoc>,
    pub relations: Option<&'a mut crate::src::xmlschemas::_xmlSchemaSchemaRelation>,
    pub located: i32,
    pub parsed: i32,
    pub imported: i32,
    pub preserveDoc: i32,
    pub globals: Option<&'a mut crate::src::xmlschemas::_xmlSchemaItemList>,
    pub locals: Option<&'a mut crate::src::xmlschemas::_xmlSchemaItemList>,
    pub schema: *mut crate::src::xmlschemas::_xmlSchema<'a>,
}
impl<'a> _xmlSchemaImport<'a> {
    pub const fn new() -> Self {
        _xmlSchemaImport {
            type_0: 0,
            flags: 0,
            schemaLocation: None,
            origTargetNamespace: None,
            targetNamespace: None,
            doc: None,
            relations: None,
            located: 0,
            parsed: 0,
            imported: 0,
            preserveDoc: 0,
            globals: None,
            locals: None,
            schema: (0 as *mut crate::src::xmlschemas::_xmlSchema<'a>),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaImport<'a> {
    fn default() -> Self {
        _xmlSchemaImport::new()
    }
}
pub type xmlSchemaTreeItemPtr = *mut crate::src::xmlschemas::_xmlSchemaTreeItem;
pub type xmlSchemaTreeItem = crate::src::xmlschemas::_xmlSchemaTreeItem;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaTreeItem {
    pub type_0: u32,
    pub annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
    pub next: *mut crate::src::xmlschemas::_xmlSchemaTreeItem,
    pub children: *mut crate::src::xmlschemas::_xmlSchemaTreeItem,
}
impl _xmlSchemaTreeItem {
    pub const fn new() -> Self {
        _xmlSchemaTreeItem {
            type_0: 0,
            annot: (0 as *mut crate::src::xmlschemas::_xmlSchemaAnnot),
            next: (0 as *mut crate::src::xmlschemas::_xmlSchemaTreeItem),
            children: (0 as *mut crate::src::xmlschemas::_xmlSchemaTreeItem),
        }
    }
}
impl std::default::Default for _xmlSchemaTreeItem {
    fn default() -> Self {
        _xmlSchemaTreeItem::new()
    }
}
pub const XML_SCHEMAS_ANYTYPE: xmlSchemaValType = 45;
pub type xmlSchemaNotationPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaNotation<'a>;
pub type xmlSchemaNotation<'a> = crate::src::xmlschemas::_xmlSchemaNotation<'a>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaNotation<'a> {
    pub type_0: u32,
    pub name: *const u8,
    pub annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
    pub identifier: Option<&'a u8>,
    pub targetNamespace: *const u8,
}
impl<'a> _xmlSchemaNotation<'a> {
    pub const fn new() -> Self {
        _xmlSchemaNotation {
            type_0: 0,
            name: (0 as *const u8),
            annot: (0 as *mut crate::src::xmlschemas::_xmlSchemaAnnot),
            identifier: None,
            targetNamespace: (0 as *const u8),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaNotation<'a> {
    fn default() -> Self {
        _xmlSchemaNotation::new()
    }
}
pub type xmlPatternPtr = *mut crate::src::xmlreader::_xmlPattern;
pub type xmlPattern = crate::src::xmlreader::_xmlPattern;
pub type xmlSchemaModelGroupDefPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaModelGroupDef<'a>;
pub type xmlSchemaModelGroupDef<'a> = crate::src::xmlschemas::_xmlSchemaModelGroupDef<'a>;
#[repr(C)]
pub struct _xmlSchemaModelGroupDef<'a> {
    pub type_0: u32,
    pub annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
    pub next: Option<&'a mut crate::src::xmlschemas::_xmlSchemaTreeItem>,
    pub children: *mut crate::src::xmlschemas::_xmlSchemaTreeItem,
    pub name: *const u8,
    pub targetNamespace: *const u8,
    pub node: *mut crate::src::threads::_xmlNode,
    pub flags: i32,
}
impl<'a> _xmlSchemaModelGroupDef<'a> {
    pub const fn new() -> Self {
        _xmlSchemaModelGroupDef {
            type_0: 0,
            annot: (0 as *mut crate::src::xmlschemas::_xmlSchemaAnnot),
            next: None,
            children: (0 as *mut crate::src::xmlschemas::_xmlSchemaTreeItem),
            name: (0 as *const u8),
            targetNamespace: (0 as *const u8),
            node: (0 as *mut crate::src::threads::_xmlNode),
            flags: 0,
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaModelGroupDef<'a> {
    fn default() -> Self {
        _xmlSchemaModelGroupDef::new()
    }
}
pub type xmlSchemaAttributeGroupPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaAttributeGroup<'a>;
pub type xmlSchemaAttributeGroup<'a> = crate::src::xmlschemas::_xmlSchemaAttributeGroup<'a>;
#[repr(C)]
pub struct _xmlSchemaAttributeGroup<'a> {
    pub type_0: u32,
    pub next: Option<&'a mut crate::src::xmlschemas::_xmlSchemaAttribute<'a>>,
    pub name: *const u8,
    pub id: Option<&'a u8>,
    pub ref_0: Option<&'a u8>,
    pub refNs: Option<&'a u8>,
    pub annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
    pub attributes: Option<&'a mut crate::src::xmlschemas::_xmlSchemaAttribute<'a>>,
    pub node: *mut crate::src::threads::_xmlNode,
    pub flags: i32,
    pub attributeWildcard: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a>,
    pub refPrefix: Option<&'a u8>,
    pub refItem: Option<&'a mut crate::src::xmlschemas::_xmlSchemaAttributeGroup<'a>>,
    pub targetNamespace: *const u8,
    pub attrUses: *mut core::ffi::c_void,
}
impl<'a> _xmlSchemaAttributeGroup<'a> {
    pub const fn new() -> Self {
        _xmlSchemaAttributeGroup {
            type_0: 0,
            next: None,
            name: (0 as *const u8),
            id: None,
            ref_0: None,
            refNs: None,
            annot: (0 as *mut crate::src::xmlschemas::_xmlSchemaAnnot),
            attributes: None,
            node: (0 as *mut crate::src::threads::_xmlNode),
            flags: 0,
            attributeWildcard: (0 as *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a>),
            refPrefix: None,
            refItem: None,
            targetNamespace: (0 as *const u8),
            attrUses: (0 as *mut core::ffi::c_void),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaAttributeGroup<'a> {
    fn default() -> Self {
        _xmlSchemaAttributeGroup::new()
    }
}
pub type xmlSchemaModelGroupPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaModelGroup<'a>;
pub type xmlSchemaModelGroup<'a> = crate::src::xmlschemas::_xmlSchemaModelGroup<'a>;
#[repr(C)]
pub struct _xmlSchemaModelGroup<'a> {
    pub type_0: u32,
    pub annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
    pub next: Option<&'a mut crate::src::xmlschemas::_xmlSchemaTreeItem>,
    pub children: *mut crate::src::xmlschemas::_xmlSchemaTreeItem,
    pub node: *mut crate::src::threads::_xmlNode,
}
impl<'a> _xmlSchemaModelGroup<'a> {
    pub const fn new() -> Self {
        _xmlSchemaModelGroup {
            type_0: 0,
            annot: (0 as *mut crate::src::xmlschemas::_xmlSchemaAnnot),
            next: None,
            children: (0 as *mut crate::src::xmlschemas::_xmlSchemaTreeItem),
            node: (0 as *mut crate::src::threads::_xmlNode),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaModelGroup<'a> {
    fn default() -> Self {
        _xmlSchemaModelGroup::new()
    }
}
pub type xmlSchemaAttributeUseProhibPtr = *mut crate::src::xmlschemas::_xmlSchemaAttributeUseProhib;
pub type xmlSchemaAttributeUseProhib = crate::src::xmlschemas::_xmlSchemaAttributeUseProhib;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAttributeUseProhib {
    pub type_0: u32,
    pub node: *mut crate::src::threads::_xmlNode,
    pub name: *const u8,
    pub targetNamespace: *const u8,
    pub isRef: i32,
}
impl _xmlSchemaAttributeUseProhib {
    pub const fn new() -> Self {
        _xmlSchemaAttributeUseProhib {
            type_0: 0,
            node: (0 as *mut crate::src::threads::_xmlNode),
            name: (0 as *const u8),
            targetNamespace: (0 as *const u8),
            isRef: 0,
        }
    }
}
impl std::default::Default for _xmlSchemaAttributeUseProhib {
    fn default() -> Self {
        _xmlSchemaAttributeUseProhib::new()
    }
}
pub type xmlSchemaParticlePtr = *mut crate::src::xmlschemas::_xmlSchemaParticle;
pub type xmlSchemaParticle = crate::src::xmlschemas::_xmlSchemaParticle;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaParticle {
    pub type_0: u32,
    pub annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
    pub next: *mut crate::src::xmlschemas::_xmlSchemaTreeItem,
    pub children: *mut crate::src::xmlschemas::_xmlSchemaTreeItem,
    pub minOccurs: i32,
    pub maxOccurs: i32,
    pub node: *mut crate::src::threads::_xmlNode,
}
impl _xmlSchemaParticle {
    pub const fn new() -> Self {
        _xmlSchemaParticle {
            type_0: 0,
            annot: (0 as *mut crate::src::xmlschemas::_xmlSchemaAnnot),
            next: (0 as *mut crate::src::xmlschemas::_xmlSchemaTreeItem),
            children: (0 as *mut crate::src::xmlschemas::_xmlSchemaTreeItem),
            minOccurs: 0,
            maxOccurs: 0,
            node: (0 as *mut crate::src::threads::_xmlNode),
        }
    }
}
impl std::default::Default for _xmlSchemaParticle {
    fn default() -> Self {
        _xmlSchemaParticle::new()
    }
}
pub type xmlSchemaValType = u32;
pub const XML_SCHEMAS_ANYSIMPLETYPE: xmlSchemaValType = 46;
pub const XML_SCHEMAS_BASE64BINARY: xmlSchemaValType = 44;
pub const XML_SCHEMAS_HEXBINARY: xmlSchemaValType = 43;
pub const XML_SCHEMAS_UBYTE: xmlSchemaValType = 42;
pub const XML_SCHEMAS_BYTE: xmlSchemaValType = 41;
pub const XML_SCHEMAS_USHORT: xmlSchemaValType = 40;
pub const XML_SCHEMAS_SHORT: xmlSchemaValType = 39;
pub const XML_SCHEMAS_ULONG: xmlSchemaValType = 38;
pub const XML_SCHEMAS_LONG: xmlSchemaValType = 37;
pub const XML_SCHEMAS_UINT: xmlSchemaValType = 36;
pub const XML_SCHEMAS_INT: xmlSchemaValType = 35;
pub const XML_SCHEMAS_PINTEGER: xmlSchemaValType = 34;
pub const XML_SCHEMAS_NNINTEGER: xmlSchemaValType = 33;
pub const XML_SCHEMAS_NINTEGER: xmlSchemaValType = 32;
pub const XML_SCHEMAS_NPINTEGER: xmlSchemaValType = 31;
pub const XML_SCHEMAS_INTEGER: xmlSchemaValType = 30;
pub const XML_SCHEMAS_ANYURI: xmlSchemaValType = 29;
pub const XML_SCHEMAS_NOTATION: xmlSchemaValType = 28;
pub const XML_SCHEMAS_ENTITIES: xmlSchemaValType = 27;
pub const XML_SCHEMAS_ENTITY: xmlSchemaValType = 26;
pub const XML_SCHEMAS_IDREFS: xmlSchemaValType = 25;
pub const XML_SCHEMAS_IDREF: xmlSchemaValType = 24;
pub const XML_SCHEMAS_ID: xmlSchemaValType = 23;
pub const XML_SCHEMAS_NCNAME: xmlSchemaValType = 22;
pub const XML_SCHEMAS_QNAME: xmlSchemaValType = 21;
pub const XML_SCHEMAS_NAME: xmlSchemaValType = 20;
pub const XML_SCHEMAS_NMTOKENS: xmlSchemaValType = 19;
pub const XML_SCHEMAS_NMTOKEN: xmlSchemaValType = 18;
pub const XML_SCHEMAS_LANGUAGE: xmlSchemaValType = 17;
pub const XML_SCHEMAS_TOKEN: xmlSchemaValType = 16;
pub const XML_SCHEMAS_BOOLEAN: xmlSchemaValType = 15;
pub const XML_SCHEMAS_DOUBLE: xmlSchemaValType = 14;
pub const XML_SCHEMAS_FLOAT: xmlSchemaValType = 13;
pub const XML_SCHEMAS_DURATION: xmlSchemaValType = 12;
pub const XML_SCHEMAS_DATETIME: xmlSchemaValType = 11;
pub const XML_SCHEMAS_DATE: xmlSchemaValType = 10;
pub const XML_SCHEMAS_GYEARMONTH: xmlSchemaValType = 9;
pub const XML_SCHEMAS_GYEAR: xmlSchemaValType = 8;
pub const XML_SCHEMAS_GMONTHDAY: xmlSchemaValType = 7;
pub const XML_SCHEMAS_GMONTH: xmlSchemaValType = 6;
pub const XML_SCHEMAS_GDAY: xmlSchemaValType = 5;
pub const XML_SCHEMAS_TIME: xmlSchemaValType = 4;
pub const XML_SCHEMAS_DECIMAL: xmlSchemaValType = 3;
pub const XML_SCHEMAS_NORMSTRING: xmlSchemaValType = 2;
pub const XML_SCHEMAS_STRING: xmlSchemaValType = 1;
pub const XML_SCHEMAS_UNKNOWN: xmlSchemaValType = 0;
pub type xmlSchemaWhitespaceValueType = u32;
pub const XML_SCHEMA_WHITESPACE_COLLAPSE: xmlSchemaWhitespaceValueType = 3;
pub const XML_SCHEMA_WHITESPACE_REPLACE: xmlSchemaWhitespaceValueType = 2;
pub const XML_SCHEMA_WHITESPACE_PRESERVE: xmlSchemaWhitespaceValueType = 1;
pub const XML_SCHEMA_WHITESPACE_UNKNOWN: xmlSchemaWhitespaceValueType = 0;
pub type xmlSchemaIncludePtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaInclude<'a>;
pub type xmlSchemaInclude<'a> = crate::src::xmlschemas::_xmlSchemaInclude<'a>;
#[repr(C)]
pub struct _xmlSchemaInclude<'a> {
    pub type_0: i32,
    pub flags: i32,
    pub schemaLocation: Option<&'a u8>,
    pub origTargetNamespace: Option<&'a u8>,
    pub targetNamespace: Option<&'a u8>,
    pub doc: Option<&'a mut crate::src::threads::_xmlDoc>,
    pub relations: Option<&'a mut crate::src::xmlschemas::_xmlSchemaSchemaRelation>,
    pub located: i32,
    pub parsed: i32,
    pub imported: i32,
    pub preserveDoc: i32,
    pub globals: Option<&'a mut crate::src::xmlschemas::_xmlSchemaItemList>,
    pub locals: Option<&'a mut crate::src::xmlschemas::_xmlSchemaItemList>,
    pub ownerImport: *mut crate::src::xmlschemas::_xmlSchemaImport<'a>,
}
impl<'a> _xmlSchemaInclude<'a> {
    pub const fn new() -> Self {
        _xmlSchemaInclude {
            type_0: 0,
            flags: 0,
            schemaLocation: None,
            origTargetNamespace: None,
            targetNamespace: None,
            doc: None,
            relations: None,
            located: 0,
            parsed: 0,
            imported: 0,
            preserveDoc: 0,
            globals: None,
            locals: None,
            ownerImport: (0 as *mut crate::src::xmlschemas::_xmlSchemaImport<'a>),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaInclude<'a> {
    fn default() -> Self {
        _xmlSchemaInclude::new()
    }
}
pub type xmlSchemaAnnotItemPtr = *mut crate::src::xmlschemas::_xmlSchemaAnnotItem;
pub type xmlSchemaAnnotItem = crate::src::xmlschemas::_xmlSchemaAnnotItem;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _xmlSchemaAnnotItem {
    pub type_0: u32,
    pub annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
}
impl _xmlSchemaAnnotItem {
    pub const fn new() -> Self {
        _xmlSchemaAnnotItem {
            type_0: 0,
            annot: (0 as *mut crate::src::xmlschemas::_xmlSchemaAnnot),
        }
    }
}
impl std::default::Default for _xmlSchemaAnnotItem {
    fn default() -> Self {
        _xmlSchemaAnnotItem::new()
    }
}
pub const XML_PATTERN_XSSEL: C2RustUnnamed_2 = 2;
pub const XML_PATTERN_XSFIELD: C2RustUnnamed_2 = 4;
pub type xmlSchemaSAXPlugPtr<'a> = *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'a>;
pub type xmlSchemaSAXPlugStruct<'a> = crate::src::xmlschemas::_xmlSchemaSAXPlug<'a>;
#[repr(C)]
pub struct _xmlSchemaSAXPlug<'a> {
    pub magic: u32,
    pub user_sax_ptr: Option<&'a mut *mut crate::src::tree::_xmlSAXHandler>,
    pub user_sax: *mut crate::src::tree::_xmlSAXHandler,
    pub user_data_ptr: Option<&'a mut *mut core::ffi::c_void>,
    pub user_data: *mut core::ffi::c_void,
    pub schemas_sax: crate::src::tree::_xmlSAXHandler,
    pub ctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a>,
}
impl<'a> _xmlSchemaSAXPlug<'a> {
    pub const fn new() -> Self {
        _xmlSchemaSAXPlug {
            magic: 0,
            user_sax_ptr: None,
            user_sax: (0 as *mut crate::src::tree::_xmlSAXHandler),
            user_data_ptr: None,
            user_data: (0 as *mut core::ffi::c_void),
            schemas_sax: crate::src::tree::_xmlSAXHandler::new(),
            ctxt: (0 as *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a>),
        }
    }
}
impl<'a> std::default::Default for _xmlSchemaSAXPlug<'a> {
    fn default() -> Self {
        _xmlSchemaSAXPlug::new()
    }
}
pub type C2RustUnnamed_2 = u32;
pub const XML_PATTERN_XPATH: C2RustUnnamed_2 = 1;
pub const XML_PATTERN_DEFAULT: C2RustUnnamed_2 = 0;
static mut xmlSchemaNs: *const u8 =
    b"http://www.w3.org/2001/XMLSchema\0" as *const u8 as *const i8 as *const xmlChar;
static mut xmlSchemaInstanceNs: *const u8 =
    b"http://www.w3.org/2001/XMLSchema-instance\0" as *const u8 as *const i8 as *const xmlChar;
static mut xmlNamespaceNs: *const u8 =
    b"http://www.w3.org/2000/xmlns/\0" as *const u8 as *const i8 as *const xmlChar;
extern "C" fn xmlSchemaItemTypeToStr(mut type_0: u32) -> *const u8 {
    match type_0 as u32 {
        1 => {
            return b"simple type definition\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        4 => {
            return b"simple type definition\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        5 => {
            return b"complex type definition\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        14 => {
            return b"element declaration\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        26 => {
            return b"attribute use\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        15 => {
            return b"attribute declaration\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        17 => {
            return b"model group definition\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        16 => {
            return b"attribute group definition\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        18 => {
            return b"notation declaration\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        6 => {
            return b"model group (sequence)\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        7 => {
            return b"model group (choice)\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        8 => {
            return b"model group (all)\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        25 => return b"particle\0" as *const u8 as *const i8 as *mut xmlChar,
        22 => {
            return b"unique identity-constraint\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        23 => {
            return b"key identity-constraint\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        24 => {
            return b"keyref identity-constraint\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        2 => {
            return b"wildcard (any)\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        2000 => {
            return b"[helper component] QName reference\0" as *const u8 as *const i8
                as *mut xmlChar;
        },
        2001 => {
            return b"[helper component] attribute use prohibition\0" as *const u8 as *const i8
                as *mut xmlChar;
        },
        _ => {
            return b"Not a schema component\0" as *const u8 as *const i8 as *mut xmlChar;
        },
    };
}
extern "C" fn xmlSchemaGetComponentTypeStr<'a1>(
    mut item: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a1>,
) -> *const u8 {
    match (unsafe { (*item).type_0 }) as u32 {
        1 => {
            if (unsafe { (*(item as xmlSchemaTypePtr)).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                || (unsafe { (*(item as xmlSchemaTypePtr)).builtInType }) == XML_SCHEMAS_ANYTYPE as i32
            {
                return b"complex type definition\0" as *const u8 as *const i8 as *mut xmlChar;
            } else {
                return b"simple type definition\0" as *const u8 as *const i8 as *mut xmlChar;
            }
        },
        _ => return xmlSchemaItemTypeToStr(unsafe { (*item).type_0 }),
    };
}
extern "C" fn xmlSchemaGetComponentNode<'a1>(
    mut item: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a1>,
) -> *mut crate::src::threads::_xmlNode {
    match (unsafe { (*item).type_0 }) as u32 {
        14 => return unsafe { (*(item as xmlSchemaElementPtr)).node },
        15 => return unsafe { (*(item as xmlSchemaAttributePtr)).node },
        5 | 4 => return unsafe { (*(item as xmlSchemaTypePtr)).node },
        2 | 21 => return unsafe { (*(item as xmlSchemaWildcardPtr)).node },
        25 => return unsafe { (*(item as xmlSchemaParticlePtr)).node },
        6 | 7 | 8 => return unsafe { (*(item as xmlSchemaModelGroupPtr)).node },
        17 => return unsafe { (*(item as xmlSchemaModelGroupDefPtr)).node },
        16 => return unsafe { (*(item as xmlSchemaAttributeGroupPtr)).node },
        22 | 23 | 24 => return unsafe { (*(item as xmlSchemaIDCPtr)).node },
        2000 => return unsafe { (*(item as xmlSchemaQNameRefPtr)).node },
        26 => return unsafe { (*(item as xmlSchemaAttributeUsePtr)).node },
        _ => return 0 as xmlNodePtr,
    };
}
extern "C" fn xmlSchemaFormatQName<'a1>(
    mut buf: Option<&'a1 mut *mut u8>,
    mut namespaceName: *const u8,
    mut localName: *const u8,
) -> *const u8 {
    if !(*(borrow_mut(&mut buf)).unwrap()).is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(
            *(borrow_mut(&mut buf)).unwrap() as *mut libc::c_void
        ) });
        *(borrow_mut(&mut buf)).unwrap() = 0 as *mut xmlChar;
    }
    if !namespaceName.is_null() {
        *(borrow_mut(&mut buf)).unwrap() =
            xmlStrdup(b"{\0" as *const u8 as *const i8 as *mut xmlChar);
        *(borrow_mut(&mut buf)).unwrap() =
            xmlStrcat(*(borrow_mut(&mut buf)).unwrap(), namespaceName);
        *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
            *(borrow_mut(&mut buf)).unwrap(),
            b"}\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    if !localName.is_null() {
        if namespaceName.is_null() {
            return localName;
        }
        *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(*(borrow_mut(&mut buf)).unwrap(), localName);
    } else {
        *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
            *(borrow_mut(&mut buf)).unwrap(),
            b"(NULL)\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    return *(borrow(&buf)).unwrap() as *const xmlChar;
}
extern "C" fn xmlSchemaFormatQNameNs<'a1>(
    mut buf: Option<&'a1 mut *mut u8>,
    mut ns: *mut crate::src::threads::_xmlNs,
    mut localName: *const u8,
) -> *const u8 {
    if !ns.is_null() {
        return xmlSchemaFormatQName(borrow_mut(&mut buf), unsafe { (*ns).href }, localName);
    } else {
        return xmlSchemaFormatQName(borrow_mut(&mut buf), 0 as *const xmlChar, localName);
    };
}
extern "C" fn xmlSchemaGetComponentName<'a1>(
    mut item: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a1>,
) -> *const u8 {
    if item.is_null() {
        return 0 as *const xmlChar;
    }
    match (unsafe { (*item).type_0 }) as u32 {
        14 => return unsafe { (*(item as xmlSchemaElementPtr)).name },
        15 => return unsafe { (*(item as xmlSchemaAttributePtr)).name },
        16 => return unsafe { (*(item as xmlSchemaAttributeGroupPtr)).name },
        1 | 4 | 5 => return unsafe { (*(item as xmlSchemaTypePtr)).name },
        17 => return unsafe { (*(item as xmlSchemaModelGroupDefPtr)).name },
        23 | 22 | 24 => return unsafe { (*(item as xmlSchemaIDCPtr)).name },
        26 => {
            if !(unsafe { (*(item as xmlSchemaAttributeUsePtr)).attrDecl }).is_null() {
                return xmlSchemaGetComponentName(
                    (unsafe { (*(item as xmlSchemaAttributeUsePtr)).attrDecl }) as xmlSchemaBasicItemPtr,
                );
            } else {
                return 0 as *const xmlChar;
            }
        },
        2000 => return unsafe { (*(item as xmlSchemaQNameRefPtr)).name },
        18 => return unsafe { (*(item as xmlSchemaNotationPtr)).name },
        _ => {},
    }
    return 0 as *const xmlChar;
}
extern "C" fn xmlSchemaGetComponentTargetNs<'a1>(
    mut item: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a1>,
) -> *const u8 {
    if item.is_null() {
        return 0 as *const xmlChar;
    }
    match (unsafe { (*item).type_0 }) as u32 {
        14 => return unsafe { (*(item as xmlSchemaElementPtr)).targetNamespace },
        15 => return unsafe { (*(item as xmlSchemaAttributePtr)).targetNamespace },
        16 => return unsafe { (*(item as xmlSchemaAttributeGroupPtr)).targetNamespace },
        1 => {
            return b"http://www.w3.org/2001/XMLSchema\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        4 | 5 => return unsafe { (*(item as xmlSchemaTypePtr)).targetNamespace },
        17 => return unsafe { (*(item as xmlSchemaModelGroupDefPtr)).targetNamespace },
        23 | 22 | 24 => return unsafe { (*(item as xmlSchemaIDCPtr)).targetNamespace },
        26 => {
            if !(unsafe { (*(item as xmlSchemaAttributeUsePtr)).attrDecl }).is_null() {
                return xmlSchemaGetComponentTargetNs(
                    (unsafe { (*(item as xmlSchemaAttributeUsePtr)).attrDecl }) as xmlSchemaBasicItemPtr,
                );
            }
        },
        2000 => return unsafe { (*(item as xmlSchemaQNameRefPtr)).targetNamespace },
        18 => return unsafe { (*(item as xmlSchemaNotationPtr)).targetNamespace },
        _ => {},
    }
    return 0 as *const xmlChar;
}
extern "C" fn xmlSchemaGetComponentQName<'a1>(
    mut buf: Option<&'a1 mut *mut u8>,
    mut item: *mut core::ffi::c_void,
) -> *const u8 {
    return xmlSchemaFormatQName(
        borrow_mut(&mut buf),
        xmlSchemaGetComponentTargetNs(item as xmlSchemaBasicItemPtr),
        xmlSchemaGetComponentName(item as xmlSchemaBasicItemPtr),
    );
}
extern "C" fn xmlSchemaGetComponentDesignation<'a1>(
    mut buf: Option<&'a1 mut *mut u8>,
    mut item: *mut core::ffi::c_void,
) -> *const u8 {
    let mut str: *mut u8 = 0 as *mut xmlChar;
    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
        *(borrow_mut(&mut buf)).unwrap(),
        xmlSchemaGetComponentTypeStr(item as xmlSchemaBasicItemPtr),
    );
    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
        *(borrow_mut(&mut buf)).unwrap(),
        b" '\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
        *(borrow_mut(&mut buf)).unwrap(),
        xmlSchemaGetComponentQName(
            Some(&mut str),
            item as xmlSchemaBasicItemPtr as *mut libc::c_void,
        ),
    );
    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
        *(borrow_mut(&mut buf)).unwrap(),
        b"'\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    if !str.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
        str = 0 as *mut xmlChar;
    }
    return *(borrow(&buf)).unwrap();
}
extern "C" fn xmlSchemaGetIDCDesignation<'a1, 'a2>(
    mut buf: Option<&'a1 mut *mut u8>,
    mut idc: *mut crate::src::xmlschemas::_xmlSchemaIDC<'a2>,
) -> *const u8 {
    return xmlSchemaGetComponentDesignation(borrow_mut(&mut buf), idc as *mut libc::c_void);
}
extern "C" fn xmlSchemaWildcardPCToString(mut pc: i32) -> *const u8 {
    match pc {
        1 => return b"skip\0" as *const u8 as *const i8 as *mut xmlChar,
        2 => return b"lax\0" as *const u8 as *const i8 as *mut xmlChar,
        3 => return b"strict\0" as *const u8 as *const i8 as *mut xmlChar,
        _ => {
            return b"invalid process contents\0" as *const u8 as *const i8 as *mut xmlChar;
        },
    };
}
extern "C" fn xmlSchemaGetCanonValueWhtspExt_1<'a1>(
    mut val: *mut crate::src::xmlschemastypes::_xmlSchemaVal,
    mut ws: u32,
    mut retValue: Option<&'a1 mut *mut u8>,
    mut for_hash: i32,
) -> i32 {
    let mut current_block: u64;
    let mut list: i32 = 0;
    let mut valType: u32 = XML_SCHEMAS_UNKNOWN;
    let mut value: *const u8 = 0 as *const xmlChar;
    let mut value2: *const u8 = 0 as *const xmlChar;
    if borrow(&retValue).is_none() || val.is_null() {
        return -(1 as i32);
    }
    list = if !(xmlSchemaValueGetNext(val)).is_null() {
        1 as i32
    } else {
        0 as i32
    };
    *(borrow_mut(&mut retValue)).unwrap() = 0 as *mut xmlChar;
    loop {
        value = 0 as *const xmlChar;
        valType = xmlSchemaGetValType(val);
        match valType as u32 {
            1 | 2 | 46 => {
                value = xmlSchemaValueGetAsString(val);
                if !value.is_null() {
                    if ws as u32 == XML_SCHEMA_WHITESPACE_COLLAPSE as i32 as u32 {
                        value2 = xmlSchemaCollapseString(value);
                    } else if ws as u32 == XML_SCHEMA_WHITESPACE_REPLACE as i32 as u32 {
                        value2 = xmlSchemaWhiteSpaceReplace(value);
                    }
                    if !value2.is_null() {
                        value = value2;
                    }
                }
            },
            _ => {
                if xmlSchemaGetCanonValue(val, Some(&mut value2)) == -(1 as i32) {
                    if !value2.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(
                            value2 as *mut xmlChar as *mut libc::c_void,
                        ) });
                    }
                    current_block = 11962130098811163542;
                    break;
                } else {
                    if for_hash != 0 && valType as u32 == XML_SCHEMAS_DECIMAL as i32 as u32 {
                        let mut len: i32 = xmlStrlen(value2);
                        if len > 2 as i32
                            && (unsafe { *value2.offset((len - 1 as i32) as isize) }) as i32 == '0' as i32
                            && (unsafe { *value2.offset((len - 2 as i32) as isize) }) as i32 == '.' as i32
                        {
                            (unsafe { *(value2 as *mut xmlChar).offset((len - 2 as i32) as isize) =
                                0 as i32 as xmlChar });
                        }
                    }
                    value = value2;
                }
            },
        }
        if (*(borrow_mut(&mut retValue)).unwrap()).is_null() {
            if value.is_null() {
                if list == 0 {
                    *(borrow_mut(&mut retValue)).unwrap() =
                        xmlStrdup(b"\0" as *const u8 as *const i8 as *mut xmlChar);
                }
            } else {
                *(borrow_mut(&mut retValue)).unwrap() = xmlStrdup(value);
            }
        } else if !value.is_null() {
            *(borrow_mut(&mut retValue)).unwrap() = xmlStrcat(
                *(borrow_mut(&mut retValue)).unwrap(),
                b" \0" as *const u8 as *const i8 as *mut xmlChar,
            );
            *(borrow_mut(&mut retValue)).unwrap() =
                xmlStrcat(*(borrow_mut(&mut retValue)).unwrap(), value);
        }
        if !value2.is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(
                value2 as *mut xmlChar as *mut libc::c_void,
            ) });
            value2 = 0 as *const xmlChar;
        }
        val = xmlSchemaValueGetNext(val);
        if val.is_null() {
            current_block = 3222590281903869779;
            break;
        }
    }
    match current_block {
        3222590281903869779 => return 0 as i32,
        _ => {
            if !(*(borrow_mut(&mut retValue)).unwrap()).is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(
                    *(borrow_mut(&mut retValue)).unwrap() as *mut libc::c_void
                ) });
            }
            if !value2.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(
                    value2 as *mut xmlChar as *mut libc::c_void,
                ) });
            }
            return -(1 as i32);
        },
    };
}
extern "C" fn xmlSchemaGetCanonValueWhtspExt<'a1>(
    mut val: *mut crate::src::xmlschemastypes::_xmlSchemaVal,
    mut ws: u32,
    mut retValue: Option<&'a1 mut *mut u8>,
) -> i32 {
    return xmlSchemaGetCanonValueWhtspExt_1(val, ws, borrow_mut(&mut retValue), 0 as i32);
}
extern "C" fn xmlSchemaGetCanonValueHash<'a1>(
    mut val: *mut crate::src::xmlschemastypes::_xmlSchemaVal,
    mut retValue: Option<&'a1 mut *mut u8>,
) -> i32 {
    return xmlSchemaGetCanonValueWhtspExt_1(
        val,
        XML_SCHEMA_WHITESPACE_COLLAPSE,
        borrow_mut(&mut retValue),
        1 as i32,
    );
}
extern "C" fn xmlSchemaFormatItemForReport<'a1, 'a2>(
    mut buf: Option<&'a1 mut *mut u8>,
    mut itemDes: *const u8,
    mut item: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2>,
    mut itemNode: *mut crate::src::threads::_xmlNode,
) -> *mut u8 {
    let mut str: *mut u8 = 0 as *mut xmlChar;
    let mut named: i32 = 1 as i32;
    if !(*(borrow_mut(&mut buf)).unwrap()).is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(
            *(borrow_mut(&mut buf)).unwrap() as *mut libc::c_void
        ) });
        *(borrow_mut(&mut buf)).unwrap() = 0 as *mut xmlChar;
    }
    if !itemDes.is_null() {
        *(borrow_mut(&mut buf)).unwrap() = xmlStrdup(itemDes);
    } else if !item.is_null() {
        let mut current_block_107: u64;
        match (unsafe { (*item).type_0 }) as u32 {
            1 => {
                let mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'_> =
                    item as xmlSchemaTypePtr;
                if (unsafe { (*type_0).flags }) & (1 as i32) << 8 as i32 != 0 {
                    *(borrow_mut(&mut buf)).unwrap() =
                        xmlStrdup(b"atomic type 'xs:\0" as *const u8 as *const i8 as *mut xmlChar);
                } else if (unsafe { (*type_0).flags }) & (1 as i32) << 6 as i32 != 0 {
                    *(borrow_mut(&mut buf)).unwrap() =
                        xmlStrdup(b"list type 'xs:\0" as *const u8 as *const i8 as *mut xmlChar);
                } else if (unsafe { (*type_0).flags }) & (1 as i32) << 7 as i32 != 0 {
                    *(borrow_mut(&mut buf)).unwrap() =
                        xmlStrdup(b"union type 'xs:\0" as *const u8 as *const i8 as *mut xmlChar);
                } else {
                    *(borrow_mut(&mut buf)).unwrap() =
                        xmlStrdup(b"simple type 'xs:\0" as *const u8 as *const i8 as *mut xmlChar);
                }
                *(borrow_mut(&mut buf)).unwrap() =
                    xmlStrcat(*(borrow_mut(&mut buf)).unwrap(), unsafe { (*type_0).name });
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            },
            4 => {
                let mut type_1: *mut crate::src::xmlschemas::_xmlSchemaType<'_> =
                    item as xmlSchemaTypePtr;
                if (unsafe { (*type_1).flags }) & (1 as i32) << 3 as i32 != 0 {
                    *(borrow_mut(&mut buf)).unwrap() =
                        xmlStrdup(b"\0" as *const u8 as *const i8 as *mut xmlChar);
                } else {
                    *(borrow_mut(&mut buf)).unwrap() =
                        xmlStrdup(b"local \0" as *const u8 as *const i8 as *mut xmlChar);
                }
                if (unsafe { (*type_1).flags }) & (1 as i32) << 8 as i32 != 0 {
                    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                        *(borrow_mut(&mut buf)).unwrap(),
                        b"atomic type\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                } else if (unsafe { (*type_1).flags }) & (1 as i32) << 6 as i32 != 0 {
                    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                        *(borrow_mut(&mut buf)).unwrap(),
                        b"list type\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                } else if (unsafe { (*type_1).flags }) & (1 as i32) << 7 as i32 != 0 {
                    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                        *(borrow_mut(&mut buf)).unwrap(),
                        b"union type\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                } else {
                    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                        *(borrow_mut(&mut buf)).unwrap(),
                        b"simple type\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                }
                if (unsafe { (*type_1).flags }) & (1 as i32) << 3 as i32 != 0 {
                    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                        *(borrow_mut(&mut buf)).unwrap(),
                        b" '\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                    *(borrow_mut(&mut buf)).unwrap() =
                        xmlStrcat(*(borrow_mut(&mut buf)).unwrap(), unsafe { (*type_1).name });
                    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                        *(borrow_mut(&mut buf)).unwrap(),
                        b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                }
                current_block_107 = 13253659531982233645;
            },
            5 => {
                let mut type_2: *mut crate::src::xmlschemas::_xmlSchemaType<'_> =
                    item as xmlSchemaTypePtr;
                if (unsafe { (*type_2).flags }) & (1 as i32) << 3 as i32 != 0 {
                    *(borrow_mut(&mut buf)).unwrap() =
                        xmlStrdup(b"\0" as *const u8 as *const i8 as *mut xmlChar);
                } else {
                    *(borrow_mut(&mut buf)).unwrap() =
                        xmlStrdup(b"local \0" as *const u8 as *const i8 as *mut xmlChar);
                }
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    b"complex type\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                if (unsafe { (*type_2).flags }) & (1 as i32) << 3 as i32 != 0 {
                    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                        *(borrow_mut(&mut buf)).unwrap(),
                        b" '\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                    *(borrow_mut(&mut buf)).unwrap() =
                        xmlStrcat(*(borrow_mut(&mut buf)).unwrap(), unsafe { (*type_2).name });
                    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                        *(borrow_mut(&mut buf)).unwrap(),
                        b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                }
                current_block_107 = 13253659531982233645;
            },
            26 => {
                let mut ause: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_> =
                    0 as *mut xmlSchemaAttributeUse;
                ause = item as xmlSchemaAttributeUsePtr;
                *(borrow_mut(&mut buf)).unwrap() =
                    xmlStrdup(b"attribute use \0" as *const u8 as *const i8 as *mut xmlChar);
                if !(unsafe { (*ause).attrDecl }).is_null() {
                    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                        *(borrow_mut(&mut buf)).unwrap(),
                        b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                        *(borrow_mut(&mut buf)).unwrap(),
                        xmlSchemaGetComponentQName(
                            Some(&mut str),
                            (unsafe { (*ause).attrDecl }) as *mut libc::c_void,
                        ),
                    );
                    if !str.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                        str = 0 as *mut xmlChar;
                    }
                    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                        *(borrow_mut(&mut buf)).unwrap(),
                        b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                } else {
                    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                        *(borrow_mut(&mut buf)).unwrap(),
                        b"(unknown)\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                }
                current_block_107 = 13253659531982233645;
            },
            15 => {
                let mut attr: *mut crate::src::xmlschemas::_xmlSchemaAttribute<'_> =
                    0 as *mut xmlSchemaAttribute;
                attr = item as xmlSchemaAttributePtr;
                *(borrow_mut(&mut buf)).unwrap() =
                    xmlStrdup(b"attribute decl.\0" as *const u8 as *const i8 as *mut xmlChar);
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    b" '\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    xmlSchemaFormatQName(Some(&mut str), unsafe { (*attr).targetNamespace }, unsafe { (*attr).name }),
                );
                if !str.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                    str = 0 as *mut xmlChar;
                }
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            },
            16 => {
                xmlSchemaGetComponentDesignation(borrow_mut(&mut buf), item as *mut libc::c_void);
                current_block_107 = 13253659531982233645;
            },
            14 => {
                let mut elem: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> =
                    0 as *mut xmlSchemaElement;
                elem = item as xmlSchemaElementPtr;
                *(borrow_mut(&mut buf)).unwrap() =
                    xmlStrdup(b"element decl.\0" as *const u8 as *const i8 as *mut xmlChar);
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    b" '\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    xmlSchemaFormatQName(Some(&mut str), unsafe { (*elem).targetNamespace }, unsafe { (*elem).name }),
                );
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            },
            22 | 23 | 24 => {
                if (unsafe { (*item).type_0 }) as u32 == XML_SCHEMA_TYPE_IDC_UNIQUE as i32 as u32 {
                    *(borrow_mut(&mut buf)).unwrap() =
                        xmlStrdup(b"unique '\0" as *const u8 as *const i8 as *mut xmlChar);
                } else if (unsafe { (*item).type_0 }) as u32 == XML_SCHEMA_TYPE_IDC_KEY as i32 as u32 {
                    *(borrow_mut(&mut buf)).unwrap() =
                        xmlStrdup(b"key '\0" as *const u8 as *const i8 as *mut xmlChar);
                } else {
                    *(borrow_mut(&mut buf)).unwrap() =
                        xmlStrdup(b"keyRef '\0" as *const u8 as *const i8 as *mut xmlChar);
                }
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    unsafe { (*(item as xmlSchemaIDCPtr)).name },
                );
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            },
            2 | 21 => {
                *(borrow_mut(&mut buf)).unwrap() = xmlStrdup(xmlSchemaWildcardPCToString(
                    unsafe { (*(item as xmlSchemaWildcardPtr)).processContents },
                ));
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    b" wildcard\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            },
            1000 | 1001 | 1002 | 1003 | 1004 | 1005 | 1006 | 1007 | 1008 | 1009 | 1010 | 1011 => {
                *(borrow_mut(&mut buf)).unwrap() =
                    xmlStrdup(b"facet '\0" as *const u8 as *const i8 as *mut xmlChar);
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    xmlSchemaFacetTypeToString(unsafe { (*item).type_0 }),
                );
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                current_block_107 = 13253659531982233645;
            },
            17 => {
                *(borrow_mut(&mut buf)).unwrap() =
                    xmlStrdup(b"model group def.\0" as *const u8 as *const i8 as *mut xmlChar);
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    b" '\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    xmlSchemaGetComponentQName(Some(&mut str), item as *mut libc::c_void),
                );
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                if !str.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                    str = 0 as *mut xmlChar;
                }
                current_block_107 = 13253659531982233645;
            },
            6 | 7 | 8 | 25 => {
                *(borrow_mut(&mut buf)).unwrap() = xmlStrdup(xmlSchemaGetComponentTypeStr(item));
                current_block_107 = 13253659531982233645;
            },
            18 => {
                *(borrow_mut(&mut buf)).unwrap() = xmlStrdup(xmlSchemaGetComponentTypeStr(item));
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    b" '\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    xmlSchemaGetComponentQName(Some(&mut str), item as *mut libc::c_void),
                );
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                if !str.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                    str = 0 as *mut xmlChar;
                }
                current_block_107 = 2993333835388634117;
            },
            _ => {
                current_block_107 = 2993333835388634117;
            },
        }
        match current_block_107 {
            2993333835388634117 => {
                named = 0 as i32;
            },
            _ => {},
        }
    } else {
        named = 0 as i32;
    }
    if named == 0 as i32 && !itemNode.is_null() {
        let mut elem_0: *mut crate::src::threads::_xmlNode = 0 as *mut xmlNode;
        if (unsafe { (*itemNode).type_0 }) as u32 == XML_ATTRIBUTE_NODE as i32 as u32 {
            elem_0 = unsafe { (*itemNode).parent };
        } else {
            elem_0 = itemNode;
        }
        *(borrow_mut(&mut buf)).unwrap() =
            xmlStrdup(b"Element '\0" as *const u8 as *const i8 as *mut xmlChar);
        if !(unsafe { (*elem_0).ns }).is_null() {
            *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                *(borrow_mut(&mut buf)).unwrap(),
                xmlSchemaFormatQName(Some(&mut str), unsafe { (*(*elem_0).ns).href }, unsafe { (*elem_0).name }),
            );
            if !str.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                str = 0 as *mut xmlChar;
            }
        } else {
            *(borrow_mut(&mut buf)).unwrap() =
                xmlStrcat(*(borrow_mut(&mut buf)).unwrap(), unsafe { (*elem_0).name });
        }
        *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
            *(borrow_mut(&mut buf)).unwrap(),
            b"'\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    if !itemNode.is_null() && (unsafe { (*itemNode).type_0 }) as u32 == XML_ATTRIBUTE_NODE as i32 as u32 {
        *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
            *(borrow_mut(&mut buf)).unwrap(),
            b", attribute '\0" as *const u8 as *const i8 as *mut xmlChar,
        );
        if !(unsafe { (*itemNode).ns }).is_null() {
            *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                *(borrow_mut(&mut buf)).unwrap(),
                xmlSchemaFormatQName(Some(&mut str), unsafe { (*(*itemNode).ns).href }, unsafe { (*itemNode).name }),
            );
            if !str.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                str = 0 as *mut xmlChar;
            }
        } else {
            *(borrow_mut(&mut buf)).unwrap() =
                xmlStrcat(*(borrow_mut(&mut buf)).unwrap(), unsafe { (*itemNode).name });
        }
        *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
            *(borrow_mut(&mut buf)).unwrap(),
            b"'\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    if !str.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
        str = 0 as *mut xmlChar;
    }
    return xmlEscapeFormatString(borrow_mut(&mut buf));
}
extern "C" fn xmlSchemaFormatFacetEnumSet<'a1, 'a2, 'a3>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut buf: Option<&'a2 mut *mut u8>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a3>,
) -> *const u8 {
    let mut facet: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as *mut xmlSchemaFacet;
    let mut ws: u32 = XML_SCHEMA_WHITESPACE_UNKNOWN;
    let mut value: *mut u8 = 0 as *mut xmlChar;
    let mut res: i32 = 0;
    let mut found: i32 = 0 as i32;
    if !(*(borrow_mut(&mut buf)).unwrap()).is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(
            *(borrow_mut(&mut buf)).unwrap() as *mut libc::c_void
        ) });
    }
    *(borrow_mut(&mut buf)).unwrap() = 0 as *mut xmlChar;
    loop {
        ws = xmlSchemaGetWhiteSpaceFacetValue(unsafe { (*type_0).baseType });
        facet = unsafe { (*type_0).facets };
        while !facet.is_null() {
            if !((unsafe { (*facet).type_0 }) as u32 != XML_SCHEMA_FACET_ENUMERATION as i32 as u32) {
                found = 1 as i32;
                res = xmlSchemaGetCanonValueWhtspExt(unsafe { (*facet).val }, ws, Some(&mut value));
                if res == -(1 as i32) {
                    xmlSchemaInternalErr(
                        actxt,
                        b"xmlSchemaFormatFacetEnumSet\0" as *const u8 as *const i8,
                        b"compute the canonical lexical representation\0" as *const u8 as *const i8,
                    );
                    if !(*(borrow_mut(&mut buf)).unwrap()).is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(
                            *(borrow_mut(&mut buf)).unwrap() as *mut libc::c_void,
                        ) });
                    }
                    *(borrow_mut(&mut buf)).unwrap() = 0 as *mut xmlChar;
                    return 0 as *const xmlChar;
                }
                if (*(borrow_mut(&mut buf)).unwrap()).is_null() {
                    *(borrow_mut(&mut buf)).unwrap() =
                        xmlStrdup(b"'\0" as *const u8 as *const i8 as *mut xmlChar);
                } else {
                    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                        *(borrow_mut(&mut buf)).unwrap(),
                        b", '\0" as *const u8 as *const i8 as *mut xmlChar,
                    );
                }
                *(borrow_mut(&mut buf)).unwrap() =
                    xmlStrcat(*(borrow_mut(&mut buf)).unwrap(), value);
                *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut buf)).unwrap(),
                    b"'\0" as *const u8 as *const i8 as *mut xmlChar,
                );
                if !value.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(value as *mut libc::c_void) });
                    value = 0 as *mut xmlChar;
                }
            }
            facet = unsafe { (*facet).next };
        }
        if found != 0 {
            break;
        }
        type_0 = unsafe { (*type_0).baseType };
        if !(!type_0.is_null() && (unsafe { (*type_0).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32) {
            break;
        }
    }
    return *(borrow(&buf)).unwrap() as *const xmlChar;
}
extern "C" fn xmlSchemaPSimpleErr(mut msg: *const i8) {
    (unsafe { __xmlSimpleError(
        XML_FROM_SCHEMASP as i32,
        XML_ERR_NO_MEMORY as i32,
        0 as xmlNodePtr,
        0 as *const i8,
        msg,
    ) });
}
extern "C" fn xmlSchemaPErrMemory<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut extra: *const i8,
    mut node: *mut crate::src::threads::_xmlNode,
) {
    if !ctxt.is_null() {
        let fresh0 = unsafe { &mut ((*ctxt).nberrors) };
        *fresh0 += 1;
    }
    (unsafe { __xmlSimpleError(
        XML_FROM_SCHEMASP as i32,
        XML_ERR_NO_MEMORY as i32,
        node,
        0 as *const i8,
        extra,
    ) });
}
extern "C" fn xmlSchemaPErr<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut error: i32,
    mut msg: *const i8,
    mut str1: *const u8,
    mut str2: *const u8,
) {
    let mut channel: Option<
        unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> (),
    > = None;
    let mut schannel: Option<
        unsafe extern "C" fn(
            _: *mut core::ffi::c_void,
            _: *mut crate::src::threads::_xmlError,
        ) -> (),
    > = None;
    let mut data: *mut core::ffi::c_void = 0 as *mut libc::c_void;
    if !ctxt.is_null() {
        let fresh1 = unsafe { &mut ((*ctxt).nberrors) };
        *fresh1 += 1;
        (unsafe { (*ctxt).err = error });
        channel = unsafe { (*ctxt).error };
        data = unsafe { (*ctxt).errCtxt };
        schannel = unsafe { (*ctxt).serror };
    }
    (unsafe { __xmlRaiseError(
        schannel,
        channel,
        data,
        ctxt as *mut libc::c_void,
        node as *mut libc::c_void,
        XML_FROM_SCHEMASP as i32,
        error,
        XML_ERR_ERROR,
        0 as *const i8,
        0 as i32,
        str1 as *const i8,
        str2 as *const i8,
        0 as *const i8,
        0 as i32,
        0 as i32,
        msg,
        str1,
        str2,
    ) });
}
extern "C" fn xmlSchemaPErr2<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut child: *mut crate::src::threads::_xmlNode,
    mut error: i32,
    mut msg: *const i8,
    mut str1: *const u8,
    mut str2: *const u8,
) {
    if !child.is_null() {
        xmlSchemaPErr(ctxt, child, error, msg, str1, str2);
    } else {
        xmlSchemaPErr(ctxt, node, error, msg, str1, str2);
    };
}
extern "C" fn xmlSchemaPErrExt<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut error: i32,
    mut strData1: *const u8,
    mut strData2: *const u8,
    mut strData3: *const u8,
    mut msg: *const i8,
    mut str1: *const u8,
    mut str2: *const u8,
    mut str3: *const u8,
    mut str4: *const u8,
    mut str5: *const u8,
) {
    let mut channel: Option<
        unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> (),
    > = None;
    let mut schannel: Option<
        unsafe extern "C" fn(
            _: *mut core::ffi::c_void,
            _: *mut crate::src::threads::_xmlError,
        ) -> (),
    > = None;
    let mut data: *mut core::ffi::c_void = 0 as *mut libc::c_void;
    if !ctxt.is_null() {
        let fresh2 = unsafe { &mut ((*ctxt).nberrors) };
        *fresh2 += 1;
        (unsafe { (*ctxt).err = error });
        channel = unsafe { (*ctxt).error };
        data = unsafe { (*ctxt).errCtxt };
        schannel = unsafe { (*ctxt).serror };
    }
    (unsafe { __xmlRaiseError(
        schannel,
        channel,
        data,
        ctxt as *mut libc::c_void,
        node as *mut libc::c_void,
        XML_FROM_SCHEMASP as i32,
        error,
        XML_ERR_ERROR,
        0 as *const i8,
        0 as i32,
        strData1 as *const i8,
        strData2 as *const i8,
        strData3 as *const i8,
        0 as i32,
        0 as i32,
        msg,
        str1,
        str2,
        str3,
        str4,
        str5,
    ) });
}
extern "C" fn xmlSchemaVErrMemory<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut extra: *const i8,
    mut node: *mut crate::src::threads::_xmlNode,
) {
    if !ctxt.is_null() {
        let fresh3 = unsafe { &mut ((*ctxt).nberrors) };
        *fresh3 += 1;
        (unsafe { (*ctxt).err = XML_SCHEMAV_INTERNAL as i32 });
    }
    (unsafe { __xmlSimpleError(
        XML_FROM_SCHEMASV as i32,
        XML_ERR_NO_MEMORY as i32,
        node,
        0 as *const i8,
        extra,
    ) });
}
extern "C" fn xmlSchemaPSimpleInternalErr(
    mut node: *mut crate::src::threads::_xmlNode,
    mut msg: *const i8,
    mut str: *const u8,
) {
    (unsafe { __xmlSimpleError(
        XML_FROM_SCHEMASP as i32,
        XML_SCHEMAP_INTERNAL as i32,
        node,
        msg,
        str as *const i8,
    ) });
}
extern "C" fn xmlSchemaErr4Line<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut errorLevel: u32,
    mut error: i32,
    mut node: *mut crate::src::threads::_xmlNode,
    mut line: i32,
    mut msg: *const i8,
    mut str1: *const u8,
    mut str2: *const u8,
    mut str3: *const u8,
    mut str4: *const u8,
) {
    let mut schannel: Option<
        unsafe extern "C" fn(
            _: *mut core::ffi::c_void,
            _: *mut crate::src::threads::_xmlError,
        ) -> (),
    > = None;
    let mut channel: Option<
        unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> (),
    > = None;
    let mut data: *mut core::ffi::c_void = 0 as *mut libc::c_void;
    if !ctxt.is_null() {
        if (unsafe { (*ctxt).type_0 }) == 2 as i32 {
            let mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'_> =
                ctxt as xmlSchemaValidCtxtPtr;
            let mut file: *const i8 = 0 as *const i8;
            let mut col: i32 = 0 as i32;
            if errorLevel as u32 != XML_ERR_WARNING as i32 as u32 {
                let fresh4 = unsafe { &mut ((*vctxt).nberrors) };
                *fresh4 += 1;
                (unsafe { (*vctxt).err = error });
                channel = unsafe { (*vctxt).error };
            } else {
                channel = unsafe { (*vctxt).warning };
            }
            schannel = unsafe { (*vctxt).serror };
            data = unsafe { (*vctxt).errCtxt };
            if line == 0 as i32 {
                if node.is_null() && (unsafe { (*vctxt).depth }) >= 0 as i32 && !(unsafe { (*vctxt).inode }).is_null() {
                    node = unsafe { (*(*vctxt).inode).node };
                }
                if node.is_null()
                    && !(unsafe { (*vctxt).parserCtxt }).is_null()
                    && !(unsafe { (*(*vctxt).parserCtxt).input }).is_null()
                {
                    file = unsafe { (*(*(*vctxt).parserCtxt).input).filename };
                    line = unsafe { (*(*(*vctxt).parserCtxt).input).line };
                    col = unsafe { (*(*(*vctxt).parserCtxt).input).col };
                }
            } else {
                node = 0 as xmlNodePtr;
                if !(unsafe { (*vctxt).doc }).is_null() {
                    file = (unsafe { (*(*vctxt).doc).URL }) as *const i8;
                } else if !(unsafe { (*vctxt).parserCtxt }).is_null()
                    && !(unsafe { (*(*vctxt).parserCtxt).input }).is_null()
                {
                    file = unsafe { (*(*(*vctxt).parserCtxt).input).filename };
                }
            }
            if unsafe { ((*vctxt).locFunc).is_some() } {
                if file.is_null() || line == 0 as i32 {
                    let mut l: u64 = 0;
                    let mut f: *const i8 = 0 as *const i8;
                    (unsafe { ((*vctxt).locFunc).expect("non-null function pointer")(
                        (*vctxt).locCtxt,
                        &mut f,
                        &mut l,
                    ) });
                    if file.is_null() {
                        file = f;
                    }
                    if line == 0 as i32 {
                        line = l as i32;
                    }
                }
            }
            if file.is_null() && !(unsafe { (*vctxt).filename }).is_null() {
                file = unsafe { (*vctxt).filename };
            }
            (unsafe { __xmlRaiseError(
                schannel,
                channel,
                data,
                ctxt as *mut libc::c_void,
                node as *mut libc::c_void,
                XML_FROM_SCHEMASV as i32,
                error,
                errorLevel,
                file,
                line,
                str1 as *const i8,
                str2 as *const i8,
                str3 as *const i8,
                0 as i32,
                col,
                msg,
                str1,
                str2,
                str3,
                str4,
            ) });
        } else if (unsafe { (*ctxt).type_0 }) == 1 as i32 {
            let mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'_> =
                ctxt as xmlSchemaParserCtxtPtr;
            if errorLevel as u32 != XML_ERR_WARNING as i32 as u32 {
                let fresh5 = unsafe { &mut ((*pctxt).nberrors) };
                *fresh5 += 1;
                (unsafe { (*pctxt).err = error });
                channel = unsafe { (*pctxt).error };
            } else {
                channel = unsafe { (*pctxt).warning };
            }
            schannel = unsafe { (*pctxt).serror };
            data = unsafe { (*pctxt).errCtxt };
            (unsafe { __xmlRaiseError(
                schannel,
                channel,
                data,
                ctxt as *mut libc::c_void,
                node as *mut libc::c_void,
                XML_FROM_SCHEMASP as i32,
                error,
                errorLevel,
                0 as *const i8,
                0 as i32,
                str1 as *const i8,
                str2 as *const i8,
                str3 as *const i8,
                0 as i32,
                0 as i32,
                msg,
                str1,
                str2,
                str3,
                str4,
            ) });
        } else {
            (unsafe { (*__xmlGenericError()).expect("non-null function pointer")(
                *__xmlGenericErrorContext(),
                b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
                b"xmlschemas.c\0" as *const u8 as *const i8,
                2188 as i32,
            ) });
        }
    }
}
extern "C" fn xmlSchemaErr3<'a1>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut error: i32,
    mut node: *mut crate::src::threads::_xmlNode,
    mut msg: *const i8,
    mut str1: *const u8,
    mut str2: *const u8,
    mut str3: *const u8,
) {
    xmlSchemaErr4Line(
        actxt,
        XML_ERR_ERROR,
        error,
        node,
        0 as i32,
        msg,
        str1,
        str2,
        str3,
        0 as *const xmlChar,
    );
}
extern "C" fn xmlSchemaErr4<'a1>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut error: i32,
    mut node: *mut crate::src::threads::_xmlNode,
    mut msg: *const i8,
    mut str1: *const u8,
    mut str2: *const u8,
    mut str3: *const u8,
    mut str4: *const u8,
) {
    xmlSchemaErr4Line(
        actxt,
        XML_ERR_ERROR,
        error,
        node,
        0 as i32,
        msg,
        str1,
        str2,
        str3,
        str4,
    );
}
extern "C" fn xmlSchemaErr<'a1>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut error: i32,
    mut node: *mut crate::src::threads::_xmlNode,
    mut msg: *const i8,
    mut str1: *const u8,
    mut str2: *const u8,
) {
    xmlSchemaErr4(
        actxt,
        error,
        node,
        msg,
        str1,
        str2,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
}
extern "C" fn xmlSchemaFormatNodeForError<'a1, 'a2>(
    mut msg: Option<&'a1 mut *mut u8>,
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *mut u8 {
    let mut str: *mut u8 = 0 as *mut xmlChar;
    *(borrow_mut(&mut msg)).unwrap() = 0 as *mut xmlChar;
    if !node.is_null()
        && (unsafe { (*node).type_0 }) as u32 != XML_ELEMENT_NODE as i32 as u32
        && (unsafe { (*node).type_0 }) as u32 != XML_ATTRIBUTE_NODE as i32 as u32
    {
        *(borrow_mut(&mut msg)).unwrap() =
            xmlStrdup(b"\0" as *const u8 as *const i8 as *mut xmlChar);
        return *(borrow_mut(&mut msg)).unwrap();
    }
    if !node.is_null() {
        if (unsafe { (*node).type_0 }) as u32 == XML_ATTRIBUTE_NODE as i32 as u32 {
            let mut elem: *mut crate::src::threads::_xmlNode = unsafe { (*node).parent };
            *(borrow_mut(&mut msg)).unwrap() =
                xmlStrdup(b"Element '\0" as *const u8 as *const i8 as *mut xmlChar);
            if !(unsafe { (*elem).ns }).is_null() {
                *(borrow_mut(&mut msg)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut msg)).unwrap(),
                    xmlSchemaFormatQName(Some(&mut str), unsafe { (*(*elem).ns).href }, unsafe { (*elem).name }),
                );
            } else {
                *(borrow_mut(&mut msg)).unwrap() = xmlStrcat(
                    *(borrow_mut(&mut msg)).unwrap(),
                    xmlSchemaFormatQName(Some(&mut str), 0 as *const xmlChar, unsafe { (*elem).name }),
                );
            }
            if !str.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                str = 0 as *mut xmlChar;
            }
            *(borrow_mut(&mut msg)).unwrap() = xmlStrcat(
                *(borrow_mut(&mut msg)).unwrap(),
                b"', \0" as *const u8 as *const i8 as *mut xmlChar,
            );
            *(borrow_mut(&mut msg)).unwrap() = xmlStrcat(
                *(borrow_mut(&mut msg)).unwrap(),
                b"attribute '\0" as *const u8 as *const i8 as *mut xmlChar,
            );
        } else {
            *(borrow_mut(&mut msg)).unwrap() =
                xmlStrdup(b"Element '\0" as *const u8 as *const i8 as *mut xmlChar);
        }
        if !(unsafe { (*node).ns }).is_null() {
            *(borrow_mut(&mut msg)).unwrap() = xmlStrcat(
                *(borrow_mut(&mut msg)).unwrap(),
                xmlSchemaFormatQName(Some(&mut str), unsafe { (*(*node).ns).href }, unsafe { (*node).name }),
            );
        } else {
            *(borrow_mut(&mut msg)).unwrap() = xmlStrcat(
                *(borrow_mut(&mut msg)).unwrap(),
                xmlSchemaFormatQName(Some(&mut str), 0 as *const xmlChar, unsafe { (*node).name }),
            );
        }
        if !str.is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
            str = 0 as *mut xmlChar;
        }
        *(borrow_mut(&mut msg)).unwrap() = xmlStrcat(
            *(borrow_mut(&mut msg)).unwrap(),
            b"': \0" as *const u8 as *const i8 as *mut xmlChar,
        );
    } else if (unsafe { (*actxt).type_0 }) == 2 as i32 {
        let mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'_> =
            actxt as xmlSchemaValidCtxtPtr;
        if (unsafe { (*(*vctxt).inode).nodeType }) == XML_ATTRIBUTE_NODE as i32 {
            let mut ielem: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'_> =
                unsafe { *((*vctxt).elemInfos).offset((*vctxt).depth as isize) };
            *(borrow_mut(&mut msg)).unwrap() =
                xmlStrdup(b"Element '\0" as *const u8 as *const i8 as *mut xmlChar);
            *(borrow_mut(&mut msg)).unwrap() = xmlStrcat(
                *(borrow_mut(&mut msg)).unwrap(),
                xmlSchemaFormatQName(Some(&mut str), unsafe { (*ielem).nsName }, unsafe { (*ielem).localName }),
            );
            if !str.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                str = 0 as *mut xmlChar;
            }
            *(borrow_mut(&mut msg)).unwrap() = xmlStrcat(
                *(borrow_mut(&mut msg)).unwrap(),
                b"', \0" as *const u8 as *const i8 as *mut xmlChar,
            );
            *(borrow_mut(&mut msg)).unwrap() = xmlStrcat(
                *(borrow_mut(&mut msg)).unwrap(),
                b"attribute '\0" as *const u8 as *const i8 as *mut xmlChar,
            );
        } else {
            *(borrow_mut(&mut msg)).unwrap() =
                xmlStrdup(b"Element '\0" as *const u8 as *const i8 as *mut xmlChar);
        }
        *(borrow_mut(&mut msg)).unwrap() = xmlStrcat(
            *(borrow_mut(&mut msg)).unwrap(),
            xmlSchemaFormatQName(
                Some(&mut str),
                unsafe { (*(*vctxt).inode).nsName },
                unsafe { (*(*vctxt).inode).localName },
            ),
        );
        if !str.is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
            str = 0 as *mut xmlChar;
        }
        *(borrow_mut(&mut msg)).unwrap() = xmlStrcat(
            *(borrow_mut(&mut msg)).unwrap(),
            b"': \0" as *const u8 as *const i8 as *mut xmlChar,
        );
    } else if (unsafe { (*actxt).type_0 }) == 1 as i32 {
        *(borrow_mut(&mut msg)).unwrap() =
            xmlStrdup(b"\0" as *const u8 as *const i8 as *mut xmlChar);
    } else {
        (unsafe { (*__xmlGenericError()).expect("non-null function pointer")(
            *__xmlGenericErrorContext(),
            b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
            b"xmlschemas.c\0" as *const u8 as *const i8,
            2309 as i32,
        ) });
        return 0 as *mut xmlChar;
    }
    xmlEscapeFormatString(borrow_mut(&mut msg));
    return *(borrow_mut(&mut msg)).unwrap();
}
extern "C" fn xmlSchemaInternalErr2<'a1>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut funcName: *const i8,
    mut message: *const i8,
    mut str1: *const u8,
    mut str2: *const u8,
) {
    let mut msg: *mut u8 = 0 as *mut xmlChar;
    if actxt.is_null() {
        return;
    }
    msg = xmlStrdup(b"Internal error: %s, \0" as *const u8 as *const i8 as *mut xmlChar);
    msg = xmlStrcat(msg, message as *mut xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const i8 as *mut xmlChar);
    if (unsafe { (*actxt).type_0 }) == 2 as i32 {
        xmlSchemaErr3(
            actxt,
            XML_SCHEMAV_INTERNAL as i32,
            0 as xmlNodePtr,
            msg as *const i8,
            funcName as *const xmlChar,
            str1,
            str2,
        );
    } else if (unsafe { (*actxt).type_0 }) == 1 as i32 {
        xmlSchemaErr3(
            actxt,
            XML_SCHEMAP_INTERNAL as i32,
            0 as xmlNodePtr,
            msg as *const i8,
            funcName as *const xmlChar,
            str1,
            str2,
        );
    }
    if !msg.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void) });
        msg = 0 as *mut xmlChar;
    }
}
extern "C" fn xmlSchemaInternalErr<'a1>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut funcName: *const i8,
    mut message: *const i8,
) {
    xmlSchemaInternalErr2(
        actxt,
        funcName,
        message,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
}
extern "C" fn xmlSchemaCustomErr4<'a1, 'a2>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut error: u32,
    mut node: *mut crate::src::threads::_xmlNode,
    mut item: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2>,
    mut message: *const i8,
    mut str1: *const u8,
    mut str2: *const u8,
    mut str3: *const u8,
    mut str4: *const u8,
) {
    let mut msg: *mut u8 = 0 as *mut xmlChar;
    if node.is_null() && !item.is_null() && (unsafe { (*actxt).type_0 }) == 1 as i32 {
        node = xmlSchemaGetComponentNode(item);
        xmlSchemaFormatItemForReport(Some(&mut msg), 0 as *const xmlChar, item, 0 as xmlNodePtr);
        msg = xmlStrcat(msg, b": \0" as *const u8 as *const i8 as *mut xmlChar);
    } else {
        xmlSchemaFormatNodeForError(Some(&mut msg), actxt, node);
    }
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const i8 as *mut xmlChar);
    xmlSchemaErr4(
        actxt,
        error as i32,
        node,
        msg as *const i8,
        str1,
        str2,
        str3,
        str4,
    );
    if !msg.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void) });
        msg = 0 as *mut xmlChar;
    }
}
extern "C" fn xmlSchemaCustomErr<'a1, 'a2>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut error: u32,
    mut node: *mut crate::src::threads::_xmlNode,
    mut item: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2>,
    mut message: *const i8,
    mut str1: *const u8,
    mut str2: *const u8,
) {
    xmlSchemaCustomErr4(
        actxt,
        error,
        node,
        item,
        message,
        str1,
        str2,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
}
extern "C" fn xmlSchemaCustomWarning<'a1, 'a2, 'a3>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut error: u32,
    mut node: *mut crate::src::threads::_xmlNode,
    mut _type_0: Option<&'a2 mut crate::src::xmlschemas::_xmlSchemaType<'a3>>,
    mut message: *const i8,
    mut str1: *const u8,
    mut str2: *const u8,
    mut str3: *const u8,
) {
    let mut msg: *mut u8 = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(Some(&mut msg), actxt, node);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const i8 as *mut xmlChar);
    xmlSchemaErr4Line(
        actxt,
        XML_ERR_WARNING,
        error as i32,
        node,
        0 as i32,
        msg as *const i8,
        str1,
        str2,
        str3,
        0 as *const xmlChar,
    );
    if !msg.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void) });
        msg = 0 as *mut xmlChar;
    }
}
extern "C" fn xmlSchemaKeyrefErr<'a1, 'a2, 'a3>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut error: u32,
    mut idcNode: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'a2>,
    mut _type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a3>,
    mut message: *const i8,
    mut str1: *const u8,
    mut str2: *const u8,
) {
    let mut msg: *mut u8 = 0 as *mut xmlChar;
    let mut qname: *mut u8 = 0 as *mut xmlChar;
    msg = xmlStrdup(b"Element '%s': \0" as *const u8 as *const i8 as *mut xmlChar);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const i8 as *mut xmlChar);
    xmlSchemaErr4Line(
        vctxt as xmlSchemaAbstractCtxtPtr,
        XML_ERR_ERROR,
        error as i32,
        0 as xmlNodePtr,
        unsafe { (*idcNode).nodeLine },
        msg as *const i8,
        xmlSchemaFormatQName(
            Some(&mut qname),
            (unsafe { *((*(*vctxt).nodeQNames).items).offset(((*idcNode).nodeQNameID + 1 as i32) as isize) })
                as *const xmlChar,
            (unsafe { *((*(*vctxt).nodeQNames).items).offset((*idcNode).nodeQNameID as isize) })
                as *const xmlChar,
        ),
        str1,
        str2,
        0 as *const xmlChar,
    );
    if !qname.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(qname as *mut libc::c_void) });
        qname = 0 as *mut xmlChar;
    }
    if !msg.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void) });
        msg = 0 as *mut xmlChar;
    }
}
extern "C" fn xmlSchemaEvalErrorNodeType<'a1>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> i32 {
    if !node.is_null() {
        return (unsafe { (*node).type_0 }) as i32;
    }
    if (unsafe { (*actxt).type_0 }) == 2 as i32 && !(unsafe { (*(actxt as xmlSchemaValidCtxtPtr)).inode }).is_null() {
        return unsafe { (*(*(actxt as xmlSchemaValidCtxtPtr)).inode).nodeType };
    }
    return -(1 as i32);
}
extern "C" fn xmlSchemaIsGlobalItem<'a1>(
    mut item: *mut crate::src::xmlschemas::_xmlSchemaType<'a1>,
) -> i32 {
    match (unsafe { (*item).type_0 }) as u32 {
        5 | 4 => {
            if (unsafe { (*item).flags }) & (1 as i32) << 3 as i32 != 0 {
                return 1 as i32;
            }
        },
        17 => return 1 as i32,
        14 => {
            if (unsafe { (*(item as xmlSchemaElementPtr)).flags }) & (1 as i32) << 1 as i32 != 0 {
                return 1 as i32;
            }
        },
        15 => {
            if (unsafe { (*(item as xmlSchemaAttributePtr)).flags }) & (1 as i32) << 0 as i32 != 0 {
                return 1 as i32;
            }
        },
        _ => return 1 as i32,
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaSimpleTypeErr<'a1, 'a2>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut error: u32,
    mut node: *mut crate::src::threads::_xmlNode,
    mut value: *const u8,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
    mut displayValue: i32,
) {
    let mut msg: *mut u8 = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(Some(&mut msg), actxt, node);
    if displayValue != 0 || xmlSchemaEvalErrorNodeType(actxt, node) == XML_ATTRIBUTE_NODE as i32 {
        msg = xmlStrcat(
            msg,
            b"'%s' is not a valid value of \0" as *const u8 as *const i8 as *mut xmlChar,
        );
    } else {
        msg = xmlStrcat(
            msg,
            b"The character content is not a valid value of \0" as *const u8 as *const i8
                as *mut xmlChar,
        );
    }
    if xmlSchemaIsGlobalItem(type_0) == 0 {
        msg = xmlStrcat(
            msg,
            b"the local \0" as *const u8 as *const i8 as *mut xmlChar,
        );
    } else {
        msg = xmlStrcat(msg, b"the \0" as *const u8 as *const i8 as *mut xmlChar);
    }
    if (unsafe { (*type_0).flags }) & (1 as i32) << 8 as i32 != 0 {
        msg = xmlStrcat(
            msg,
            b"atomic type\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    } else if (unsafe { (*type_0).flags }) & (1 as i32) << 6 as i32 != 0 {
        msg = xmlStrcat(
            msg,
            b"list type\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    } else if (unsafe { (*type_0).flags }) & (1 as i32) << 7 as i32 != 0 {
        msg = xmlStrcat(
            msg,
            b"union type\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    if xmlSchemaIsGlobalItem(type_0) != 0 {
        let mut str: *mut u8 = 0 as *mut xmlChar;
        msg = xmlStrcat(msg, b" '\0" as *const u8 as *const i8 as *mut xmlChar);
        if (unsafe { (*type_0).builtInType }) != 0 as i32 {
            msg = xmlStrcat(msg, b"xs:\0" as *const u8 as *const i8 as *mut xmlChar);
            str = xmlStrdup(unsafe { (*type_0).name });
        } else {
            let mut qName: *const u8 =
                xmlSchemaFormatQName(Some(&mut str), unsafe { (*type_0).targetNamespace }, unsafe { (*type_0).name });
            if str.is_null() {
                str = xmlStrdup(qName);
            }
        }
        msg = xmlStrcat(msg, xmlEscapeFormatString(Some(&mut str)));
        msg = xmlStrcat(msg, b"'\0" as *const u8 as *const i8 as *mut xmlChar);
        if !str.is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
            str = 0 as *mut xmlChar;
        }
    }
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const i8 as *mut xmlChar);
    if displayValue != 0 || xmlSchemaEvalErrorNodeType(actxt, node) == XML_ATTRIBUTE_NODE as i32 {
        xmlSchemaErr(
            actxt,
            error as i32,
            node,
            msg as *const i8,
            value,
            0 as *const xmlChar,
        );
    } else {
        xmlSchemaErr(
            actxt,
            error as i32,
            node,
            msg as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    if !msg.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void) });
        msg = 0 as *mut xmlChar;
    }
}
extern "C" fn xmlSchemaFormatErrorNodeQName<'a1, 'a2>(
    mut str: Option<&'a1 mut *mut u8>,
    mut ni: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *const u8 {
    if !node.is_null() {
        if !(unsafe { (*node).ns }).is_null() {
            return xmlSchemaFormatQName(borrow_mut(&mut str), unsafe { (*(*node).ns).href }, unsafe { (*node).name });
        } else {
            return xmlSchemaFormatQName(borrow_mut(&mut str), 0 as *const xmlChar, unsafe { (*node).name });
        }
    } else {
        if !ni.is_null() {
            return xmlSchemaFormatQName(borrow_mut(&mut str), unsafe { (*ni).nsName }, unsafe { (*ni).localName });
        }
    }
    return 0 as *const xmlChar;
}
extern "C" fn xmlSchemaIllegalAttrErr<'a1, 'a2>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut error: u32,
    mut ni: *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) {
    let mut msg: *mut u8 = 0 as *mut xmlChar;
    let mut str: *mut u8 = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(Some(&mut msg), actxt, node);
    msg = xmlStrcat(
        msg,
        b"The attribute '%s' is not allowed.\n\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    xmlSchemaErr(
        actxt,
        error as i32,
        node,
        msg as *const i8,
        xmlSchemaFormatErrorNodeQName(Some(&mut str), ni as xmlSchemaNodeInfoPtr, node),
        0 as *const xmlChar,
    );
    if !str.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
        str = 0 as *mut xmlChar;
    }
    if !msg.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void) });
        msg = 0 as *mut xmlChar;
    }
}
extern "C" fn xmlSchemaComplexTypeErr<'a1, 'a2, 'a3>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut error: u32,
    mut node: *mut crate::src::threads::_xmlNode,
    mut _type_0: Option<&'a2 mut crate::src::xmlschemas::_xmlSchemaType<'a3>>,
    mut message: *const i8,
    mut nbval: i32,
    mut nbneg: i32,
    mut values: *mut *mut u8,
) {
    let mut str: *mut u8 = 0 as *mut xmlChar;
    let mut msg: *mut u8 = 0 as *mut xmlChar;
    let mut localName: *mut u8 = 0 as *mut xmlChar;
    let mut nsName: *mut u8 = 0 as *mut xmlChar;
    let mut cur: *const u8 = 0 as *const xmlChar;
    let mut end: *const u8 = 0 as *const xmlChar;
    let mut i: i32 = 0;
    xmlSchemaFormatNodeForError(Some(&mut msg), actxt, node);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\0" as *const u8 as *const i8 as *mut xmlChar);
    if nbval + nbneg > 0 as i32 {
        if nbval + nbneg > 1 as i32 {
            str = xmlStrdup(b" Expected is one of ( \0" as *const u8 as *const i8 as *mut xmlChar);
        } else {
            str = xmlStrdup(b" Expected is ( \0" as *const u8 as *const i8 as *mut xmlChar);
        }
        nsName = 0 as *mut xmlChar;
        let mut current_block_55: u64;
        i = 0 as i32;
        while i < nbval + nbneg {
            cur = unsafe { *values.offset(i as isize) };
            if !cur.is_null() {
                if (unsafe { *cur.offset(0 as i32 as isize) }) as i32 == 'n' as i32
                    && (unsafe { *cur.offset(1 as i32 as isize) }) as i32 == 'o' as i32
                    && (unsafe { *cur.offset(2 as i32 as isize) }) as i32 == 't' as i32
                    && (unsafe { *cur.offset(3 as i32 as isize) }) as i32 == ' ' as i32
                {
                    cur = unsafe { cur.offset(4 as i32 as isize) };
                    str = xmlStrcat(str, b"##other\0" as *const u8 as *const i8 as *mut xmlChar);
                }
                localName = 0 as *mut xmlChar;
                end = cur;
                if (unsafe { *end }) as i32 == '*' as i32 {
                    localName = xmlStrdup(b"*\0" as *const u8 as *const i8 as *mut xmlChar);
                    end = unsafe { end.offset(1) };
                } else {
                    while (unsafe { *end }) as i32 != 0 as i32 && (unsafe { *end }) as i32 != '|' as i32 {
                        end = unsafe { end.offset(1) };
                    }
                    localName = xmlStrncat(
                        localName,
                        cur as *mut xmlChar,
                        (unsafe { end.offset_from(cur) }) as i64 as i32,
                    );
                }
                if (unsafe { *end }) as i32 != 0 as i32 {
                    end = unsafe { end.offset(1) };
                    if nbneg == 0 as i32
                        || (unsafe { *end }) as i32 != '*' as i32
                        || (unsafe { *localName }) as i32 != '*' as i32
                    {
                        cur = end;
                        if (unsafe { *end }) as i32 == '*' as i32 {
                            nsName = xmlStrdup(b"{*}\0" as *const u8 as *const i8 as *mut xmlChar);
                        } else {
                            while (unsafe { *end }) as i32 != 0 as i32 {
                                end = unsafe { end.offset(1) };
                            }
                            if i >= nbval {
                                nsName = xmlStrdup(
                                    b"{##other:\0" as *const u8 as *const i8 as *mut xmlChar,
                                );
                            } else {
                                nsName =
                                    xmlStrdup(b"{\0" as *const u8 as *const i8 as *mut xmlChar);
                            }
                            nsName = xmlStrncat(
                                nsName,
                                cur as *mut xmlChar,
                                (unsafe { end.offset_from(cur) }) as i64 as i32,
                            );
                            nsName =
                                xmlStrcat(nsName, b"}\0" as *const u8 as *const i8 as *mut xmlChar);
                        }
                        str = xmlStrcat(str, nsName);
                        if !nsName.is_null() {
                            (unsafe { xmlFree.expect("non-null function pointer")(
                                nsName as *mut libc::c_void,
                            ) });
                            nsName = 0 as *mut xmlChar;
                        }
                        current_block_55 = 7990025728955927862;
                    } else {
                        if !localName.is_null() {
                            (unsafe { xmlFree.expect("non-null function pointer")(
                                localName as *mut libc::c_void,
                            ) });
                            localName = 0 as *mut xmlChar;
                        }
                        current_block_55 = 13536709405535804910;
                    }
                } else {
                    current_block_55 = 7990025728955927862;
                }
                match current_block_55 {
                    13536709405535804910 => {},
                    _ => {
                        str = xmlStrcat(str, localName);
                        if !localName.is_null() {
                            (unsafe { xmlFree.expect("non-null function pointer")(
                                localName as *mut libc::c_void,
                            ) });
                            localName = 0 as *mut xmlChar;
                        }
                        if i < nbval + nbneg - 1 as i32 {
                            str = xmlStrcat(str, b", \0" as *const u8 as *const i8 as *mut xmlChar);
                        }
                    },
                }
            }
            i += 1;
        }
        str = xmlStrcat(str, b" ).\n\0" as *const u8 as *const i8 as *mut xmlChar);
        msg = xmlStrcat(msg, xmlEscapeFormatString(Some(&mut str)));
        if !str.is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
            str = 0 as *mut xmlChar;
        }
    } else {
        msg = xmlStrcat(msg, b"\n\0" as *const u8 as *const i8 as *mut xmlChar);
    }
    xmlSchemaErr(
        actxt,
        error as i32,
        node,
        msg as *const i8,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
    (unsafe { xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void) });
}
extern "C" fn xmlSchemaFacetErr<'a1, 'a2, 'a3>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut error: u32,
    mut node: *mut crate::src::threads::_xmlNode,
    mut value: *const u8,
    mut length: u64,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
    mut facet: *mut crate::src::xmlschemas::_xmlSchemaFacet<'a3>,
    mut message: *const i8,
    mut str1: *const u8,
    mut str2: *const u8,
) {
    let mut str: *mut u8 = 0 as *mut xmlChar;
    let mut msg: *mut u8 = 0 as *mut xmlChar;
    let mut facetType: u32 = 0 as xmlSchemaTypeType;
    let mut nodeType: i32 = xmlSchemaEvalErrorNodeType(actxt, node);
    xmlSchemaFormatNodeForError(Some(&mut msg), actxt, node);
    if error as u32 == XML_SCHEMAV_CVC_ENUMERATION_VALID as i32 as u32 {
        facetType = XML_SCHEMA_FACET_ENUMERATION;
    } else {
        facetType = unsafe { (*facet).type_0 };
    }
    msg = xmlStrcat(msg, b"[\0" as *const u8 as *const i8 as *mut xmlChar);
    msg = xmlStrcat(msg, b"facet '\0" as *const u8 as *const i8 as *mut xmlChar);
    msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(facetType));
    msg = xmlStrcat(msg, b"'] \0" as *const u8 as *const i8 as *mut xmlChar);
    if message.is_null() {
        if facetType as u32 == XML_SCHEMA_FACET_LENGTH as i32 as u32
            || facetType as u32 == XML_SCHEMA_FACET_MINLENGTH as i32 as u32
            || facetType as u32 == XML_SCHEMA_FACET_MAXLENGTH as i32 as u32
        {
            let mut len: [i8; 25] = [0; 25];
            let mut actLen: [i8; 25] = [0; 25];
            if nodeType == XML_ATTRIBUTE_NODE as i32 {
                msg = xmlStrcat(
                    msg,
                    b"The value '%s' has a length of '%s'; \0" as *const u8 as *const i8
                        as *mut xmlChar,
                );
            } else {
                msg = xmlStrcat(
                    msg,
                    b"The value has a length of '%s'; \0" as *const u8 as *const i8 as *mut xmlChar,
                );
            }
            (unsafe { snprintf(
                len.as_mut_ptr(),
                24 as i32 as u64,
                b"%lu\0" as *const u8 as *const i8,
                xmlSchemaGetFacetValueAsULong(facet),
            ) });
            (unsafe { snprintf(
                actLen.as_mut_ptr(),
                24 as i32 as u64,
                b"%lu\0" as *const u8 as *const i8,
                length,
            ) });
            if facetType as u32 == XML_SCHEMA_FACET_LENGTH as i32 as u32 {
                msg = xmlStrcat(
                    msg,
                    b"this differs from the allowed length of '%s'.\n\0" as *const u8 as *const i8
                        as *mut xmlChar,
                );
            } else if facetType as u32 == XML_SCHEMA_FACET_MAXLENGTH as i32 as u32 {
                msg = xmlStrcat(
                    msg,
                    b"this exceeds the allowed maximum length of '%s'.\n\0" as *const u8
                        as *const i8 as *mut xmlChar,
                );
            } else if facetType as u32 == XML_SCHEMA_FACET_MINLENGTH as i32 as u32 {
                msg = xmlStrcat(
                    msg,
                    b"this underruns the allowed minimum length of '%s'.\n\0" as *const u8
                        as *const i8 as *mut xmlChar,
                );
            }
            if nodeType == XML_ATTRIBUTE_NODE as i32 {
                xmlSchemaErr3(
                    actxt,
                    error as i32,
                    node,
                    msg as *const i8,
                    value,
                    actLen.as_mut_ptr() as *const xmlChar,
                    len.as_mut_ptr() as *const xmlChar,
                );
            } else {
                xmlSchemaErr(
                    actxt,
                    error as i32,
                    node,
                    msg as *const i8,
                    actLen.as_mut_ptr() as *const xmlChar,
                    len.as_mut_ptr() as *const xmlChar,
                );
            }
        } else if facetType as u32 == XML_SCHEMA_FACET_ENUMERATION as i32 as u32 {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is not an element of the set {%s}.\n\0" as *const u8 as *const i8
                    as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                xmlSchemaFormatFacetEnumSet(actxt, Some(&mut str), type_0),
            );
        } else if facetType as u32 == XML_SCHEMA_FACET_PATTERN as i32 as u32 {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is not accepted by the pattern '%s'.\n\0" as *const u8 as *const i8
                    as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                unsafe { (*facet).value },
            );
        } else if facetType as u32 == XML_SCHEMA_FACET_MININCLUSIVE as i32 as u32 {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is less than the minimum value allowed ('%s').\n\0" as *const u8
                    as *const i8 as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                unsafe { (*facet).value },
            );
        } else if facetType as u32 == XML_SCHEMA_FACET_MAXINCLUSIVE as i32 as u32 {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is greater than the maximum value allowed ('%s').\n\0" as *const u8
                    as *const i8 as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                unsafe { (*facet).value },
            );
        } else if facetType as u32 == XML_SCHEMA_FACET_MINEXCLUSIVE as i32 as u32 {
            msg = xmlStrcat(
                msg,
                b"The value '%s' must be greater than '%s'.\n\0" as *const u8 as *const i8
                    as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                unsafe { (*facet).value },
            );
        } else if facetType as u32 == XML_SCHEMA_FACET_MAXEXCLUSIVE as i32 as u32 {
            msg = xmlStrcat(
                msg,
                b"The value '%s' must be less than '%s'.\n\0" as *const u8 as *const i8
                    as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                unsafe { (*facet).value },
            );
        } else if facetType as u32 == XML_SCHEMA_FACET_TOTALDIGITS as i32 as u32 {
            msg = xmlStrcat(
                msg,
                b"The value '%s' has more digits than are allowed ('%s').\n\0" as *const u8
                    as *const i8 as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                unsafe { (*facet).value },
            );
        } else if facetType as u32 == XML_SCHEMA_FACET_FRACTIONDIGITS as i32 as u32 {
            msg = xmlStrcat(
                msg,
                b"The value '%s' has more fractional digits than are allowed ('%s').\n\0"
                    as *const u8 as *const i8 as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                unsafe { (*facet).value },
            );
        } else if nodeType == XML_ATTRIBUTE_NODE as i32 {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is not facet-valid.\n\0" as *const u8 as *const i8 as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                value,
                0 as *const xmlChar,
            );
        } else {
            msg = xmlStrcat(
                msg,
                b"The value is not facet-valid.\n\0" as *const u8 as *const i8 as *mut xmlChar,
            );
            xmlSchemaErr(
                actxt,
                error as i32,
                node,
                msg as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
        }
    } else {
        msg = xmlStrcat(msg, message as *const xmlChar);
        msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const i8 as *mut xmlChar);
        xmlSchemaErr(actxt, error as i32, node, msg as *const i8, str1, str2);
    }
    if !str.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
        str = 0 as *mut xmlChar;
    }
    (unsafe { xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void) });
}
extern "C" fn xmlSchemaPMissingAttrErr<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut error: u32,
    mut ownerItem: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2>,
    mut ownerElem: *mut crate::src::threads::_xmlNode,
    mut name: *const i8,
    mut message: *const i8,
) {
    let mut des: *mut u8 = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(Some(&mut des), 0 as *const xmlChar, ownerItem, ownerElem);
    if !message.is_null() {
        xmlSchemaPErr(
            ctxt,
            ownerElem,
            error as i32,
            b"%s: %s.\n\0" as *const u8 as *const i8,
            des,
            message as *mut xmlChar,
        );
    } else {
        xmlSchemaPErr(
            ctxt,
            ownerElem,
            error as i32,
            b"%s: The attribute '%s' is required but missing.\n\0" as *const u8 as *const i8,
            des,
            name as *mut xmlChar,
        );
    }
    if !des.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(des as *mut libc::c_void) });
        des = 0 as *mut xmlChar;
    }
}
extern "C" fn xmlSchemaPResCompAttrErr<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut error: u32,
    mut ownerItem: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2>,
    mut ownerElem: *mut crate::src::threads::_xmlNode,
    mut name: *const i8,
    mut refName: *const u8,
    mut refURI: *const u8,
    mut refType: u32,
    mut refTypeStr: *const i8,
) {
    let mut des: *mut u8 = 0 as *mut xmlChar;
    let mut strA: *mut u8 = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(Some(&mut des), 0 as *const xmlChar, ownerItem, ownerElem);
    if refTypeStr.is_null() {
        refTypeStr = xmlSchemaItemTypeToStr(refType) as *const i8;
    }
    xmlSchemaPErrExt(
        ctxt,
        ownerElem,
        error as i32,
        0 as *const xmlChar,
        0 as *const xmlChar,
        0 as *const xmlChar,
        b"%s, attribute '%s': The QName value '%s' does not resolve to a(n) %s.\n\0" as *const u8
            as *const i8,
        des,
        name as *mut xmlChar,
        xmlSchemaFormatQName(Some(&mut strA), refURI, refName),
        refTypeStr as *mut xmlChar,
        0 as *const xmlChar,
    );
    if !des.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(des as *mut libc::c_void) });
        des = 0 as *mut xmlChar;
    }
    if !strA.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(strA as *mut libc::c_void) });
        strA = 0 as *mut xmlChar;
    }
}
extern "C" fn xmlSchemaPCustomAttrErr<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut error: u32,
    mut ownerDes: Option<&'a2 mut *mut u8>,
    mut ownerItem: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a3>,
    mut attr: *mut crate::src::threads::_xmlAttr,
    mut msg: *const i8,
) {
    let mut des: *mut u8 = 0 as *mut xmlChar;
    if borrow(&ownerDes).is_none() {
        xmlSchemaFormatItemForReport(
            Some(&mut des),
            0 as *const xmlChar,
            ownerItem,
            unsafe { (*attr).parent },
        );
    } else if (*(borrow_mut(&mut ownerDes)).unwrap()).is_null() {
        xmlSchemaFormatItemForReport(
            borrow_mut(&mut ownerDes),
            0 as *const xmlChar,
            ownerItem,
            unsafe { (*attr).parent },
        );
        des = *(borrow_mut(&mut ownerDes)).unwrap();
    } else {
        des = *(borrow_mut(&mut ownerDes)).unwrap();
    }
    if attr.is_null() {
        xmlSchemaPErrExt(
            ctxt,
            0 as xmlNodePtr,
            error as i32,
            0 as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
            b"%s, attribute '%s': %s.\n\0" as *const u8 as *const i8,
            des,
            b"Unknown\0" as *const u8 as *const i8 as *const xmlChar,
            msg as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    } else {
        xmlSchemaPErrExt(
            ctxt,
            attr as xmlNodePtr,
            error as i32,
            0 as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
            b"%s, attribute '%s': %s.\n\0" as *const u8 as *const i8,
            des,
            unsafe { (*attr).name },
            msg as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    if borrow(&ownerDes).is_none() {
        if !des.is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(des as *mut libc::c_void) });
            des = 0 as *mut xmlChar;
        }
    }
}
extern "C" fn xmlSchemaPIllegalAttrErr<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut error: u32,
    mut _ownerComp: Option<&'a2 mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a3>>,
    mut attr: *mut crate::src::threads::_xmlAttr,
) {
    let mut strA: *mut u8 = 0 as *mut xmlChar;
    let mut strB: *mut u8 = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(
        Some(&mut strA),
        ctxt as xmlSchemaAbstractCtxtPtr,
        unsafe { (*attr).parent },
    );
    xmlSchemaErr4(
        ctxt as xmlSchemaAbstractCtxtPtr,
        error as i32,
        attr as xmlNodePtr,
        b"%sThe attribute '%s' is not allowed.\n\0" as *const u8 as *const i8,
        strA,
        xmlSchemaFormatQNameNs(Some(&mut strB), unsafe { (*attr).ns }, unsafe { (*attr).name }),
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
    if !strA.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(strA as *mut libc::c_void) });
        strA = 0 as *mut xmlChar;
    }
    if !strB.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(strB as *mut libc::c_void) });
        strB = 0 as *mut xmlChar;
    }
}
extern "C" fn xmlSchemaPCustomErrExt<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut error: u32,
    mut item: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2>,
    mut itemElem: *mut crate::src::threads::_xmlNode,
    mut message: *const i8,
    mut str1: *const u8,
    mut str2: *const u8,
    mut str3: *const u8,
) {
    let mut des: *mut u8 = 0 as *mut xmlChar;
    let mut msg: *mut u8 = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(Some(&mut des), 0 as *const xmlChar, item, itemElem);
    msg = xmlStrdup(b"%s: \0" as *const u8 as *const i8 as *mut xmlChar);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const i8 as *mut xmlChar);
    if itemElem.is_null() && !item.is_null() {
        itemElem = xmlSchemaGetComponentNode(item);
    }
    xmlSchemaPErrExt(
        ctxt,
        itemElem,
        error as i32,
        0 as *const xmlChar,
        0 as *const xmlChar,
        0 as *const xmlChar,
        msg as *const i8,
        des,
        str1,
        str2,
        str3,
        0 as *const xmlChar,
    );
    if !des.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(des as *mut libc::c_void) });
        des = 0 as *mut xmlChar;
    }
    if !msg.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void) });
        msg = 0 as *mut xmlChar;
    }
}
extern "C" fn xmlSchemaPCustomErr<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut error: u32,
    mut item: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2>,
    mut itemElem: *mut crate::src::threads::_xmlNode,
    mut message: *const i8,
    mut str1: *const u8,
) {
    xmlSchemaPCustomErrExt(
        ctxt,
        error,
        item,
        itemElem,
        message,
        str1,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
}
extern "C" fn xmlSchemaPAttrUseErr4<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut error: u32,
    mut node: *mut crate::src::threads::_xmlNode,
    mut ownerItem: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2>,
    attruse: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'a3>,
    mut message: *const i8,
    mut str1: *const u8,
    mut str2: *const u8,
    mut str3: *const u8,
    mut str4: *const u8,
) {
    let mut str: *mut u8 = 0 as *mut xmlChar;
    let mut msg: *mut u8 = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(
        Some(&mut msg),
        0 as *const xmlChar,
        ownerItem,
        0 as xmlNodePtr,
    );
    msg = xmlStrcat(msg, b", \0" as *const u8 as *const i8 as *mut xmlChar);
    msg = xmlStrcat(
        msg,
        xmlSchemaFormatItemForReport(
            Some(&mut str),
            0 as *const xmlChar,
            attruse as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
        ),
    );
    if !str.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
        str = 0 as *mut xmlChar;
    }
    msg = xmlStrcat(msg, b": \0" as *const u8 as *const i8 as *mut xmlChar);
    msg = xmlStrcat(msg, message as *const xmlChar);
    msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const i8 as *mut xmlChar);
    xmlSchemaErr4(
        ctxt as xmlSchemaAbstractCtxtPtr,
        error as i32,
        node,
        msg as *const i8,
        str1,
        str2,
        str3,
        str4,
    );
    (unsafe { xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void) });
}
extern "C" fn xmlSchemaPIllegalFacetAtomicErr<'a1, 'a2, 'a3, 'a4>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut error: u32,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
    mut baseType: *mut crate::src::xmlschemas::_xmlSchemaType<'a3>,
    mut facet: *mut crate::src::xmlschemas::_xmlSchemaFacet<'a4>,
) {
    let mut des: *mut u8 = 0 as *mut xmlChar;
    let mut strT: *mut u8 = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(
        Some(&mut des),
        0 as *const xmlChar,
        type_0 as xmlSchemaBasicItemPtr,
        unsafe { (*type_0).node },
    );
    xmlSchemaPErrExt(
        ctxt,
        unsafe { (*type_0).node },
        error as i32,
        0 as *const xmlChar,
        0 as *const xmlChar,
        0 as *const xmlChar,
        b"%s: The facet '%s' is not allowed on types derived from the type %s.\n\0" as *const u8
            as *const i8,
        des,
        xmlSchemaFacetTypeToString(unsafe { (*facet).type_0 }),
        xmlSchemaFormatItemForReport(
            Some(&mut strT),
            0 as *const xmlChar,
            baseType as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
        ),
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
    if !des.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(des as *mut libc::c_void) });
        des = 0 as *mut xmlChar;
    }
    if !strT.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(strT as *mut libc::c_void) });
        strT = 0 as *mut xmlChar;
    }
}
extern "C" fn xmlSchemaPIllegalFacetListUnionErr<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut error: u32,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
    mut facet: *mut crate::src::xmlschemas::_xmlSchemaFacet<'a3>,
) {
    let mut des: *mut u8 = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(
        Some(&mut des),
        0 as *const xmlChar,
        type_0 as xmlSchemaBasicItemPtr,
        unsafe { (*type_0).node },
    );
    xmlSchemaPErr(
        ctxt,
        unsafe { (*type_0).node },
        error as i32,
        b"%s: The facet '%s' is not allowed.\n\0" as *const u8 as *const i8,
        des,
        xmlSchemaFacetTypeToString(unsafe { (*facet).type_0 }),
    );
    if !des.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(des as *mut libc::c_void) });
        des = 0 as *mut xmlChar;
    }
}
extern "C" fn xmlSchemaPMutualExclAttrErr<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut error: u32,
    mut ownerItem: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2>,
    mut attr: *mut crate::src::threads::_xmlAttr,
    mut name1: *const i8,
    mut name2: *const i8,
) {
    let mut des: *mut u8 = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(
        Some(&mut des),
        0 as *const xmlChar,
        ownerItem,
        unsafe { (*attr).parent },
    );
    xmlSchemaPErrExt(
        ctxt,
        attr as xmlNodePtr,
        error as i32,
        0 as *const xmlChar,
        0 as *const xmlChar,
        0 as *const xmlChar,
        b"%s: The attributes '%s' and '%s' are mutually exclusive.\n\0" as *const u8 as *const i8,
        des,
        name1 as *mut xmlChar,
        name2 as *mut xmlChar,
        0 as *const xmlChar,
        0 as *const xmlChar,
    );
    if !des.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(des as *mut libc::c_void) });
        des = 0 as *mut xmlChar;
    }
}
extern "C" fn xmlSchemaPSimpleTypeErr<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut error: u32,
    mut _ownerItem: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a3>,
    mut expected: *const i8,
    mut value: *const u8,
    mut message: *const i8,
    mut str1: *const u8,
    mut str2: *const u8,
) {
    let mut msg: *mut u8 = 0 as *mut xmlChar;
    xmlSchemaFormatNodeForError(Some(&mut msg), ctxt as xmlSchemaAbstractCtxtPtr, node);
    if message.is_null() {
        if !type_0.is_null() {
            if (unsafe { (*node).type_0 }) as u32 == XML_ATTRIBUTE_NODE as i32 as u32 {
                msg = xmlStrcat(
                    msg,
                    b"'%s' is not a valid value of \0" as *const u8 as *const i8 as *mut xmlChar,
                );
            } else {
                msg = xmlStrcat(
                    msg,
                    b"The character content is not a valid value of \0" as *const u8 as *const i8
                        as *mut xmlChar,
                );
            }
            if xmlSchemaIsGlobalItem(type_0) == 0 {
                msg = xmlStrcat(
                    msg,
                    b"the local \0" as *const u8 as *const i8 as *mut xmlChar,
                );
            } else {
                msg = xmlStrcat(msg, b"the \0" as *const u8 as *const i8 as *mut xmlChar);
            }
            if (unsafe { (*type_0).flags }) & (1 as i32) << 8 as i32 != 0 {
                msg = xmlStrcat(
                    msg,
                    b"atomic type\0" as *const u8 as *const i8 as *mut xmlChar,
                );
            } else if (unsafe { (*type_0).flags }) & (1 as i32) << 6 as i32 != 0 {
                msg = xmlStrcat(
                    msg,
                    b"list type\0" as *const u8 as *const i8 as *mut xmlChar,
                );
            } else if (unsafe { (*type_0).flags }) & (1 as i32) << 7 as i32 != 0 {
                msg = xmlStrcat(
                    msg,
                    b"union type\0" as *const u8 as *const i8 as *mut xmlChar,
                );
            }
            if xmlSchemaIsGlobalItem(type_0) != 0 {
                let mut str: *mut u8 = 0 as *mut xmlChar;
                msg = xmlStrcat(msg, b" '\0" as *const u8 as *const i8 as *mut xmlChar);
                if (unsafe { (*type_0).builtInType }) != 0 as i32 {
                    msg = xmlStrcat(msg, b"xs:\0" as *const u8 as *const i8 as *mut xmlChar);
                    str = xmlStrdup(unsafe { (*type_0).name });
                } else {
                    let mut qName: *const u8 = xmlSchemaFormatQName(
                        Some(&mut str),
                        unsafe { (*type_0).targetNamespace },
                        unsafe { (*type_0).name },
                    );
                    if str.is_null() {
                        str = xmlStrdup(qName);
                    }
                }
                msg = xmlStrcat(msg, xmlEscapeFormatString(Some(&mut str)));
                msg = xmlStrcat(msg, b"'.\0" as *const u8 as *const i8 as *mut xmlChar);
                if !str.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                    str = 0 as *mut xmlChar;
                }
            }
        } else if (unsafe { (*node).type_0 }) as u32 == XML_ATTRIBUTE_NODE as i32 as u32 {
            msg = xmlStrcat(
                msg,
                b"The value '%s' is not valid.\0" as *const u8 as *const i8 as *mut xmlChar,
            );
        } else {
            msg = xmlStrcat(
                msg,
                b"The character content is not valid.\0" as *const u8 as *const i8 as *mut xmlChar,
            );
        }
        if !expected.is_null() {
            let mut expectedEscaped: *mut u8 = xmlCharStrdup(expected);
            msg = xmlStrcat(
                msg,
                b" Expected is '\0" as *const u8 as *const i8 as *mut xmlChar,
            );
            msg = xmlStrcat(msg, xmlEscapeFormatString(Some(&mut expectedEscaped)));
            if !expectedEscaped.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(expectedEscaped as *mut libc::c_void) });
                expectedEscaped = 0 as *mut xmlChar;
            }
            msg = xmlStrcat(msg, b"'.\n\0" as *const u8 as *const i8 as *mut xmlChar);
        } else {
            msg = xmlStrcat(msg, b"\n\0" as *const u8 as *const i8 as *mut xmlChar);
        }
        if (unsafe { (*node).type_0 }) as u32 == XML_ATTRIBUTE_NODE as i32 as u32 {
            xmlSchemaPErr(
                ctxt,
                node,
                error as i32,
                msg as *const i8,
                value,
                0 as *const xmlChar,
            );
        } else {
            xmlSchemaPErr(
                ctxt,
                node,
                error as i32,
                msg as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
        }
    } else {
        msg = xmlStrcat(msg, message as *mut xmlChar);
        msg = xmlStrcat(msg, b".\n\0" as *const u8 as *const i8 as *mut xmlChar);
        xmlSchemaPErrExt(
            ctxt,
            node,
            error as i32,
            0 as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
            msg as *const i8,
            str1,
            str2,
            0 as *const xmlChar,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    if !msg.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void) });
        msg = 0 as *mut xmlChar;
    }
}
extern "C" fn xmlSchemaPContentErr<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut error: u32,
    mut ownerItem: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2>,
    mut ownerElem: *mut crate::src::threads::_xmlNode,
    mut child: *mut crate::src::threads::_xmlNode,
    mut message: *const i8,
    mut content: *const i8,
) {
    let mut des: *mut u8 = 0 as *mut xmlChar;
    xmlSchemaFormatItemForReport(Some(&mut des), 0 as *const xmlChar, ownerItem, ownerElem);
    if !message.is_null() {
        xmlSchemaPErr2(
            ctxt,
            ownerElem,
            child,
            error as i32,
            b"%s: %s.\n\0" as *const u8 as *const i8,
            des,
            message as *mut xmlChar,
        );
    } else if !content.is_null() {
        xmlSchemaPErr2(
            ctxt,
            ownerElem,
            child,
            error as i32,
            b"%s: The content is not valid. Expected is %s.\n\0" as *const u8 as *const i8,
            des,
            content as *mut xmlChar,
        );
    } else {
        xmlSchemaPErr2(
            ctxt,
            ownerElem,
            child,
            error as i32,
            b"%s: The content is not valid.\n\0" as *const u8 as *const i8,
            des,
            0 as *const xmlChar,
        );
    }
    if !des.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(des as *mut libc::c_void) });
        des = 0 as *mut xmlChar;
    }
}
extern "C" fn xmlSchemaNewSchema<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
) -> *mut crate::src::xmlschemas::_xmlSchema<'a2> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchema<'_> = 0 as *mut xmlSchema;
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchema>() as u64) })
        as xmlSchemaPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating schema\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchema>() as u64,
    ) });
    let fresh6 = unsafe { &mut ((*ret).dict) };
    *fresh6 = unsafe { (*ctxt).dict };
    (unsafe { xmlDictReference((*ret).dict) });
    return ret;
}
#[no_mangle]
pub extern "C" fn xmlSchemaNewFacet<'a1>() -> *mut crate::src::xmlschemas::_xmlSchemaFacet<'a1> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as *mut xmlSchemaFacet;
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaFacet>() as u64
    ) }) as xmlSchemaFacetPtr;
    if ret.is_null() {
        return 0 as xmlSchemaFacetPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaFacet>() as u64,
    ) });
    return ret;
}
extern "C" fn xmlSchemaNewAnnot<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *mut crate::src::xmlschemas::_xmlSchemaAnnot {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaAnnot = 0 as *mut xmlSchemaAnnot;
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaAnnot>() as u64
    ) }) as xmlSchemaAnnotPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating annotation\0" as *const u8 as *const i8,
            node,
        );
        return 0 as xmlSchemaAnnotPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaAnnot>() as u64,
    ) });
    let fresh7 = unsafe { &mut ((*ret).content) };
    *fresh7 = node;
    return ret;
}
extern "C" fn xmlSchemaItemListCreate() -> *mut crate::src::xmlschemas::_xmlSchemaItemList {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaItemList = 0 as *mut xmlSchemaItemList;
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaItemList>() as u64
    ) }) as xmlSchemaItemListPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating an item list structure\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaItemListPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaItemList>() as u64,
    ) });
    return ret;
}
extern "C" fn xmlSchemaItemListClear(mut list: *mut crate::src::xmlschemas::_xmlSchemaItemList) {
    if !(unsafe { (*list).items }).is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")((*list).items as *mut libc::c_void) });
        let fresh8 = unsafe { &mut ((*list).items) };
        *fresh8 = 0 as *mut *mut libc::c_void;
    }
    (unsafe { (*list).nbItems = 0 as i32 });
    (unsafe { (*list).sizeItems = 0 as i32 });
}
extern "C" fn xmlSchemaItemListAdd(
    mut list: *mut crate::src::xmlschemas::_xmlSchemaItemList,
    mut item: *mut core::ffi::c_void,
) -> i32 {
    if (unsafe { (*list).items }).is_null() {
        let fresh9 = unsafe { &mut ((*list).items) };
        *fresh9 = (unsafe { xmlMalloc.expect("non-null function pointer")(
            (20 as i32 as u64).wrapping_mul(::std::mem::size_of::<*mut libc::c_void>() as u64),
        ) }) as *mut *mut libc::c_void;
        if (unsafe { (*list).items }).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"allocating new item list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
        (unsafe { (*list).sizeItems = 20 as i32 });
    } else if (unsafe { (*list).sizeItems }) <= (unsafe { (*list).nbItems }) {
        (unsafe { (*list).sizeItems *= 2 as i32 });
        let fresh10 = unsafe { &mut ((*list).items) };
        *fresh10 = (unsafe { xmlRealloc.expect("non-null function pointer")(
            (*list).items as *mut libc::c_void,
            ((*list).sizeItems as u64)
                .wrapping_mul(::std::mem::size_of::<*mut libc::c_void>() as u64),
        ) }) as *mut *mut libc::c_void;
        if (unsafe { (*list).items }).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"growing item list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            (unsafe { (*list).sizeItems = 0 as i32 });
            return -(1 as i32);
        }
    }
    let fresh11 = unsafe { &mut ((*list).nbItems) };
    let mut fresh12 = *fresh11;
    *fresh11 = *fresh11 + 1;
    let fresh13 = unsafe { &mut (*((*list).items).offset(fresh12 as isize)) };
    *fresh13 = item;
    return 0 as i32;
}
extern "C" fn xmlSchemaItemListAddSize(
    mut list: *mut crate::src::xmlschemas::_xmlSchemaItemList,
    mut initialSize: i32,
    mut item: *mut core::ffi::c_void,
) -> i32 {
    if (unsafe { (*list).items }).is_null() {
        if initialSize <= 0 as i32 {
            initialSize = 1 as i32;
        }
        let fresh14 = unsafe { &mut ((*list).items) };
        *fresh14 = (unsafe { xmlMalloc.expect("non-null function pointer")(
            (initialSize as u64).wrapping_mul(::std::mem::size_of::<*mut libc::c_void>() as u64),
        ) }) as *mut *mut libc::c_void;
        if (unsafe { (*list).items }).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"allocating new item list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
        (unsafe { (*list).sizeItems = initialSize });
    } else if (unsafe { (*list).sizeItems }) <= (unsafe { (*list).nbItems }) {
        (unsafe { (*list).sizeItems *= 2 as i32 });
        let fresh15 = unsafe { &mut ((*list).items) };
        *fresh15 = (unsafe { xmlRealloc.expect("non-null function pointer")(
            (*list).items as *mut libc::c_void,
            ((*list).sizeItems as u64)
                .wrapping_mul(::std::mem::size_of::<*mut libc::c_void>() as u64),
        ) }) as *mut *mut libc::c_void;
        if (unsafe { (*list).items }).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"growing item list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            (unsafe { (*list).sizeItems = 0 as i32 });
            return -(1 as i32);
        }
    }
    let fresh16 = unsafe { &mut ((*list).nbItems) };
    let mut fresh17 = *fresh16;
    *fresh16 = *fresh16 + 1;
    let fresh18 = unsafe { &mut (*((*list).items).offset(fresh17 as isize)) };
    *fresh18 = item;
    return 0 as i32;
}
extern "C" fn xmlSchemaItemListInsert(
    mut list: *mut crate::src::xmlschemas::_xmlSchemaItemList,
    mut item: *mut core::ffi::c_void,
    mut idx: i32,
) -> i32 {
    if (unsafe { (*list).items }).is_null() {
        let fresh19 = unsafe { &mut ((*list).items) };
        *fresh19 = (unsafe { xmlMalloc.expect("non-null function pointer")(
            (20 as i32 as u64).wrapping_mul(::std::mem::size_of::<*mut libc::c_void>() as u64),
        ) }) as *mut *mut libc::c_void;
        if (unsafe { (*list).items }).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"allocating new item list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
        (unsafe { (*list).sizeItems = 20 as i32 });
    } else if (unsafe { (*list).sizeItems }) <= (unsafe { (*list).nbItems }) {
        (unsafe { (*list).sizeItems *= 2 as i32 });
        let fresh20 = unsafe { &mut ((*list).items) };
        *fresh20 = (unsafe { xmlRealloc.expect("non-null function pointer")(
            (*list).items as *mut libc::c_void,
            ((*list).sizeItems as u64)
                .wrapping_mul(::std::mem::size_of::<*mut libc::c_void>() as u64),
        ) }) as *mut *mut libc::c_void;
        if (unsafe { (*list).items }).is_null() {
            xmlSchemaPErrMemory(
                0 as xmlSchemaParserCtxtPtr,
                b"growing item list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            (unsafe { (*list).sizeItems = 0 as i32 });
            return -(1 as i32);
        }
    }
    if idx >= (unsafe { (*list).nbItems }) {
        let fresh21 = unsafe { &mut ((*list).nbItems) };
        let mut fresh22 = *fresh21;
        *fresh21 = *fresh21 + 1;
        let fresh23 = unsafe { &mut (*((*list).items).offset(fresh22 as isize)) };
        *fresh23 = item;
    } else {
        let mut i: i32 = 0;
        i = unsafe { (*list).nbItems };
        while i > idx {
            let fresh24 = unsafe { &mut (*((*list).items).offset(i as isize)) };
            *fresh24 = unsafe { *((*list).items).offset((i - 1 as i32) as isize) };
            i -= 1;
        }
        let fresh25 = unsafe { &mut (*((*list).items).offset(idx as isize)) };
        *fresh25 = item;
        let fresh26 = unsafe { &mut ((*list).nbItems) };
        *fresh26 += 1;
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaItemListRemove(
    mut list: *mut crate::src::xmlschemas::_xmlSchemaItemList,
    mut idx: i32,
) -> i32 {
    let mut i: i32 = 0;
    if (unsafe { (*list).items }).is_null() || idx >= (unsafe { (*list).nbItems }) {
        xmlSchemaPSimpleErr(
            b"Internal error: xmlSchemaItemListRemove, index error.\n\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    if (unsafe { (*list).nbItems }) == 1 as i32 {
        (unsafe { xmlFree.expect("non-null function pointer")((*list).items as *mut libc::c_void) });
        let fresh27 = unsafe { &mut ((*list).items) };
        *fresh27 = 0 as *mut *mut libc::c_void;
        (unsafe { (*list).nbItems = 0 as i32 });
        (unsafe { (*list).sizeItems = 0 as i32 });
    } else if (unsafe { (*list).nbItems }) - 1 as i32 == idx {
        let fresh28 = unsafe { &mut ((*list).nbItems) };
        *fresh28 -= 1;
    } else {
        i = idx;
        while i < (unsafe { (*list).nbItems }) - 1 as i32 {
            let fresh29 = unsafe { &mut (*((*list).items).offset(i as isize)) };
            *fresh29 = unsafe { *((*list).items).offset((i + 1 as i32) as isize) };
            i += 1;
        }
        let fresh30 = unsafe { &mut ((*list).nbItems) };
        *fresh30 -= 1;
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaItemListFree(mut list: *mut crate::src::xmlschemas::_xmlSchemaItemList) {
    if list.is_null() {
        return;
    }
    if !(unsafe { (*list).items }).is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")((*list).items as *mut libc::c_void) });
    }
    (unsafe { xmlFree.expect("non-null function pointer")(list as *mut libc::c_void) });
}
extern "C" fn xmlSchemaBucketFree(mut bucket: *mut crate::src::xmlschemas::_xmlSchemaBucket) {
    if bucket.is_null() {
        return;
    }
    if !(unsafe { (*bucket).globals }).is_null() {
        xmlSchemaComponentListFree(unsafe { (*bucket).globals });
        xmlSchemaItemListFree(unsafe { (*bucket).globals });
    }
    if !(unsafe { (*bucket).locals }).is_null() {
        xmlSchemaComponentListFree(unsafe { (*bucket).locals });
        xmlSchemaItemListFree(unsafe { (*bucket).locals });
    }
    if !(unsafe { (*bucket).relations }).is_null() {
        let mut prev: *mut crate::src::xmlschemas::_xmlSchemaSchemaRelation =
            0 as *mut xmlSchemaSchemaRelation;
        let mut cur: *mut crate::src::xmlschemas::_xmlSchemaSchemaRelation = unsafe { (*bucket).relations };
        loop {
            prev = cur;
            cur = unsafe { (*cur).next };
            (unsafe { xmlFree.expect("non-null function pointer")(prev as *mut libc::c_void) });
            if cur.is_null() {
                break;
            }
        }
    }
    if (unsafe { (*bucket).preserveDoc }) == 0 && !(unsafe { (*bucket).doc }).is_null() {
        xmlFreeDoc(unsafe { (*bucket).doc });
    }
    if (unsafe { (*bucket).type_0 }) == 1 as i32 {
        if !(unsafe { (*(bucket as xmlSchemaImportPtr)).schema }).is_null() {
            xmlSchemaFree(unsafe { (*(bucket as xmlSchemaImportPtr)).schema });
        }
    }
    (unsafe { xmlFree.expect("non-null function pointer")(bucket as *mut libc::c_void) });
}
extern "C" fn xmlSchemaBucketFreeEntry(mut bucket: *mut core::ffi::c_void, mut _name: *const u8) {
    xmlSchemaBucketFree(bucket as xmlSchemaBucketPtr);
}
extern "C" fn xmlSchemaBucketCreate<'a1>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut type_0: i32,
    mut targetNamespace: *const u8,
) -> *mut crate::src::xmlschemas::_xmlSchemaBucket {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaBucket = 0 as *mut xmlSchemaBucket;
    let mut size: i32 = 0;
    let mut mainSchema: *mut crate::src::xmlschemas::_xmlSchema<'_> = 0 as *mut xmlSchema;
    if (unsafe { (*(*pctxt).constructor).mainSchema }).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaBucketCreate\0" as *const u8 as *const i8,
            b"no main schema on constructor\0" as *const u8 as *const i8,
        );
        return 0 as xmlSchemaBucketPtr;
    }
    mainSchema = unsafe { (*(*pctxt).constructor).mainSchema };
    if type_0 == 2 as i32 || type_0 == 3 as i32 {
        size = ::std::mem::size_of::<xmlSchemaInclude>() as u64 as i32;
    } else {
        size = ::std::mem::size_of::<xmlSchemaImport>() as u64 as i32;
    }
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(size as size_t) }) as xmlSchemaBucketPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating schema bucket\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaBucketPtr;
    }
    (unsafe { memset(ret as *mut libc::c_void, 0 as i32, size as u64) });
    let fresh31 = unsafe { &mut ((*ret).targetNamespace) };
    *fresh31 = targetNamespace;
    (unsafe { (*ret).type_0 = type_0 });
    let fresh32 = unsafe { &mut ((*ret).globals) };
    *fresh32 = xmlSchemaItemListCreate();
    if (unsafe { (*ret).globals }).is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void) });
        return 0 as xmlSchemaBucketPtr;
    }
    let fresh33 = unsafe { &mut ((*ret).locals) };
    *fresh33 = xmlSchemaItemListCreate();
    if (unsafe { (*ret).locals }).is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void) });
        return 0 as xmlSchemaBucketPtr;
    }
    if !(!(unsafe { (*(*pctxt).constructor).buckets }).is_null()
        && (unsafe { (*(*(*pctxt).constructor).buckets).nbItems }) > 0 as i32)
    {
        if type_0 == 2 as i32 || type_0 == 3 as i32 {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaBucketCreate\0" as *const u8 as *const i8,
                b"first bucket but it's an include or redefine\0" as *const u8 as *const i8,
            );
            xmlSchemaBucketFree(ret);
            return 0 as xmlSchemaBucketPtr;
        }
        (unsafe { (*ret).type_0 = 0 as i32 });
        let fresh34 = unsafe { &mut ((*(*pctxt).constructor).mainBucket) };
        *fresh34 = ret;
        let fresh35 = unsafe { &mut ((*(ret as xmlSchemaImportPtr)).schema) };
        *fresh35 = mainSchema;
        let fresh36 = unsafe { &mut ((*mainSchema).targetNamespace) };
        *fresh36 = targetNamespace;
    } else if type_0 == 0 as i32 {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaBucketCreate\0" as *const u8 as *const i8,
            b"main bucket but it's not the first one\0" as *const u8 as *const i8,
        );
        xmlSchemaBucketFree(ret);
        return 0 as xmlSchemaBucketPtr;
    } else {
        if type_0 == 1 as i32 {
            let fresh37 = unsafe { &mut ((*(ret as xmlSchemaImportPtr)).schema) };
            *fresh37 = xmlSchemaNewSchema(pctxt);
            if (unsafe { (*(ret as xmlSchemaImportPtr)).schema }).is_null() {
                xmlSchemaBucketFree(ret);
                return 0 as xmlSchemaBucketPtr;
            }
            let fresh38 = unsafe { &mut ((*(*(ret as xmlSchemaImportPtr)).schema).targetNamespace) };
            *fresh38 = targetNamespace;
        }
    }
    if type_0 == 0 as i32 || type_0 == 1 as i32 {
        let mut res: i32 = 0;
        if (unsafe { (*mainSchema).schemasImports }).is_null() {
            let fresh39 = unsafe { &mut ((*mainSchema).schemasImports) };
            *fresh39 = unsafe { xmlHashCreateDict(5 as i32, (*(*pctxt).constructor).dict) };
            if (unsafe { (*mainSchema).schemasImports }).is_null() {
                xmlSchemaBucketFree(ret);
                return 0 as xmlSchemaBucketPtr;
            }
        }
        if targetNamespace.is_null() {
            res = unsafe { xmlHashAddEntry(
                (*mainSchema).schemasImports,
                b"##\0" as *const u8 as *const i8 as *const xmlChar,
                ret as *mut libc::c_void,
            ) };
        } else {
            res = unsafe { xmlHashAddEntry(
                (*mainSchema).schemasImports,
                targetNamespace,
                ret as *mut libc::c_void,
            ) };
        }
        if res != 0 as i32 {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaBucketCreate\0" as *const u8 as *const i8,
                b"failed to add the schema bucket to the hash\0" as *const u8 as *const i8,
            );
            xmlSchemaBucketFree(ret);
            return 0 as xmlSchemaBucketPtr;
        }
    } else {
        if (unsafe { (*(*(*pctxt).constructor).bucket).type_0 }) == 0 as i32
            || (unsafe { (*(*(*pctxt).constructor).bucket).type_0 }) == 1 as i32
        {
            let fresh40 = unsafe { &mut ((*(ret as xmlSchemaIncludePtr)).ownerImport) };
            *fresh40 = (unsafe { (*(*pctxt).constructor).bucket }) as xmlSchemaImportPtr;
        } else {
            let fresh41 = unsafe { &mut ((*(ret as xmlSchemaIncludePtr)).ownerImport) };
            *fresh41 = unsafe { (*((*(*pctxt).constructor).bucket as xmlSchemaIncludePtr)).ownerImport };
        }
        if (unsafe { (*mainSchema).includes }).is_null() {
            let fresh42 = unsafe { &mut ((*mainSchema).includes) };
            *fresh42 = xmlSchemaItemListCreate() as *mut libc::c_void;
            if (unsafe { (*mainSchema).includes }).is_null() {
                xmlSchemaBucketFree(ret);
                return 0 as xmlSchemaBucketPtr;
            }
        }
        xmlSchemaItemListAdd(
            (unsafe { (*mainSchema).includes }) as xmlSchemaItemListPtr,
            ret as *mut libc::c_void,
        );
    }
    if xmlSchemaItemListAdd(unsafe { (*(*pctxt).constructor).buckets }, ret as *mut libc::c_void)
        == -(1 as i32)
    {
        return 0 as xmlSchemaBucketPtr;
    }
    return ret;
}
extern "C" fn xmlSchemaAddItemSize<'a1>(
    mut list: Option<&'a1 mut *mut crate::src::xmlschemas::_xmlSchemaItemList>,
    mut initialSize: i32,
    mut item: *mut core::ffi::c_void,
) -> i32 {
    if (*(borrow_mut(&mut list)).unwrap()).is_null() {
        *(borrow_mut(&mut list)).unwrap() = xmlSchemaItemListCreate();
        if (*(borrow_mut(&mut list)).unwrap()).is_null() {
            return -(1 as i32);
        }
    }
    xmlSchemaItemListAddSize(*(borrow_mut(&mut list)).unwrap(), initialSize, item);
    return 0 as i32;
}
extern "C" fn xmlSchemaFreeAnnot(mut annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot) {
    if annot.is_null() {
        return;
    }
    if (unsafe { (*annot).next }).is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(annot as *mut libc::c_void) });
    } else {
        let mut prev: *mut crate::src::xmlschemas::_xmlSchemaAnnot = 0 as *mut xmlSchemaAnnot;
        loop {
            prev = annot;
            annot = unsafe { (*annot).next };
            (unsafe { xmlFree.expect("non-null function pointer")(prev as *mut libc::c_void) });
            if annot.is_null() {
                break;
            }
        }
    };
}
extern "C" fn xmlSchemaFreeNotation<'a1>(
    mut nota: *mut crate::src::xmlschemas::_xmlSchemaNotation<'a1>,
) {
    if nota.is_null() {
        return;
    }
    (unsafe { xmlFree.expect("non-null function pointer")(nota as *mut libc::c_void) });
}
extern "C" fn xmlSchemaFreeAttribute<'a1>(
    mut attr: *mut crate::src::xmlschemas::_xmlSchemaAttribute<'a1>,
) {
    if attr.is_null() {
        return;
    }
    if !(unsafe { (*attr).annot }).is_null() {
        xmlSchemaFreeAnnot(unsafe { (*attr).annot });
    }
    if !(unsafe { (*attr).defVal }).is_null() {
        xmlSchemaFreeValue(unsafe { (*attr).defVal });
    }
    (unsafe { xmlFree.expect("non-null function pointer")(attr as *mut libc::c_void) });
}
extern "C" fn xmlSchemaFreeAttributeUse<'a1>(
    mut use_0: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'a1>,
) {
    if use_0.is_null() {
        return;
    }
    if !(unsafe { (*use_0).annot }).is_null() {
        xmlSchemaFreeAnnot(unsafe { (*use_0).annot });
    }
    if !(unsafe { (*use_0).defVal }).is_null() {
        xmlSchemaFreeValue(unsafe { (*use_0).defVal });
    }
    (unsafe { xmlFree.expect("non-null function pointer")(use_0 as *mut libc::c_void) });
}
extern "C" fn xmlSchemaFreeAttributeUseProhib(
    mut prohib: *mut crate::src::xmlschemas::_xmlSchemaAttributeUseProhib,
) {
    if prohib.is_null() {
        return;
    }
    (unsafe { xmlFree.expect("non-null function pointer")(prohib as *mut libc::c_void) });
}
extern "C" fn xmlSchemaFreeWildcardNsSet(
    mut set: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs,
) {
    let mut next: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs = 0 as *mut xmlSchemaWildcardNs;
    while !set.is_null() {
        next = unsafe { (*set).next };
        (unsafe { xmlFree.expect("non-null function pointer")(set as *mut libc::c_void) });
        set = next;
    }
}
#[no_mangle]
pub extern "C" fn xmlSchemaFreeWildcard<'a1>(
    mut wildcard: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a1>,
) {
    if wildcard.is_null() {
        return;
    }
    if !(unsafe { (*wildcard).annot }).is_null() {
        xmlSchemaFreeAnnot(unsafe { (*wildcard).annot });
    }
    if !(unsafe { (*wildcard).nsSet }).is_null() {
        xmlSchemaFreeWildcardNsSet(unsafe { (*wildcard).nsSet });
    }
    if !(unsafe { (*wildcard).negNsSet }).is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")((*wildcard).negNsSet as *mut libc::c_void) });
    }
    (unsafe { xmlFree.expect("non-null function pointer")(wildcard as *mut libc::c_void) });
}
extern "C" fn xmlSchemaFreeAttributeGroup<'a1>(
    mut attrGr: *mut crate::src::xmlschemas::_xmlSchemaAttributeGroup<'a1>,
) {
    if attrGr.is_null() {
        return;
    }
    if !(unsafe { (*attrGr).annot }).is_null() {
        xmlSchemaFreeAnnot(unsafe { (*attrGr).annot });
    }
    if !(unsafe { (*attrGr).attrUses }).is_null() {
        xmlSchemaItemListFree((unsafe { (*attrGr).attrUses }) as xmlSchemaItemListPtr);
    }
    (unsafe { xmlFree.expect("non-null function pointer")(attrGr as *mut libc::c_void) });
}
extern "C" fn xmlSchemaFreeQNameRef<'a1>(
    mut item: *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'a1>,
) {
    (unsafe { xmlFree.expect("non-null function pointer")(item as *mut libc::c_void) });
}
extern "C" fn xmlSchemaFreeTypeLinkList<'a1>(
    mut link: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'a1>,
) {
    let mut next: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'_> = 0 as *mut xmlSchemaTypeLink;
    while !link.is_null() {
        next = unsafe { (*link).next };
        (unsafe { xmlFree.expect("non-null function pointer")(link as *mut libc::c_void) });
        link = next;
    }
}
extern "C" fn xmlSchemaFreeIDCStateObjList<'a1>(
    mut sto: *mut crate::src::xmlschemas::_xmlSchemaIDCStateObj<'a1>,
) {
    let mut next: *mut crate::src::xmlschemas::_xmlSchemaIDCStateObj<'_> =
        0 as *mut xmlSchemaIDCStateObj;
    while !sto.is_null() {
        next = unsafe { (*sto).next };
        if !(unsafe { (*sto).history }).is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")((*sto).history as *mut libc::c_void) });
        }
        if !(unsafe { (*sto).xpathCtxt }).is_null() {
            (unsafe { xmlFreeStreamCtxt((*sto).xpathCtxt as xmlStreamCtxtPtr) });
        }
        (unsafe { xmlFree.expect("non-null function pointer")(sto as *mut libc::c_void) });
        sto = next;
    }
}
extern "C" fn xmlSchemaFreeIDC<'a1>(mut idcDef: *mut crate::src::xmlschemas::_xmlSchemaIDC<'a1>) {
    let mut cur: *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'_> =
        0 as *mut xmlSchemaIDCSelect;
    let mut prev: *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'_> =
        0 as *mut xmlSchemaIDCSelect;
    if idcDef.is_null() {
        return;
    }
    if !(unsafe { (*idcDef).annot }).is_null() {
        xmlSchemaFreeAnnot(unsafe { (*idcDef).annot });
    }
    if !(unsafe { (*idcDef).selector }).is_null() {
        if !(unsafe { (*(*idcDef).selector).xpathComp }).is_null() {
            (unsafe { xmlFreePattern((*(*idcDef).selector).xpathComp as xmlPatternPtr) });
        }
        (unsafe { xmlFree.expect("non-null function pointer")((*idcDef).selector as *mut libc::c_void) });
    }
    if !(unsafe { (*idcDef).fields }).is_null() {
        cur = unsafe { (*idcDef).fields };
        loop {
            prev = cur;
            cur = unsafe { (*cur).next };
            if !(unsafe { (*prev).xpathComp }).is_null() {
                (unsafe { xmlFreePattern((*prev).xpathComp as xmlPatternPtr) });
            }
            (unsafe { xmlFree.expect("non-null function pointer")(prev as *mut libc::c_void) });
            if cur.is_null() {
                break;
            }
        }
    }
    (unsafe { xmlFree.expect("non-null function pointer")(idcDef as *mut libc::c_void) });
}
extern "C" fn xmlSchemaFreeElement<'a1>(
    mut elem: *mut crate::src::xmlschemas::_xmlSchemaElement<'a1>,
) {
    if elem.is_null() {
        return;
    }
    if !(unsafe { (*elem).annot }).is_null() {
        xmlSchemaFreeAnnot(unsafe { (*elem).annot });
    }
    if !(unsafe { (*elem).contModel }).is_null() {
        xmlRegFreeRegexp(unsafe { (*elem).contModel });
    }
    if !(unsafe { (*elem).defVal }).is_null() {
        xmlSchemaFreeValue(unsafe { (*elem).defVal });
    }
    (unsafe { xmlFree.expect("non-null function pointer")(elem as *mut libc::c_void) });
}
#[no_mangle]
pub extern "C" fn xmlSchemaFreeFacet<'a1>(
    mut facet: *mut crate::src::xmlschemas::_xmlSchemaFacet<'a1>,
) {
    if facet.is_null() {
        return;
    }
    if !(unsafe { (*facet).val }).is_null() {
        xmlSchemaFreeValue(unsafe { (*facet).val });
    }
    if !(unsafe { (*facet).regexp }).is_null() {
        xmlRegFreeRegexp(unsafe { (*facet).regexp });
    }
    if !(unsafe { (*facet).annot }).is_null() {
        xmlSchemaFreeAnnot(unsafe { (*facet).annot });
    }
    (unsafe { xmlFree.expect("non-null function pointer")(facet as *mut libc::c_void) });
}
#[no_mangle]
pub extern "C" fn xmlSchemaFreeType<'a1>(
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a1>,
) {
    if type_0.is_null() {
        return;
    }
    if !(unsafe { (*type_0).annot }).is_null() {
        xmlSchemaFreeAnnot(unsafe { (*type_0).annot });
    }
    if !(unsafe { (*type_0).facets }).is_null() {
        let mut facet: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as *mut xmlSchemaFacet;
        let mut next: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as *mut xmlSchemaFacet;
        facet = unsafe { (*type_0).facets };
        while !facet.is_null() {
            next = unsafe { (*facet).next };
            xmlSchemaFreeFacet(facet);
            facet = next;
        }
    }
    if !(unsafe { (*type_0).attrUses }).is_null() {
        xmlSchemaItemListFree((unsafe { (*type_0).attrUses }) as xmlSchemaItemListPtr);
    }
    if !(unsafe { (*type_0).memberTypes }).is_null() {
        xmlSchemaFreeTypeLinkList(unsafe { (*type_0).memberTypes });
    }
    if !(unsafe { (*type_0).facetSet }).is_null() {
        let mut next_0: *mut crate::src::xmlschemas::_xmlSchemaFacetLink<'_> =
            0 as *mut xmlSchemaFacetLink;
        let mut link: *mut crate::src::xmlschemas::_xmlSchemaFacetLink<'_> =
            0 as *mut xmlSchemaFacetLink;
        link = unsafe { (*type_0).facetSet };
        loop {
            next_0 = unsafe { (*link).next };
            (unsafe { xmlFree.expect("non-null function pointer")(link as *mut libc::c_void) });
            link = next_0;
            if link.is_null() {
                break;
            }
        }
    }
    if !(unsafe { (*type_0).contModel }).is_null() {
        xmlRegFreeRegexp(unsafe { (*type_0).contModel });
    }
    (unsafe { xmlFree.expect("non-null function pointer")(type_0 as *mut libc::c_void) });
}
extern "C" fn xmlSchemaFreeModelGroupDef<'a1>(
    mut item: *mut crate::src::xmlschemas::_xmlSchemaModelGroupDef<'a1>,
) {
    if !(unsafe { (*item).annot }).is_null() {
        xmlSchemaFreeAnnot(unsafe { (*item).annot });
    }
    (unsafe { xmlFree.expect("non-null function pointer")(item as *mut libc::c_void) });
}
extern "C" fn xmlSchemaFreeModelGroup<'a1>(
    mut item: *mut crate::src::xmlschemas::_xmlSchemaModelGroup<'a1>,
) {
    if !(unsafe { (*item).annot }).is_null() {
        xmlSchemaFreeAnnot(unsafe { (*item).annot });
    }
    (unsafe { xmlFree.expect("non-null function pointer")(item as *mut libc::c_void) });
}
extern "C" fn xmlSchemaComponentListFree(
    mut list: *mut crate::src::xmlschemas::_xmlSchemaItemList,
) {
    if list.is_null() || (unsafe { (*list).nbItems }) == 0 as i32 {
        return;
    }
    let mut item: *mut crate::src::xmlschemas::_xmlSchemaTreeItem = 0 as *mut xmlSchemaTreeItem;
    let mut items: *mut *mut crate::src::xmlschemas::_xmlSchemaTreeItem =
        (unsafe { (*list).items }) as *mut xmlSchemaTreeItemPtr;
    let mut i: i32 = 0;
    i = 0 as i32;
    while i < (unsafe { (*list).nbItems }) {
        item = unsafe { *items.offset(i as isize) };
        if !item.is_null() {
            match (unsafe { (*item).type_0 }) as u32 {
                4 | 5 => {
                    xmlSchemaFreeType(item as xmlSchemaTypePtr);
                },
                15 => {
                    xmlSchemaFreeAttribute(item as xmlSchemaAttributePtr);
                },
                26 => {
                    xmlSchemaFreeAttributeUse(item as xmlSchemaAttributeUsePtr);
                },
                2001 => {
                    xmlSchemaFreeAttributeUseProhib(item as xmlSchemaAttributeUseProhibPtr);
                },
                14 => {
                    xmlSchemaFreeElement(item as xmlSchemaElementPtr);
                },
                25 => {
                    if !(unsafe { (*item).annot }).is_null() {
                        xmlSchemaFreeAnnot(unsafe { (*item).annot });
                    }
                    (unsafe { xmlFree.expect("non-null function pointer")(item as *mut libc::c_void) });
                },
                6 | 7 | 8 => {
                    xmlSchemaFreeModelGroup(item as xmlSchemaModelGroupPtr);
                },
                16 => {
                    xmlSchemaFreeAttributeGroup(item as xmlSchemaAttributeGroupPtr);
                },
                17 => {
                    xmlSchemaFreeModelGroupDef(item as xmlSchemaModelGroupDefPtr);
                },
                2 | 21 => {
                    xmlSchemaFreeWildcard(item as xmlSchemaWildcardPtr);
                },
                23 | 22 | 24 => {
                    xmlSchemaFreeIDC(item as xmlSchemaIDCPtr);
                },
                18 => {
                    xmlSchemaFreeNotation(item as xmlSchemaNotationPtr);
                },
                2000 => {
                    xmlSchemaFreeQNameRef(item as xmlSchemaQNameRefPtr);
                },
                _ => {
                    xmlSchemaPSimpleInternalErr (0 as xmlNodePtr , b"Internal error: xmlSchemaComponentListFree, unexpected component type '%s'\n\0" as * const u8 as * const i8 , xmlSchemaGetComponentTypeStr (item as xmlSchemaBasicItemPtr) ,) ;
                },
            }
        }
        i += 1;
    }
    (unsafe { (*list).nbItems = 0 as i32 });
}
#[no_mangle]
pub extern "C" fn xmlSchemaFree<'a1>(mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a1>) {
    if schema.is_null() {
        return;
    }
    if !(unsafe { (*schema).volatiles }).is_null() {
        (unsafe { (*__xmlGenericError()).expect("non-null function pointer")(
            *__xmlGenericErrorContext(),
            b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
            b"xmlschemas.c\0" as *const u8 as *const i8,
            4191 as i32,
        ) });
    }
    if !(unsafe { (*schema).notaDecl }).is_null() {
        (unsafe { xmlHashFree((*schema).notaDecl, None) });
    }
    if !(unsafe { (*schema).attrDecl }).is_null() {
        (unsafe { xmlHashFree((*schema).attrDecl, None) });
    }
    if !(unsafe { (*schema).attrgrpDecl }).is_null() {
        (unsafe { xmlHashFree((*schema).attrgrpDecl, None) });
    }
    if !(unsafe { (*schema).elemDecl }).is_null() {
        (unsafe { xmlHashFree((*schema).elemDecl, None) });
    }
    if !(unsafe { (*schema).typeDecl }).is_null() {
        (unsafe { xmlHashFree((*schema).typeDecl, None) });
    }
    if !(unsafe { (*schema).groupDecl }).is_null() {
        (unsafe { xmlHashFree((*schema).groupDecl, None) });
    }
    if !(unsafe { (*schema).idcDef }).is_null() {
        (unsafe { xmlHashFree((*schema).idcDef, None) });
    }
    if !(unsafe { (*schema).schemasImports }).is_null() {
        (unsafe { xmlHashFree((*schema).schemasImports, Some(xmlSchemaBucketFreeEntry)) });
    }
    if !(unsafe { (*schema).includes }).is_null() {
        let mut list: *mut crate::src::xmlschemas::_xmlSchemaItemList =
            (unsafe { (*schema).includes }) as xmlSchemaItemListPtr;
        let mut i: i32 = 0;
        i = 0 as i32;
        while i < (unsafe { (*list).nbItems }) {
            xmlSchemaBucketFree((unsafe { *((*list).items).offset(i as isize) }) as xmlSchemaBucketPtr);
            i += 1;
        }
        xmlSchemaItemListFree(list);
    }
    if !(unsafe { (*schema).annot }).is_null() {
        xmlSchemaFreeAnnot(unsafe { (*schema).annot });
    }
    (unsafe { xmlDictFree((*schema).dict) });
    (unsafe { xmlFree.expect("non-null function pointer")(schema as *mut libc::c_void) });
}
extern "C" fn xmlSchemaElementDump(
    mut payload: *mut core::ffi::c_void,
    mut data: *mut core::ffi::c_void,
    mut _name: *const u8,
    mut namespace: *const u8,
    mut _context: *const u8,
) {
    let mut elem: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> =
        payload as xmlSchemaElementPtr;
    let mut output: *mut crate::src::tree::_IO_FILE = data as *mut FILE;
    if elem.is_null() {
        return;
    }
    (unsafe { fprintf(output, b"Element\0" as *const u8 as *const i8) });
    if (unsafe { (*elem).flags }) & (1 as i32) << 1 as i32 != 0 {
        (unsafe { fprintf(output, b" (global)\0" as *const u8 as *const i8) });
    }
    (unsafe { fprintf(output, b": '%s' \0" as *const u8 as *const i8, (*elem).name) });
    if !namespace.is_null() {
        (unsafe { fprintf(output, b"ns '%s'\0" as *const u8 as *const i8, namespace) });
    }
    (unsafe { fprintf(output, b"\n\0" as *const u8 as *const i8) });
    if (unsafe { (*elem).flags }) & (1 as i32) << 0 as i32 != 0
        || (unsafe { (*elem).flags }) & (1 as i32) << 4 as i32 != 0
        || (unsafe { (*elem).flags }) & (1 as i32) << 3 as i32 != 0
        || (unsafe { (*elem).flags }) & (1 as i32) << 2 as i32 != 0
    {
        (unsafe { fprintf(output, b"  props: \0" as *const u8 as *const i8) });
        if (unsafe { (*elem).flags }) & (1 as i32) << 3 as i32 != 0 {
            (unsafe { fprintf(output, b"[fixed] \0" as *const u8 as *const i8) });
        }
        if (unsafe { (*elem).flags }) & (1 as i32) << 2 as i32 != 0 {
            (unsafe { fprintf(output, b"[default] \0" as *const u8 as *const i8) });
        }
        if (unsafe { (*elem).flags }) & (1 as i32) << 4 as i32 != 0 {
            (unsafe { fprintf(output, b"[abstract] \0" as *const u8 as *const i8) });
        }
        if (unsafe { (*elem).flags }) & (1 as i32) << 0 as i32 != 0 {
            (unsafe { fprintf(output, b"[nillable] \0" as *const u8 as *const i8) });
        }
        (unsafe { fprintf(output, b"\n\0" as *const u8 as *const i8) });
    }
    if !(unsafe { (*elem).value }).is_null() {
        (unsafe { fprintf(
            output,
            b"  value: '%s'\n\0" as *const u8 as *const i8,
            (*elem).value,
        ) });
    }
    if !(unsafe { (*elem).namedType }).is_null() {
        (unsafe { fprintf(
            output,
            b"  type: '%s' \0" as *const u8 as *const i8,
            (*elem).namedType,
        ) });
        if !(unsafe { (*elem).namedTypeNs }).is_null() {
            (unsafe { fprintf(
                output,
                b"ns '%s'\n\0" as *const u8 as *const i8,
                (*elem).namedTypeNs,
            ) });
        } else {
            (unsafe { fprintf(output, b"\n\0" as *const u8 as *const i8) });
        }
    } else if !(unsafe { (*elem).subtypes }).is_null() {
        xmlSchemaTypeDump(unsafe { (*elem).subtypes }, output);
    }
    if !(unsafe { (*elem).substGroup }).is_null() {
        (unsafe { fprintf(
            output,
            b"  substitutionGroup: '%s' \0" as *const u8 as *const i8,
            (*elem).substGroup,
        ) });
        if !(unsafe { (*elem).substGroupNs }).is_null() {
            (unsafe { fprintf(
                output,
                b"ns '%s'\n\0" as *const u8 as *const i8,
                (*elem).substGroupNs,
            ) });
        } else {
            (unsafe { fprintf(output, b"\n\0" as *const u8 as *const i8) });
        }
    }
}
extern "C" fn xmlSchemaAnnotDump(
    mut output: *mut crate::src::tree::_IO_FILE,
    mut annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
) {
    let mut content: *mut u8 = 0 as *mut xmlChar;
    if annot.is_null() {
        return;
    }
    content = xmlNodeGetContent((unsafe { (*annot).content }) as *const xmlNode);
    if !content.is_null() {
        (unsafe { fprintf(
            output,
            b"  Annot: %s\n\0" as *const u8 as *const i8,
            content,
        ) });
        (unsafe { xmlFree.expect("non-null function pointer")(content as *mut libc::c_void) });
    } else {
        (unsafe { fprintf(output, b"  Annot: empty\n\0" as *const u8 as *const i8) });
    };
}
extern "C" fn xmlSchemaContentModelDump(
    mut particle: *mut crate::src::xmlschemas::_xmlSchemaParticle,
    mut output: *mut crate::src::tree::_IO_FILE,
    mut depth: i32,
) {
    let mut str: *mut u8 = 0 as *mut xmlChar;
    let mut term: *mut crate::src::xmlschemas::_xmlSchemaTreeItem = 0 as *mut xmlSchemaTreeItem;
    let mut shift: [i8; 100] = [0; 100];
    let mut i: i32 = 0;
    if particle.is_null() {
        return;
    }
    i = 0 as i32;
    while i < depth && i < 25 as i32 {
        shift[(2 as i32 * i + 1 as i32) as usize] = ' ' as i32 as i8;
        shift[(2 as i32 * i) as usize] = shift[(2 as i32 * i + 1 as i32) as usize];
        i += 1;
    }
    shift[(2 as i32 * i + 1 as i32) as usize] = 0 as i32 as i8;
    shift[(2 as i32 * i) as usize] = shift[(2 as i32 * i + 1 as i32) as usize];
    (unsafe { fprintf(
        output,
        b"%s\0" as *const u8 as *const i8,
        shift.as_mut_ptr(),
    ) });
    if (unsafe { (*particle).children }).is_null() {
        (unsafe { fprintf(
            output,
            b"MISSING particle term\n\0" as *const u8 as *const i8,
        ) });
        return;
    }
    term = unsafe { (*particle).children };
    if term.is_null() {
        (unsafe { fprintf(output, b"(NULL)\0" as *const u8 as *const i8) });
    } else {
        match (unsafe { (*term).type_0 }) as u32 {
            14 => {
                (unsafe { fprintf(
                    output,
                    b"ELEM '%s'\0" as *const u8 as *const i8,
                    xmlSchemaFormatQName(
                        Some(&mut str),
                        (*(term as xmlSchemaElementPtr)).targetNamespace,
                        (*(term as xmlSchemaElementPtr)).name,
                    ),
                ) });
                if !str.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                    str = 0 as *mut xmlChar;
                }
            },
            6 => {
                (unsafe { fprintf(output, b"SEQUENCE\0" as *const u8 as *const i8) });
            },
            7 => {
                (unsafe { fprintf(output, b"CHOICE\0" as *const u8 as *const i8) });
            },
            8 => {
                (unsafe { fprintf(output, b"ALL\0" as *const u8 as *const i8) });
            },
            2 => {
                (unsafe { fprintf(output, b"ANY\0" as *const u8 as *const i8) });
            },
            _ => {
                (unsafe { fprintf(output, b"UNKNOWN\n\0" as *const u8 as *const i8) });
                return;
            },
        }
    }
    if (unsafe { (*particle).minOccurs }) != 1 as i32 {
        (unsafe { fprintf(
            output,
            b" min: %d\0" as *const u8 as *const i8,
            (*particle).minOccurs,
        ) });
    }
    if (unsafe { (*particle).maxOccurs }) >= (1 as i32) << 30 as i32 {
        (unsafe { fprintf(output, b" max: unbounded\0" as *const u8 as *const i8) });
    } else if (unsafe { (*particle).maxOccurs }) != 1 as i32 {
        (unsafe { fprintf(
            output,
            b" max: %d\0" as *const u8 as *const i8,
            (*particle).maxOccurs,
        ) });
    }
    (unsafe { fprintf(output, b"\n\0" as *const u8 as *const i8) });
    if !term.is_null()
        && ((unsafe { (*term).type_0 }) as u32 == XML_SCHEMA_TYPE_SEQUENCE as i32 as u32
            || (unsafe { (*term).type_0 }) as u32 == XML_SCHEMA_TYPE_CHOICE as i32 as u32
            || (unsafe { (*term).type_0 }) as u32 == XML_SCHEMA_TYPE_ALL as i32 as u32)
        && !(unsafe { (*term).children }).is_null()
    {
        xmlSchemaContentModelDump(
            (unsafe { (*term).children }) as xmlSchemaParticlePtr,
            output,
            depth + 1 as i32,
        );
    }
    if !(unsafe { (*particle).next }).is_null() {
        xmlSchemaContentModelDump((unsafe { (*particle).next }) as xmlSchemaParticlePtr, output, depth);
    }
}
extern "C" fn xmlSchemaAttrUsesDump(
    mut uses: *mut crate::src::xmlschemas::_xmlSchemaItemList,
    mut output: *mut crate::src::tree::_IO_FILE,
) {
    let mut use_0: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_> =
        0 as *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_>;
    let mut prohib: *mut crate::src::xmlschemas::_xmlSchemaAttributeUseProhib =
        0 as *mut crate::src::xmlschemas::_xmlSchemaAttributeUseProhib;
    let mut ref_0: *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'_> =
        0 as *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'_>;
    let mut name: *const u8 = 0 as *const xmlChar;
    let mut tns: *const u8 = 0 as *const xmlChar;
    let mut str: *mut u8 = 0 as *mut xmlChar;
    let mut i: i32 = 0;
    if uses.is_null() || (unsafe { (*uses).nbItems }) == 0 as i32 {
        return;
    }
    (unsafe { fprintf(output, b"  attributes:\n\0" as *const u8 as *const i8) });
    i = 0 as i32;
    while i < (unsafe { (*uses).nbItems }) {
        use_0 = (unsafe { *((*uses).items).offset(i as isize) }) as xmlSchemaAttributeUsePtr;
        if (unsafe { (*use_0).type_0 }) as u32 == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB as i32 as u32 {
            (unsafe { fprintf(output, b"  [prohibition] \0" as *const u8 as *const i8) });
            prohib = use_0 as xmlSchemaAttributeUseProhibPtr;
            name = unsafe { (*prohib).name };
            tns = unsafe { (*prohib).targetNamespace };
        } else if (unsafe { (*use_0).type_0 }) as u32 == XML_SCHEMA_EXTRA_QNAMEREF as i32 as u32 {
            (unsafe { fprintf(output, b"  [reference] \0" as *const u8 as *const i8) });
            ref_0 = use_0 as xmlSchemaQNameRefPtr;
            name = unsafe { (*ref_0).name };
            tns = unsafe { (*ref_0).targetNamespace };
        } else {
            (unsafe { fprintf(output, b"  [use] \0" as *const u8 as *const i8) });
            name = unsafe { (*(*use_0).attrDecl).name };
            tns = unsafe { (*(*use_0).attrDecl).targetNamespace };
        }
        (unsafe { fprintf(
            output,
            b"'%s'\n\0" as *const u8 as *const i8,
            xmlSchemaFormatQName(Some(&mut str), tns, name) as *const i8,
        ) });
        if !str.is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
            str = 0 as *mut xmlChar;
        }
        i += 1;
    }
}
extern "C" fn xmlSchemaTypeDump<'a1>(
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a1>,
    mut output: *mut crate::src::tree::_IO_FILE,
) {
    if type_0.is_null() {
        (unsafe { fprintf(output, b"Type: NULL\n\0" as *const u8 as *const i8) });
        return;
    }
    (unsafe { fprintf(output, b"Type: \0" as *const u8 as *const i8) });
    if !(unsafe { (*type_0).name }).is_null() {
        (unsafe { fprintf(output, b"'%s' \0" as *const u8 as *const i8, (*type_0).name) });
    } else {
        (unsafe { fprintf(output, b"(no name) \0" as *const u8 as *const i8) });
    }
    if !(unsafe { (*type_0).targetNamespace }).is_null() {
        (unsafe { fprintf(
            output,
            b"ns '%s' \0" as *const u8 as *const i8,
            (*type_0).targetNamespace,
        ) });
    }
    match (unsafe { (*type_0).type_0 }) as u32 {
        1 => {
            (unsafe { fprintf(output, b"[basic] \0" as *const u8 as *const i8) });
        },
        4 => {
            (unsafe { fprintf(output, b"[simple] \0" as *const u8 as *const i8) });
        },
        5 => {
            (unsafe { fprintf(output, b"[complex] \0" as *const u8 as *const i8) });
        },
        6 => {
            (unsafe { fprintf(output, b"[sequence] \0" as *const u8 as *const i8) });
        },
        7 => {
            (unsafe { fprintf(output, b"[choice] \0" as *const u8 as *const i8) });
        },
        8 => {
            (unsafe { fprintf(output, b"[all] \0" as *const u8 as *const i8) });
        },
        11 => {
            (unsafe { fprintf(output, b"[ur] \0" as *const u8 as *const i8) });
        },
        12 => {
            (unsafe { fprintf(output, b"[restriction] \0" as *const u8 as *const i8) });
        },
        13 => {
            (unsafe { fprintf(output, b"[extension] \0" as *const u8 as *const i8) });
        },
        _ => {
            (unsafe { fprintf(
                output,
                b"[unknown type %d] \0" as *const u8 as *const i8,
                (*type_0).type_0 as u32,
            ) });
        },
    }
    (unsafe { fprintf(output, b"content: \0" as *const u8 as *const i8) });
    match (unsafe { (*type_0).contentType }) as u32 {
        0 => {
            (unsafe { fprintf(output, b"[unknown] \0" as *const u8 as *const i8) });
        },
        1 => {
            (unsafe { fprintf(output, b"[empty] \0" as *const u8 as *const i8) });
        },
        2 => {
            (unsafe { fprintf(output, b"[element] \0" as *const u8 as *const i8) });
        },
        3 => {
            (unsafe { fprintf(output, b"[mixed] \0" as *const u8 as *const i8) });
        },
        6 => {
            (unsafe { fprintf(output, b"[basic] \0" as *const u8 as *const i8) });
        },
        4 => {
            (unsafe { fprintf(output, b"[simple] \0" as *const u8 as *const i8) });
        },
        7 => {
            (unsafe { fprintf(output, b"[any] \0" as *const u8 as *const i8) });
        },
        5 | _ => {},
    }
    (unsafe { fprintf(output, b"\n\0" as *const u8 as *const i8) });
    if !(unsafe { (*type_0).base }).is_null() {
        (unsafe { fprintf(
            output,
            b"  base type: '%s'\0" as *const u8 as *const i8,
            (*type_0).base,
        ) });
        if !(unsafe { (*type_0).baseNs }).is_null() {
            (unsafe { fprintf(
                output,
                b" ns '%s'\n\0" as *const u8 as *const i8,
                (*type_0).baseNs,
            ) });
        } else {
            (unsafe { fprintf(output, b"\n\0" as *const u8 as *const i8) });
        }
    }
    if !(unsafe { (*type_0).attrUses }).is_null() {
        xmlSchemaAttrUsesDump((unsafe { (*type_0).attrUses }) as xmlSchemaItemListPtr, output);
    }
    if !(unsafe { (*type_0).annot }).is_null() {
        xmlSchemaAnnotDump(output, unsafe { (*type_0).annot });
    }
    if (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        && !(unsafe { (*type_0).subtypes }).is_null()
    {
        xmlSchemaContentModelDump((unsafe { (*type_0).subtypes }) as xmlSchemaParticlePtr, output, 1 as i32);
    }
}
extern "C" fn xmlSchemaTypeDumpEntry(
    mut type_0: *mut core::ffi::c_void,
    mut output: *mut core::ffi::c_void,
    mut _name: *const u8,
) {
    xmlSchemaTypeDump(type_0 as xmlSchemaTypePtr, output as *mut FILE);
}
#[no_mangle]
pub extern "C" fn xmlSchemaDump<'a1, 'a2>(
    mut output: *mut crate::src::tree::_IO_FILE,
    mut schema: Option<&'a1 mut crate::src::xmlschemas::_xmlSchema<'a2>>,
) {
    if output.is_null() {
        return;
    }
    if borrow(&schema).is_none() {
        (unsafe { fprintf(output, b"Schemas: NULL\n\0" as *const u8 as *const i8) });
        return;
    }
    (unsafe { fprintf(output, b"Schemas: \0" as *const u8 as *const i8) });
    if !((*(borrow_mut(&mut schema)).unwrap()).name).is_null() {
        (unsafe { fprintf(
            output,
            b"%s, \0" as *const u8 as *const i8,
            (*(borrow(&schema)).unwrap()).name,
        ) });
    } else {
        (unsafe { fprintf(output, b"no name, \0" as *const u8 as *const i8) });
    }
    if !((*(borrow_mut(&mut schema)).unwrap()).targetNamespace).is_null() {
        (unsafe { fprintf(
            output,
            b"%s\0" as *const u8 as *const i8,
            (*(borrow(&schema)).unwrap()).targetNamespace as *const i8,
        ) });
    } else {
        (unsafe { fprintf(output, b"no target namespace\0" as *const u8 as *const i8) });
    }
    (unsafe { fprintf(output, b"\n\0" as *const u8 as *const i8) });
    if !((*(borrow_mut(&mut schema)).unwrap()).annot).is_null() {
        xmlSchemaAnnotDump(output, (*(borrow_mut(&mut schema)).unwrap()).annot);
    }
    (unsafe { xmlHashScan(
        (*(borrow_mut(&mut schema)).unwrap()).typeDecl,
        Some(xmlSchemaTypeDumpEntry),
        output as *mut libc::c_void,
    ) });
    (unsafe { xmlHashScanFull(
        (*(borrow_mut(&mut schema)).unwrap()).elemDecl,
        Some(xmlSchemaElementDump),
        output as *mut libc::c_void,
    ) });
}
extern "C" fn xmlSchemaGetPropNode(
    mut node: *mut crate::src::threads::_xmlNode,
    mut name: *const i8,
) -> *mut crate::src::threads::_xmlAttr {
    let mut prop: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    if node.is_null() || name.is_null() {
        return 0 as xmlAttrPtr;
    }
    prop = unsafe { (*node).properties };
    while !prop.is_null() {
        if (unsafe { (*prop).ns }).is_null() && xmlStrEqual(unsafe { (*prop).name }, name as *mut xmlChar) != 0 {
            return prop;
        }
        prop = unsafe { (*prop).next };
    }
    return 0 as xmlAttrPtr;
}
extern "C" fn xmlSchemaGetPropNodeNs(
    mut node: *mut crate::src::threads::_xmlNode,
    mut uri: *const i8,
    mut name: *const i8,
) -> *mut crate::src::threads::_xmlAttr {
    let mut prop: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    if node.is_null() || name.is_null() {
        return 0 as xmlAttrPtr;
    }
    prop = unsafe { (*node).properties };
    while !prop.is_null() {
        if !(unsafe { (*prop).ns }).is_null()
            && xmlStrEqual(unsafe { (*prop).name }, name as *mut xmlChar) != 0
            && xmlStrEqual(unsafe { (*(*prop).ns).href }, uri as *mut xmlChar) != 0
        {
            return prop;
        }
        prop = unsafe { (*prop).next };
    }
    return 0 as xmlAttrPtr;
}
extern "C" fn xmlSchemaGetNodeContent<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *const u8 {
    let mut val: *mut u8 = 0 as *mut xmlChar;
    let mut ret: *const u8 = 0 as *const xmlChar;
    val = xmlNodeGetContent(node as *const xmlNode);
    if val.is_null() {
        val = xmlStrdup(b"\0" as *const u8 as *const i8 as *mut xmlChar);
    }
    ret = unsafe { xmlDictLookup((*ctxt).dict, val, -(1 as i32)) };
    (unsafe { xmlFree.expect("non-null function pointer")(val as *mut libc::c_void) });
    return ret;
}
extern "C" fn xmlSchemaGetNodeContentNoDict(
    mut node: *mut crate::src::threads::_xmlNode,
) -> *const u8 {
    return xmlNodeGetContent(node as *const xmlNode) as *const xmlChar;
}
extern "C" fn xmlSchemaGetProp<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut name: *const i8,
) -> *const u8 {
    let mut val: *mut u8 = 0 as *mut xmlChar;
    let mut ret: *const u8 = 0 as *const xmlChar;
    val = xmlGetNoNsProp(node as *const xmlNode, name as *mut xmlChar);
    if val.is_null() {
        return 0 as *const xmlChar;
    }
    ret = unsafe { xmlDictLookup((*ctxt).dict, val, -(1 as i32)) };
    (unsafe { xmlFree.expect("non-null function pointer")(val as *mut libc::c_void) });
    return ret;
}
extern "C" fn xmlSchemaGetElem<'a1, 'a2>(
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a1>,
    mut name: *const u8,
    mut nsName: *const u8,
) -> *mut crate::src::xmlschemas::_xmlSchemaElement<'a2> {
    let mut current_block: u64;
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> = 0 as xmlSchemaElementPtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaElementPtr;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, unsafe { (*schema).targetNamespace }) != 0 {
            ret = (unsafe { xmlHashLookup((*schema).elemDecl, name) }) as xmlSchemaElementPtr;
            if !ret.is_null() {
                current_block = 16011728522843784008;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            16011728522843784008 => {},
            _ => {
                if (unsafe { xmlHashSize((*schema).schemasImports) }) > 1 as i32 {
                    let mut import: *mut crate::src::xmlschemas::_xmlSchemaImport<'_> =
                        0 as *mut crate::src::xmlschemas::_xmlSchemaImport<'_>;
                    if nsName.is_null() {
                        import = (unsafe { xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const i8 as *const xmlChar,
                        ) }) as xmlSchemaImportPtr;
                    } else {
                        import =
                            (unsafe { xmlHashLookup((*schema).schemasImports, nsName) }) as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = (unsafe { xmlHashLookup((*(*import).schema).elemDecl, name) })
                            as xmlSchemaElementPtr;
                    }
                }
            },
        }
    }
    return ret;
}
extern "C" fn xmlSchemaGetType<'a1, 'a2>(
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a1>,
    mut name: *const u8,
    mut nsName: *const u8,
) -> *mut crate::src::xmlschemas::_xmlSchemaType<'a2> {
    let mut current_block: u64;
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as xmlSchemaTypePtr;
    if name.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    if !nsName.is_null() && xmlStrEqual(nsName, unsafe { xmlSchemaNs }) != 0 {
        ret = xmlSchemaGetPredefinedType(name, nsName);
        if !ret.is_null() {
            current_block = 7386887182042359627;
        } else {
            current_block = 15427931788582360902;
        }
    } else {
        current_block = 15427931788582360902;
    }
    match current_block {
        15427931788582360902 => {
            if !schema.is_null() {
                if xmlStrEqual(nsName, unsafe { (*schema).targetNamespace }) != 0 {
                    ret = (unsafe { xmlHashLookup((*schema).typeDecl, name) }) as xmlSchemaTypePtr;
                    if !ret.is_null() {
                        current_block = 7386887182042359627;
                    } else {
                        current_block = 11812396948646013369;
                    }
                } else {
                    current_block = 11812396948646013369;
                }
                match current_block {
                    7386887182042359627 => {},
                    _ => {
                        if (unsafe { xmlHashSize((*schema).schemasImports) }) > 1 as i32 {
                            let mut import: *mut crate::src::xmlschemas::_xmlSchemaImport<'_> =
                                0 as *mut crate::src::xmlschemas::_xmlSchemaImport<'_>;
                            if nsName.is_null() {
                                import = (unsafe { xmlHashLookup(
                                    (*schema).schemasImports,
                                    b"##\0" as *const u8 as *const i8 as *const xmlChar,
                                ) }) as xmlSchemaImportPtr;
                            } else {
                                import = (unsafe { xmlHashLookup((*schema).schemasImports, nsName) })
                                    as xmlSchemaImportPtr;
                            }
                            if !import.is_null() {
                                ret = (unsafe { xmlHashLookup((*(*import).schema).typeDecl, name) })
                                    as xmlSchemaTypePtr;
                            }
                        }
                    },
                }
            }
        },
        _ => {},
    }
    return ret;
}
extern "C" fn xmlSchemaGetAttributeDecl<'a1, 'a2>(
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a1>,
    mut name: *const u8,
    mut nsName: *const u8,
) -> *mut crate::src::xmlschemas::_xmlSchemaAttribute<'a2> {
    let mut current_block: u64;
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaAttribute<'_> = 0 as xmlSchemaAttributePtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaAttributePtr;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, unsafe { (*schema).targetNamespace }) != 0 {
            ret = (unsafe { xmlHashLookup((*schema).attrDecl, name) }) as xmlSchemaAttributePtr;
            if !ret.is_null() {
                current_block = 16794065014550217599;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            16794065014550217599 => {},
            _ => {
                if (unsafe { xmlHashSize((*schema).schemasImports) }) > 1 as i32 {
                    let mut import: *mut crate::src::xmlschemas::_xmlSchemaImport<'_> =
                        0 as *mut crate::src::xmlschemas::_xmlSchemaImport<'_>;
                    if nsName.is_null() {
                        import = (unsafe { xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const i8 as *const xmlChar,
                        ) }) as xmlSchemaImportPtr;
                    } else {
                        import =
                            (unsafe { xmlHashLookup((*schema).schemasImports, nsName) }) as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = (unsafe { xmlHashLookup((*(*import).schema).attrDecl, name) })
                            as xmlSchemaAttributePtr;
                    }
                }
            },
        }
    }
    return ret;
}
extern "C" fn xmlSchemaGetAttributeGroup<'a1, 'a2>(
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a1>,
    mut name: *const u8,
    mut nsName: *const u8,
) -> *mut crate::src::xmlschemas::_xmlSchemaAttributeGroup<'a2> {
    let mut current_block: u64;
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaAttributeGroup<'_> =
        0 as xmlSchemaAttributeGroupPtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, unsafe { (*schema).targetNamespace }) != 0 {
            ret = (unsafe { xmlHashLookup((*schema).attrgrpDecl, name) }) as xmlSchemaAttributeGroupPtr;
            if !ret.is_null() {
                current_block = 16237746940514357066;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            16237746940514357066 => {},
            _ => {
                if (unsafe { xmlHashSize((*schema).schemasImports) }) > 1 as i32 {
                    let mut import: *mut crate::src::xmlschemas::_xmlSchemaImport<'_> =
                        0 as *mut crate::src::xmlschemas::_xmlSchemaImport<'_>;
                    if nsName.is_null() {
                        import = (unsafe { xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const i8 as *const xmlChar,
                        ) }) as xmlSchemaImportPtr;
                    } else {
                        import =
                            (unsafe { xmlHashLookup((*schema).schemasImports, nsName) }) as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = (unsafe { xmlHashLookup((*(*import).schema).attrgrpDecl, name) })
                            as xmlSchemaAttributeGroupPtr;
                    }
                }
            },
        }
    }
    return ret;
}
extern "C" fn xmlSchemaGetGroup<'a1, 'a2>(
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a1>,
    mut name: *const u8,
    mut nsName: *const u8,
) -> *mut crate::src::xmlschemas::_xmlSchemaModelGroupDef<'a2> {
    let mut current_block: u64;
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaModelGroupDef<'_> =
        0 as xmlSchemaModelGroupDefPtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaModelGroupDefPtr;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, unsafe { (*schema).targetNamespace }) != 0 {
            ret = (unsafe { xmlHashLookup((*schema).groupDecl, name) }) as xmlSchemaModelGroupDefPtr;
            if !ret.is_null() {
                current_block = 13643637003490791894;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            13643637003490791894 => {},
            _ => {
                if (unsafe { xmlHashSize((*schema).schemasImports) }) > 1 as i32 {
                    let mut import: *mut crate::src::xmlschemas::_xmlSchemaImport<'_> =
                        0 as *mut crate::src::xmlschemas::_xmlSchemaImport<'_>;
                    if nsName.is_null() {
                        import = (unsafe { xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const i8 as *const xmlChar,
                        ) }) as xmlSchemaImportPtr;
                    } else {
                        import =
                            (unsafe { xmlHashLookup((*schema).schemasImports, nsName) }) as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = (unsafe { xmlHashLookup((*(*import).schema).groupDecl, name) })
                            as xmlSchemaModelGroupDefPtr;
                    }
                }
            },
        }
    }
    return ret;
}
extern "C" fn xmlSchemaGetNotation<'a1, 'a2>(
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a1>,
    mut name: *const u8,
    mut nsName: *const u8,
) -> *mut crate::src::xmlschemas::_xmlSchemaNotation<'a2> {
    let mut current_block: u64;
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaNotation<'_> =
        0 as *mut crate::src::xmlschemas::_xmlSchemaNotation<'_>;
    if name.is_null() || schema.is_null() {
        return 0 as *mut crate::src::xmlschemas::_xmlSchemaNotation<'_>;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, unsafe { (*schema).targetNamespace }) != 0 {
            ret = (unsafe { xmlHashLookup((*schema).notaDecl, name) }) as xmlSchemaNotationPtr;
            if !ret.is_null() {
                current_block = 16231198170495011546;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            16231198170495011546 => {},
            _ => {
                if (unsafe { xmlHashSize((*schema).schemasImports) }) > 1 as i32 {
                    let mut import: *mut crate::src::xmlschemas::_xmlSchemaImport<'_> =
                        0 as *mut crate::src::xmlschemas::_xmlSchemaImport<'_>;
                    if nsName.is_null() {
                        import = (unsafe { xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const i8 as *const xmlChar,
                        ) }) as xmlSchemaImportPtr;
                    } else {
                        import =
                            (unsafe { xmlHashLookup((*schema).schemasImports, nsName) }) as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = (unsafe { xmlHashLookup((*(*import).schema).notaDecl, name) })
                            as xmlSchemaNotationPtr;
                    }
                }
            },
        }
    }
    return ret;
}
extern "C" fn xmlSchemaGetIDC<'a1, 'a2>(
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a1>,
    mut name: *const u8,
    mut nsName: *const u8,
) -> *mut crate::src::xmlschemas::_xmlSchemaIDC<'a2> {
    let mut current_block: u64;
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaIDC<'_> = 0 as xmlSchemaIDCPtr;
    if name.is_null() || schema.is_null() {
        return 0 as xmlSchemaIDCPtr;
    }
    if !schema.is_null() {
        if xmlStrEqual(nsName, unsafe { (*schema).targetNamespace }) != 0 {
            ret = (unsafe { xmlHashLookup((*schema).idcDef, name) }) as xmlSchemaIDCPtr;
            if !ret.is_null() {
                current_block = 6863404656786974296;
            } else {
                current_block = 6483416627284290920;
            }
        } else {
            current_block = 6483416627284290920;
        }
        match current_block {
            6863404656786974296 => {},
            _ => {
                if (unsafe { xmlHashSize((*schema).schemasImports) }) > 1 as i32 {
                    let mut import: *mut crate::src::xmlschemas::_xmlSchemaImport<'_> =
                        0 as *mut crate::src::xmlschemas::_xmlSchemaImport<'_>;
                    if nsName.is_null() {
                        import = (unsafe { xmlHashLookup(
                            (*schema).schemasImports,
                            b"##\0" as *const u8 as *const i8 as *const xmlChar,
                        ) }) as xmlSchemaImportPtr;
                    } else {
                        import =
                            (unsafe { xmlHashLookup((*schema).schemasImports, nsName) }) as xmlSchemaImportPtr;
                    }
                    if !import.is_null() {
                        ret = (unsafe { xmlHashLookup((*(*import).schema).idcDef, name) }) as xmlSchemaIDCPtr;
                    }
                }
            },
        }
    }
    return ret;
}
extern "C" fn xmlSchemaGetNamedComponent<'a1, 'a2>(
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a1>,
    mut itemType: u32,
    mut name: *const u8,
    mut targetNs: *const u8,
) -> *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2> {
    match itemType as u32 {
        17 => return xmlSchemaGetGroup(schema, name, targetNs) as xmlSchemaBasicItemPtr,
        14 => return xmlSchemaGetElem(schema, name, targetNs) as xmlSchemaBasicItemPtr,
        _ => {
            (unsafe { (*__xmlGenericError()).expect("non-null function pointer")(
                *__xmlGenericErrorContext(),
                b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
                b"xmlschemas.c\0" as *const u8 as *const i8,
                5063 as i32,
            ) });
            return 0 as xmlSchemaBasicItemPtr;
        },
    };
}
extern "C" fn xmlSchemaIsBlank(mut str: *mut u8, mut len: i32) -> i32 {
    if str.is_null() {
        return 1 as i32;
    }
    if len < 0 as i32 {
        while (unsafe { *str }) as i32 != 0 as i32 {
            if !((unsafe { *str }) as i32 == 0x20 as i32
                || 0x9 as i32 <= (unsafe { *str }) as i32 && (unsafe { *str }) as i32 <= 0xa as i32
                || (unsafe { *str }) as i32 == 0xd as i32)
            {
                return 0 as i32;
            }
            str = unsafe { str.offset(1) };
        }
    } else {
        while (unsafe { *str }) as i32 != 0 as i32 && len != 0 as i32 {
            if !((unsafe { *str }) as i32 == 0x20 as i32
                || 0x9 as i32 <= (unsafe { *str }) as i32 && (unsafe { *str }) as i32 <= 0xa as i32
                || (unsafe { *str }) as i32 == 0xd as i32)
            {
                return 0 as i32;
            }
            str = unsafe { str.offset(1) };
            len -= 1;
        }
    }
    return 1 as i32;
}
extern "C" fn xmlSchemaFindRedefCompInGraph<'a1>(
    mut bucket: *mut crate::src::xmlschemas::_xmlSchemaBucket,
    mut type_0: u32,
    mut name: *const u8,
    mut nsName: *const u8,
) -> *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a1> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_> =
        0 as *mut xmlSchemaBasicItem;
    let mut i: i32 = 0;
    if bucket.is_null() || name.is_null() {
        return 0 as xmlSchemaBasicItemPtr;
    }
    if !((unsafe { (*bucket).globals }).is_null() || (unsafe { (*(*bucket).globals).nbItems }) == 0 as i32) {
        i = 0 as i32;
        while i < (unsafe { (*(*bucket).globals).nbItems }) {
            ret = (unsafe { *((*(*bucket).globals).items).offset(i as isize) }) as xmlSchemaBasicItemPtr;
            if (unsafe { (*ret).type_0 }) as u32 == type_0 as u32 {
                match type_0 as u32 {
                    5 | 4 => {
                        if (unsafe { (*(ret as xmlSchemaTypePtr)).name }) == name
                            && (unsafe { (*(ret as xmlSchemaTypePtr)).targetNamespace }) == nsName
                        {
                            return ret;
                        }
                    },
                    17 => {
                        if (unsafe { (*(ret as xmlSchemaModelGroupDefPtr)).name }) == name
                            && (unsafe { (*(ret as xmlSchemaModelGroupDefPtr)).targetNamespace }) == nsName
                        {
                            return ret;
                        }
                    },
                    16 => {
                        if (unsafe { (*(ret as xmlSchemaAttributeGroupPtr)).name }) == name
                            && (unsafe { (*(ret as xmlSchemaAttributeGroupPtr)).targetNamespace }) == nsName
                        {
                            return ret;
                        }
                    },
                    _ => return 0 as xmlSchemaBasicItemPtr,
                }
            }
            i += 1;
        }
    }
    if !(unsafe { (*bucket).relations }).is_null() {
        let mut rel: *mut crate::src::xmlschemas::_xmlSchemaSchemaRelation = unsafe { (*bucket).relations };
        (unsafe { (*bucket).flags |= (1 as i32) << 0 as i32 });
        loop {
            if !(unsafe { (*rel).bucket }).is_null()
                && (unsafe { (*(*rel).bucket).flags }) & (1 as i32) << 0 as i32 == 0 as i32
            {
                ret = xmlSchemaFindRedefCompInGraph(unsafe { (*rel).bucket }, type_0, name, nsName);
                if !ret.is_null() {
                    return ret;
                }
            }
            rel = unsafe { (*rel).next };
            if rel.is_null() {
                break;
            }
        }
        (unsafe { (*bucket).flags ^= (1 as i32) << 0 as i32 });
    }
    return 0 as xmlSchemaBasicItemPtr;
}
extern "C" fn xmlSchemaAddNotation<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut name: *const u8,
    mut nsName: *const u8,
    mut _node: *mut crate::src::threads::_xmlNode,
) -> *mut crate::src::xmlschemas::_xmlSchemaNotation<'a3> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaNotation<'_> = 0 as xmlSchemaNotationPtr;
    if ctxt.is_null() || schema.is_null() || name.is_null() {
        return 0 as xmlSchemaNotationPtr;
    }
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaNotation>() as u64
    ) }) as xmlSchemaNotationPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"add annotation\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaNotationPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaNotation>() as u64,
    ) });
    (unsafe { (*ret).type_0 = XML_SCHEMA_TYPE_NOTATION });
    let fresh43 = unsafe { &mut ((*ret).name) };
    *fresh43 = name;
    let fresh44 = unsafe { &mut ((*ret).targetNamespace) };
    *fresh44 = nsName;
    xmlSchemaAddItemSize(
        Some(unsafe { &mut (*(*(*ctxt).constructor).bucket).globals }),
        5 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
extern "C" fn xmlSchemaAddAttribute<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut name: *const u8,
    mut nsName: *const u8,
    mut node: *mut crate::src::threads::_xmlNode,
    mut topLevel: i32,
) -> *mut crate::src::xmlschemas::_xmlSchemaAttribute<'a3> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaAttribute<'_> = 0 as xmlSchemaAttributePtr;
    if ctxt.is_null() || schema.is_null() {
        return 0 as xmlSchemaAttributePtr;
    }
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaAttribute>() as u64
    ) }) as xmlSchemaAttributePtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating attribute\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaAttributePtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaAttribute>() as u64,
    ) });
    (unsafe { (*ret).type_0 = XML_SCHEMA_TYPE_ATTRIBUTE });
    let fresh45 = unsafe { &mut ((*ret).node) };
    *fresh45 = node;
    let fresh46 = unsafe { &mut ((*ret).name) };
    *fresh46 = name;
    let fresh47 = unsafe { &mut ((*ret).targetNamespace) };
    *fresh47 = nsName;
    if topLevel != 0 {
        xmlSchemaAddItemSize(
            Some(unsafe { &mut (*(*(*ctxt).constructor).bucket).globals }),
            5 as i32,
            ret as *mut libc::c_void,
        );
    } else {
        xmlSchemaAddItemSize(
            Some(unsafe { &mut (*(*(*ctxt).constructor).bucket).locals }),
            10 as i32,
            ret as *mut libc::c_void,
        );
    }
    xmlSchemaAddItemSize(
        Some(unsafe { &mut (*(*ctxt).constructor).pending }),
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
extern "C" fn xmlSchemaAddAttributeUse<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'a2> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_> =
        0 as xmlSchemaAttributeUsePtr;
    if pctxt.is_null() {
        return 0 as xmlSchemaAttributeUsePtr;
    }
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaAttributeUse>() as u64,
    ) }) as xmlSchemaAttributeUsePtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            pctxt,
            b"allocating attribute\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaAttributeUsePtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaAttributeUse>() as u64,
    ) });
    (unsafe { (*ret).type_0 = XML_SCHEMA_TYPE_ATTRIBUTE_USE });
    let fresh48 = unsafe { &mut ((*ret).node) };
    *fresh48 = node;
    xmlSchemaAddItemSize(
        Some(unsafe { &mut (*(*(*pctxt).constructor).bucket).locals }),
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
extern "C" fn xmlSchemaAddRedef<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut targetBucket: *mut crate::src::xmlschemas::_xmlSchemaBucket,
    mut item: *mut core::ffi::c_void,
    mut refName: *const u8,
    mut refTargetNs: *const u8,
) -> *mut crate::src::xmlschemas::_xmlSchemaRedef<'a2>
where
    'a2: 'a1,
    'a1: 'a2,
{
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaRedef<'_> = 0 as *mut xmlSchemaRedef;
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaRedef>() as u64
    ) }) as xmlSchemaRedefPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            pctxt,
            b"allocating redefinition info\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaRedefPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaRedef>() as u64,
    ) });
    let fresh49 = unsafe { &mut ((*ret).item) };
    *fresh49 = item as xmlSchemaBasicItemPtr;
    let fresh50 = unsafe { &mut ((*ret).targetBucket) };
    *fresh50 = targetBucket;
    let fresh51 = unsafe { &mut ((*ret).refName) };
    *fresh51 = refName;
    let fresh52 = unsafe { &mut ((*ret).refTargetNs) };
    *fresh52 = refTargetNs;
    if (unsafe { (*(*pctxt).constructor).redefs }).is_null() {
        let fresh53 = unsafe { &mut ((*(*pctxt).constructor).redefs) };
        *fresh53 = ret;
    } else {
        let fresh54 = unsafe { &mut ((*(*(*pctxt).constructor).lastRedef).next) };
        *fresh54 = ret;
    }
    let fresh55 = unsafe { &mut ((*(*pctxt).constructor).lastRedef) };
    *fresh55 = ret;
    return ret;
}
extern "C" fn xmlSchemaAddAttributeGroupDefinition<'a1, 'a2, 'a3>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut _schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut name: *const u8,
    mut nsName: *const u8,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *mut crate::src::xmlschemas::_xmlSchemaAttributeGroup<'a3> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaAttributeGroup<'_> =
        0 as xmlSchemaAttributeGroupPtr;
    if pctxt.is_null() || name.is_null() {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaAttributeGroup>() as u64,
    ) }) as xmlSchemaAttributeGroupPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            pctxt,
            b"allocating attribute group\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaAttributeGroup>() as u64,
    ) });
    (unsafe { (*ret).type_0 = XML_SCHEMA_TYPE_ATTRIBUTEGROUP });
    let fresh56 = unsafe { &mut ((*ret).name) };
    *fresh56 = name;
    let fresh57 = unsafe { &mut ((*ret).targetNamespace) };
    *fresh57 = nsName;
    let fresh58 = unsafe { &mut ((*ret).node) };
    *fresh58 = node;
    (unsafe { (*ret).flags |= (1 as i32) << 1 as i32 });
    if (unsafe { (*pctxt).isRedefine }) != 0 {
        let fresh59 = unsafe { &mut ((*pctxt).redef) };
        *fresh59 = xmlSchemaAddRedef(
            pctxt,
            unsafe { (*pctxt).redefined },
            ret as *mut libc::c_void,
            name,
            nsName,
        );
        if (unsafe { (*pctxt).redef }).is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void) });
            return 0 as xmlSchemaAttributeGroupPtr;
        }
        (unsafe { (*pctxt).redefCounter = 0 as i32 });
    }
    xmlSchemaAddItemSize(
        Some(unsafe { &mut (*(*(*pctxt).constructor).bucket).globals }),
        5 as i32,
        ret as *mut libc::c_void,
    );
    xmlSchemaAddItemSize(
        Some(unsafe { &mut (*(*pctxt).constructor).pending }),
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
extern "C" fn xmlSchemaAddElement<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut name: *const u8,
    mut nsName: *const u8,
    mut node: *mut crate::src::threads::_xmlNode,
    mut topLevel: i32,
) -> *mut crate::src::xmlschemas::_xmlSchemaElement<'a2> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> = 0 as xmlSchemaElementPtr;
    if ctxt.is_null() || name.is_null() {
        return 0 as xmlSchemaElementPtr;
    }
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaElement>() as u64
    ) }) as xmlSchemaElementPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating element\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaElementPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaElement>() as u64,
    ) });
    (unsafe { (*ret).type_0 = XML_SCHEMA_TYPE_ELEMENT });
    let fresh60 = unsafe { &mut ((*ret).name) };
    *fresh60 = name;
    let fresh61 = unsafe { &mut ((*ret).targetNamespace) };
    *fresh61 = nsName;
    let fresh62 = unsafe { &mut ((*ret).node) };
    *fresh62 = node;
    if topLevel != 0 {
        xmlSchemaAddItemSize(
            Some(unsafe { &mut (*(*(*ctxt).constructor).bucket).globals }),
            5 as i32,
            ret as *mut libc::c_void,
        );
    } else {
        xmlSchemaAddItemSize(
            Some(unsafe { &mut (*(*(*ctxt).constructor).bucket).locals }),
            10 as i32,
            ret as *mut libc::c_void,
        );
    }
    xmlSchemaAddItemSize(
        Some(unsafe { &mut (*(*ctxt).constructor).pending }),
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
extern "C" fn xmlSchemaAddType<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut type_0: u32,
    mut name: *const u8,
    mut nsName: *const u8,
    mut node: *mut crate::src::threads::_xmlNode,
    mut topLevel: i32,
) -> *mut crate::src::xmlschemas::_xmlSchemaType<'a3> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as xmlSchemaTypePtr;
    if ctxt.is_null() || schema.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaType>() as u64
    ) }) as xmlSchemaTypePtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating type\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaTypePtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaType>() as u64,
    ) });
    (unsafe { (*ret).type_0 = type_0 });
    let fresh63 = unsafe { &mut ((*ret).name) };
    *fresh63 = name;
    let fresh64 = unsafe { &mut ((*ret).targetNamespace) };
    *fresh64 = nsName;
    let fresh65 = unsafe { &mut ((*ret).node) };
    *fresh65 = node;
    if topLevel != 0 {
        if (unsafe { (*ctxt).isRedefine }) != 0 {
            let fresh66 = unsafe { &mut ((*ctxt).redef) };
            *fresh66 = xmlSchemaAddRedef(
                ctxt,
                unsafe { (*ctxt).redefined },
                ret as *mut libc::c_void,
                name,
                nsName,
            );
            if (unsafe { (*ctxt).redef }).is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void) });
                return 0 as xmlSchemaTypePtr;
            }
            (unsafe { (*ctxt).redefCounter = 0 as i32 });
        }
        xmlSchemaAddItemSize(
            Some(unsafe { &mut (*(*(*ctxt).constructor).bucket).globals }),
            5 as i32,
            ret as *mut libc::c_void,
        );
    } else {
        xmlSchemaAddItemSize(
            Some(unsafe { &mut (*(*(*ctxt).constructor).bucket).locals }),
            10 as i32,
            ret as *mut libc::c_void,
        );
    }
    xmlSchemaAddItemSize(
        Some(unsafe { &mut (*(*ctxt).constructor).pending }),
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
extern "C" fn xmlSchemaNewQNameRef<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut refType: u32,
    mut refName: *const u8,
    mut refNs: *const u8,
) -> *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'a2> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'_> = 0 as *mut xmlSchemaQNameRef;
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaQNameRef>() as u64
    ) }) as xmlSchemaQNameRefPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            pctxt,
            b"allocating QName reference item\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaQNameRefPtr;
    }
    let fresh67 = unsafe { &mut ((*ret).node) };
    *fresh67 = 0 as xmlNodePtr;
    (unsafe { (*ret).type_0 = XML_SCHEMA_EXTRA_QNAMEREF });
    let fresh68 = unsafe { &mut ((*ret).name) };
    *fresh68 = refName;
    let fresh69 = unsafe { &mut ((*ret).targetNamespace) };
    *fresh69 = refNs;
    let fresh70 = unsafe { &mut ((*ret).item) };
    *fresh70 = 0 as xmlSchemaBasicItemPtr;
    (unsafe { (*ret).itemType = refType });
    xmlSchemaAddItemSize(
        Some(unsafe { &mut (*(*(*pctxt).constructor).bucket).locals }),
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
extern "C" fn xmlSchemaAddAttributeUseProhib<'a1>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
) -> *mut crate::src::xmlschemas::_xmlSchemaAttributeUseProhib {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaAttributeUseProhib =
        0 as *mut xmlSchemaAttributeUseProhib;
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<
        xmlSchemaAttributeUseProhib,
    >() as u64) }) as xmlSchemaAttributeUseProhibPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            pctxt,
            b"allocating attribute use prohibition\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaAttributeUseProhibPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaAttributeUseProhib>() as u64,
    ) });
    (unsafe { (*ret).type_0 = XML_SCHEMA_EXTRA_ATTR_USE_PROHIB });
    xmlSchemaAddItemSize(
        Some(unsafe { &mut (*(*(*pctxt).constructor).bucket).locals }),
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
extern "C" fn xmlSchemaAddModelGroup<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut type_0: u32,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *mut crate::src::xmlschemas::_xmlSchemaModelGroup<'a3> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaModelGroup<'_> =
        0 as xmlSchemaModelGroupPtr;
    if ctxt.is_null() || schema.is_null() {
        return 0 as xmlSchemaModelGroupPtr;
    }
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaModelGroup>() as u64,
    ) }) as xmlSchemaModelGroupPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating model group component\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaModelGroupPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaModelGroup>() as u64,
    ) });
    (unsafe { (*ret).type_0 = type_0 });
    let fresh71 = unsafe { &mut ((*ret).node) };
    *fresh71 = node;
    xmlSchemaAddItemSize(
        Some(unsafe { &mut (*(*(*ctxt).constructor).bucket).locals }),
        10 as i32,
        ret as *mut libc::c_void,
    );
    if type_0 as u32 == XML_SCHEMA_TYPE_SEQUENCE as i32 as u32
        || type_0 as u32 == XML_SCHEMA_TYPE_CHOICE as i32 as u32
    {
        xmlSchemaAddItemSize(
            Some(unsafe { &mut (*(*ctxt).constructor).pending }),
            10 as i32,
            ret as *mut libc::c_void,
        );
    }
    return ret;
}
extern "C" fn xmlSchemaAddParticle<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut min: i32,
    mut max: i32,
) -> *mut crate::src::xmlschemas::_xmlSchemaParticle {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaParticle = 0 as xmlSchemaParticlePtr;
    if ctxt.is_null() {
        return 0 as xmlSchemaParticlePtr;
    }
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaParticle>() as u64
    ) }) as xmlSchemaParticlePtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating particle component\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaParticlePtr;
    }
    (unsafe { (*ret).type_0 = XML_SCHEMA_TYPE_PARTICLE });
    let fresh72 = unsafe { &mut ((*ret).annot) };
    *fresh72 = 0 as xmlSchemaAnnotPtr;
    let fresh73 = unsafe { &mut ((*ret).node) };
    *fresh73 = node;
    (unsafe { (*ret).minOccurs = min });
    (unsafe { (*ret).maxOccurs = max });
    let fresh74 = unsafe { &mut ((*ret).next) };
    *fresh74 = 0 as xmlSchemaTreeItemPtr;
    let fresh75 = unsafe { &mut ((*ret).children) };
    *fresh75 = 0 as xmlSchemaTreeItemPtr;
    xmlSchemaAddItemSize(
        Some(unsafe { &mut (*(*(*ctxt).constructor).bucket).locals }),
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
extern "C" fn xmlSchemaAddModelGroupDefinition<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut name: *const u8,
    mut nsName: *const u8,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *mut crate::src::xmlschemas::_xmlSchemaModelGroupDef<'a3> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaModelGroupDef<'_> =
        0 as xmlSchemaModelGroupDefPtr;
    if ctxt.is_null() || schema.is_null() || name.is_null() {
        return 0 as xmlSchemaModelGroupDefPtr;
    }
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaModelGroupDef>() as u64,
    ) }) as xmlSchemaModelGroupDefPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"adding group\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaModelGroupDefPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaModelGroupDef>() as u64,
    ) });
    let fresh76 = unsafe { &mut ((*ret).name) };
    *fresh76 = name;
    (unsafe { (*ret).type_0 = XML_SCHEMA_TYPE_GROUP });
    let fresh77 = unsafe { &mut ((*ret).node) };
    *fresh77 = node;
    let fresh78 = unsafe { &mut ((*ret).targetNamespace) };
    *fresh78 = nsName;
    if (unsafe { (*ctxt).isRedefine }) != 0 {
        let fresh79 = unsafe { &mut ((*ctxt).redef) };
        *fresh79 = xmlSchemaAddRedef(
            ctxt,
            unsafe { (*ctxt).redefined },
            ret as *mut libc::c_void,
            name,
            nsName,
        );
        if (unsafe { (*ctxt).redef }).is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void) });
            return 0 as xmlSchemaModelGroupDefPtr;
        }
        (unsafe { (*ctxt).redefCounter = 0 as i32 });
    }
    xmlSchemaAddItemSize(
        Some(unsafe { &mut (*(*(*ctxt).constructor).bucket).globals }),
        5 as i32,
        ret as *mut libc::c_void,
    );
    xmlSchemaAddItemSize(
        Some(unsafe { &mut (*(*ctxt).constructor).pending }),
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
extern "C" fn xmlSchemaNewWildcardNsConstraint<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
) -> *mut crate::src::xmlschemas::_xmlSchemaWildcardNs {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs = 0 as *mut xmlSchemaWildcardNs;
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaWildcardNs>() as u64,
    ) }) as xmlSchemaWildcardNsPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"creating wildcard namespace constraint\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaWildcardNsPtr;
    }
    let fresh80 = unsafe { &mut ((*ret).value) };
    *fresh80 = 0 as *const xmlChar;
    let fresh81 = unsafe { &mut ((*ret).next) };
    *fresh81 = 0 as *mut _xmlSchemaWildcardNs;
    return ret;
}
extern "C" fn xmlSchemaAddIDC<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut name: *const u8,
    mut nsName: *const u8,
    mut category: i32,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *mut crate::src::xmlschemas::_xmlSchemaIDC<'a3> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaIDC<'_> = 0 as xmlSchemaIDCPtr;
    if ctxt.is_null() || schema.is_null() || name.is_null() {
        return 0 as xmlSchemaIDCPtr;
    }
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<xmlSchemaIDC>() as u64) })
        as xmlSchemaIDCPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating an identity-constraint definition\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaIDCPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaIDC>() as u64,
    ) });
    let fresh82 = unsafe { &mut ((*ret).targetNamespace) };
    *fresh82 = nsName;
    let fresh83 = unsafe { &mut ((*ret).name) };
    *fresh83 = name;
    (unsafe { (*ret).type_0 = category as xmlSchemaTypeType });
    let fresh84 = unsafe { &mut ((*ret).node) };
    *fresh84 = node;
    xmlSchemaAddItemSize(
        Some(unsafe { &mut (*(*(*ctxt).constructor).bucket).globals }),
        5 as i32,
        ret as *mut libc::c_void,
    );
    if category == XML_SCHEMA_TYPE_IDC_KEYREF as i32 {
        xmlSchemaAddItemSize(
            Some(unsafe { &mut (*(*ctxt).constructor).pending }),
            10 as i32,
            ret as *mut libc::c_void,
        );
    }
    return ret;
}
extern "C" fn xmlSchemaAddWildcard<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut type_0: u32,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a3> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'_> = 0 as xmlSchemaWildcardPtr;
    if ctxt.is_null() || schema.is_null() {
        return 0 as xmlSchemaWildcardPtr;
    }
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaWildcard>() as u64
    ) }) as xmlSchemaWildcardPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"adding wildcard\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaWildcardPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaWildcard>() as u64,
    ) });
    (unsafe { (*ret).type_0 = type_0 });
    let fresh85 = unsafe { &mut ((*ret).node) };
    *fresh85 = node;
    xmlSchemaAddItemSize(
        Some(unsafe { &mut (*(*(*ctxt).constructor).bucket).locals }),
        10 as i32,
        ret as *mut libc::c_void,
    );
    return ret;
}
extern "C" fn xmlSchemaSubstGroupFree<'a1>(
    mut group: *mut crate::src::xmlschemas::_xmlSchemaSubstGroup<'a1>,
) {
    if group.is_null() {
        return;
    }
    if !(unsafe { (*group).members }).is_null() {
        xmlSchemaItemListFree(unsafe { (*group).members });
    }
    (unsafe { xmlFree.expect("non-null function pointer")(group as *mut libc::c_void) });
}
extern "C" fn xmlSchemaSubstGroupFreeEntry(mut group: *mut core::ffi::c_void, mut _name: *const u8) {
    xmlSchemaSubstGroupFree(group as xmlSchemaSubstGroupPtr);
}
extern "C" fn xmlSchemaSubstGroupAdd<'a1, 'a2, 'a3>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut head: *mut crate::src::xmlschemas::_xmlSchemaElement<'a2>,
) -> *mut crate::src::xmlschemas::_xmlSchemaSubstGroup<'a3>
where
    'a2: 'a3,
    'a3: 'a2,
{
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaSubstGroup<'_> =
        0 as *mut xmlSchemaSubstGroup;
    if (unsafe { (*(*pctxt).constructor).substGroups }).is_null() {
        let fresh86 = unsafe { &mut ((*(*pctxt).constructor).substGroups) };
        *fresh86 = unsafe { xmlHashCreateDict(10 as i32, (*pctxt).dict) };
        if (unsafe { (*(*pctxt).constructor).substGroups }).is_null() {
            return 0 as xmlSchemaSubstGroupPtr;
        }
    }
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaSubstGroup>() as u64,
    ) }) as xmlSchemaSubstGroupPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating a substitution group container\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaSubstGroupPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaSubstGroup>() as u64,
    ) });
    let fresh87 = unsafe { &mut ((*ret).head) };
    *fresh87 = head;
    let fresh88 = unsafe { &mut ((*ret).members) };
    *fresh88 = xmlSchemaItemListCreate();
    if (unsafe { (*ret).members }).is_null() {
        xmlSchemaSubstGroupFree(ret);
        return 0 as xmlSchemaSubstGroupPtr;
    }
    if (unsafe { xmlHashAddEntry2(
        (*(*pctxt).constructor).substGroups,
        (*head).name,
        (*head).targetNamespace,
        ret as *mut libc::c_void,
    ) }) != 0 as i32
    {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaSubstGroupAdd\0" as *const u8 as *const i8,
            b"failed to add a new substitution container\0" as *const u8 as *const i8,
        );
        xmlSchemaSubstGroupFree(ret);
        return 0 as xmlSchemaSubstGroupPtr;
    }
    return ret;
}
extern "C" fn xmlSchemaSubstGroupGet<'a1, 'a2, 'a3>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut head: *mut crate::src::xmlschemas::_xmlSchemaElement<'a2>,
) -> *mut crate::src::xmlschemas::_xmlSchemaSubstGroup<'a3> {
    if (unsafe { (*(*pctxt).constructor).substGroups }).is_null() {
        return 0 as xmlSchemaSubstGroupPtr;
    }
    return (unsafe { xmlHashLookup2(
        (*(*pctxt).constructor).substGroups,
        (*head).name,
        (*head).targetNamespace,
    ) }) as xmlSchemaSubstGroupPtr;
}
extern "C" fn xmlSchemaAddElementSubstitutionMember<'a1, 'a2, 'a3>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut head: *mut crate::src::xmlschemas::_xmlSchemaElement<'a2>,
    mut member: *mut crate::src::xmlschemas::_xmlSchemaElement<'a3>,
) -> i32 {
    let mut substGroup: *mut crate::src::xmlschemas::_xmlSchemaSubstGroup<'_> =
        0 as xmlSchemaSubstGroupPtr;
    if pctxt.is_null() || head.is_null() || member.is_null() {
        return -(1 as i32);
    }
    substGroup = xmlSchemaSubstGroupGet(pctxt, head);
    if substGroup.is_null() {
        substGroup = xmlSchemaSubstGroupAdd(pctxt, head);
    }
    if substGroup.is_null() {
        return -(1 as i32);
    }
    if xmlSchemaItemListAdd(unsafe { (*substGroup).members }, member as *mut libc::c_void) == -(1 as i32) {
        return -(1 as i32);
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaPValAttrNodeQNameValue<'a1, 'a2, 'a3, 'a4, 'a5>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut ownerItem: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a3>,
    mut attr: *mut crate::src::threads::_xmlAttr,
    mut value: *const u8,
    mut uri: Option<&'a4 mut *const u8>,
    mut local: Option<&'a5 mut *const u8>,
) -> i32 {
    let mut pref: *const u8 = 0 as *const xmlChar;
    let mut ns: *mut crate::src::threads::_xmlNs = 0 as *mut xmlNs;
    let mut len: i32 = 0;
    let mut ret: i32 = 0;
    *(borrow_mut(&mut uri)).unwrap() = 0 as *const xmlChar;
    *(borrow_mut(&mut local)).unwrap() = 0 as *const xmlChar;
    ret = xmlValidateQName(value, 1 as i32);
    if ret > 0 as i32 {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            ownerItem,
            attr as xmlNodePtr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),
            0 as *const i8,
            value,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        *(borrow_mut(&mut local)).unwrap() = value;
        return unsafe { (*ctxt).err };
    } else {
        if ret < 0 as i32 {
            return -(1 as i32);
        }
    }
    if (unsafe { strchr(value as *mut i8, ':' as i32) }).is_null() {
        ns = xmlSearchNs(unsafe { (*attr).doc }, unsafe { (*attr).parent }, 0 as *const xmlChar);
        if !ns.is_null()
            && !(unsafe { (*ns).href }).is_null()
            && (unsafe { *((*ns).href).offset(0 as i32 as isize) }) as i32 != 0
        {
            *(borrow_mut(&mut uri)).unwrap() = unsafe { xmlDictLookup((*ctxt).dict, (*ns).href, -(1 as i32)) };
        } else if (unsafe { (*schema).flags }) & (1 as i32) << 9 as i32 != 0 {
            *(borrow_mut(&mut uri)).unwrap() = unsafe { (*ctxt).targetNamespace };
        }
        *(borrow_mut(&mut local)).unwrap() = unsafe { xmlDictLookup((*ctxt).dict, value, -(1 as i32)) };
        return 0 as i32;
    }
    *(borrow_mut(&mut local)).unwrap() = xmlSplitQName3(value, Some(&mut len));
    *(borrow_mut(&mut local)).unwrap() =
        unsafe { xmlDictLookup((*ctxt).dict, *(borrow(&local)).unwrap(), -(1 as i32)) };
    pref = unsafe { xmlDictLookup((*ctxt).dict, value, len) };
    ns = xmlSearchNs(unsafe { (*attr).doc }, unsafe { (*attr).parent }, pref);
    if ns.is_null() {
        xmlSchemaPSimpleTypeErr (ctxt , XML_SCHEMAP_S4S_ATTR_INVALID_VALUE , ownerItem , attr as xmlNodePtr , xmlSchemaGetBuiltInType (XML_SCHEMAS_QNAME) , 0 as * const i8 , value , b"The value '%s' of simple type 'xs:QName' has no corresponding namespace declaration in scope\0" as * const u8 as * const i8 , value , 0 as * const xmlChar ,) ;
        return unsafe { (*ctxt).err };
    } else {
        *(borrow_mut(&mut uri)).unwrap() = unsafe { xmlDictLookup((*ctxt).dict, (*ns).href, -(1 as i32)) };
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaPValAttrNodeQName<'a1, 'a2, 'a3, 'a4, 'a5>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut ownerItem: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a3>,
    mut attr: *mut crate::src::threads::_xmlAttr,
    mut uri: Option<&'a4 mut *const u8>,
    mut local: Option<&'a5 mut *const u8>,
) -> i32 {
    let mut value: *const u8 = 0 as *const xmlChar;
    value = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    return xmlSchemaPValAttrNodeQNameValue(
        ctxt,
        schema,
        ownerItem,
        attr,
        value,
        borrow_mut(&mut uri),
        borrow_mut(&mut local),
    );
}
extern "C" fn xmlSchemaPValAttrQName<'a1, 'a2, 'a3, 'a4, 'a5>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut ownerItem: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a3>,
    mut ownerElem: *mut crate::src::threads::_xmlNode,
    mut name: *const i8,
    mut uri: Option<&'a4 mut *const u8>,
    mut local: Option<&'a5 mut *const u8>,
) -> i32 {
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    attr = xmlSchemaGetPropNode(ownerElem, name);
    if attr.is_null() {
        *(borrow_mut(&mut local)).unwrap() = 0 as *const xmlChar;
        *(borrow_mut(&mut uri)).unwrap() = 0 as *const xmlChar;
        return 0 as i32;
    }
    return xmlSchemaPValAttrNodeQName(
        ctxt,
        schema,
        ownerItem,
        attr,
        borrow_mut(&mut uri),
        borrow_mut(&mut local),
    );
}
extern "C" fn xmlSchemaPValAttrNodeID<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut attr: *mut crate::src::threads::_xmlAttr,
) -> i32 {
    let mut ret: i32 = 0;
    let mut value: *const u8 = 0 as *const xmlChar;
    if attr.is_null() {
        return 0 as i32;
    }
    value = xmlSchemaGetNodeContentNoDict(attr as xmlNodePtr);
    ret = xmlValidateNCName(value, 1 as i32);
    if ret == 0 as i32 {
        if (unsafe { (*attr).atype }) as u32 != XML_ATTRIBUTE_ID as i32 as u32 {
            let mut res: *mut crate::src::tree::_xmlID<'_> = 0 as *mut xmlID;
            let mut strip: *mut u8 = 0 as *mut xmlChar;
            strip = xmlSchemaCollapseString(value);
            if !strip.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(
                    value as *mut xmlChar as *mut libc::c_void,
                ) });
                value = strip;
            }
            res = xmlAddID(0 as xmlValidCtxtPtr, unsafe { (*attr).doc }, value, attr);
            if res.is_null() {
                ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as i32;
                xmlSchemaPSimpleTypeErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                    0 as xmlSchemaBasicItemPtr,
                    attr as xmlNodePtr,
                    xmlSchemaGetBuiltInType(XML_SCHEMAS_ID),
                    0 as *const i8,
                    0 as *const xmlChar,
                    b"Duplicate value '%s' of simple type 'xs:ID'\0" as *const u8 as *const i8,
                    value,
                    0 as *const xmlChar,
                );
            } else {
                (unsafe { (*attr).atype = XML_ATTRIBUTE_ID });
            }
        }
    } else if ret > 0 as i32 {
        ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as i32;
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_ID),
            0 as *const i8,
            0 as *const xmlChar,
            b"The value '%s' of simple type 'xs:ID' is not a valid 'xs:NCName'\0" as *const u8
                as *const i8,
            value,
            0 as *const xmlChar,
        );
    }
    if !value.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(value as *mut xmlChar as *mut libc::c_void) });
    }
    return ret;
}
extern "C" fn xmlSchemaPValAttrID<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut ownerElem: *mut crate::src::threads::_xmlNode,
    mut name: *const u8,
) -> i32 {
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    attr = xmlSchemaGetPropNode(ownerElem, name as *const i8);
    if attr.is_null() {
        return 0 as i32;
    }
    return xmlSchemaPValAttrNodeID(ctxt, attr);
}
extern "C" fn xmlGetMaxOccurs<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut min: i32,
    mut max: i32,
    mut def: i32,
    mut expected: *const i8,
) -> i32 {
    let mut val: *const u8 = 0 as *const xmlChar;
    let mut cur: *const u8 = 0 as *const xmlChar;
    let mut ret: i32 = 0 as i32;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    attr = xmlSchemaGetPropNode(node, b"maxOccurs\0" as *const u8 as *const i8);
    if attr.is_null() {
        return def;
    }
    val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    if xmlStrEqual(
        val,
        b"unbounded\0" as *const u8 as *const i8 as *const xmlChar,
    ) != 0
    {
        if max != (1 as i32) << 30 as i32 {
            xmlSchemaPSimpleTypeErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                0 as xmlSchemaBasicItemPtr,
                attr as xmlNodePtr,
                0 as xmlSchemaTypePtr,
                expected,
                val,
                0 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return def;
        } else {
            return (1 as i32) << 30 as i32;
        }
    }
    cur = val;
    while (unsafe { *cur }) as i32 == 0x20 as i32
        || 0x9 as i32 <= (unsafe { *cur }) as i32 && (unsafe { *cur }) as i32 <= 0xa as i32
        || (unsafe { *cur }) as i32 == 0xd as i32
    {
        cur = unsafe { cur.offset(1) };
    }
    if (unsafe { *cur }) as i32 == 0 as i32 {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            0 as xmlSchemaTypePtr,
            expected,
            val,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return def;
    }
    while (unsafe { *cur }) as i32 >= '0' as i32 && (unsafe { *cur }) as i32 <= '9' as i32 {
        if ret > 2147483647 as i32 / 10 as i32 {
            ret = 2147483647 as i32;
        } else {
            let mut digit: i32 = (unsafe { *cur }) as i32 - '0' as i32;
            ret *= 10 as i32;
            if ret > 2147483647 as i32 - digit {
                ret = 2147483647 as i32;
            } else {
                ret += digit;
            }
        }
        cur = unsafe { cur.offset(1) };
    }
    while (unsafe { *cur }) as i32 == 0x20 as i32
        || 0x9 as i32 <= (unsafe { *cur }) as i32 && (unsafe { *cur }) as i32 <= 0xa as i32
        || (unsafe { *cur }) as i32 == 0xd as i32
    {
        cur = unsafe { cur.offset(1) };
    }
    if (unsafe { *cur }) as i32 != 0 as i32 || ret < min || max != -(1 as i32) && ret > max {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            0 as xmlSchemaTypePtr,
            expected,
            val,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return def;
    }
    return ret;
}
extern "C" fn xmlGetMinOccurs<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut min: i32,
    mut max: i32,
    mut def: i32,
    mut expected: *const i8,
) -> i32 {
    let mut val: *const u8 = 0 as *const xmlChar;
    let mut cur: *const u8 = 0 as *const xmlChar;
    let mut ret: i32 = 0 as i32;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    attr = xmlSchemaGetPropNode(node, b"minOccurs\0" as *const u8 as *const i8);
    if attr.is_null() {
        return def;
    }
    val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    cur = val;
    while (unsafe { *cur }) as i32 == 0x20 as i32
        || 0x9 as i32 <= (unsafe { *cur }) as i32 && (unsafe { *cur }) as i32 <= 0xa as i32
        || (unsafe { *cur }) as i32 == 0xd as i32
    {
        cur = unsafe { cur.offset(1) };
    }
    if (unsafe { *cur }) as i32 == 0 as i32 {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            0 as xmlSchemaTypePtr,
            expected,
            val,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return def;
    }
    while (unsafe { *cur }) as i32 >= '0' as i32 && (unsafe { *cur }) as i32 <= '9' as i32 {
        if ret > 2147483647 as i32 / 10 as i32 {
            ret = 2147483647 as i32;
        } else {
            let mut digit: i32 = (unsafe { *cur }) as i32 - '0' as i32;
            ret *= 10 as i32;
            if ret > 2147483647 as i32 - digit {
                ret = 2147483647 as i32;
            } else {
                ret += digit;
            }
        }
        cur = unsafe { cur.offset(1) };
    }
    while (unsafe { *cur }) as i32 == 0x20 as i32
        || 0x9 as i32 <= (unsafe { *cur }) as i32 && (unsafe { *cur }) as i32 <= 0xa as i32
        || (unsafe { *cur }) as i32 == 0xd as i32
    {
        cur = unsafe { cur.offset(1) };
    }
    if (unsafe { *cur }) as i32 != 0 as i32 || ret < min || max != -(1 as i32) && ret > max {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            0 as xmlSchemaTypePtr,
            expected,
            val,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return def;
    }
    return ret;
}
extern "C" fn xmlSchemaPGetBoolNodeValue<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut ownerItem: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> i32 {
    let mut value: *mut u8 = 0 as *mut xmlChar;
    let mut res: i32 = 0 as i32;
    value = xmlNodeGetContent(node as *const xmlNode);
    if xmlStrEqual(value, b"true\0" as *const u8 as *const i8 as *mut xmlChar) != 0 {
        res = 1 as i32;
    } else if xmlStrEqual(value, b"false\0" as *const u8 as *const i8 as *mut xmlChar) != 0 {
        res = 0 as i32;
    } else if xmlStrEqual(value, b"1\0" as *const u8 as *const i8 as *mut xmlChar) != 0 {
        res = 1 as i32;
    } else if xmlStrEqual(value, b"0\0" as *const u8 as *const i8 as *mut xmlChar) != 0 {
        res = 0 as i32;
    } else {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_INVALID_BOOLEAN,
            ownerItem,
            node,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
            0 as *const i8,
            value,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    if !value.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(value as *mut libc::c_void) });
    }
    return res;
}
extern "C" fn xmlGetBooleanProp<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut name: *const i8,
    mut def: i32,
) -> i32 {
    let mut val: *const u8 = 0 as *const xmlChar;
    val = xmlSchemaGetProp(ctxt, node, name);
    if val.is_null() {
        return def;
    }
    if xmlStrEqual(val, b"true\0" as *const u8 as *const i8 as *mut xmlChar) != 0 {
        def = 1 as i32;
    } else if xmlStrEqual(val, b"false\0" as *const u8 as *const i8 as *mut xmlChar) != 0 {
        def = 0 as i32;
    } else if xmlStrEqual(val, b"1\0" as *const u8 as *const i8 as *mut xmlChar) != 0 {
        def = 1 as i32;
    } else if xmlStrEqual(val, b"0\0" as *const u8 as *const i8 as *mut xmlChar) != 0 {
        def = 0 as i32;
    } else {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_INVALID_BOOLEAN,
            0 as xmlSchemaBasicItemPtr,
            xmlSchemaGetPropNode(node, name) as xmlNodePtr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
            0 as *const i8,
            val,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    return def;
}
extern "C" fn xmlSchemaPValAttrNodeValue<'a1, 'a2, 'a3>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut ownerItem: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2>,
    mut attr: *mut crate::src::threads::_xmlAttr,
    mut value: *const u8,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a3>,
) -> i32
where
    'a3: 'static,
{
    let mut ret: i32 = 0 as i32;
    if pctxt.is_null() || type_0.is_null() || attr.is_null() {
        return -(1 as i32);
    }
    if (unsafe { (*type_0).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32 {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaPValAttrNodeValue\0" as *const u8 as *const i8,
            b"the given type is not a built-in type\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    match unsafe { (*type_0).builtInType } {
        22 | 21 | 29 | 16 | 17 => {
            ret = xmlSchemaValPredefTypeNode(
                type_0,
                value,
                Option::<&'_ mut *mut crate::src::xmlschemastypes::_xmlSchemaVal>::None,
                attr as xmlNodePtr,
            );
        },
        _ => {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaPValAttrNodeValue\0" as *const u8 as *const i8,
                b"validation using the given type is not supported while parsing a schema\0"
                    as *const u8 as *const i8,
            );
            return -(1 as i32);
        },
    }
    if ret < 0 as i32 {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaPValAttrNodeValue\0" as *const u8 as *const i8,
            b"failed to validate a schema attribute value\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    } else {
        if ret > 0 as i32 {
            if (unsafe { (*type_0).flags }) & (1 as i32) << 6 as i32 != 0 {
                ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as i32;
            } else {
                ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as i32;
            }
            xmlSchemaPSimpleTypeErr(
                pctxt,
                ret as xmlParserErrors,
                ownerItem,
                attr as xmlNodePtr,
                type_0,
                0 as *const i8,
                value,
                0 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
        }
    }
    return ret;
}
extern "C" fn xmlSchemaPValAttrNode<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut ownerItem: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2>,
    mut attr: *mut crate::src::threads::_xmlAttr,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a3>,
    mut value: *mut *const u8,
) -> i32
where
    'a3: 'static,
{
    let mut val: *const u8 = 0 as *const xmlChar;
    if ctxt.is_null() || type_0.is_null() || attr.is_null() {
        return -(1 as i32);
    }
    val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    if !value.is_null() {
        (unsafe { *value = val });
    }
    return xmlSchemaPValAttrNodeValue(ctxt, ownerItem, attr, val, type_0);
}
extern "C" fn xmlSchemaPValAttr<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut ownerItem: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2>,
    mut ownerElem: *mut crate::src::threads::_xmlNode,
    mut name: *const i8,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a3>,
    mut value: *mut *const u8,
) -> i32
where
    'a3: 'static,
{
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    if ctxt.is_null() || type_0.is_null() {
        if !value.is_null() {
            (unsafe { *value = 0 as *const xmlChar });
        }
        return -(1 as i32);
    }
    if (unsafe { (*type_0).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32 {
        if !value.is_null() {
            (unsafe { *value = 0 as *const xmlChar });
        }
        xmlSchemaPErr(
            ctxt,
            ownerElem,
            XML_SCHEMAP_INTERNAL as i32,
            b"Internal error: xmlSchemaPValAttr, the given type '%s' is not a built-in type.\n\0"
                as *const u8 as *const i8,
            unsafe { (*type_0).name },
            0 as *const xmlChar,
        );
        return -(1 as i32);
    }
    attr = xmlSchemaGetPropNode(ownerElem, name);
    if attr.is_null() {
        if !value.is_null() {
            (unsafe { *value = 0 as *const xmlChar });
        }
        return 0 as i32;
    }
    return xmlSchemaPValAttrNode(ctxt, ownerItem, attr, type_0, value);
}
extern "C" fn xmlSchemaCheckReference<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut _schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut attr: *mut crate::src::threads::_xmlAttr,
    mut namespaceName: *const u8,
) -> i32 {
    if xmlStrEqual(unsafe { (*pctxt).targetNamespace }, namespaceName) != 0 {
        return 0 as i32;
    }
    if xmlStrEqual(unsafe { xmlSchemaNs }, namespaceName) != 0 {
        return 0 as i32;
    }
    if !(unsafe { (*(*(*pctxt).constructor).bucket).relations }).is_null() {
        let mut rel: *mut crate::src::xmlschemas::_xmlSchemaSchemaRelation =
            0 as *mut xmlSchemaSchemaRelation;
        rel = unsafe { (*(*(*pctxt).constructor).bucket).relations };
        loop {
            if ((unsafe { (*rel).type_0 }) == 0 as i32 || (unsafe { (*rel).type_0 }) == 1 as i32)
                && xmlStrEqual(namespaceName, unsafe { (*rel).importNamespace }) != 0
            {
                return 0 as i32;
            }
            rel = unsafe { (*rel).next };
            if rel.is_null() {
                break;
            }
        }
    }
    let mut n: *mut crate::src::threads::_xmlNode = if !attr.is_null() {
        attr as xmlNodePtr
    } else {
        node
    };
    if namespaceName.is_null() {
        xmlSchemaCustomErr (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_SRC_RESOLVE , n , 0 as xmlSchemaBasicItemPtr , b"References from this schema to components in no namespace are not allowed, since not indicated by an import statement\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
    } else {
        xmlSchemaCustomErr (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_SRC_RESOLVE , n , 0 as xmlSchemaBasicItemPtr , b"References from this schema to components in the namespace '%s' are not allowed, since not indicated by an import statement\0" as * const u8 as * const i8 , namespaceName , 0 as * const xmlChar ,) ;
    }
    return XML_SCHEMAP_SRC_RESOLVE as i32;
}
extern "C" fn xmlSchemaParseLocalAttributes<'a1, 'a2, 'a3, 'a4>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut child: Option<&'a3 mut *mut crate::src::threads::_xmlNode>,
    mut list: *mut *mut crate::src::xmlschemas::_xmlSchemaItemList,
    mut parentType: i32,
    mut hasRefs: Option<&'a4 mut i32>,
) -> i32
where
    'a1: 'static,
{
    let mut item: *mut core::ffi::c_void = 0 as *mut libc::c_void;
    while !(*(borrow(&child)).unwrap()).is_null()
        && !(unsafe { (**(borrow(&child)).unwrap()).ns }).is_null()
        && xmlStrEqual(
            unsafe { (**(borrow(&child)).unwrap()).name },
            b"attribute\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(**(borrow(&child)).unwrap()).ns).href }, unsafe { xmlSchemaNs }) != 0
        || !(*(borrow(&child)).unwrap()).is_null()
            && !(unsafe { (**(borrow(&child)).unwrap()).ns }).is_null()
            && xmlStrEqual(
                unsafe { (**(borrow(&child)).unwrap()).name },
                b"attributeGroup\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(**(borrow(&child)).unwrap()).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        if !(*(borrow(&child)).unwrap()).is_null()
            && !(unsafe { (**(borrow(&child)).unwrap()).ns }).is_null()
            && xmlStrEqual(
                unsafe { (**(borrow(&child)).unwrap()).name },
                b"attribute\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(**(borrow(&child)).unwrap()).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            item = xmlSchemaParseLocalAttribute(
                ctxt,
                schema,
                *(borrow_mut(&mut child)).unwrap(),
                unsafe { *list },
                parentType,
            ) as *mut libc::c_void;
        } else {
            item = xmlSchemaParseAttributeGroupRef(ctxt, schema, *(borrow_mut(&mut child)).unwrap())
                as *mut libc::c_void;
            if !item.is_null() && !borrow(&hasRefs).is_none() {
                *(borrow_mut(&mut hasRefs)).unwrap() = 1 as i32;
            }
        }
        if !item.is_null() {
            if (unsafe { *list }).is_null() {
                (unsafe { *list = xmlSchemaItemListCreate() });
                if (unsafe { *list }).is_null() {
                    return -(1 as i32);
                }
            }
            if xmlSchemaItemListAddSize(unsafe { *list }, 2 as i32, item) == -(1 as i32) {
                return -(1 as i32);
            }
        }
        *(borrow_mut(&mut child)).unwrap() = unsafe { (**(borrow_mut(&mut child)).unwrap()).next };
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaParseAnnotation<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut needed: i32,
) -> *mut crate::src::xmlschemas::_xmlSchemaAnnot {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaAnnot = 0 as *mut xmlSchemaAnnot;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    let mut barked: i32 = 0 as i32;
    if ctxt.is_null() || node.is_null() {
        return 0 as xmlSchemaAnnotPtr;
    }
    if needed != 0 {
        ret = xmlSchemaNewAnnot(ctxt, node);
    } else {
        ret = 0 as xmlSchemaAnnotPtr;
    }
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*attr).name },
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
            || !(unsafe { (*attr).ns }).is_null() && xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = unsafe { (*node).children };
    while !child.is_null() {
        if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"appinfo\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            attr = unsafe { (*child).properties };
            while !attr.is_null() {
                if (unsafe { (*attr).ns }).is_null()
                    && xmlStrEqual(
                        unsafe { (*attr).name },
                        b"source\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) == 0
                    || !(unsafe { (*attr).ns }).is_null() && xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0
                {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                        attr,
                    );
                }
                attr = unsafe { (*attr).next };
            }
            xmlSchemaPValAttr(
                ctxt,
                0 as xmlSchemaBasicItemPtr,
                child,
                b"source\0" as *const u8 as *const i8,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
                0 as *mut *const u8,
            );
            child = unsafe { (*child).next };
        } else if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"documentation\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            attr = unsafe { (*child).properties };
            while !attr.is_null() {
                if (unsafe { (*attr).ns }).is_null() {
                    if xmlStrEqual(
                        unsafe { (*attr).name },
                        b"source\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) == 0
                    {
                        xmlSchemaPIllegalAttrErr(
                            ctxt,
                            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                            Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                            attr,
                        );
                    }
                } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0
                    || xmlStrEqual(
                        unsafe { (*attr).name },
                        b"lang\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) != 0
                        && xmlStrEqual(
                            unsafe { (*(*attr).ns).href },
                            b"http://www.w3.org/XML/1998/namespace\0" as *const u8 as *const i8
                                as *const xmlChar,
                        ) == 0
                {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                        attr,
                    );
                }
                attr = unsafe { (*attr).next };
            }
            attr = xmlSchemaGetPropNodeNs(
                child,
                b"http://www.w3.org/XML/1998/namespace\0" as *const u8 as *const i8
                    as *const xmlChar as *const i8,
                b"lang\0" as *const u8 as *const i8,
            );
            if !attr.is_null() {
                xmlSchemaPValAttrNode(
                    ctxt,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                    xmlSchemaGetBuiltInType(XML_SCHEMAS_LANGUAGE),
                    0 as *mut *const u8,
                );
            }
            child = unsafe { (*child).next };
        } else {
            if barked == 0 {
                xmlSchemaPContentErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    child,
                    0 as *const i8,
                    b"(appinfo | documentation)*\0" as *const u8 as *const i8,
                );
            }
            barked = 1 as i32;
            child = unsafe { (*child).next };
        }
    }
    return ret;
}
extern "C" fn xmlSchemaParseFacet<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *mut crate::src::xmlschemas::_xmlSchemaFacet<'a3> {
    let mut facet: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as *mut xmlSchemaFacet;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut value: *const u8 = 0 as *const xmlChar;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaFacetPtr;
    }
    facet = xmlSchemaNewFacet();
    if facet.is_null() {
        xmlSchemaPErrMemory(ctxt, b"allocating facet\0" as *const u8 as *const i8, node);
        return 0 as xmlSchemaFacetPtr;
    }
    let fresh89 = unsafe { &mut ((*facet).node) };
    *fresh89 = node;
    value = xmlSchemaGetProp(ctxt, node, b"value\0" as *const u8 as *const i8);
    if value.is_null() {
        xmlSchemaPErr2(
            ctxt,
            node,
            child,
            XML_SCHEMAP_FACET_NO_VALUE as i32,
            b"Facet %s has no value\n\0" as *const u8 as *const i8,
            unsafe { (*node).name },
            0 as *const xmlChar,
        );
        xmlSchemaFreeFacet(facet);
        return 0 as xmlSchemaFacetPtr;
    }
    if !node.is_null()
        && !(unsafe { (*node).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*node).name },
            b"minInclusive\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*node).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        (unsafe { (*facet).type_0 = XML_SCHEMA_FACET_MININCLUSIVE });
    } else if !node.is_null()
        && !(unsafe { (*node).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*node).name },
            b"minExclusive\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*node).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        (unsafe { (*facet).type_0 = XML_SCHEMA_FACET_MINEXCLUSIVE });
    } else if !node.is_null()
        && !(unsafe { (*node).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*node).name },
            b"maxInclusive\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*node).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        (unsafe { (*facet).type_0 = XML_SCHEMA_FACET_MAXINCLUSIVE });
    } else if !node.is_null()
        && !(unsafe { (*node).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*node).name },
            b"maxExclusive\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*node).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        (unsafe { (*facet).type_0 = XML_SCHEMA_FACET_MAXEXCLUSIVE });
    } else if !node.is_null()
        && !(unsafe { (*node).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*node).name },
            b"totalDigits\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*node).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        (unsafe { (*facet).type_0 = XML_SCHEMA_FACET_TOTALDIGITS });
    } else if !node.is_null()
        && !(unsafe { (*node).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*node).name },
            b"fractionDigits\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*node).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        (unsafe { (*facet).type_0 = XML_SCHEMA_FACET_FRACTIONDIGITS });
    } else if !node.is_null()
        && !(unsafe { (*node).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*node).name },
            b"pattern\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*node).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        (unsafe { (*facet).type_0 = XML_SCHEMA_FACET_PATTERN });
    } else if !node.is_null()
        && !(unsafe { (*node).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*node).name },
            b"enumeration\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*node).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        (unsafe { (*facet).type_0 = XML_SCHEMA_FACET_ENUMERATION });
    } else if !node.is_null()
        && !(unsafe { (*node).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*node).name },
            b"whiteSpace\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*node).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        (unsafe { (*facet).type_0 = XML_SCHEMA_FACET_WHITESPACE });
    } else if !node.is_null()
        && !(unsafe { (*node).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*node).name },
            b"length\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*node).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        (unsafe { (*facet).type_0 = XML_SCHEMA_FACET_LENGTH });
    } else if !node.is_null()
        && !(unsafe { (*node).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*node).name },
            b"maxLength\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*node).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        (unsafe { (*facet).type_0 = XML_SCHEMA_FACET_MAXLENGTH });
    } else if !node.is_null()
        && !(unsafe { (*node).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*node).name },
            b"minLength\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*node).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        (unsafe { (*facet).type_0 = XML_SCHEMA_FACET_MINLENGTH });
    } else {
        xmlSchemaPErr2(
            ctxt,
            node,
            child,
            XML_SCHEMAP_UNKNOWN_FACET_TYPE as i32,
            b"Unknown facet type %s\n\0" as *const u8 as *const i8,
            unsafe { (*node).name },
            0 as *const xmlChar,
        );
        xmlSchemaFreeFacet(facet);
        return 0 as xmlSchemaFacetPtr;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    let fresh90 = unsafe { &mut ((*facet).value) };
    *fresh90 = value;
    if (unsafe { (*facet).type_0 }) as u32 != XML_SCHEMA_FACET_PATTERN as i32 as u32
        && (unsafe { (*facet).type_0 }) as u32 != XML_SCHEMA_FACET_ENUMERATION as i32 as u32
    {
        let mut fixed: *const u8 = 0 as *const xmlChar;
        fixed = xmlSchemaGetProp(ctxt, node, b"fixed\0" as *const u8 as *const i8);
        if !fixed.is_null() {
            if xmlStrEqual(fixed, b"true\0" as *const u8 as *const i8 as *mut xmlChar) != 0 {
                (unsafe { (*facet).fixed = 1 as i32 });
            }
        }
    }
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        let fresh91 = unsafe { &mut ((*facet).annot) };
        *fresh91 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = unsafe { (*child).next };
    }
    if !child.is_null() {
        xmlSchemaPErr2(
            ctxt,
            node,
            child,
            XML_SCHEMAP_UNKNOWN_FACET_CHILD as i32,
            b"Facet %s has unexpected child content\n\0" as *const u8 as *const i8,
            unsafe { (*node).name },
            0 as *const xmlChar,
        );
    }
    return facet;
}
extern "C" fn xmlSchemaParseWildcardNs<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut _schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut wildc: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a3>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> i32 {
    let mut pc: *const u8 = 0 as *const xmlChar;
    let mut ns: *const u8 = 0 as *const xmlChar;
    let mut dictnsItem: *const u8 = 0 as *const xmlChar;
    let mut ret: i32 = 0 as i32;
    let mut nsItem: *mut u8 = 0 as *mut xmlChar;
    let mut tmp: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs = 0 as *mut xmlSchemaWildcardNs;
    let mut lastNs: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs = 0 as xmlSchemaWildcardNsPtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    pc = xmlSchemaGetProp(ctxt, node, b"processContents\0" as *const u8 as *const i8);
    if pc.is_null() || xmlStrEqual(pc, b"strict\0" as *const u8 as *const i8 as *const xmlChar) != 0
    {
        (unsafe { (*wildc).processContents = 3 as i32 });
    } else if xmlStrEqual(pc, b"skip\0" as *const u8 as *const i8 as *const xmlChar) != 0 {
        (unsafe { (*wildc).processContents = 1 as i32 });
    } else if xmlStrEqual(pc, b"lax\0" as *const u8 as *const i8 as *const xmlChar) != 0 {
        (unsafe { (*wildc).processContents = 2 as i32 });
    } else {
        xmlSchemaPSimpleTypeErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            node,
            0 as xmlSchemaTypePtr,
            b"(strict | skip | lax)\0" as *const u8 as *const i8,
            pc,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        (unsafe { (*wildc).processContents = 3 as i32 });
        ret = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as i32;
    }
    attr = xmlSchemaGetPropNode(node, b"namespace\0" as *const u8 as *const i8);
    ns = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
    if attr.is_null() || xmlStrEqual(ns, b"##any\0" as *const u8 as *const i8 as *mut xmlChar) != 0
    {
        (unsafe { (*wildc).any = 1 as i32 });
    } else if xmlStrEqual(ns, b"##other\0" as *const u8 as *const i8 as *mut xmlChar) != 0 {
        let fresh92 = unsafe { &mut ((*wildc).negNsSet) };
        *fresh92 = xmlSchemaNewWildcardNsConstraint(ctxt);
        if (unsafe { (*wildc).negNsSet }).is_null() {
            return -(1 as i32);
        }
        let fresh93 = unsafe { &mut ((*(*wildc).negNsSet).value) };
        *fresh93 = unsafe { (*ctxt).targetNamespace };
    } else {
        let mut end: *const u8 = 0 as *const xmlChar;
        let mut cur: *const u8 = 0 as *const xmlChar;
        cur = ns;
        loop {
            while (unsafe { *cur }) as i32 == 0x20 as i32
                || 0x9 as i32 <= (unsafe { *cur }) as i32 && (unsafe { *cur }) as i32 <= 0xa as i32
                || (unsafe { *cur }) as i32 == 0xd as i32
            {
                cur = unsafe { cur.offset(1) };
            }
            end = cur;
            while (unsafe { *end }) as i32 != 0 as i32
                && !((unsafe { *end }) as i32 == 0x20 as i32
                    || 0x9 as i32 <= (unsafe { *end }) as i32 && (unsafe { *end }) as i32 <= 0xa as i32
                    || (unsafe { *end }) as i32 == 0xd as i32)
            {
                end = unsafe { end.offset(1) };
            }
            if end == cur {
                break;
            }
            nsItem = xmlStrndup(cur, (unsafe { end.offset_from(cur) }) as i64 as i32);
            if xmlStrEqual(
                nsItem,
                b"##other\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
                || xmlStrEqual(nsItem, b"##any\0" as *const u8 as *const i8 as *mut xmlChar) != 0
            {
                xmlSchemaPSimpleTypeErr(
                    ctxt,
                    XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER,
                    0 as xmlSchemaBasicItemPtr,
                    attr as xmlNodePtr,
                    0 as xmlSchemaTypePtr,
                    b"((##any | ##other) | List of (xs:anyURI | (##targetNamespace | ##local)))\0"
                        as *const u8 as *const i8,
                    nsItem,
                    0 as *const i8,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
                ret = XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER as i32;
            } else {
                if xmlStrEqual(
                    nsItem,
                    b"##targetNamespace\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                    dictnsItem = unsafe { (*ctxt).targetNamespace };
                } else if xmlStrEqual(
                    nsItem,
                    b"##local\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                    dictnsItem = 0 as *const xmlChar;
                } else {
                    xmlSchemaPValAttrNodeValue(
                        ctxt,
                        0 as xmlSchemaBasicItemPtr,
                        attr,
                        nsItem,
                        xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
                    );
                    dictnsItem = unsafe { xmlDictLookup((*ctxt).dict, nsItem, -(1 as i32)) };
                }
                tmp = unsafe { (*wildc).nsSet };
                while !tmp.is_null() {
                    if dictnsItem == (unsafe { (*tmp).value }) {
                        break;
                    }
                    tmp = unsafe { (*tmp).next };
                }
                if tmp.is_null() {
                    tmp = xmlSchemaNewWildcardNsConstraint(ctxt);
                    if tmp.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(nsItem as *mut libc::c_void) });
                        return -(1 as i32);
                    }
                    let fresh94 = unsafe { &mut ((*tmp).value) };
                    *fresh94 = dictnsItem;
                    let fresh95 = unsafe { &mut ((*tmp).next) };
                    *fresh95 = 0 as *mut _xmlSchemaWildcardNs;
                    if (unsafe { (*wildc).nsSet }).is_null() {
                        let fresh96 = unsafe { &mut ((*wildc).nsSet) };
                        *fresh96 = tmp;
                    } else if !lastNs.is_null() {
                        let fresh97 = unsafe { &mut ((*lastNs).next) };
                        *fresh97 = tmp;
                    }
                    lastNs = tmp;
                }
            }
            (unsafe { xmlFree.expect("non-null function pointer")(nsItem as *mut libc::c_void) });
            cur = end;
            if !((unsafe { *cur }) as i32 != 0 as i32) {
                break;
            }
        }
    }
    return ret;
}
extern "C" fn xmlSchemaPCheckParticleCorrect_2<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut _item: *mut crate::src::xmlschemas::_xmlSchemaParticle,
    mut node: *mut crate::src::threads::_xmlNode,
    mut minOccurs: i32,
    mut maxOccurs: i32,
) -> i32 {
    if maxOccurs == 0 as i32 && minOccurs == 0 as i32 {
        return 0 as i32;
    }
    if maxOccurs != (1 as i32) << 30 as i32 {
        if maxOccurs < 1 as i32 {
            xmlSchemaPCustomAttrErr(
                ctxt,
                XML_SCHEMAP_P_PROPS_CORRECT_2_2,
                Option::<&'_ mut *mut u8>::None,
                0 as xmlSchemaBasicItemPtr,
                xmlSchemaGetPropNode(node, b"maxOccurs\0" as *const u8 as *const i8),
                b"The value must be greater than or equal to 1\0" as *const u8 as *const i8,
            );
            return XML_SCHEMAP_P_PROPS_CORRECT_2_2 as i32;
        } else {
            if minOccurs > maxOccurs {
                xmlSchemaPCustomAttrErr(
                    ctxt,
                    XML_SCHEMAP_P_PROPS_CORRECT_2_1,
                    Option::<&'_ mut *mut u8>::None,
                    0 as xmlSchemaBasicItemPtr,
                    xmlSchemaGetPropNode(node, b"minOccurs\0" as *const u8 as *const i8),
                    b"The value must not be greater than the value of 'maxOccurs'\0" as *const u8
                        as *const i8,
                );
                return XML_SCHEMAP_P_PROPS_CORRECT_2_1 as i32;
            }
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaParseAny<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *mut crate::src::xmlschemas::_xmlSchemaParticle {
    let mut particle: *mut crate::src::xmlschemas::_xmlSchemaParticle = 0 as *mut xmlSchemaParticle;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut wild: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'_> = 0 as *mut xmlSchemaWildcard;
    let mut min: i32 = 0;
    let mut max: i32 = 0;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    let mut annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot = 0 as xmlSchemaAnnotPtr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaParticlePtr;
    }
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"minOccurs\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"maxOccurs\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"namespace\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"processContents\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    max = xmlGetMaxOccurs(
        ctxt,
        node,
        0 as i32,
        (1 as i32) << 30 as i32,
        1 as i32,
        b"(xs:nonNegativeInteger | unbounded)\0" as *const u8 as *const i8,
    );
    min = xmlGetMinOccurs(
        ctxt,
        node,
        0 as i32,
        -(1 as i32),
        1 as i32,
        b"xs:nonNegativeInteger\0" as *const u8 as *const i8,
    );
    xmlSchemaPCheckParticleCorrect_2(ctxt, 0 as xmlSchemaParticlePtr, node, min, max);
    wild = xmlSchemaAddWildcard(ctxt, schema, XML_SCHEMA_TYPE_ANY, node);
    if wild.is_null() {
        return 0 as xmlSchemaParticlePtr;
    }
    xmlSchemaParseWildcardNs(ctxt, schema, wild, node);
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        annot = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = unsafe { (*child).next };
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?)\0" as *const u8 as *const i8,
        );
    }
    if min == 0 as i32 && max == 0 as i32 {
        return 0 as xmlSchemaParticlePtr;
    }
    particle = xmlSchemaAddParticle(ctxt, node, min, max);
    if particle.is_null() {
        return 0 as xmlSchemaParticlePtr;
    }
    let fresh98 = unsafe { &mut ((*particle).annot) };
    *fresh98 = annot;
    let fresh99 = unsafe { &mut ((*particle).children) };
    *fresh99 = wild as xmlSchemaTreeItemPtr;
    return particle;
}
extern "C" fn xmlSchemaParseNotation<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *mut crate::src::xmlschemas::_xmlSchemaNotation<'a3> {
    let mut name: *const u8 = 0 as *const xmlChar;
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaNotation<'_> = 0 as *mut xmlSchemaNotation;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaNotationPtr;
    }
    name = xmlSchemaGetProp(ctxt, node, b"name\0" as *const u8 as *const i8);
    if name.is_null() {
        xmlSchemaPErr2(
            ctxt,
            node,
            child,
            XML_SCHEMAP_NOTATION_NO_NAME as i32,
            b"Notation has no name\n\0" as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return 0 as xmlSchemaNotationPtr;
    }
    ret = xmlSchemaAddNotation(ctxt, schema, name, unsafe { (*ctxt).targetNamespace }, node);
    if ret.is_null() {
        return 0 as xmlSchemaNotationPtr;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        let fresh100 = unsafe { &mut ((*ret).annot) };
        *fresh100 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = unsafe { (*child).next };
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?)\0" as *const u8 as *const i8,
        );
    }
    return ret;
}
extern "C" fn xmlSchemaParseAnyAttribute<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a3> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'_> = 0 as *mut xmlSchemaWildcard;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaWildcardPtr;
    }
    ret = xmlSchemaAddWildcard(ctxt, schema, XML_SCHEMA_TYPE_ANY_ATTRIBUTE, node);
    if ret.is_null() {
        return 0 as xmlSchemaWildcardPtr;
    }
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"namespace\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"processContents\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    if xmlSchemaParseWildcardNs(ctxt, schema, ret, node) != 0 as i32 {
        return 0 as xmlSchemaWildcardPtr;
    }
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        let fresh101 = unsafe { &mut ((*ret).annot) };
        *fresh101 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = unsafe { (*child).next };
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?)\0" as *const u8 as *const i8,
        );
    }
    return ret;
}
extern "C" fn xmlSchemaParseLocalAttribute<'a1, 'a2, 'a3>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut uses: *mut crate::src::xmlschemas::_xmlSchemaItemList,
    mut parentType: i32,
) -> *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a3>
where
    'a1: 'static,
{
    let mut current_block: u64;
    let mut attrValue: *const u8 = 0 as *const xmlChar;
    let mut name: *const u8 = 0 as *const xmlChar;
    let mut ns: *const u8 = 0 as *const xmlChar;
    let mut use_0: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_> =
        0 as xmlSchemaAttributeUsePtr;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    let mut tmpNs: *const u8 = 0 as *const xmlChar;
    let mut tmpName: *const u8 = 0 as *const xmlChar;
    let mut defValue: *const u8 = 0 as *const xmlChar;
    let mut isRef: i32 = 0 as i32;
    let mut occurs: i32 = 2 as i32;
    let mut nberrors: i32 = 0;
    let mut hasForm: i32 = 0 as i32;
    let mut defValueType: i32 = 0 as i32;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaBasicItemPtr;
    }
    attr = xmlSchemaGetPropNode(node, b"ref\0" as *const u8 as *const i8);
    if !attr.is_null() {
        if xmlSchemaPValAttrNodeQName(
            pctxt,
            schema,
            0 as xmlSchemaBasicItemPtr,
            attr,
            Some(&mut tmpNs),
            Some(&mut tmpName),
        ) != 0 as i32
        {
            return 0 as xmlSchemaBasicItemPtr;
        }
        if xmlSchemaCheckReference(pctxt, schema, node, attr, tmpNs) != 0 as i32 {
            return 0 as xmlSchemaBasicItemPtr;
        }
        isRef = 1 as i32;
    }
    nberrors = unsafe { (*pctxt).nberrors };
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if isRef != 0 {
                if xmlStrEqual(
                    unsafe { (*attr).name },
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                    xmlSchemaPValAttrNodeID(pctxt, attr);
                    current_block = 7049889939919688114;
                } else if xmlStrEqual(
                    unsafe { (*attr).name },
                    b"ref\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                    current_block = 7049889939919688114;
                } else {
                    current_block = 9007357115414505193;
                }
            } else if xmlStrEqual(
                unsafe { (*attr).name },
                b"name\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
                current_block = 7049889939919688114;
            } else if xmlStrEqual(
                unsafe { (*attr).name },
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
                xmlSchemaPValAttrNodeID(pctxt, attr);
                current_block = 7049889939919688114;
            } else if xmlStrEqual(
                unsafe { (*attr).name },
                b"type\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
                xmlSchemaPValAttrNodeQName(
                    pctxt,
                    schema,
                    0 as xmlSchemaBasicItemPtr,
                    attr,
                    Some(&mut tmpNs),
                    Some(&mut tmpName),
                );
                current_block = 7049889939919688114;
            } else if xmlStrEqual(
                unsafe { (*attr).name },
                b"form\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
                hasForm = 1 as i32;
                attrValue = xmlSchemaGetNodeContent(pctxt, attr as xmlNodePtr);
                if xmlStrEqual(
                    attrValue,
                    b"qualified\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0
                {
                    ns = unsafe { (*pctxt).targetNamespace };
                } else if xmlStrEqual(
                    attrValue,
                    b"unqualified\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                {
                    xmlSchemaPSimpleTypeErr(
                        pctxt,
                        XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                        0 as xmlSchemaBasicItemPtr,
                        attr as xmlNodePtr,
                        0 as xmlSchemaTypePtr,
                        b"(qualified | unqualified)\0" as *const u8 as *const i8,
                        attrValue,
                        0 as *const i8,
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                }
                current_block = 7049889939919688114;
            } else {
                current_block = 9007357115414505193;
            }
            match current_block {
                7049889939919688114 => {},
                _ => {
                    if xmlStrEqual(
                        unsafe { (*attr).name },
                        b"use\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) != 0
                    {
                        attrValue = xmlSchemaGetNodeContent(pctxt, attr as xmlNodePtr);
                        if xmlStrEqual(
                            attrValue,
                            b"optional\0" as *const u8 as *const i8 as *mut xmlChar,
                        ) != 0
                        {
                            occurs = 2 as i32;
                        } else if xmlStrEqual(
                            attrValue,
                            b"prohibited\0" as *const u8 as *const i8 as *mut xmlChar,
                        ) != 0
                        {
                            occurs = 0 as i32;
                        } else if xmlStrEqual(
                            attrValue,
                            b"required\0" as *const u8 as *const i8 as *mut xmlChar,
                        ) != 0
                        {
                            occurs = 1 as i32;
                        } else {
                            xmlSchemaPSimpleTypeErr(
                                pctxt,
                                XML_SCHEMAP_INVALID_ATTR_USE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr,
                                0 as xmlSchemaTypePtr,
                                b"(optional | prohibited | required)\0" as *const u8 as *const i8,
                                attrValue,
                                0 as *const i8,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        }
                        current_block = 7049889939919688114;
                    } else if xmlStrEqual(
                        unsafe { (*attr).name },
                        b"default\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) != 0
                    {
                        if !defValue.is_null() {
                            xmlSchemaPMutualExclAttrErr(
                                pctxt,
                                XML_SCHEMAP_SRC_ATTRIBUTE_1,
                                0 as xmlSchemaBasicItemPtr,
                                attr,
                                b"default\0" as *const u8 as *const i8,
                                b"fixed\0" as *const u8 as *const i8,
                            );
                        } else {
                            defValue = xmlSchemaGetNodeContent(pctxt, attr as xmlNodePtr);
                            defValueType = 1 as i32;
                        }
                        current_block = 7049889939919688114;
                    } else if xmlStrEqual(
                        unsafe { (*attr).name },
                        b"fixed\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) != 0
                    {
                        if !defValue.is_null() {
                            xmlSchemaPMutualExclAttrErr(
                                pctxt,
                                XML_SCHEMAP_SRC_ATTRIBUTE_1,
                                0 as xmlSchemaBasicItemPtr,
                                attr,
                                b"default\0" as *const u8 as *const i8,
                                b"fixed\0" as *const u8 as *const i8,
                            );
                        } else {
                            defValue = xmlSchemaGetNodeContent(pctxt, attr as xmlNodePtr);
                            defValueType = 2 as i32;
                        }
                        current_block = 7049889939919688114;
                    } else {
                        current_block = 981995395831942902;
                    }
                },
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) == 0 {
            current_block = 7049889939919688114;
        } else {
            current_block = 981995395831942902;
        }
        match current_block {
            981995395831942902 => {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            },
            _ => {},
        }
        attr = unsafe { (*attr).next };
    }
    if defValueType == 1 as i32 && occurs != 2 as i32 {
        xmlSchemaPSimpleTypeErr (pctxt , XML_SCHEMAP_SRC_ATTRIBUTE_2 , 0 as xmlSchemaBasicItemPtr , node , 0 as xmlSchemaTypePtr , b"(optional | prohibited | required)\0" as * const u8 as * const i8 , 0 as * const xmlChar , b"The value of the attribute 'use' must be 'optional' if the attribute 'default' is present\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
    }
    if nberrors != (unsafe { (*pctxt).nberrors }) {
        return 0 as xmlSchemaBasicItemPtr;
    }
    if isRef == 0 {
        let mut attrDecl: *mut crate::src::xmlschemas::_xmlSchemaAttribute<'_> =
            0 as *mut xmlSchemaAttribute;
        if hasForm == 0 && (unsafe { (*schema).flags }) & (1 as i32) << 1 as i32 != 0 {
            ns = unsafe { (*pctxt).targetNamespace };
        }
        if xmlStrEqual(ns, unsafe { xmlSchemaInstanceNs }) != 0 {
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_NO_XSI,
                node,
                0 as xmlSchemaBasicItemPtr,
                b"The target namespace must not match '%s'\0" as *const u8 as *const i8,
                unsafe { xmlSchemaInstanceNs },
                0 as *const xmlChar,
            );
        }
        attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const i8);
        if attr.is_null() {
            xmlSchemaPMissingAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"name\0" as *const u8 as *const i8,
                0 as *const i8,
            );
            return 0 as xmlSchemaBasicItemPtr;
        }
        if xmlSchemaPValAttrNode(
            pctxt,
            0 as xmlSchemaBasicItemPtr,
            attr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
            &mut name,
        ) != 0 as i32
        {
            return 0 as xmlSchemaBasicItemPtr;
        }
        if xmlStrEqual(name, b"xmlns\0" as *const u8 as *const i8 as *mut xmlChar) != 0 {
            xmlSchemaPSimpleTypeErr(
                pctxt,
                XML_SCHEMAP_NO_XMLNS,
                0 as xmlSchemaBasicItemPtr,
                attr as xmlNodePtr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                0 as *const i8,
                0 as *const xmlChar,
                b"The value of the attribute must not match 'xmlns'\0" as *const u8 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return 0 as xmlSchemaBasicItemPtr;
        }
        if !(occurs == 0 as i32) {
            use_0 = xmlSchemaAddAttributeUse(pctxt, node);
            if use_0.is_null() {
                return 0 as xmlSchemaBasicItemPtr;
            }
            (unsafe { (*use_0).occurs = occurs });
            attrDecl = xmlSchemaAddAttribute(pctxt, schema, name, ns, node, 0 as i32);
            if attrDecl.is_null() {
                return 0 as xmlSchemaBasicItemPtr;
            }
            if !tmpName.is_null() {
                let fresh102 = unsafe { &mut ((*attrDecl).typeName) };
                *fresh102 = tmpName;
                let fresh103 = unsafe { &mut ((*attrDecl).typeNs) };
                *fresh103 = tmpNs;
            }
            let fresh104 = unsafe { &mut ((*use_0).attrDecl) };
            *fresh104 = attrDecl;
            if !defValue.is_null() {
                let fresh105 = unsafe { &mut ((*attrDecl).defValue) };
                *fresh105 = defValue;
                if defValueType == 2 as i32 {
                    (unsafe { (*attrDecl).flags |= (1 as i32) << 9 as i32 });
                }
            }
        }
    } else if occurs != 0 as i32 {
        let mut ref_0: *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'_> =
            0 as *mut xmlSchemaQNameRef;
        use_0 = xmlSchemaAddAttributeUse(pctxt, node);
        if use_0.is_null() {
            return 0 as xmlSchemaBasicItemPtr;
        }
        xmlSchemaAddItemSize(
            Some(unsafe { &mut (*(*pctxt).constructor).pending }),
            10 as i32,
            use_0 as *mut libc::c_void,
        );
        (unsafe { (*use_0).occurs = occurs });
        ref_0 = xmlSchemaNewQNameRef(pctxt, XML_SCHEMA_TYPE_ATTRIBUTE, tmpName, tmpNs);
        if ref_0.is_null() {
            return 0 as xmlSchemaBasicItemPtr;
        }
        let fresh106 = unsafe { &mut ((*use_0).attrDecl) };
        *fresh106 = ref_0 as xmlSchemaAttributePtr;
        if !defValue.is_null() {
            let fresh107 = unsafe { &mut ((*use_0).defValue) };
            *fresh107 = defValue;
        }
        if defValueType == 2 as i32 {
            (unsafe { (*use_0).flags |= (1 as i32) << 0 as i32 });
        }
    }
    child = unsafe { (*node).children };
    if occurs == 0 as i32 {
        let mut prohib: *mut crate::src::xmlschemas::_xmlSchemaAttributeUseProhib =
            0 as *mut xmlSchemaAttributeUseProhib;
        if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            xmlSchemaParseAnnotation(pctxt, child, 0 as i32);
            child = unsafe { (*child).next };
        }
        if !child.is_null() {
            xmlSchemaPContentErr(
                pctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"(annotation?)\0" as *const u8 as *const i8,
            );
        }
        if parentType == XML_SCHEMA_TYPE_ATTRIBUTEGROUP as i32 {
            xmlSchemaCustomWarning (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH , node , Option :: < & '_ mut crate :: src :: xmlschemas :: _xmlSchemaType < '_ > > :: None , b"Skipping attribute use prohibition, since it is pointless inside an <attributeGroup>\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
            return 0 as xmlSchemaBasicItemPtr;
        } else {
            if parentType == XML_SCHEMA_TYPE_EXTENSION as i32 {
                xmlSchemaCustomWarning (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH , node , Option :: < & '_ mut crate :: src :: xmlschemas :: _xmlSchemaType < '_ > > :: None , b"Skipping attribute use prohibition, since it is pointless when extending a type\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
                return 0 as xmlSchemaBasicItemPtr;
            }
        }
        if isRef == 0 {
            tmpName = name;
            tmpNs = ns;
        }
        if !uses.is_null() {
            let mut i: i32 = 0;
            i = 0 as i32;
            while i < (unsafe { (*uses).nbItems }) {
                use_0 = (unsafe { *((*uses).items).offset(i as isize) }) as xmlSchemaAttributeUsePtr;
                if (unsafe { (*use_0).type_0 }) as u32 == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB as i32 as u32
                    && tmpName == (unsafe { (*(use_0 as xmlSchemaAttributeUseProhibPtr)).name })
                    && tmpNs == (unsafe { (*(use_0 as xmlSchemaAttributeUseProhibPtr)).targetNamespace })
                {
                    let mut str: *mut u8 = 0 as *mut xmlChar;
                    xmlSchemaCustomWarning(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH,
                        node,
                        Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaType<'_>>::None,
                        b"Skipping duplicate attribute use prohibition '%s'\0" as *const u8
                            as *const i8,
                        xmlSchemaFormatQName(Some(&mut str), tmpNs, tmpName),
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                    if !str.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                        str = 0 as *mut xmlChar;
                    }
                    return 0 as xmlSchemaBasicItemPtr;
                }
                i += 1;
            }
        }
        prohib = xmlSchemaAddAttributeUseProhib(pctxt);
        if prohib.is_null() {
            return 0 as xmlSchemaBasicItemPtr;
        }
        let fresh108 = unsafe { &mut ((*prohib).node) };
        *fresh108 = node;
        let fresh109 = unsafe { &mut ((*prohib).name) };
        *fresh109 = tmpName;
        let fresh110 = unsafe { &mut ((*prohib).targetNamespace) };
        *fresh110 = tmpNs;
        if isRef != 0 {
            xmlSchemaAddItemSize(
                Some(unsafe { &mut (*(*pctxt).constructor).pending }),
                10 as i32,
                prohib as *mut libc::c_void,
            );
        }
        return prohib as xmlSchemaBasicItemPtr;
    } else {
        if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            let fresh111 = unsafe { &mut ((*use_0).annot) };
            *fresh111 = xmlSchemaParseAnnotation(pctxt, child, 1 as i32);
            child = unsafe { (*child).next };
        }
        if isRef != 0 {
            if !child.is_null() {
                if !child.is_null()
                    && !(unsafe { (*child).ns }).is_null()
                    && xmlStrEqual(
                        unsafe { (*child).name },
                        b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0
                    && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                {
                    xmlSchemaPContentErr(
                        pctxt,
                        XML_SCHEMAP_SRC_ATTRIBUTE_3_2,
                        0 as xmlSchemaBasicItemPtr,
                        node,
                        child,
                        0 as *const i8,
                        b"(annotation?)\0" as *const u8 as *const i8,
                    );
                } else {
                    xmlSchemaPContentErr(
                        pctxt,
                        XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                        0 as xmlSchemaBasicItemPtr,
                        node,
                        child,
                        0 as *const i8,
                        b"(annotation?)\0" as *const u8 as *const i8,
                    );
                }
            }
        } else {
            if !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            {
                if !(unsafe { (*(*use_0).attrDecl).typeName }).is_null() {
                    xmlSchemaPContentErr(
                        pctxt,
                        XML_SCHEMAP_SRC_ATTRIBUTE_4,
                        0 as xmlSchemaBasicItemPtr,
                        node,
                        child,
                        b"The attribute 'type' and the <simpleType> child are mutually exclusive\0"
                            as *const u8 as *const i8,
                        0 as *const i8,
                    );
                } else {
                    let fresh112 = unsafe { &mut ((*(*use_0).attrDecl).subtypes) };
                    *fresh112 = xmlSchemaParseSimpleType(pctxt, schema, child, 0 as i32);
                }
                child = unsafe { (*child).next };
            }
            if !child.is_null() {
                xmlSchemaPContentErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    child,
                    0 as *const i8,
                    b"(annotation?, simpleType?)\0" as *const u8 as *const i8,
                );
            }
        }
    }
    return use_0 as xmlSchemaBasicItemPtr;
}
extern "C" fn xmlSchemaParseGlobalAttribute<'a1, 'a2, 'a3>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *mut crate::src::xmlschemas::_xmlSchemaAttribute<'a3>
where
    'a1: 'a3,
    'a3: 'static,
    'a3: 'a1,
{
    let mut attrValue: *const u8 = 0 as *const xmlChar;
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaAttribute<'_> =
        0 as *mut xmlSchemaAttribute;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaAttributePtr;
    }
    attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const i8);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"name\0" as *const u8 as *const i8,
            0 as *const i8,
        );
        return 0 as xmlSchemaAttributePtr;
    }
    if xmlSchemaPValAttrNode(
        pctxt,
        0 as xmlSchemaBasicItemPtr,
        attr,
        xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
        &mut attrValue,
    ) != 0 as i32
    {
        return 0 as xmlSchemaAttributePtr;
    }
    if xmlStrEqual(
        attrValue,
        b"xmlns\0" as *const u8 as *const i8 as *mut xmlChar,
    ) != 0
    {
        xmlSchemaPSimpleTypeErr(
            pctxt,
            XML_SCHEMAP_NO_XMLNS,
            0 as xmlSchemaBasicItemPtr,
            attr as xmlNodePtr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
            0 as *const i8,
            0 as *const xmlChar,
            b"The value of the attribute must not match 'xmlns'\0" as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return 0 as xmlSchemaAttributePtr;
    }
    if xmlStrEqual(unsafe { (*pctxt).targetNamespace }, unsafe { xmlSchemaInstanceNs }) != 0 {
        xmlSchemaCustomErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_NO_XSI,
            node,
            0 as xmlSchemaBasicItemPtr,
            b"The target namespace must not match '%s'\0" as *const u8 as *const i8,
            unsafe { xmlSchemaInstanceNs },
            0 as *const xmlChar,
        );
    }
    ret = xmlSchemaAddAttribute(
        pctxt,
        schema,
        attrValue,
        unsafe { (*pctxt).targetNamespace },
        node,
        1 as i32,
    );
    if ret.is_null() {
        return 0 as xmlSchemaAttributePtr;
    }
    (unsafe { (*ret).flags |= (1 as i32) << 0 as i32 });
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"default\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"fixed\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"name\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"type\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    xmlSchemaPValAttrQName(
        pctxt,
        schema,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"type\0" as *const u8 as *const i8,
        Some(unsafe { &mut (*ret).typeNs }),
        Some(unsafe { &mut (*ret).typeName }),
    );
    xmlSchemaPValAttrID(
        pctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    let fresh113 = unsafe { &mut ((*ret).defValue) };
    *fresh113 = xmlSchemaGetProp(pctxt, node, b"fixed\0" as *const u8 as *const i8);
    if !(unsafe { (*ret).defValue }).is_null() {
        (unsafe { (*ret).flags |= (1 as i32) << 9 as i32 });
    }
    attr = xmlSchemaGetPropNode(node, b"default\0" as *const u8 as *const i8);
    if !attr.is_null() {
        if (unsafe { (*ret).flags }) & (1 as i32) << 9 as i32 != 0 {
            xmlSchemaPMutualExclAttrErr(
                pctxt,
                XML_SCHEMAP_SRC_ATTRIBUTE_1,
                ret as xmlSchemaBasicItemPtr,
                attr,
                b"default\0" as *const u8 as *const i8,
                b"fixed\0" as *const u8 as *const i8,
            );
        } else {
            let fresh114 = unsafe { &mut ((*ret).defValue) };
            *fresh114 = xmlSchemaGetNodeContent(pctxt, attr as xmlNodePtr);
        }
    }
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        let fresh115 = unsafe { &mut ((*ret).annot) };
        *fresh115 = xmlSchemaParseAnnotation(pctxt, child, 1 as i32);
        child = unsafe { (*child).next };
    }
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        if !(unsafe { (*ret).typeName }).is_null() {
            xmlSchemaPContentErr(
                pctxt,
                XML_SCHEMAP_SRC_ATTRIBUTE_4,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                b"The attribute 'type' and the <simpleType> child are mutually exclusive\0"
                    as *const u8 as *const i8,
                0 as *const i8,
            );
        } else {
            let fresh116 = unsafe { &mut ((*ret).subtypes) };
            *fresh116 = xmlSchemaParseSimpleType(pctxt, schema, child, 0 as i32);
        }
        child = unsafe { (*child).next };
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            pctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, simpleType?)\0" as *const u8 as *const i8,
        );
    }
    return ret;
}
extern "C" fn xmlSchemaParseAttributeGroupRef<'a1, 'a2, 'a3>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'a3> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'_> = 0 as *mut xmlSchemaQNameRef;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    let mut refNs: *const u8 = 0 as *const xmlChar;
    let mut ref_0: *const u8 = 0 as *const xmlChar;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaQNameRefPtr;
    }
    attr = xmlSchemaGetPropNode(node, b"ref\0" as *const u8 as *const i8);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"ref\0" as *const u8 as *const i8,
            0 as *const i8,
        );
        return 0 as xmlSchemaQNameRefPtr;
    }
    xmlSchemaPValAttrNodeQName(
        pctxt,
        schema,
        0 as xmlSchemaBasicItemPtr,
        attr,
        Some(&mut refNs),
        Some(&mut ref_0),
    );
    if xmlSchemaCheckReference(pctxt, schema, node, attr, refNs) != 0 as i32 {
        return 0 as xmlSchemaQNameRefPtr;
    }
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"ref\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    xmlSchemaPValAttrID(
        pctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        xmlSchemaParseAnnotation(pctxt, child, 0 as i32);
        child = unsafe { (*child).next };
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            pctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?)\0" as *const u8 as *const i8,
        );
    }
    if (unsafe { (*pctxt).isRedefine }) != 0
        && !(unsafe { (*pctxt).redef }).is_null()
        && (unsafe { (*(*(*pctxt).redef).item).type_0 }) as u32 == XML_SCHEMA_TYPE_ATTRIBUTEGROUP as i32 as u32
        && ref_0 == (unsafe { (*(*pctxt).redef).refName })
        && refNs == (unsafe { (*(*pctxt).redef).refTargetNs })
    {
        if (unsafe { (*pctxt).redefCounter }) != 0 as i32 {
            let mut str: *mut u8 = 0 as *mut xmlChar;
            xmlSchemaCustomErr (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_SRC_REDEFINE , node , 0 as xmlSchemaBasicItemPtr , b"The redefining attribute group definition '%s' must not contain more than one reference to the redefined definition\0" as * const u8 as * const i8 , xmlSchemaFormatQName (Some (& mut str) , refNs , ref_0) , 0 as * const xmlChar ,) ;
            if !str.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                str = 0 as *mut xmlChar;
            }
            return 0 as xmlSchemaQNameRefPtr;
        }
        let fresh117 = unsafe { &mut ((*pctxt).redefCounter) };
        *fresh117 += 1;
        ret = xmlSchemaNewQNameRef(pctxt, XML_SCHEMA_TYPE_ATTRIBUTEGROUP, ref_0, refNs);
        if ret.is_null() {
            return 0 as xmlSchemaQNameRefPtr;
        }
        let fresh118 = unsafe { &mut ((*ret).node) };
        *fresh118 = node;
        let fresh119 = unsafe { &mut ((*(*pctxt).redef).reference) };
        *fresh119 = ret as xmlSchemaBasicItemPtr;
    } else {
        ret = xmlSchemaNewQNameRef(pctxt, XML_SCHEMA_TYPE_ATTRIBUTEGROUP, ref_0, refNs);
        if ret.is_null() {
            return 0 as xmlSchemaQNameRefPtr;
        }
        let fresh120 = unsafe { &mut ((*ret).node) };
        *fresh120 = node;
        xmlSchemaAddItemSize(
            Some(unsafe { &mut (*(*pctxt).constructor).pending }),
            10 as i32,
            ret as *mut libc::c_void,
        );
    }
    return ret;
}
extern "C" fn xmlSchemaParseAttributeGroupDefinition<'a1, 'a2, 'a3>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *mut crate::src::xmlschemas::_xmlSchemaAttributeGroup<'a3>
where
    'a1: 'static,
{
    let mut name: *const u8 = 0 as *const xmlChar;
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaAttributeGroup<'_> =
        0 as *mut xmlSchemaAttributeGroup;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    let mut hasRefs: i32 = 0 as i32;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const i8);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"name\0" as *const u8 as *const i8,
            0 as *const i8,
        );
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    if xmlSchemaPValAttrNode(
        pctxt,
        0 as xmlSchemaBasicItemPtr,
        attr,
        xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
        &mut name,
    ) != 0 as i32
    {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    ret = xmlSchemaAddAttributeGroupDefinition(pctxt, schema, name, unsafe { (*pctxt).targetNamespace }, node);
    if ret.is_null() {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"name\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    xmlSchemaPValAttrID(
        pctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        let fresh121 = unsafe { &mut ((*ret).annot) };
        *fresh121 = xmlSchemaParseAnnotation(pctxt, child, 1 as i32);
        child = unsafe { (*child).next };
    }
    if xmlSchemaParseLocalAttributes(
        pctxt,
        schema,
        Some(&mut child),
        (unsafe { &mut (*ret).attrUses }) as *mut *mut libc::c_void as *mut xmlSchemaItemListPtr,
        XML_SCHEMA_TYPE_ATTRIBUTEGROUP as i32,
        Some(&mut hasRefs),
    ) == -(1 as i32)
    {
        return 0 as xmlSchemaAttributeGroupPtr;
    }
    if hasRefs != 0 {
        (unsafe { (*ret).flags |= (1 as i32) << 4 as i32 });
    }
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"anyAttribute\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        let fresh122 = unsafe { &mut ((*ret).attributeWildcard) };
        *fresh122 = xmlSchemaParseAnyAttribute(pctxt, schema, child);
        child = unsafe { (*child).next };
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            pctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, ((attribute | attributeGroup)*, anyAttribute?))\0" as *const u8
                as *const i8,
        );
    }
    return ret;
}
extern "C" fn xmlSchemaPValAttrFormDefault<'a1>(
    mut value: *const u8,
    mut flags: Option<&'a1 mut i32>,
    mut flagQualified: i32,
) -> i32 {
    if xmlStrEqual(
        value,
        b"qualified\0" as *const u8 as *const i8 as *mut xmlChar,
    ) != 0
    {
        if *(borrow(&flags)).unwrap() & flagQualified == 0 as i32 {
            *(borrow_mut(&mut flags)).unwrap() |= flagQualified;
        }
    } else if xmlStrEqual(
        value,
        b"unqualified\0" as *const u8 as *const i8 as *mut xmlChar,
    ) == 0
    {
        return 1 as i32;
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaPValAttrBlockFinal<'a1>(
    mut value: *const u8,
    mut flags: Option<&'a1 mut i32>,
    mut flagAll: i32,
    mut flagExtension: i32,
    mut flagRestriction: i32,
    mut flagSubstitution: i32,
    mut flagList: i32,
    mut flagUnion: i32,
) -> i32 {
    let mut ret: i32 = 0 as i32;
    if borrow(&flags).is_none() || value.is_null() {
        return -(1 as i32);
    }
    if (unsafe { *value.offset(0 as i32 as isize) }) as i32 == 0 as i32 {
        return 0 as i32;
    }
    if xmlStrEqual(value, b"#all\0" as *const u8 as *const i8 as *mut xmlChar) != 0 {
        if flagAll != -(1 as i32) {
            *(borrow_mut(&mut flags)).unwrap() |= flagAll;
        } else {
            if flagExtension != -(1 as i32) {
                *(borrow_mut(&mut flags)).unwrap() |= flagExtension;
            }
            if flagRestriction != -(1 as i32) {
                *(borrow_mut(&mut flags)).unwrap() |= flagRestriction;
            }
            if flagSubstitution != -(1 as i32) {
                *(borrow_mut(&mut flags)).unwrap() |= flagSubstitution;
            }
            if flagList != -(1 as i32) {
                *(borrow_mut(&mut flags)).unwrap() |= flagList;
            }
            if flagUnion != -(1 as i32) {
                *(borrow_mut(&mut flags)).unwrap() |= flagUnion;
            }
        }
    } else {
        let mut end: *const u8 = 0 as *const xmlChar;
        let mut cur: *const u8 = value;
        let mut item: *mut u8 = 0 as *mut xmlChar;
        loop {
            while (unsafe { *cur }) as i32 == 0x20 as i32
                || 0x9 as i32 <= (unsafe { *cur }) as i32 && (unsafe { *cur }) as i32 <= 0xa as i32
                || (unsafe { *cur }) as i32 == 0xd as i32
            {
                cur = unsafe { cur.offset(1) };
            }
            end = cur;
            while (unsafe { *end }) as i32 != 0 as i32
                && !((unsafe { *end }) as i32 == 0x20 as i32
                    || 0x9 as i32 <= (unsafe { *end }) as i32 && (unsafe { *end }) as i32 <= 0xa as i32
                    || (unsafe { *end }) as i32 == 0xd as i32)
            {
                end = unsafe { end.offset(1) };
            }
            if end == cur {
                break;
            }
            item = xmlStrndup(cur, (unsafe { end.offset_from(cur) }) as i64 as i32);
            if xmlStrEqual(
                item,
                b"extension\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
                if flagExtension != -(1 as i32) {
                    if *(borrow(&flags)).unwrap() & flagExtension == 0 as i32 {
                        *(borrow_mut(&mut flags)).unwrap() |= flagExtension;
                    }
                } else {
                    ret = 1 as i32;
                }
            } else if xmlStrEqual(
                item,
                b"restriction\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
                if flagRestriction != -(1 as i32) {
                    if *(borrow(&flags)).unwrap() & flagRestriction == 0 as i32 {
                        *(borrow_mut(&mut flags)).unwrap() |= flagRestriction;
                    }
                } else {
                    ret = 1 as i32;
                }
            } else if xmlStrEqual(
                item,
                b"substitution\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
                if flagSubstitution != -(1 as i32) {
                    if *(borrow(&flags)).unwrap() & flagSubstitution == 0 as i32 {
                        *(borrow_mut(&mut flags)).unwrap() |= flagSubstitution;
                    }
                } else {
                    ret = 1 as i32;
                }
            } else if xmlStrEqual(item, b"list\0" as *const u8 as *const i8 as *mut xmlChar) != 0 {
                if flagList != -(1 as i32) {
                    if *(borrow(&flags)).unwrap() & flagList == 0 as i32 {
                        *(borrow_mut(&mut flags)).unwrap() |= flagList;
                    }
                } else {
                    ret = 1 as i32;
                }
            } else if xmlStrEqual(item, b"union\0" as *const u8 as *const i8 as *mut xmlChar) != 0 {
                if flagUnion != -(1 as i32) {
                    if *(borrow(&flags)).unwrap() & flagUnion == 0 as i32 {
                        *(borrow_mut(&mut flags)).unwrap() |= flagUnion;
                    }
                } else {
                    ret = 1 as i32;
                }
            } else {
                ret = 1 as i32;
            }
            if !item.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(item as *mut libc::c_void) });
            }
            cur = end;
            if !(ret == 0 as i32 && (unsafe { *cur }) as i32 != 0 as i32) {
                break;
            }
        }
    }
    return ret;
}
extern "C" fn xmlSchemaCheckCSelectorXPath<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut idc: *mut crate::src::xmlschemas::_xmlSchemaIDC<'a2>,
    mut selector: *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'a3>,
    mut attr: *mut crate::src::threads::_xmlAttr,
    mut isField: i32,
) -> i32 {
    let mut node: *mut crate::src::threads::_xmlNode = 0 as *mut xmlNode;
    if selector.is_null() {
        xmlSchemaPErr(
            ctxt,
            unsafe { (*idc).node },
            XML_SCHEMAP_INTERNAL as i32,
            b"Internal error: xmlSchemaCheckCSelectorXPath, the selector is not specified.\n\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return -(1 as i32);
    }
    if attr.is_null() {
        node = unsafe { (*idc).node };
    } else {
        node = attr as xmlNodePtr;
    }
    if (unsafe { (*selector).xpath }).is_null() {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"The XPath expression of the selector is not valid\0" as *const u8 as *const i8,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as i32;
    } else {
        let mut nsArray: *mut *const u8 = 0 as *mut *const xmlChar;
        let mut nsList: *mut *mut crate::src::threads::_xmlNs = 0 as *mut xmlNsPtr;
        if attr.is_null() {
            nsList = 0 as *mut xmlNsPtr;
        } else {
            nsList = xmlGetNsList(unsafe { (*attr).doc }, unsafe { (*attr).parent });
        }
        if !nsList.is_null() {
            let mut i: i32 = 0;
            let mut count: i32 = 0 as i32;
            i = 0 as i32;
            while !(unsafe { *nsList.offset(i as isize) }).is_null() {
                count += 1;
                i += 1;
            }
            nsArray = (unsafe { xmlMalloc.expect("non-null function pointer")(
                ((count * 2 as i32 + 1 as i32) as u64)
                    .wrapping_mul(::std::mem::size_of::<*const xmlChar>() as u64),
            ) }) as *mut *const xmlChar;
            if nsArray.is_null() {
                xmlSchemaPErrMemory(
                    ctxt,
                    b"allocating a namespace array\0" as *const u8 as *const i8,
                    0 as xmlNodePtr,
                );
                (unsafe { xmlFree.expect("non-null function pointer")(nsList as *mut libc::c_void) });
                return -(1 as i32);
            }
            i = 0 as i32;
            while i < count {
                let fresh123 = unsafe { &mut (*nsArray.offset((2 as i32 * i) as isize)) };
                *fresh123 = unsafe { (**nsList.offset(i as isize)).href };
                let fresh124 = unsafe { &mut (*nsArray.offset((2 as i32 * i + 1 as i32) as isize)) };
                *fresh124 = unsafe { (**nsList.offset(i as isize)).prefix };
                i += 1;
            }
            let fresh125 = unsafe { &mut (*nsArray.offset((count * 2 as i32) as isize)) };
            *fresh125 = 0 as *const xmlChar;
            (unsafe { xmlFree.expect("non-null function pointer")(nsList as *mut libc::c_void) });
        }
        if isField != 0 {
            let fresh126 = unsafe { &mut ((*selector).xpathComp) };
            *fresh126 = (unsafe { xmlPatterncompile(
                (*selector).xpath,
                0 as *mut xmlDict,
                XML_PATTERN_XSFIELD as i32,
                nsArray,
            ) }) as *mut libc::c_void;
        } else {
            let fresh127 = unsafe { &mut ((*selector).xpathComp) };
            *fresh127 = (unsafe { xmlPatterncompile(
                (*selector).xpath,
                0 as *mut xmlDict,
                XML_PATTERN_XSSEL as i32,
                nsArray,
            ) }) as *mut libc::c_void;
        }
        if !nsArray.is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(
                nsArray as *mut *mut xmlChar as *mut libc::c_void,
            ) });
        }
        if (unsafe { (*selector).xpathComp }).is_null() {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"The XPath expression '%s' could not be compiled\0" as *const u8 as *const i8,
                unsafe { (*selector).xpath },
            );
            return XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as i32;
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaAddAnnotation(
    mut annItem: *mut crate::src::xmlschemas::_xmlSchemaAnnotItem,
    mut annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot,
) -> *mut crate::src::xmlschemas::_xmlSchemaAnnot {
    if annItem.is_null() || annot.is_null() {
        return 0 as xmlSchemaAnnotPtr;
    }
    match (unsafe { (*annItem).type_0 }) as u32 {
        14 => {
            let mut item: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> =
                annItem as xmlSchemaElementPtr;
            let mut cur: *mut crate::src::xmlschemas::_xmlSchemaAnnot = unsafe { (*item).annot };
            if (unsafe { (*item).annot }).is_null() {
                let fresh128 = unsafe { &mut ((*item).annot) };
                *fresh128 = annot;
                return annot;
            }
            cur = unsafe { (*item).annot };
            if !(unsafe { (*cur).next }).is_null() {
                cur = unsafe { (*cur).next };
            }
            let fresh129 = unsafe { &mut ((*cur).next) };
            *fresh129 = annot;
        },
        15 => {
            let mut item_0: *mut crate::src::xmlschemas::_xmlSchemaAttribute<'_> =
                annItem as xmlSchemaAttributePtr;
            let mut cur_0: *mut crate::src::xmlschemas::_xmlSchemaAnnot = unsafe { (*item_0).annot };
            if (unsafe { (*item_0).annot }).is_null() {
                let fresh130 = unsafe { &mut ((*item_0).annot) };
                *fresh130 = annot;
                return annot;
            }
            cur_0 = unsafe { (*item_0).annot };
            if !(unsafe { (*cur_0).next }).is_null() {
                cur_0 = unsafe { (*cur_0).next };
            }
            let fresh131 = unsafe { &mut ((*cur_0).next) };
            *fresh131 = annot;
        },
        21 | 2 => {
            let mut item_1: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'_> =
                annItem as xmlSchemaWildcardPtr;
            let mut cur_1: *mut crate::src::xmlschemas::_xmlSchemaAnnot = unsafe { (*item_1).annot };
            if (unsafe { (*item_1).annot }).is_null() {
                let fresh132 = unsafe { &mut ((*item_1).annot) };
                *fresh132 = annot;
                return annot;
            }
            cur_1 = unsafe { (*item_1).annot };
            if !(unsafe { (*cur_1).next }).is_null() {
                cur_1 = unsafe { (*cur_1).next };
            }
            let fresh133 = unsafe { &mut ((*cur_1).next) };
            *fresh133 = annot;
        },
        25 | 23 | 24 | 22 => {
            let mut item_2: *mut crate::src::xmlschemas::_xmlSchemaAnnotItem = annItem;
            let mut cur_2: *mut crate::src::xmlschemas::_xmlSchemaAnnot = unsafe { (*item_2).annot };
            if (unsafe { (*item_2).annot }).is_null() {
                let fresh134 = unsafe { &mut ((*item_2).annot) };
                *fresh134 = annot;
                return annot;
            }
            cur_2 = unsafe { (*item_2).annot };
            if !(unsafe { (*cur_2).next }).is_null() {
                cur_2 = unsafe { (*cur_2).next };
            }
            let fresh135 = unsafe { &mut ((*cur_2).next) };
            *fresh135 = annot;
        },
        16 => {
            let mut item_3: *mut crate::src::xmlschemas::_xmlSchemaAttributeGroup<'_> =
                annItem as xmlSchemaAttributeGroupPtr;
            let mut cur_3: *mut crate::src::xmlschemas::_xmlSchemaAnnot = unsafe { (*item_3).annot };
            if (unsafe { (*item_3).annot }).is_null() {
                let fresh136 = unsafe { &mut ((*item_3).annot) };
                *fresh136 = annot;
                return annot;
            }
            cur_3 = unsafe { (*item_3).annot };
            if !(unsafe { (*cur_3).next }).is_null() {
                cur_3 = unsafe { (*cur_3).next };
            }
            let fresh137 = unsafe { &mut ((*cur_3).next) };
            *fresh137 = annot;
        },
        18 => {
            let mut item_4: *mut crate::src::xmlschemas::_xmlSchemaNotation<'_> =
                annItem as xmlSchemaNotationPtr;
            let mut cur_4: *mut crate::src::xmlschemas::_xmlSchemaAnnot = unsafe { (*item_4).annot };
            if (unsafe { (*item_4).annot }).is_null() {
                let fresh138 = unsafe { &mut ((*item_4).annot) };
                *fresh138 = annot;
                return annot;
            }
            cur_4 = unsafe { (*item_4).annot };
            if !(unsafe { (*cur_4).next }).is_null() {
                cur_4 = unsafe { (*cur_4).next };
            }
            let fresh139 = unsafe { &mut ((*cur_4).next) };
            *fresh139 = annot;
        },
        1000 | 1001 | 1002 | 1003 | 1004 | 1005 | 1006 | 1007 | 1008 | 1009 | 1010 | 1011 => {
            let mut item_5: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> =
                annItem as xmlSchemaFacetPtr;
            let mut cur_5: *mut crate::src::xmlschemas::_xmlSchemaAnnot = unsafe { (*item_5).annot };
            if (unsafe { (*item_5).annot }).is_null() {
                let fresh140 = unsafe { &mut ((*item_5).annot) };
                *fresh140 = annot;
                return annot;
            }
            cur_5 = unsafe { (*item_5).annot };
            if !(unsafe { (*cur_5).next }).is_null() {
                cur_5 = unsafe { (*cur_5).next };
            }
            let fresh141 = unsafe { &mut ((*cur_5).next) };
            *fresh141 = annot;
        },
        4 | 5 => {
            let mut item_6: *mut crate::src::xmlschemas::_xmlSchemaType<'_> =
                annItem as xmlSchemaTypePtr;
            let mut cur_6: *mut crate::src::xmlschemas::_xmlSchemaAnnot = unsafe { (*item_6).annot };
            if (unsafe { (*item_6).annot }).is_null() {
                let fresh142 = unsafe { &mut ((*item_6).annot) };
                *fresh142 = annot;
                return annot;
            }
            cur_6 = unsafe { (*item_6).annot };
            if !(unsafe { (*cur_6).next }).is_null() {
                cur_6 = unsafe { (*cur_6).next };
            }
            let fresh143 = unsafe { &mut ((*cur_6).next) };
            *fresh143 = annot;
        },
        17 => {
            let mut item_7: *mut crate::src::xmlschemas::_xmlSchemaModelGroupDef<'_> =
                annItem as xmlSchemaModelGroupDefPtr;
            let mut cur_7: *mut crate::src::xmlschemas::_xmlSchemaAnnot = unsafe { (*item_7).annot };
            if (unsafe { (*item_7).annot }).is_null() {
                let fresh144 = unsafe { &mut ((*item_7).annot) };
                *fresh144 = annot;
                return annot;
            }
            cur_7 = unsafe { (*item_7).annot };
            if !(unsafe { (*cur_7).next }).is_null() {
                cur_7 = unsafe { (*cur_7).next };
            }
            let fresh145 = unsafe { &mut ((*cur_7).next) };
            *fresh145 = annot;
        },
        6 | 7 | 8 => {
            let mut item_8: *mut crate::src::xmlschemas::_xmlSchemaModelGroup<'_> =
                annItem as xmlSchemaModelGroupPtr;
            let mut cur_8: *mut crate::src::xmlschemas::_xmlSchemaAnnot = unsafe { (*item_8).annot };
            if (unsafe { (*item_8).annot }).is_null() {
                let fresh146 = unsafe { &mut ((*item_8).annot) };
                *fresh146 = annot;
                return annot;
            }
            cur_8 = unsafe { (*item_8).annot };
            if !(unsafe { (*cur_8).next }).is_null() {
                cur_8 = unsafe { (*cur_8).next };
            }
            let fresh147 = unsafe { &mut ((*cur_8).next) };
            *fresh147 = annot;
        },
        _ => {
            xmlSchemaPCustomErr (0 as xmlSchemaParserCtxtPtr , XML_SCHEMAP_INTERNAL , 0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"Internal error: xmlSchemaAddAnnotation, The item is not a annotated schema component\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
        },
    }
    return annot;
}
extern "C" fn xmlSchemaParseIDCSelectorAndField<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut idc: *mut crate::src::xmlschemas::_xmlSchemaIDC<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut isField: i32,
) -> *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'a3> {
    let mut item: *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'_> =
        0 as *mut xmlSchemaIDCSelect;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"xpath\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    item = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaIDCSelect>() as u64,
    ) }) as xmlSchemaIDCSelectPtr;
    if item.is_null() {
        xmlSchemaPErrMemory(
            ctxt,
            b"allocating a 'selector' of an identity-constraint definition\0" as *const u8
                as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaIDCSelectPtr;
    }
    (unsafe { memset(
        item as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaIDCSelect>() as u64,
    ) });
    attr = xmlSchemaGetPropNode(node, b"xpath\0" as *const u8 as *const i8);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"name\0" as *const u8 as *const i8,
            0 as *const i8,
        );
    } else {
        let fresh148 = unsafe { &mut ((*item).xpath) };
        *fresh148 = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
        if xmlSchemaCheckCSelectorXPath(ctxt, idc, item, attr, isField) == -(1 as i32) {
            xmlSchemaPErr (ctxt , attr as xmlNodePtr , XML_SCHEMAP_INTERNAL as i32 , b"Internal error: xmlSchemaParseIDCSelectorAndField, validating the XPath expression of a IDC selector.\n\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
        }
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        xmlSchemaAddAnnotation(
            idc as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as i32),
        );
        child = unsafe { (*child).next };
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?)\0" as *const u8 as *const i8,
        );
    }
    return item;
}
extern "C" fn xmlSchemaParseIDC<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut idcCategory: u32,
    mut targetNamespace: *const u8,
) -> *mut crate::src::xmlschemas::_xmlSchemaIDC<'a3> {
    let mut item: *mut crate::src::xmlschemas::_xmlSchemaIDC<'_> = 0 as xmlSchemaIDCPtr;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    let mut name: *const u8 = 0 as *const xmlChar;
    let mut field: *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'_> =
        0 as xmlSchemaIDCSelectPtr;
    let mut lastField: *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'_> =
        0 as xmlSchemaIDCSelectPtr;
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"name\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && (idcCategory as u32 != XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
                    || xmlStrEqual(
                        unsafe { (*attr).name },
                        b"refer\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) == 0)
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const i8);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"name\0" as *const u8 as *const i8,
            0 as *const i8,
        );
        return 0 as xmlSchemaIDCPtr;
    } else {
        if xmlSchemaPValAttrNode(
            ctxt,
            0 as xmlSchemaBasicItemPtr,
            attr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
            &mut name,
        ) != 0 as i32
        {
            return 0 as xmlSchemaIDCPtr;
        }
    }
    item = xmlSchemaAddIDC(
        ctxt,
        schema,
        name,
        targetNamespace,
        idcCategory as i32,
        node,
    );
    if item.is_null() {
        return 0 as xmlSchemaIDCPtr;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    if idcCategory as u32 == XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32 {
        attr = xmlSchemaGetPropNode(node, b"refer\0" as *const u8 as *const i8);
        if attr.is_null() {
            xmlSchemaPMissingAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"refer\0" as *const u8 as *const i8,
                0 as *const i8,
            );
        } else {
            let fresh149 = unsafe { &mut ((*item).ref_0) };
            *fresh149 = xmlSchemaNewQNameRef(
                ctxt,
                XML_SCHEMA_TYPE_IDC_KEY,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            if (unsafe { (*item).ref_0 }).is_null() {
                return 0 as xmlSchemaIDCPtr;
            }
            xmlSchemaPValAttrNodeQName(
                ctxt,
                schema,
                0 as xmlSchemaBasicItemPtr,
                attr,
                Some(unsafe { &mut (*(*item).ref_0).targetNamespace }),
                Some(unsafe { &mut (*(*item).ref_0).name }),
            );
            xmlSchemaCheckReference(ctxt, schema, node, attr, unsafe { (*(*item).ref_0).targetNamespace });
        }
    }
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        let fresh150 = unsafe { &mut ((*item).annot) };
        *fresh150 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = unsafe { (*child).next };
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            b"A child element is missing\0" as *const u8 as *const i8,
            b"(annotation?, (selector, field+))\0" as *const u8 as *const i8,
        );
    }
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"selector\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        let fresh151 = unsafe { &mut ((*item).selector) };
        *fresh151 = xmlSchemaParseIDCSelectorAndField(ctxt, item, child, 0 as i32);
        child = unsafe { (*child).next };
        if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"field\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            loop {
                field = xmlSchemaParseIDCSelectorAndField(ctxt, item, child, 1 as i32);
                if !field.is_null() {
                    (unsafe { (*field).index = (*item).nbFields });
                    let fresh152 = unsafe { &mut ((*item).nbFields) };
                    *fresh152 += 1;
                    if !lastField.is_null() {
                        let fresh153 = unsafe { &mut ((*lastField).next) };
                        *fresh153 = field;
                    } else {
                        let fresh154 = unsafe { &mut ((*item).fields) };
                        *fresh154 = field;
                    }
                    lastField = field;
                }
                child = unsafe { (*child).next };
                if !(!child.is_null()
                    && !(unsafe { (*child).ns }).is_null()
                    && xmlStrEqual(
                        unsafe { (*child).name },
                        b"field\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0
                    && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0)
                {
                    break;
                }
            }
        } else {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"(annotation?, (selector, field+))\0" as *const u8 as *const i8,
            );
        }
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, (selector, field+))\0" as *const u8 as *const i8,
        );
    }
    return item;
}
extern "C" fn xmlSchemaParseElement<'a1, 'a2, 'a3, 'a4>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut isElemRef: Option<&'a3 mut i32>,
    mut topLevel: i32,
) -> *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a4>
where
    'a1: 'static,
{
    let mut current_block: u64;
    let mut decl: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> = 0 as xmlSchemaElementPtr;
    let mut particle: *mut crate::src::xmlschemas::_xmlSchemaParticle = 0 as xmlSchemaParticlePtr;
    let mut annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot = 0 as xmlSchemaAnnotPtr;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    let mut nameAttr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    let mut min: i32 = 0;
    let mut max: i32 = 0;
    let mut isRef: i32 = 0 as i32;
    let mut des: *mut u8 = 0 as *mut xmlChar;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaBasicItemPtr;
    }
    if !borrow(&isElemRef).is_none() {
        *(borrow_mut(&mut isElemRef)).unwrap() = 0 as i32;
    }
    nameAttr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const i8);
    attr = xmlSchemaGetPropNode(node, b"ref\0" as *const u8 as *const i8);
    if topLevel != 0 || attr.is_null() {
        if nameAttr.is_null() {
            xmlSchemaPMissingAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"name\0" as *const u8 as *const i8,
                0 as *const i8,
            );
            return 0 as xmlSchemaBasicItemPtr;
        }
    } else {
        isRef = 1 as i32;
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        annot = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = unsafe { (*child).next };
    }
    if topLevel != 0 {
        current_block = 10380409671385728102;
    } else {
        min = xmlGetMinOccurs(
            ctxt,
            node,
            0 as i32,
            -(1 as i32),
            1 as i32,
            b"xs:nonNegativeInteger\0" as *const u8 as *const i8,
        );
        max = xmlGetMaxOccurs(
            ctxt,
            node,
            0 as i32,
            (1 as i32) << 30 as i32,
            1 as i32,
            b"(xs:nonNegativeInteger | unbounded)\0" as *const u8 as *const i8,
        );
        xmlSchemaPCheckParticleCorrect_2(ctxt, 0 as xmlSchemaParticlePtr, node, min, max);
        particle = xmlSchemaAddParticle(ctxt, node, min, max);
        if particle.is_null() {
            current_block = 6846348394768048216;
        } else if isRef != 0 {
            let mut refNs: *const u8 = 0 as *const xmlChar;
            let mut ref_0: *const u8 = 0 as *const xmlChar;
            let mut refer: *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'_> =
                0 as xmlSchemaQNameRefPtr;
            if !borrow(&isElemRef).is_none() {
                *(borrow_mut(&mut isElemRef)).unwrap() = 1 as i32;
            }
            xmlSchemaPValAttrNodeQName(
                ctxt,
                schema,
                0 as xmlSchemaBasicItemPtr,
                attr,
                Some(&mut refNs),
                Some(&mut ref_0),
            );
            xmlSchemaCheckReference(ctxt, schema, node, attr, refNs);
            if !nameAttr.is_null() {
                xmlSchemaPMutualExclAttrErr(
                    ctxt,
                    XML_SCHEMAP_SRC_ELEMENT_2_1,
                    0 as xmlSchemaBasicItemPtr,
                    nameAttr,
                    b"ref\0" as *const u8 as *const i8,
                    b"name\0" as *const u8 as *const i8,
                );
            }
            attr = unsafe { (*node).properties };
            while !attr.is_null() {
                if (unsafe { (*attr).ns }).is_null() {
                    if xmlStrEqual(
                        unsafe { (*attr).name },
                        b"ref\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) != 0
                        || xmlStrEqual(
                            unsafe { (*attr).name },
                            b"name\0" as *const u8 as *const i8 as *mut xmlChar,
                        ) != 0
                        || xmlStrEqual(
                            unsafe { (*attr).name },
                            b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                        ) != 0
                        || xmlStrEqual(
                            unsafe { (*attr).name },
                            b"maxOccurs\0" as *const u8 as *const i8 as *mut xmlChar,
                        ) != 0
                        || xmlStrEqual(
                            unsafe { (*attr).name },
                            b"minOccurs\0" as *const u8 as *const i8 as *mut xmlChar,
                        ) != 0
                    {
                        attr = unsafe { (*attr).next };
                    } else {
                        xmlSchemaPCustomAttrErr (ctxt , XML_SCHEMAP_SRC_ELEMENT_2_2 , Option :: < & '_ mut * mut u8 > :: None , 0 as xmlSchemaBasicItemPtr , attr , b"Only the attributes 'minOccurs', 'maxOccurs' and 'id' are allowed in addition to 'ref'\0" as * const u8 as * const i8 ,) ;
                        break;
                    }
                } else {
                    if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
                        xmlSchemaPIllegalAttrErr(
                            ctxt,
                            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                            Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                            attr,
                        );
                    }
                    attr = unsafe { (*attr).next };
                }
            }
            if !child.is_null() {
                xmlSchemaPContentErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    child,
                    0 as *const i8,
                    b"(annotation?)\0" as *const u8 as *const i8,
                );
            }
            if min == 0 as i32 && max == 0 as i32 {
                current_block = 6846348394768048216;
            } else {
                refer = xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_ELEMENT, ref_0, refNs);
                if refer.is_null() {
                    current_block = 6846348394768048216;
                } else {
                    let fresh155 = unsafe { &mut ((*particle).children) };
                    *fresh155 = refer as xmlSchemaTreeItemPtr;
                    let fresh156 = unsafe { &mut ((*particle).annot) };
                    *fresh156 = annot;
                    xmlSchemaAddItemSize(
                        Some(unsafe { &mut (*(*ctxt).constructor).pending }),
                        10 as i32,
                        particle as *mut libc::c_void,
                    );
                    return particle as xmlSchemaBasicItemPtr;
                }
            }
        } else {
            current_block = 10380409671385728102;
        }
    }
    match current_block {
        10380409671385728102 => {
            let mut ns: *const u8 = 0 as *const xmlChar;
            let mut fixed: *const u8 = 0 as *const xmlChar;
            let mut name: *const u8 = 0 as *const xmlChar;
            let mut attrValue: *const u8 = 0 as *const xmlChar;
            let mut curIDC: *mut crate::src::xmlschemas::_xmlSchemaIDC<'_> = 0 as xmlSchemaIDCPtr;
            let mut lastIDC: *mut crate::src::xmlschemas::_xmlSchemaIDC<'_> = 0 as xmlSchemaIDCPtr;
            if !(xmlSchemaPValAttrNode(
                ctxt,
                0 as xmlSchemaBasicItemPtr,
                nameAttr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                &mut name,
            ) != 0 as i32)
            {
                if topLevel != 0 {
                    ns = unsafe { (*ctxt).targetNamespace };
                } else {
                    attr = xmlSchemaGetPropNode(node, b"form\0" as *const u8 as *const i8);
                    if !attr.is_null() {
                        attrValue = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if xmlStrEqual(
                            attrValue,
                            b"qualified\0" as *const u8 as *const i8 as *mut xmlChar,
                        ) != 0
                        {
                            ns = unsafe { (*ctxt).targetNamespace };
                        } else if xmlStrEqual(
                            attrValue,
                            b"unqualified\0" as *const u8 as *const i8 as *mut xmlChar,
                        ) == 0
                        {
                            xmlSchemaPSimpleTypeErr(
                                ctxt,
                                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr,
                                0 as xmlSchemaTypePtr,
                                b"(qualified | unqualified)\0" as *const u8 as *const i8,
                                attrValue,
                                0 as *const i8,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        }
                    } else if (unsafe { (*schema).flags }) & (1 as i32) << 0 as i32 != 0 {
                        ns = unsafe { (*ctxt).targetNamespace };
                    }
                }
                decl = xmlSchemaAddElement(ctxt, name, ns, node, topLevel);
                if !decl.is_null() {
                    attr = unsafe { (*node).properties };
                    while !attr.is_null() {
                        if (unsafe { (*attr).ns }).is_null() {
                            if xmlStrEqual(
                                unsafe { (*attr).name },
                                b"name\0" as *const u8 as *const i8 as *mut xmlChar,
                            ) == 0
                                && xmlStrEqual(
                                    unsafe { (*attr).name },
                                    b"type\0" as *const u8 as *const i8 as *mut xmlChar,
                                ) == 0
                                && xmlStrEqual(
                                    unsafe { (*attr).name },
                                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                                ) == 0
                                && xmlStrEqual(
                                    unsafe { (*attr).name },
                                    b"default\0" as *const u8 as *const i8 as *mut xmlChar,
                                ) == 0
                                && xmlStrEqual(
                                    unsafe { (*attr).name },
                                    b"fixed\0" as *const u8 as *const i8 as *mut xmlChar,
                                ) == 0
                                && xmlStrEqual(
                                    unsafe { (*attr).name },
                                    b"block\0" as *const u8 as *const i8 as *mut xmlChar,
                                ) == 0
                                && xmlStrEqual(
                                    unsafe { (*attr).name },
                                    b"nillable\0" as *const u8 as *const i8 as *mut xmlChar,
                                ) == 0
                            {
                                if topLevel == 0 as i32 {
                                    if xmlStrEqual(
                                        unsafe { (*attr).name },
                                        b"maxOccurs\0" as *const u8 as *const i8 as *mut xmlChar,
                                    ) == 0
                                        && xmlStrEqual(
                                            unsafe { (*attr).name },
                                            b"minOccurs\0" as *const u8 as *const i8
                                                as *mut xmlChar,
                                        ) == 0
                                        && xmlStrEqual(
                                            unsafe { (*attr).name },
                                            b"form\0" as *const u8 as *const i8 as *mut xmlChar,
                                        ) == 0
                                    {
                                        xmlSchemaPIllegalAttrErr(
                                            ctxt,
                                            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                            Option::<
                                                &'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<
                                                    '_,
                                                >,
                                            >::None,
                                            attr,
                                        );
                                    }
                                } else if xmlStrEqual(
                                    unsafe { (*attr).name },
                                    b"final\0" as *const u8 as *const i8 as *mut xmlChar,
                                ) == 0
                                    && xmlStrEqual(
                                        unsafe { (*attr).name },
                                        b"abstract\0" as *const u8 as *const i8 as *mut xmlChar,
                                    ) == 0
                                    && xmlStrEqual(
                                        unsafe { (*attr).name },
                                        b"substitutionGroup\0" as *const u8 as *const i8
                                            as *mut xmlChar,
                                    ) == 0
                                {
                                    xmlSchemaPIllegalAttrErr(
                                        ctxt,
                                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                                        Option::<
                                            &'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>,
                                        >::None,
                                        attr,
                                    );
                                }
                            }
                        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
                            xmlSchemaPIllegalAttrErr (ctxt , XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED , Option :: < & '_ mut crate :: src :: xmlschemas :: _xmlSchemaBasicItem < '_ > > :: None , attr ,) ;
                        }
                        attr = unsafe { (*attr).next };
                    }
                    if topLevel != 0 {
                        (unsafe { (*decl).flags |= (1 as i32) << 1 as i32 });
                        (unsafe { (*decl).flags |= (1 as i32) << 5 as i32 });
                        xmlSchemaPValAttrQName(
                            ctxt,
                            schema,
                            0 as xmlSchemaBasicItemPtr,
                            node,
                            b"substitutionGroup\0" as *const u8 as *const i8,
                            Some(unsafe { &mut (*decl).substGroupNs }),
                            Some(unsafe { &mut (*decl).substGroup }),
                        );
                        if xmlGetBooleanProp(
                            ctxt,
                            node,
                            b"abstract\0" as *const u8 as *const i8,
                            0 as i32,
                        ) != 0
                        {
                            (unsafe { (*decl).flags |= (1 as i32) << 4 as i32 });
                        }
                        attr = xmlSchemaGetPropNode(node, b"final\0" as *const u8 as *const i8);
                        if attr.is_null() {
                            if (unsafe { (*schema).flags }) & (1 as i32) << 2 as i32 != 0 {
                                (unsafe { (*decl).flags |= (1 as i32) << 15 as i32 });
                            }
                            if (unsafe { (*schema).flags }) & (1 as i32) << 3 as i32 != 0 {
                                (unsafe { (*decl).flags |= (1 as i32) << 16 as i32 });
                            }
                        } else {
                            attrValue = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                            if xmlSchemaPValAttrBlockFinal(
                                attrValue,
                                Some(unsafe { &mut (*decl).flags }),
                                -(1 as i32),
                                (1 as i32) << 15 as i32,
                                (1 as i32) << 16 as i32,
                                -(1 as i32),
                                -(1 as i32),
                                -(1 as i32),
                            ) != 0 as i32
                            {
                                xmlSchemaPSimpleTypeErr(
                                    ctxt,
                                    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                    0 as xmlSchemaBasicItemPtr,
                                    attr as xmlNodePtr,
                                    0 as xmlSchemaTypePtr,
                                    b"(#all | List of (extension | restriction))\0" as *const u8
                                        as *const i8,
                                    attrValue,
                                    0 as *const i8,
                                    0 as *const xmlChar,
                                    0 as *const xmlChar,
                                );
                            }
                        }
                    }
                    attr = xmlSchemaGetPropNode(node, b"block\0" as *const u8 as *const i8);
                    if attr.is_null() {
                        if (unsafe { (*schema).flags }) & (1 as i32) << 7 as i32 != 0 {
                            (unsafe { (*decl).flags |= (1 as i32) << 12 as i32 });
                        }
                        if (unsafe { (*schema).flags }) & (1 as i32) << 6 as i32 != 0 {
                            (unsafe { (*decl).flags |= (1 as i32) << 11 as i32 });
                        }
                        if (unsafe { (*schema).flags }) & (1 as i32) << 8 as i32 != 0 {
                            (unsafe { (*decl).flags |= (1 as i32) << 13 as i32 });
                        }
                    } else {
                        attrValue = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if xmlSchemaPValAttrBlockFinal(
                            attrValue,
                            Some(unsafe { &mut (*decl).flags }),
                            -(1 as i32),
                            (1 as i32) << 11 as i32,
                            (1 as i32) << 12 as i32,
                            (1 as i32) << 13 as i32,
                            -(1 as i32),
                            -(1 as i32),
                        ) != 0 as i32
                        {
                            xmlSchemaPSimpleTypeErr(
                                ctxt,
                                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr,
                                0 as xmlSchemaTypePtr,
                                b"(#all | List of (extension | restriction | substitution))\0"
                                    as *const u8 as *const i8,
                                attrValue,
                                0 as *const i8,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        }
                    }
                    if xmlGetBooleanProp(
                        ctxt,
                        node,
                        b"nillable\0" as *const u8 as *const i8,
                        0 as i32,
                    ) != 0
                    {
                        (unsafe { (*decl).flags |= (1 as i32) << 0 as i32 });
                    }
                    attr = xmlSchemaGetPropNode(node, b"type\0" as *const u8 as *const i8);
                    if !attr.is_null() {
                        xmlSchemaPValAttrNodeQName(
                            ctxt,
                            schema,
                            0 as xmlSchemaBasicItemPtr,
                            attr,
                            Some(unsafe { &mut (*decl).namedTypeNs }),
                            Some(unsafe { &mut (*decl).namedType }),
                        );
                        xmlSchemaCheckReference(ctxt, schema, node, attr, unsafe { (*decl).namedTypeNs });
                    }
                    let fresh157 = unsafe { &mut ((*decl).value) };
                    *fresh157 =
                        xmlSchemaGetProp(ctxt, node, b"default\0" as *const u8 as *const i8);
                    attr = xmlSchemaGetPropNode(node, b"fixed\0" as *const u8 as *const i8);
                    if !attr.is_null() {
                        fixed = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if !(unsafe { (*decl).value }).is_null() {
                            xmlSchemaPMutualExclAttrErr(
                                ctxt,
                                XML_SCHEMAP_SRC_ELEMENT_1,
                                0 as xmlSchemaBasicItemPtr,
                                attr,
                                b"default\0" as *const u8 as *const i8,
                                b"fixed\0" as *const u8 as *const i8,
                            );
                        } else {
                            (unsafe { (*decl).flags |= (1 as i32) << 3 as i32 });
                            let fresh158 = unsafe { &mut ((*decl).value) };
                            *fresh158 = fixed;
                        }
                    }
                    if !child.is_null()
                        && !(unsafe { (*child).ns }).is_null()
                        && xmlStrEqual(
                            unsafe { (*child).name },
                            b"complexType\0" as *const u8 as *const i8 as *const xmlChar,
                        ) != 0
                        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                    {
                        if !(unsafe { (*decl).namedType }).is_null() {
                            xmlSchemaPContentErr (ctxt , XML_SCHEMAP_SRC_ELEMENT_3 , 0 as xmlSchemaBasicItemPtr , node , child , b"The attribute 'type' and the <complexType> child are mutually exclusive\0" as * const u8 as * const i8 , 0 as * const i8 ,) ;
                        } else {
                            let fresh159 = unsafe { &mut ((*decl).subtypes) };
                            *fresh159 = xmlSchemaParseComplexType(ctxt, schema, child, 0 as i32);
                        }
                        child = unsafe { (*child).next };
                    } else if !child.is_null()
                        && !(unsafe { (*child).ns }).is_null()
                        && xmlStrEqual(
                            unsafe { (*child).name },
                            b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
                        ) != 0
                        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                    {
                        if !(unsafe { (*decl).namedType }).is_null() {
                            xmlSchemaPContentErr (ctxt , XML_SCHEMAP_SRC_ELEMENT_3 , 0 as xmlSchemaBasicItemPtr , node , child , b"The attribute 'type' and the <simpleType> child are mutually exclusive\0" as * const u8 as * const i8 , 0 as * const i8 ,) ;
                        } else {
                            let fresh160 = unsafe { &mut ((*decl).subtypes) };
                            *fresh160 = xmlSchemaParseSimpleType(ctxt, schema, child, 0 as i32);
                        }
                        child = unsafe { (*child).next };
                    }
                    while !child.is_null()
                        && !(unsafe { (*child).ns }).is_null()
                        && xmlStrEqual(
                            unsafe { (*child).name },
                            b"unique\0" as *const u8 as *const i8 as *const xmlChar,
                        ) != 0
                        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                        || !child.is_null()
                            && !(unsafe { (*child).ns }).is_null()
                            && xmlStrEqual(
                                unsafe { (*child).name },
                                b"key\0" as *const u8 as *const i8 as *const xmlChar,
                            ) != 0
                            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                        || !child.is_null()
                            && !(unsafe { (*child).ns }).is_null()
                            && xmlStrEqual(
                                unsafe { (*child).name },
                                b"keyref\0" as *const u8 as *const i8 as *const xmlChar,
                            ) != 0
                            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                    {
                        if !child.is_null()
                            && !(unsafe { (*child).ns }).is_null()
                            && xmlStrEqual(
                                unsafe { (*child).name },
                                b"unique\0" as *const u8 as *const i8 as *const xmlChar,
                            ) != 0
                            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                        {
                            curIDC = xmlSchemaParseIDC(
                                ctxt,
                                schema,
                                child,
                                XML_SCHEMA_TYPE_IDC_UNIQUE,
                                unsafe { (*decl).targetNamespace },
                            );
                        } else if !child.is_null()
                            && !(unsafe { (*child).ns }).is_null()
                            && xmlStrEqual(
                                unsafe { (*child).name },
                                b"key\0" as *const u8 as *const i8 as *const xmlChar,
                            ) != 0
                            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                        {
                            curIDC = xmlSchemaParseIDC(
                                ctxt,
                                schema,
                                child,
                                XML_SCHEMA_TYPE_IDC_KEY,
                                unsafe { (*decl).targetNamespace },
                            );
                        } else if !child.is_null()
                            && !(unsafe { (*child).ns }).is_null()
                            && xmlStrEqual(
                                unsafe { (*child).name },
                                b"keyref\0" as *const u8 as *const i8 as *const xmlChar,
                            ) != 0
                            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                        {
                            curIDC = xmlSchemaParseIDC(
                                ctxt,
                                schema,
                                child,
                                XML_SCHEMA_TYPE_IDC_KEYREF,
                                unsafe { (*decl).targetNamespace },
                            );
                        }
                        if !lastIDC.is_null() {
                            let fresh161 = unsafe { &mut ((*lastIDC).next) };
                            *fresh161 = curIDC;
                        } else {
                            let fresh162 = unsafe { &mut ((*decl).idcs) };
                            *fresh162 = curIDC as *mut libc::c_void;
                        }
                        lastIDC = curIDC;
                        child = unsafe { (*child).next };
                    }
                    if !child.is_null() {
                        xmlSchemaPContentErr (ctxt , XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED , 0 as xmlSchemaBasicItemPtr , node , child , 0 as * const i8 , b"(annotation?, ((simpleType | complexType)?, (unique | key | keyref)*))\0" as * const u8 as * const i8 ,) ;
                    }
                    let fresh163 = unsafe { &mut ((*decl).annot) };
                    *fresh163 = annot;
                    if !des.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(des as *mut libc::c_void) });
                        des = 0 as *mut xmlChar;
                    }
                    if topLevel != 0 {
                        return decl as xmlSchemaBasicItemPtr;
                    } else {
                        let fresh164 = unsafe { &mut ((*particle).children) };
                        *fresh164 = decl as xmlSchemaTreeItemPtr;
                        return particle as xmlSchemaBasicItemPtr;
                    }
                }
            }
        },
        _ => {},
    }
    if !des.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(des as *mut libc::c_void) });
        des = 0 as *mut xmlChar;
    }
    if !annot.is_null() {
        if !particle.is_null() {
            let fresh165 = unsafe { &mut ((*particle).annot) };
            *fresh165 = 0 as xmlSchemaAnnotPtr;
        }
        if !decl.is_null() {
            let fresh166 = unsafe { &mut ((*decl).annot) };
            *fresh166 = 0 as xmlSchemaAnnotPtr;
        }
        xmlSchemaFreeAnnot(annot);
    }
    return 0 as xmlSchemaBasicItemPtr;
}
extern "C" fn xmlSchemaParseUnion<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> i32
where
    'a1: 'static,
{
    let mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    let mut cur: *const u8 = 0 as *const xmlChar;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return -(1 as i32);
    }
    type_0 = unsafe { (*ctxt).ctxtType };
    (unsafe { (*type_0).flags |= (1 as i32) << 7 as i32 });
    let fresh167 = unsafe { &mut ((*type_0).baseType) };
    *fresh167 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"memberTypes\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    attr = xmlSchemaGetPropNode(node, b"memberTypes\0" as *const u8 as *const i8);
    if !attr.is_null() {
        let mut end: *const u8 = 0 as *const xmlChar;
        let mut tmp: *mut u8 = 0 as *mut xmlChar;
        let mut localName: *const u8 = 0 as *const xmlChar;
        let mut nsName: *const u8 = 0 as *const xmlChar;
        let mut link: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'_> =
            0 as *mut xmlSchemaTypeLink;
        let mut lastLink: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'_> =
            0 as xmlSchemaTypeLinkPtr;
        let mut ref_0: *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'_> =
            0 as *mut xmlSchemaQNameRef;
        cur = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
        let fresh168 = unsafe { &mut ((*type_0).base) };
        *fresh168 = cur;
        loop {
            while (unsafe { *cur }) as i32 == 0x20 as i32
                || 0x9 as i32 <= (unsafe { *cur }) as i32 && (unsafe { *cur }) as i32 <= 0xa as i32
                || (unsafe { *cur }) as i32 == 0xd as i32
            {
                cur = unsafe { cur.offset(1) };
            }
            end = cur;
            while (unsafe { *end }) as i32 != 0 as i32
                && !((unsafe { *end }) as i32 == 0x20 as i32
                    || 0x9 as i32 <= (unsafe { *end }) as i32 && (unsafe { *end }) as i32 <= 0xa as i32
                    || (unsafe { *end }) as i32 == 0xd as i32)
            {
                end = unsafe { end.offset(1) };
            }
            if end == cur {
                break;
            }
            tmp = xmlStrndup(cur, (unsafe { end.offset_from(cur) }) as i64 as i32);
            if xmlSchemaPValAttrNodeQNameValue(
                ctxt,
                schema,
                0 as xmlSchemaBasicItemPtr,
                attr,
                tmp,
                Some(&mut nsName),
                Some(&mut localName),
            ) == 0 as i32
            {
                link = (unsafe { xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<
                    xmlSchemaTypeLink,
                >() as u64) }) as xmlSchemaTypeLinkPtr;
                if link.is_null() {
                    xmlSchemaPErrMemory(
                        ctxt,
                        b"xmlSchemaParseUnion, allocating a type link\0" as *const u8 as *const i8,
                        0 as xmlNodePtr,
                    );
                    return -(1 as i32);
                }
                let fresh169 = unsafe { &mut ((*link).type_0) };
                *fresh169 = 0 as xmlSchemaTypePtr;
                let fresh170 = unsafe { &mut ((*link).next) };
                *fresh170 = 0 as *mut _xmlSchemaTypeLink;
                if lastLink.is_null() {
                    let fresh171 = unsafe { &mut ((*type_0).memberTypes) };
                    *fresh171 = link;
                } else {
                    let fresh172 = unsafe { &mut ((*lastLink).next) };
                    *fresh172 = link;
                }
                lastLink = link;
                ref_0 = xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_SIMPLE, localName, nsName);
                if ref_0.is_null() {
                    if !tmp.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(tmp as *mut libc::c_void) });
                        tmp = 0 as *mut xmlChar;
                    }
                    return -(1 as i32);
                }
                let fresh173 = unsafe { &mut ((*link).type_0) };
                *fresh173 = ref_0 as xmlSchemaTypePtr;
            }
            if !tmp.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(tmp as *mut libc::c_void) });
                tmp = 0 as *mut xmlChar;
            }
            cur = end;
            if !((unsafe { *cur }) as i32 != 0 as i32) {
                break;
            }
        }
    }
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as i32),
        );
        child = unsafe { (*child).next };
    }
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        let mut subtype: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
        let mut last: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as xmlSchemaTypePtr;
        while !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            subtype = xmlSchemaParseSimpleType(ctxt, schema, child, 0 as i32);
            if !subtype.is_null() {
                if last.is_null() {
                    let fresh174 = unsafe { &mut ((*type_0).subtypes) };
                    *fresh174 = subtype;
                    last = subtype;
                } else {
                    let fresh175 = unsafe { &mut ((*last).next) };
                    *fresh175 = subtype;
                    last = subtype;
                }
                let fresh176 = unsafe { &mut ((*last).next) };
                *fresh176 = 0 as *mut _xmlSchemaType;
            }
            child = unsafe { (*child).next };
        }
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, simpleType*)\0" as *const u8 as *const i8,
        );
    }
    if attr.is_null() && (unsafe { (*type_0).subtypes }).is_null() {
        xmlSchemaPCustomErr (ctxt , XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES , 0 as xmlSchemaBasicItemPtr , node , b"Either the attribute 'memberTypes' or at least one <simpleType> child must be present\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaParseList<'a1, 'a2, 'a3, 'a4>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> Option<&'a3 mut crate::src::xmlschemas::_xmlSchemaType<'a4>>
where
    'a1: 'static,
{
    let mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaType<'_>>::None;
    }
    type_0 = unsafe { (*ctxt).ctxtType };
    (unsafe { (*type_0).flags |= (1 as i32) << 6 as i32 });
    let fresh177 = unsafe { &mut ((*type_0).baseType) };
    *fresh177 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"itemType\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    xmlSchemaPValAttrQName(
        ctxt,
        schema,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"itemType\0" as *const u8 as *const i8,
        Some(unsafe { &mut (*type_0).baseNs }),
        Some(unsafe { &mut (*type_0).base }),
    );
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as i32),
        );
        child = unsafe { (*child).next };
    }
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        if !(unsafe { (*type_0).base }).is_null() {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"The attribute 'itemType' and the <simpleType> child are mutually exclusive\0"
                    as *const u8 as *const i8,
                0 as *const xmlChar,
            );
        } else {
            let fresh178 = unsafe { &mut ((*type_0).subtypes) };
            *fresh178 = xmlSchemaParseSimpleType(ctxt, schema, child, 0 as i32);
        }
        child = unsafe { (*child).next };
    } else if (unsafe { (*type_0).base }).is_null() {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"Either the attribute 'itemType' or the <simpleType> child must be present\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
        );
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, simpleType?)\0" as *const u8 as *const i8,
        );
    }
    if (unsafe { (*type_0).base }).is_null()
        && (unsafe { (*type_0).subtypes }).is_null()
        && (xmlSchemaGetPropNode(node, b"itemType\0" as *const u8 as *const i8)).is_null()
    {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_SRC_SIMPLE_TYPE_1,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"Either the attribute 'itemType' or the <simpleType> child must be present\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
        );
    }
    return Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaType<'_>>::None;
}
extern "C" fn xmlSchemaParseSimpleType<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut topLevel: i32,
) -> *mut crate::src::xmlschemas::_xmlSchemaType<'a3>
where
    'a1: 'static,
    'a1: 'a3,
    'a3: 'a1,
{
    let mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut oldCtxtType: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attrValue: *const u8 = 0 as *const xmlChar;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    let mut hasRestriction: i32 = 0 as i32;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    if topLevel != 0 {
        attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const i8);
        if attr.is_null() {
            xmlSchemaPMissingAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"name\0" as *const u8 as *const i8,
                0 as *const i8,
            );
            return 0 as xmlSchemaTypePtr;
        } else {
            if xmlSchemaPValAttrNode(
                ctxt,
                0 as xmlSchemaBasicItemPtr,
                attr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                &mut attrValue,
            ) != 0 as i32
            {
                return 0 as xmlSchemaTypePtr;
            }
            if (unsafe { (*ctxt).isS4S }) != 0 {
                let mut biType: *mut crate::src::xmlschemas::_xmlSchemaType<'_> =
                    0 as *mut xmlSchemaType;
                if (unsafe { (*ctxt).isRedefine }) != 0 {
                    xmlSchemaPCustomErr(
                        ctxt,
                        XML_SCHEMAP_SRC_REDEFINE,
                        0 as xmlSchemaBasicItemPtr,
                        node,
                        b"Redefinition of built-in simple types is not supported\0" as *const u8
                            as *const i8,
                        0 as *const xmlChar,
                    );
                    return 0 as xmlSchemaTypePtr;
                }
                biType = xmlSchemaGetPredefinedType(attrValue, unsafe { xmlSchemaNs });
                if !biType.is_null() {
                    return biType;
                }
            }
        }
    }
    if topLevel == 0 as i32 {
        type_0 = xmlSchemaAddType(
            ctxt,
            schema,
            XML_SCHEMA_TYPE_SIMPLE,
            0 as *const xmlChar,
            unsafe { (*ctxt).targetNamespace },
            node,
            0 as i32,
        );
        if type_0.is_null() {
            return 0 as xmlSchemaTypePtr;
        }
        (unsafe { (*type_0).type_0 = XML_SCHEMA_TYPE_SIMPLE });
        (unsafe { (*type_0).contentType = XML_SCHEMA_CONTENT_SIMPLE });
        attr = unsafe { (*node).properties };
        while !attr.is_null() {
            if (unsafe { (*attr).ns }).is_null() {
                if xmlStrEqual(
                    unsafe { (*attr).name },
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                        attr,
                    );
                }
            } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
            attr = unsafe { (*attr).next };
        }
    } else {
        type_0 = xmlSchemaAddType(
            ctxt,
            schema,
            XML_SCHEMA_TYPE_SIMPLE,
            attrValue,
            unsafe { (*ctxt).targetNamespace },
            node,
            1 as i32,
        );
        if type_0.is_null() {
            return 0 as xmlSchemaTypePtr;
        }
        (unsafe { (*type_0).type_0 = XML_SCHEMA_TYPE_SIMPLE });
        (unsafe { (*type_0).contentType = XML_SCHEMA_CONTENT_SIMPLE });
        (unsafe { (*type_0).flags |= (1 as i32) << 3 as i32 });
        attr = unsafe { (*node).properties };
        while !attr.is_null() {
            if (unsafe { (*attr).ns }).is_null() {
                if xmlStrEqual(
                    unsafe { (*attr).name },
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                    && xmlStrEqual(
                        unsafe { (*attr).name },
                        b"name\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) == 0
                    && xmlStrEqual(
                        unsafe { (*attr).name },
                        b"final\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) == 0
                {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                        attr,
                    );
                }
            } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
            attr = unsafe { (*attr).next };
        }
        attr = xmlSchemaGetPropNode(node, b"final\0" as *const u8 as *const i8);
        if attr.is_null() {
            if (unsafe { (*schema).flags }) & (1 as i32) << 3 as i32 != 0 {
                (unsafe { (*type_0).flags |= (1 as i32) << 10 as i32 });
            }
            if (unsafe { (*schema).flags }) & (1 as i32) << 4 as i32 != 0 {
                (unsafe { (*type_0).flags |= (1 as i32) << 11 as i32 });
            }
            if (unsafe { (*schema).flags }) & (1 as i32) << 5 as i32 != 0 {
                (unsafe { (*type_0).flags |= (1 as i32) << 12 as i32 });
            }
        } else {
            attrValue = xmlSchemaGetProp(ctxt, node, b"final\0" as *const u8 as *const i8);
            if xmlSchemaPValAttrBlockFinal(
                attrValue,
                Some(unsafe { &mut (*type_0).flags }),
                -(1 as i32),
                -(1 as i32),
                (1 as i32) << 10 as i32,
                -(1 as i32),
                (1 as i32) << 11 as i32,
                (1 as i32) << 12 as i32,
            ) != 0 as i32
            {
                xmlSchemaPSimpleTypeErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                    type_0 as xmlSchemaBasicItemPtr,
                    attr as xmlNodePtr,
                    0 as xmlSchemaTypePtr,
                    b"(#all | List of (list | union | restriction)\0" as *const u8 as *const i8,
                    attrValue,
                    0 as *const i8,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
            }
        }
    }
    let fresh179 = unsafe { &mut ((*type_0).targetNamespace) };
    *fresh179 = unsafe { (*ctxt).targetNamespace };
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    oldCtxtType = unsafe { (*ctxt).ctxtType };
    let fresh180 = unsafe { &mut ((*ctxt).ctxtType) };
    *fresh180 = type_0;
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        let fresh181 = unsafe { &mut ((*type_0).annot) };
        *fresh181 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = unsafe { (*child).next };
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, (restriction | list | union))\0" as *const u8 as *const i8,
        );
    } else if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"restriction\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        borrow(&xmlSchemaParseRestriction(
            ctxt,
            schema,
            child,
            XML_SCHEMA_TYPE_SIMPLE,
        ));
        hasRestriction = 1 as i32;
        child = unsafe { (*child).next };
    } else if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"list\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        borrow(&xmlSchemaParseList(ctxt, schema, child));
        child = unsafe { (*child).next };
    } else if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"union\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        xmlSchemaParseUnion(ctxt, schema, child);
        child = unsafe { (*child).next };
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, (restriction | list | union))\0" as *const u8 as *const i8,
        );
    }
    if topLevel != 0 && (unsafe { (*ctxt).isRedefine }) != 0 && hasRestriction == 0 {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_SRC_REDEFINE,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"This is a redefinition, thus the <simpleType> must have a <restriction> child\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
        );
    }
    let fresh182 = unsafe { &mut ((*ctxt).ctxtType) };
    *fresh182 = oldCtxtType;
    return type_0;
}
extern "C" fn xmlSchemaParseModelGroupDefRef<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *mut crate::src::xmlschemas::_xmlSchemaTreeItem {
    let mut item: *mut crate::src::xmlschemas::_xmlSchemaParticle = 0 as *mut xmlSchemaParticle;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    let mut ref_0: *const u8 = 0 as *const xmlChar;
    let mut refNs: *const u8 = 0 as *const xmlChar;
    let mut min: i32 = 0;
    let mut max: i32 = 0;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTreeItemPtr;
    }
    attr = xmlSchemaGetPropNode(node, b"ref\0" as *const u8 as *const i8);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"ref\0" as *const u8 as *const i8,
            0 as *const i8,
        );
        return 0 as xmlSchemaTreeItemPtr;
    } else {
        if xmlSchemaPValAttrNodeQName(
            ctxt,
            schema,
            0 as xmlSchemaBasicItemPtr,
            attr,
            Some(&mut refNs),
            Some(&mut ref_0),
        ) != 0 as i32
        {
            return 0 as xmlSchemaTreeItemPtr;
        }
    }
    xmlSchemaCheckReference(ctxt, schema, node, attr, refNs);
    min = xmlGetMinOccurs(
        ctxt,
        node,
        0 as i32,
        -(1 as i32),
        1 as i32,
        b"xs:nonNegativeInteger\0" as *const u8 as *const i8,
    );
    max = xmlGetMaxOccurs(
        ctxt,
        node,
        0 as i32,
        (1 as i32) << 30 as i32,
        1 as i32,
        b"(xs:nonNegativeInteger | unbounded)\0" as *const u8 as *const i8,
    );
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"ref\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"minOccurs\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"maxOccurs\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    item = xmlSchemaAddParticle(ctxt, node, min, max);
    if item.is_null() {
        return 0 as xmlSchemaTreeItemPtr;
    }
    let fresh183 = unsafe { &mut ((*item).children) };
    *fresh183 =
        xmlSchemaNewQNameRef(ctxt, XML_SCHEMA_TYPE_GROUP, ref_0, refNs) as xmlSchemaTreeItemPtr;
    xmlSchemaPCheckParticleCorrect_2(ctxt, item, node, min, max);
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        let fresh184 = unsafe { &mut ((*item).annot) };
        *fresh184 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = unsafe { (*child).next };
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?)\0" as *const u8 as *const i8,
        );
    }
    if min == 0 as i32 && max == 0 as i32 {
        return 0 as xmlSchemaTreeItemPtr;
    }
    return item as xmlSchemaTreeItemPtr;
}
extern "C" fn xmlSchemaParseModelGroupDefinition<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> *mut crate::src::xmlschemas::_xmlSchemaModelGroupDef<'a3>
where
    'a1: 'static,
{
    let mut item: *mut crate::src::xmlschemas::_xmlSchemaModelGroupDef<'_> =
        0 as *mut xmlSchemaModelGroupDef;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    let mut name: *const u8 = 0 as *const xmlChar;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaModelGroupDefPtr;
    }
    attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const i8);
    if attr.is_null() {
        xmlSchemaPMissingAttrErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"name\0" as *const u8 as *const i8,
            0 as *const i8,
        );
        return 0 as xmlSchemaModelGroupDefPtr;
    } else {
        if xmlSchemaPValAttrNode(
            ctxt,
            0 as xmlSchemaBasicItemPtr,
            attr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
            &mut name,
        ) != 0 as i32
        {
            return 0 as xmlSchemaModelGroupDefPtr;
        }
    }
    item = xmlSchemaAddModelGroupDefinition(ctxt, schema, name, unsafe { (*ctxt).targetNamespace }, node);
    if item.is_null() {
        return 0 as xmlSchemaModelGroupDefPtr;
    }
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"name\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        let fresh185 = unsafe { &mut ((*item).annot) };
        *fresh185 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = unsafe { (*child).next };
    }
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"all\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        let fresh186 = unsafe { &mut ((*item).children) };
        *fresh186 = xmlSchemaParseModelGroup(ctxt, schema, child, XML_SCHEMA_TYPE_ALL, 0 as i32);
        child = unsafe { (*child).next };
    } else if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"choice\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        let fresh187 = unsafe { &mut ((*item).children) };
        *fresh187 = xmlSchemaParseModelGroup(ctxt, schema, child, XML_SCHEMA_TYPE_CHOICE, 0 as i32);
        child = unsafe { (*child).next };
    } else if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"sequence\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        let fresh188 = unsafe { &mut ((*item).children) };
        *fresh188 =
            xmlSchemaParseModelGroup(ctxt, schema, child, XML_SCHEMA_TYPE_SEQUENCE, 0 as i32);
        child = unsafe { (*child).next };
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, (all | choice | sequence)?)\0" as *const u8 as *const i8,
        );
    }
    return item;
}
extern "C" fn xmlSchemaCleanupDoc<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut root: *mut crate::src::threads::_xmlNode,
) {
    let mut delete: *mut crate::src::threads::_xmlNode = 0 as *mut xmlNode;
    let mut cur: *mut crate::src::threads::_xmlNode = 0 as *mut xmlNode;
    if ctxt.is_null() || root.is_null() {
        return;
    }
    delete = 0 as xmlNodePtr;
    cur = root;
    let mut current_block_21: u64;
    while !cur.is_null() {
        if !delete.is_null() {
            xmlUnlinkNode(delete);
            xmlFreeNode(delete);
            delete = 0 as xmlNodePtr;
        }
        if (unsafe { (*cur).type_0 }) as u32 == XML_TEXT_NODE as i32 as u32 {
            if (unsafe { (*cur).type_0 }) as u32 == XML_TEXT_NODE as i32 as u32
                && xmlSchemaIsBlank(unsafe { (*cur).content }, -(1 as i32)) != 0
            {
                if xmlNodeGetSpacePreserve(cur as *const xmlNode) != 1 as i32 {
                    delete = cur;
                }
            }
            current_block_21 = 5689001924483802034;
        } else if (unsafe { (*cur).type_0 }) as u32 != XML_ELEMENT_NODE as i32 as u32
            && (unsafe { (*cur).type_0 }) as u32 != XML_CDATA_SECTION_NODE as i32 as u32
        {
            delete = cur;
            current_block_21 = 11313137364425335962;
        } else {
            current_block_21 = 5689001924483802034;
        }
        match current_block_21 {
            5689001924483802034 => {
                if !(unsafe { (*cur).children }).is_null() {
                    if (unsafe { (*(*cur).children).type_0 }) as u32 != XML_ENTITY_DECL as i32 as u32
                        && (unsafe { (*(*cur).children).type_0 }) as u32 != XML_ENTITY_REF_NODE as i32 as u32
                        && (unsafe { (*(*cur).children).type_0 }) as u32 != XML_ENTITY_NODE as i32 as u32
                    {
                        cur = unsafe { (*cur).children };
                        continue;
                    }
                }
            },
            _ => {},
        }
        if !(unsafe { (*cur).next }).is_null() {
            cur = unsafe { (*cur).next };
        } else {
            loop {
                cur = unsafe { (*cur).parent };
                if cur.is_null() {
                    break;
                }
                if cur == root {
                    cur = 0 as xmlNodePtr;
                    break;
                } else if !(unsafe { (*cur).next }).is_null() {
                    cur = unsafe { (*cur).next };
                    break;
                } else if cur.is_null() {
                    break;
                }
            }
        }
    }
    if !delete.is_null() {
        xmlUnlinkNode(delete);
        xmlFreeNode(delete);
        delete = 0 as xmlNodePtr;
    }
}
extern "C" fn xmlSchemaClearSchemaDefaults<'a1>(
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a1>,
) {
    if (unsafe { (*schema).flags }) & (1 as i32) << 0 as i32 != 0 {
        (unsafe { (*schema).flags ^= (1 as i32) << 0 as i32 });
    }
    if (unsafe { (*schema).flags }) & (1 as i32) << 1 as i32 != 0 {
        (unsafe { (*schema).flags ^= (1 as i32) << 1 as i32 });
    }
    if (unsafe { (*schema).flags }) & (1 as i32) << 2 as i32 != 0 {
        (unsafe { (*schema).flags ^= (1 as i32) << 2 as i32 });
    }
    if (unsafe { (*schema).flags }) & (1 as i32) << 3 as i32 != 0 {
        (unsafe { (*schema).flags ^= (1 as i32) << 3 as i32 });
    }
    if (unsafe { (*schema).flags }) & (1 as i32) << 4 as i32 != 0 {
        (unsafe { (*schema).flags ^= (1 as i32) << 4 as i32 });
    }
    if (unsafe { (*schema).flags }) & (1 as i32) << 5 as i32 != 0 {
        (unsafe { (*schema).flags ^= (1 as i32) << 5 as i32 });
    }
    if (unsafe { (*schema).flags }) & (1 as i32) << 6 as i32 != 0 {
        (unsafe { (*schema).flags ^= (1 as i32) << 6 as i32 });
    }
    if (unsafe { (*schema).flags }) & (1 as i32) << 7 as i32 != 0 {
        (unsafe { (*schema).flags ^= (1 as i32) << 7 as i32 });
    }
    if (unsafe { (*schema).flags }) & (1 as i32) << 8 as i32 != 0 {
        (unsafe { (*schema).flags ^= (1 as i32) << 8 as i32 });
    }
}
extern "C" fn xmlSchemaParseSchemaElement<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> i32 {
    let mut current_block: u64;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    let mut val: *const u8 = 0 as *const xmlChar;
    let mut res: i32 = 0 as i32;
    let mut oldErrs: i32 = unsafe { (*ctxt).nberrors };
    res = xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    if !(res == -(1 as i32)) {
        attr = xmlSchemaGetPropNode(node, b"targetNamespace\0" as *const u8 as *const i8);
        if !attr.is_null() {
            res = xmlSchemaPValAttrNode(
                ctxt,
                0 as xmlSchemaBasicItemPtr,
                attr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
                0 as *mut *const u8,
            );
            if res == -(1 as i32) {
                current_block = 10376413147378688457;
            } else if res != 0 as i32 {
                (unsafe { (*ctxt).stop = XML_SCHEMAP_S4S_ATTR_INVALID_VALUE as i32 });
                current_block = 6156756840313318511;
            } else {
                current_block = 5399440093318478209;
            }
        } else {
            current_block = 5399440093318478209;
        }
        match current_block {
            10376413147378688457 => {},
            _ => {
                match current_block {
                    5399440093318478209 => {
                        attr = xmlSchemaGetPropNode(
                            node,
                            b"elementFormDefault\0" as *const u8 as *const i8,
                        );
                        if !attr.is_null() {
                            val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                            res = xmlSchemaPValAttrFormDefault(
                                val,
                                Some(unsafe { &mut (*schema).flags }),
                                (1 as i32) << 0 as i32,
                            );
                            if res == -(1 as i32) {
                                current_block = 10376413147378688457;
                            } else {
                                if res != 0 as i32 {
                                    xmlSchemaPSimpleTypeErr(
                                        ctxt,
                                        XML_SCHEMAP_ELEMFORMDEFAULT_VALUE,
                                        0 as xmlSchemaBasicItemPtr,
                                        attr as xmlNodePtr,
                                        0 as xmlSchemaTypePtr,
                                        b"(qualified | unqualified)\0" as *const u8 as *const i8,
                                        val,
                                        0 as *const i8,
                                        0 as *const xmlChar,
                                        0 as *const xmlChar,
                                    );
                                }
                                current_block = 224731115979188411;
                            }
                        } else {
                            current_block = 224731115979188411;
                        }
                        match current_block {
                            10376413147378688457 => {},
                            _ => {
                                attr = xmlSchemaGetPropNode(
                                    node,
                                    b"attributeFormDefault\0" as *const u8 as *const i8,
                                );
                                if !attr.is_null() {
                                    val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                                    res = xmlSchemaPValAttrFormDefault(
                                        val,
                                        Some(unsafe { &mut (*schema).flags }),
                                        (1 as i32) << 1 as i32,
                                    );
                                    if res == -(1 as i32) {
                                        current_block = 10376413147378688457;
                                    } else {
                                        if res != 0 as i32 {
                                            xmlSchemaPSimpleTypeErr(
                                                ctxt,
                                                XML_SCHEMAP_ATTRFORMDEFAULT_VALUE,
                                                0 as xmlSchemaBasicItemPtr,
                                                attr as xmlNodePtr,
                                                0 as xmlSchemaTypePtr,
                                                b"(qualified | unqualified)\0" as *const u8
                                                    as *const i8,
                                                val,
                                                0 as *const i8,
                                                0 as *const xmlChar,
                                                0 as *const xmlChar,
                                            );
                                        }
                                        current_block = 5689316957504528238;
                                    }
                                } else {
                                    current_block = 5689316957504528238;
                                }
                                match current_block {
                                    10376413147378688457 => {},
                                    _ => {
                                        attr = xmlSchemaGetPropNode(
                                            node,
                                            b"finalDefault\0" as *const u8 as *const i8,
                                        );
                                        if !attr.is_null() {
                                            val = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                                            res = xmlSchemaPValAttrBlockFinal(
                                                val,
                                                Some(unsafe { &mut (*schema).flags }),
                                                -(1 as i32),
                                                (1 as i32) << 2 as i32,
                                                (1 as i32) << 3 as i32,
                                                -(1 as i32),
                                                (1 as i32) << 4 as i32,
                                                (1 as i32) << 5 as i32,
                                            );
                                            if res == -(1 as i32) {
                                                current_block = 10376413147378688457;
                                            } else {
                                                if res != 0 as i32 {
                                                    xmlSchemaPSimpleTypeErr (ctxt , XML_SCHEMAP_S4S_ATTR_INVALID_VALUE , 0 as xmlSchemaBasicItemPtr , attr as xmlNodePtr , 0 as xmlSchemaTypePtr , b"(#all | List of (extension | restriction | list | union))\0" as * const u8 as * const i8 , val , 0 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
                                                }
                                                current_block = 3123434771885419771;
                                            }
                                        } else {
                                            current_block = 3123434771885419771;
                                        }
                                        match current_block {
                                            10376413147378688457 => {},
                                            _ => {
                                                attr = xmlSchemaGetPropNode(
                                                    node,
                                                    b"blockDefault\0" as *const u8 as *const i8,
                                                );
                                                if !attr.is_null() {
                                                    val = xmlSchemaGetNodeContent(
                                                        ctxt,
                                                        attr as xmlNodePtr,
                                                    );
                                                    res = xmlSchemaPValAttrBlockFinal(
                                                        val,
                                                        Some(unsafe { &mut (*schema).flags }),
                                                        -(1 as i32),
                                                        (1 as i32) << 6 as i32,
                                                        (1 as i32) << 7 as i32,
                                                        (1 as i32) << 8 as i32,
                                                        -(1 as i32),
                                                        -(1 as i32),
                                                    );
                                                    if res == -(1 as i32) {
                                                        current_block = 10376413147378688457;
                                                    } else {
                                                        if res != 0 as i32 {
                                                            xmlSchemaPSimpleTypeErr (ctxt , XML_SCHEMAP_S4S_ATTR_INVALID_VALUE , 0 as xmlSchemaBasicItemPtr , attr as xmlNodePtr , 0 as xmlSchemaTypePtr , b"(#all | List of (extension | restriction | substitution))\0" as * const u8 as * const i8 , val , 0 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
                                                        }
                                                        current_block = 6156756840313318511;
                                                    }
                                                } else {
                                                    current_block = 6156756840313318511;
                                                }
                                            },
                                        }
                                    },
                                }
                            },
                        }
                    },
                    _ => {},
                }
                match current_block {
                    10376413147378688457 => {},
                    _ => {
                        if oldErrs != (unsafe { (*ctxt).nberrors }) {
                            res = unsafe { (*ctxt).err };
                        }
                        return res;
                    },
                }
            },
        }
    }
    return -(1 as i32);
}
extern "C" fn xmlSchemaParseSchemaTopLevel<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut nodes: *mut crate::src::threads::_xmlNode,
) -> i32
where
    'a1: 'static,
    'a1: 'a2,
    'a2: 'a1,
{
    let mut current_block: u64;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as *mut xmlNode;
    let mut annot: *mut crate::src::xmlschemas::_xmlSchemaAnnot = 0 as *mut xmlSchemaAnnot;
    let mut res: i32 = 0 as i32;
    let mut oldErrs: i32 = 0;
    let mut tmpOldErrs: i32 = 0;
    if ctxt.is_null() || schema.is_null() || nodes.is_null() {
        return -(1 as i32);
    }
    oldErrs = unsafe { (*ctxt).nberrors };
    child = nodes;
    loop {
        if !(!child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"include\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"import\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"redefine\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0)
        {
            current_block = 14832935472441733737;
            break;
        }
        if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            annot = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
            if (unsafe { (*schema).annot }).is_null() {
                let fresh189 = unsafe { &mut ((*schema).annot) };
                *fresh189 = annot;
            } else {
                xmlSchemaFreeAnnot(annot);
            }
        } else if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"import\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            tmpOldErrs = unsafe { (*ctxt).nberrors };
            res = xmlSchemaParseImport(ctxt, schema, child);
            if res == -(1 as i32) {
                current_block = 17833631497414332109;
                break;
            }
            if (unsafe { (*ctxt).stop }) != 0 {
                current_block = 5749571351303500870;
                break;
            }
            if tmpOldErrs != (unsafe { (*ctxt).nberrors }) {
                current_block = 5749571351303500870;
                break;
            }
        } else if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"include\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            tmpOldErrs = unsafe { (*ctxt).nberrors };
            res = xmlSchemaParseInclude(ctxt, schema, child);
            if res == -(1 as i32) {
                current_block = 17833631497414332109;
                break;
            }
            if (unsafe { (*ctxt).stop }) != 0 {
                current_block = 5749571351303500870;
                break;
            }
            if tmpOldErrs != (unsafe { (*ctxt).nberrors }) {
                current_block = 5749571351303500870;
                break;
            }
        } else if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"redefine\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            tmpOldErrs = unsafe { (*ctxt).nberrors };
            res = xmlSchemaParseRedefine(ctxt, schema, child);
            if res == -(1 as i32) {
                current_block = 17833631497414332109;
                break;
            }
            if (unsafe { (*ctxt).stop }) != 0 {
                current_block = 5749571351303500870;
                break;
            }
            if tmpOldErrs != (unsafe { (*ctxt).nberrors }) {
                current_block = 5749571351303500870;
                break;
            }
        }
        child = unsafe { (*child).next };
    }
    match current_block {
        14832935472441733737 => {
            while !child.is_null() {
                if !child.is_null()
                    && !(unsafe { (*child).ns }).is_null()
                    && xmlStrEqual(
                        unsafe { (*child).name },
                        b"complexType\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0
                    && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                {
                    xmlSchemaParseComplexType(ctxt, schema, child, 1 as i32);
                    child = unsafe { (*child).next };
                } else if !child.is_null()
                    && !(unsafe { (*child).ns }).is_null()
                    && xmlStrEqual(
                        unsafe { (*child).name },
                        b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0
                    && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                {
                    xmlSchemaParseSimpleType(ctxt, schema, child, 1 as i32);
                    child = unsafe { (*child).next };
                } else if !child.is_null()
                    && !(unsafe { (*child).ns }).is_null()
                    && xmlStrEqual(
                        unsafe { (*child).name },
                        b"element\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0
                    && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                {
                    xmlSchemaParseElement(
                        ctxt,
                        schema,
                        child,
                        Option::<&'_ mut i32>::None,
                        1 as i32,
                    );
                    child = unsafe { (*child).next };
                } else if !child.is_null()
                    && !(unsafe { (*child).ns }).is_null()
                    && xmlStrEqual(
                        unsafe { (*child).name },
                        b"attribute\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0
                    && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                {
                    xmlSchemaParseGlobalAttribute(ctxt, schema, child);
                    child = unsafe { (*child).next };
                } else if !child.is_null()
                    && !(unsafe { (*child).ns }).is_null()
                    && xmlStrEqual(
                        unsafe { (*child).name },
                        b"attributeGroup\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0
                    && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                {
                    xmlSchemaParseAttributeGroupDefinition(ctxt, schema, child);
                    child = unsafe { (*child).next };
                } else if !child.is_null()
                    && !(unsafe { (*child).ns }).is_null()
                    && xmlStrEqual(
                        unsafe { (*child).name },
                        b"group\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0
                    && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                {
                    xmlSchemaParseModelGroupDefinition(ctxt, schema, child);
                    child = unsafe { (*child).next };
                } else if !child.is_null()
                    && !(unsafe { (*child).ns }).is_null()
                    && xmlStrEqual(
                        unsafe { (*child).name },
                        b"notation\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0
                    && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                {
                    xmlSchemaParseNotation(ctxt, schema, child);
                    child = unsafe { (*child).next };
                } else {
                    xmlSchemaPContentErr (ctxt , XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED , 0 as xmlSchemaBasicItemPtr , unsafe { (* child) . parent } , child , 0 as * const i8 , b"((include | import | redefine | annotation)*, (((simpleType | complexType | group | attributeGroup) | element | attribute | notation), annotation*)*)\0" as * const u8 as * const i8 ,) ;
                    child = unsafe { (*child).next };
                }
                while !child.is_null()
                    && !(unsafe { (*child).ns }).is_null()
                    && xmlStrEqual(
                        unsafe { (*child).name },
                        b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0
                    && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                {
                    annot = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
                    if (unsafe { (*schema).annot }).is_null() {
                        let fresh190 = unsafe { &mut ((*schema).annot) };
                        *fresh190 = annot;
                    } else {
                        xmlSchemaFreeAnnot(annot);
                    }
                    child = unsafe { (*child).next };
                }
            }
        },
        17833631497414332109 => return -(1 as i32),
        _ => {},
    }
    let fresh191 = unsafe { &mut ((*ctxt).ctxtType) };
    *fresh191 = 0 as xmlSchemaTypePtr;
    if oldErrs != (unsafe { (*ctxt).nberrors }) {
        res = unsafe { (*ctxt).err };
    }
    return res;
}
extern "C" fn xmlSchemaSchemaRelationCreate()
-> *mut crate::src::xmlschemas::_xmlSchemaSchemaRelation {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaSchemaRelation =
        0 as *mut xmlSchemaSchemaRelation;
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaSchemaRelation>() as u64,
    ) }) as xmlSchemaSchemaRelationPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating schema relation\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaSchemaRelationPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaSchemaRelation>() as u64,
    ) });
    return ret;
}
extern "C" fn xmlSchemaRedefListFree<'a1>(
    mut redef: *mut crate::src::xmlschemas::_xmlSchemaRedef<'a1>,
) {
    let mut prev: *mut crate::src::xmlschemas::_xmlSchemaRedef<'_> = 0 as *mut xmlSchemaRedef;
    while !redef.is_null() {
        prev = redef;
        redef = unsafe { (*redef).next };
        (unsafe { xmlFree.expect("non-null function pointer")(prev as *mut libc::c_void) });
    }
}
extern "C" fn xmlSchemaConstructionCtxtFree<'a1>(
    mut con: *mut crate::src::xmlschemas::_xmlSchemaConstructionCtxt<'a1>,
) {
    if !(unsafe { (*con).buckets }).is_null() {
        xmlSchemaItemListFree(unsafe { (*con).buckets });
    }
    if !(unsafe { (*con).pending }).is_null() {
        xmlSchemaItemListFree(unsafe { (*con).pending });
    }
    if !(unsafe { (*con).substGroups }).is_null() {
        (unsafe { xmlHashFree((*con).substGroups, Some(xmlSchemaSubstGroupFreeEntry)) });
    }
    if !(unsafe { (*con).redefs }).is_null() {
        xmlSchemaRedefListFree(unsafe { (*con).redefs });
    }
    if !(unsafe { (*con).dict }).is_null() {
        (unsafe { xmlDictFree((*con).dict) });
    }
    (unsafe { xmlFree.expect("non-null function pointer")(con as *mut libc::c_void) });
}
extern "C" fn xmlSchemaConstructionCtxtCreate<'a1>(
    mut dict: *mut crate::src::xpointer::_xmlDict,
) -> *mut crate::src::xmlschemas::_xmlSchemaConstructionCtxt<'a1> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaConstructionCtxt<'_> =
        0 as *mut xmlSchemaConstructionCtxt;
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<
        xmlSchemaConstructionCtxt,
    >() as u64) }) as xmlSchemaConstructionCtxtPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating schema construction context\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaConstructionCtxtPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaConstructionCtxt>() as u64,
    ) });
    let fresh192 = unsafe { &mut ((*ret).buckets) };
    *fresh192 = xmlSchemaItemListCreate();
    if (unsafe { (*ret).buckets }).is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating list of schema buckets\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        (unsafe { xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void) });
        return 0 as xmlSchemaConstructionCtxtPtr;
    }
    let fresh193 = unsafe { &mut ((*ret).pending) };
    *fresh193 = xmlSchemaItemListCreate();
    if (unsafe { (*ret).pending }).is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating list of pending global components\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        xmlSchemaConstructionCtxtFree(ret);
        return 0 as xmlSchemaConstructionCtxtPtr;
    }
    let fresh194 = unsafe { &mut ((*ret).dict) };
    *fresh194 = dict;
    (unsafe { xmlDictReference(dict) });
    return ret;
}
extern "C" fn xmlSchemaParserCtxtCreate<'a1>()
-> *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'_> =
        0 as *mut xmlSchemaParserCtxt;
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaParserCtxt>() as u64,
    ) }) as xmlSchemaParserCtxtPtr;
    if ret.is_null() {
        xmlSchemaPErrMemory(
            0 as xmlSchemaParserCtxtPtr,
            b"allocating schema parser context\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaParserCtxtPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaParserCtxt>() as u64,
    ) });
    (unsafe { (*ret).type_0 = 1 as i32 });
    let fresh195 = unsafe { &mut ((*ret).attrProhibs) };
    *fresh195 = xmlSchemaItemListCreate();
    if (unsafe { (*ret).attrProhibs }).is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(ret as *mut libc::c_void) });
        return 0 as xmlSchemaParserCtxtPtr;
    }
    return ret;
}
extern "C" fn xmlSchemaNewParserCtxtUseDict<'a1>(
    mut URL: *const i8,
    mut dict: *mut crate::src::xpointer::_xmlDict,
) -> *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'_> =
        0 as *mut xmlSchemaParserCtxt;
    ret = xmlSchemaParserCtxtCreate();
    if ret.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    let fresh196 = unsafe { &mut ((*ret).dict) };
    *fresh196 = dict;
    (unsafe { xmlDictReference(dict) });
    if !URL.is_null() {
        let fresh197 = unsafe { &mut ((*ret).URL) };
        *fresh197 = unsafe { xmlDictLookup(dict, URL as *const xmlChar, -(1 as i32)) };
    }
    return ret;
}
extern "C" fn xmlSchemaCreatePCtxtOnVCtxt<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> i32 {
    if (unsafe { (*vctxt).pctxt }).is_null() {
        if !(unsafe { (*vctxt).schema }).is_null() {
            let fresh198 = unsafe { &mut ((*vctxt).pctxt) };
            *fresh198 = xmlSchemaNewParserCtxtUseDict(
                b"*\0" as *const u8 as *const i8,
                unsafe { (*(*vctxt).schema).dict },
            );
        } else {
            let fresh199 = unsafe { &mut ((*vctxt).pctxt) };
            *fresh199 = xmlSchemaNewParserCtxt(b"*\0" as *const u8 as *const i8);
        }
        if (unsafe { (*vctxt).pctxt }).is_null() {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaCreatePCtxtOnVCtxt\0" as *const u8 as *const i8,
                b"failed to create a temp. parser context\0" as *const u8 as *const i8,
            );
            return -(1 as i32);
        }
        xmlSchemaSetParserErrors(
            unsafe { (*vctxt).pctxt },
            unsafe { (*vctxt).error },
            unsafe { (*vctxt).warning },
            unsafe { (*vctxt).errCtxt },
        );
        xmlSchemaSetParserStructuredErrors(unsafe { (*vctxt).pctxt }, unsafe { (*vctxt).serror }, unsafe { (*vctxt).errCtxt });
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaGetSchemaBucket<'a1>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schemaLocation: *const u8,
) -> *mut crate::src::xmlschemas::_xmlSchemaBucket {
    let mut cur: *mut crate::src::xmlschemas::_xmlSchemaBucket = 0 as *mut xmlSchemaBucket;
    let mut list: *mut crate::src::xmlschemas::_xmlSchemaItemList = 0 as *mut xmlSchemaItemList;
    list = unsafe { (*(*pctxt).constructor).buckets };
    if (unsafe { (*list).nbItems }) == 0 as i32 {
        return 0 as xmlSchemaBucketPtr;
    } else {
        let mut i: i32 = 0;
        i = 0 as i32;
        while i < (unsafe { (*list).nbItems }) {
            cur = (unsafe { *((*list).items).offset(i as isize) }) as xmlSchemaBucketPtr;
            if (unsafe { (*cur).schemaLocation }) == schemaLocation {
                return cur;
            }
            i += 1;
        }
    }
    return 0 as xmlSchemaBucketPtr;
}
extern "C" fn xmlSchemaGetChameleonSchemaBucket<'a1>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schemaLocation: *const u8,
    mut targetNamespace: *const u8,
) -> *mut crate::src::xmlschemas::_xmlSchemaBucket {
    let mut cur: *mut crate::src::xmlschemas::_xmlSchemaBucket = 0 as *mut xmlSchemaBucket;
    let mut list: *mut crate::src::xmlschemas::_xmlSchemaItemList = 0 as *mut xmlSchemaItemList;
    list = unsafe { (*(*pctxt).constructor).buckets };
    if (unsafe { (*list).nbItems }) == 0 as i32 {
        return 0 as xmlSchemaBucketPtr;
    } else {
        let mut i: i32 = 0;
        i = 0 as i32;
        while i < (unsafe { (*list).nbItems }) {
            cur = (unsafe { *((*list).items).offset(i as isize) }) as xmlSchemaBucketPtr;
            if (unsafe { (*cur).origTargetNamespace }).is_null()
                && (unsafe { (*cur).schemaLocation }) == schemaLocation
                && (unsafe { (*cur).targetNamespace }) == targetNamespace
            {
                return cur;
            }
            i += 1;
        }
    }
    return 0 as xmlSchemaBucketPtr;
}
extern "C" fn xmlSchemaGetSchemaBucketByTNS<'a1>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut targetNamespace: *const u8,
    mut imported: i32,
) -> *mut crate::src::xmlschemas::_xmlSchemaBucket {
    let mut cur: *mut crate::src::xmlschemas::_xmlSchemaBucket = 0 as *mut xmlSchemaBucket;
    let mut list: *mut crate::src::xmlschemas::_xmlSchemaItemList = 0 as *mut xmlSchemaItemList;
    list = unsafe { (*(*pctxt).constructor).buckets };
    if (unsafe { (*list).nbItems }) == 0 as i32 {
        return 0 as xmlSchemaBucketPtr;
    } else {
        let mut i: i32 = 0;
        i = 0 as i32;
        while i < (unsafe { (*list).nbItems }) {
            cur = (unsafe { *((*list).items).offset(i as isize) }) as xmlSchemaBucketPtr;
            if !((unsafe { (*cur).doc }).is_null() && !(unsafe { (*cur).schemaLocation }).is_null())
                && (unsafe { (*cur).origTargetNamespace }) == targetNamespace
                && (imported != 0 && (unsafe { (*cur).imported }) != 0 || imported == 0 && (unsafe { (*cur).imported }) == 0)
            {
                return cur;
            }
            i += 1;
        }
    }
    return 0 as xmlSchemaBucketPtr;
}
extern "C" fn xmlSchemaParseNewDocWithContext<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut bucket: *mut crate::src::xmlschemas::_xmlSchemaBucket,
) -> i32
where
    'a1: 'a2,
    'a1: 'static,
    'a2: 'a1,
{
    let mut oldFlags: i32 = 0;
    let mut oldDoc: *mut crate::src::threads::_xmlDoc = 0 as *mut xmlDoc;
    let mut node: *mut crate::src::threads::_xmlNode = 0 as *mut xmlNode;
    let mut ret: i32 = 0;
    let mut oldErrs: i32 = 0;
    let mut oldbucket: *mut crate::src::xmlschemas::_xmlSchemaBucket =
        unsafe { (*(*pctxt).constructor).bucket };
    oldFlags = unsafe { (*schema).flags };
    oldDoc = unsafe { (*schema).doc };
    if (unsafe { (*schema).flags }) != 0 as i32 {
        xmlSchemaClearSchemaDefaults(schema);
    }
    let fresh200 = unsafe { &mut ((*schema).doc) };
    *fresh200 = unsafe { (*bucket).doc };
    let fresh201 = unsafe { &mut ((*pctxt).schema) };
    *fresh201 = schema;
    let fresh202 = unsafe { &mut ((*pctxt).targetNamespace) };
    *fresh202 = unsafe { (*bucket).targetNamespace };
    let fresh203 = unsafe { &mut ((*(*pctxt).constructor).bucket) };
    *fresh203 = bucket;
    if !(unsafe { (*bucket).targetNamespace }).is_null()
        && xmlStrEqual(unsafe { (*bucket).targetNamespace }, unsafe { xmlSchemaNs }) != 0
    {
        (unsafe { (*pctxt).isS4S = 1 as i32 });
    }
    let fresh204 = unsafe { &mut ((*bucket).parsed) };
    *fresh204 += 1;
    node = xmlDocGetRootElement((unsafe { (*bucket).doc }) as *const xmlDoc);
    ret = xmlSchemaParseSchemaElement(pctxt, schema, node);
    if !(ret != 0 as i32) {
        if !(unsafe { (*node).children }).is_null() {
            oldErrs = unsafe { (*pctxt).nberrors };
            ret = xmlSchemaParseSchemaTopLevel(pctxt, schema, unsafe { (*node).children });
            if !(ret != 0 as i32) {
                if ret == 0 as i32 && oldErrs != (unsafe { (*pctxt).nberrors }) {
                    ret = unsafe { (*pctxt).err };
                }
            }
        }
    }
    let fresh205 = unsafe { &mut ((*(*pctxt).constructor).bucket) };
    *fresh205 = oldbucket;
    let fresh206 = unsafe { &mut ((*schema).doc) };
    *fresh206 = oldDoc;
    (unsafe { (*schema).flags = oldFlags });
    return ret;
}
extern "C" fn xmlSchemaParseNewDoc<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut bucket: *mut crate::src::xmlschemas::_xmlSchemaBucket,
) -> i32
where
    'a1: 'a2,
    'a2: 'static,
    'a2: 'a1,
{
    let mut newpctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'_> =
        0 as *mut xmlSchemaParserCtxt;
    let mut res: i32 = 0 as i32;
    if bucket.is_null() {
        return 0 as i32;
    }
    if (unsafe { (*bucket).parsed }) != 0 {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaParseNewDoc\0" as *const u8 as *const i8,
            b"reparsing a schema doc\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    if (unsafe { (*bucket).doc }).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaParseNewDoc\0" as *const u8 as *const i8,
            b"parsing a schema doc, but there's no doc\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    if (unsafe { (*pctxt).constructor }).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaParseNewDoc\0" as *const u8 as *const i8,
            b"no constructor\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    newpctxt = xmlSchemaNewParserCtxtUseDict((unsafe { (*bucket).schemaLocation }) as *const i8, unsafe { (*pctxt).dict });
    if newpctxt.is_null() {
        return -(1 as i32);
    }
    let fresh207 = unsafe { &mut ((*newpctxt).constructor) };
    *fresh207 = unsafe { (*pctxt).constructor };
    let fresh208 = unsafe { &mut ((*newpctxt).schema) };
    *fresh208 = schema;
    xmlSchemaSetParserErrors(newpctxt, unsafe { (*pctxt).error }, unsafe { (*pctxt).warning }, unsafe { (*pctxt).errCtxt });
    xmlSchemaSetParserStructuredErrors(newpctxt, unsafe { (*pctxt).serror }, unsafe { (*pctxt).errCtxt });
    (unsafe { (*newpctxt).counter = (*pctxt).counter });
    res = xmlSchemaParseNewDocWithContext(newpctxt, schema, bucket);
    if res != 0 as i32 {
        (unsafe { (*pctxt).err = res });
    }
    (unsafe { (*pctxt).nberrors += (*newpctxt).nberrors });
    (unsafe { (*pctxt).counter = (*newpctxt).counter });
    let fresh209 = unsafe { &mut ((*newpctxt).constructor) };
    *fresh209 = 0 as xmlSchemaConstructionCtxtPtr;
    xmlSchemaFreeParserCtxt(newpctxt);
    return res;
}
extern "C" fn xmlSchemaSchemaRelationAddChild(
    mut bucket: *mut crate::src::xmlschemas::_xmlSchemaBucket,
    mut rel: *mut crate::src::xmlschemas::_xmlSchemaSchemaRelation,
) {
    let mut cur: *mut crate::src::xmlschemas::_xmlSchemaSchemaRelation = unsafe { (*bucket).relations };
    if cur.is_null() {
        let fresh210 = unsafe { &mut ((*bucket).relations) };
        *fresh210 = rel;
        return;
    }
    while !(unsafe { (*cur).next }).is_null() {
        cur = unsafe { (*cur).next };
    }
    let fresh211 = unsafe { &mut ((*cur).next) };
    *fresh211 = rel;
}
extern "C" fn xmlSchemaBuildAbsoluteURI(
    mut dict: *mut crate::src::xpointer::_xmlDict,
    mut location: *const u8,
    mut ctxtNode: *mut crate::src::threads::_xmlNode,
) -> *const u8 {
    if !location.is_null() {
        if ctxtNode.is_null() {
            return location;
        } else {
            let mut base: *mut u8 = 0 as *mut xmlChar;
            let mut URI: *mut u8 = 0 as *mut xmlChar;
            let mut ret: *const u8 = 0 as *const xmlChar;
            base = xmlNodeGetBase(unsafe { (*ctxtNode).doc }, ctxtNode as *const xmlNode);
            if base.is_null() {
                URI = xmlBuildURI(location, unsafe { (*(*ctxtNode).doc).URL });
            } else {
                URI = xmlBuildURI(location, base);
                (unsafe { xmlFree.expect("non-null function pointer")(base as *mut libc::c_void) });
            }
            if !URI.is_null() {
                ret = unsafe { xmlDictLookup(dict, URI, -(1 as i32)) };
                (unsafe { xmlFree.expect("non-null function pointer")(URI as *mut libc::c_void) });
                return ret;
            }
        }
    }
    return 0 as *const xmlChar;
}
extern "C" fn xmlSchemaAddSchemaDoc<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut type_0: i32,
    mut schemaLocation: *const u8,
    mut schemaDoc: *mut crate::src::threads::_xmlDoc,
    mut schemaBuffer: *const i8,
    mut schemaBufferLen: i32,
    mut invokingNode: *mut crate::src::threads::_xmlNode,
    mut sourceTargetNamespace: *const u8,
    mut importNamespace: *const u8,
    mut bucket: Option<&'a2 mut *mut crate::src::xmlschemas::_xmlSchemaBucket>,
) -> i32 {
    let mut current_block: u64;
    let mut targetNamespace: *const u8 = 0 as *const xmlChar;
    let mut relation: *mut crate::src::xmlschemas::_xmlSchemaSchemaRelation =
        0 as xmlSchemaSchemaRelationPtr;
    let mut doc: *mut crate::src::threads::_xmlDoc = 0 as xmlDocPtr;
    let mut res: i32 = 0 as i32;
    let mut err: i32 = 0 as i32;
    let mut located: i32 = 0 as i32;
    let mut preserveDoc: i32 = 0 as i32;
    let mut bkt: *mut crate::src::xmlschemas::_xmlSchemaBucket = 0 as xmlSchemaBucketPtr;
    if !borrow(&bucket).is_none() {
        *(borrow_mut(&mut bucket)).unwrap() = 0 as xmlSchemaBucketPtr;
    }
    match type_0 {
        1 | 0 => {
            err = XML_SCHEMAP_SRC_IMPORT as i32;
        },
        2 => {
            err = XML_SCHEMAP_SRC_INCLUDE as i32;
        },
        3 => {
            err = XML_SCHEMAP_SRC_REDEFINE as i32;
        },
        _ => {},
    }
    if type_0 == 0 as i32
        || !(!(unsafe { (*(*pctxt).constructor).buckets }).is_null()
            && (unsafe { (*(*(*pctxt).constructor).buckets).nbItems }) > 0 as i32)
    {
        current_block = 13370431095695323903;
    } else {
        if !schemaLocation.is_null() {
            bkt = xmlSchemaGetSchemaBucket(pctxt, schemaLocation);
            if !bkt.is_null() && (unsafe { (*(*pctxt).constructor).bucket }) == bkt {
                xmlSchemaCustomErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    err as xmlParserErrors,
                    invokingNode,
                    0 as xmlSchemaBasicItemPtr,
                    b"The schema must not import/include/redefine itself\0" as *const u8
                        as *const i8,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
                current_block = 16820852522665970781;
            } else {
                current_block = 17833034027772472439;
            }
        } else {
            current_block = 17833034027772472439;
        }
        match current_block {
            16820852522665970781 => {},
            _ => {
                relation = xmlSchemaSchemaRelationCreate();
                if relation.is_null() {
                    return -(1 as i32);
                }
                xmlSchemaSchemaRelationAddChild(unsafe { (*(*pctxt).constructor).bucket }, relation);
                (unsafe { (*relation).type_0 = type_0 });
                if type_0 == 0 as i32 || type_0 == 1 as i32 {
                    let fresh212 = unsafe { &mut ((*relation).importNamespace) };
                    *fresh212 = importNamespace;
                    if schemaLocation.is_null() {
                        current_block = 16820852522665970781;
                    } else {
                        targetNamespace = importNamespace;
                        current_block = 7056779235015430508;
                    }
                } else {
                    current_block = 7056779235015430508;
                }
                match current_block {
                    16820852522665970781 => {},
                    _ => {
                        if !bkt.is_null() {
                            if (type_0 == 0 as i32 || type_0 == 1 as i32) && (unsafe { (*bkt).imported }) == 0 {
                                if schemaLocation.is_null() {
                                    schemaLocation = b"in_memory_buffer\0" as *const u8 as *const i8
                                        as *mut xmlChar;
                                }
                                if xmlStrEqual(schemaLocation, unsafe { (*bkt).schemaLocation }) == 0 {
                                    xmlSchemaCustomErr (pctxt as xmlSchemaAbstractCtxtPtr , err as xmlParserErrors , invokingNode , 0 as xmlSchemaBasicItemPtr , b"The schema document '%s' cannot be imported, since it was already included or redefined\0" as * const u8 as * const i8 , schemaLocation , 0 as * const xmlChar ,) ;
                                    current_block = 16820852522665970781;
                                } else {
                                    current_block = 6450597802325118133;
                                }
                            } else if !(type_0 == 0 as i32 || type_0 == 1 as i32)
                                && (unsafe { (*bkt).imported }) != 0
                            {
                                if schemaLocation.is_null() {
                                    schemaLocation = b"in_memory_buffer\0" as *const u8 as *const i8
                                        as *mut xmlChar;
                                }
                                if xmlStrEqual(schemaLocation, unsafe { (*bkt).schemaLocation }) == 0 {
                                    xmlSchemaCustomErr (pctxt as xmlSchemaAbstractCtxtPtr , err as xmlParserErrors , invokingNode , 0 as xmlSchemaBasicItemPtr , b"The schema document '%s' cannot be included or redefined, since it was already imported\0" as * const u8 as * const i8 , schemaLocation , 0 as * const xmlChar ,) ;
                                    current_block = 16820852522665970781;
                                } else {
                                    current_block = 6450597802325118133;
                                }
                            } else {
                                current_block = 6450597802325118133;
                            }
                        } else {
                            current_block = 6450597802325118133;
                        }
                        match current_block {
                            16820852522665970781 => {},
                            _ => {
                                if type_0 == 0 as i32 || type_0 == 1 as i32 {
                                    if !bkt.is_null() {
                                        let fresh213 = unsafe { &mut ((*relation).bucket) };
                                        *fresh213 = bkt;
                                        current_block = 16820852522665970781;
                                    } else {
                                        bkt = xmlSchemaGetSchemaBucketByTNS(
                                            pctxt,
                                            importNamespace,
                                            1 as i32,
                                        );
                                        if !bkt.is_null() {
                                            let fresh214 = unsafe { &mut ((*relation).bucket) };
                                            *fresh214 = bkt;
                                            if (unsafe { (*bkt).schemaLocation }).is_null() {
                                                let fresh215 = unsafe { &mut ((*bkt).schemaLocation) };
                                                *fresh215 = schemaLocation;
                                                current_block = 8869332144787829186;
                                            } else {
                                                if xmlStrEqual(
                                                    schemaLocation,
                                                    unsafe { (*bkt).schemaLocation },
                                                ) == 0
                                                {
                                                    if schemaLocation.is_null() {
                                                        schemaLocation = b"in_memory_buffer\0"
                                                            as *const u8
                                                            as *const i8
                                                            as *mut xmlChar;
                                                    }
                                                    xmlSchemaCustomWarning (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_WARN_SKIP_SCHEMA , invokingNode , Option :: < & '_ mut crate :: src :: xmlschemas :: _xmlSchemaType < '_ > > :: None , b"Skipping import of schema located at '%s' for the namespace '%s', since this namespace was already imported with the schema located at '%s'\0" as * const u8 as * const i8 , schemaLocation , importNamespace , unsafe { (* bkt) . schemaLocation } ,) ;
                                                }
                                                current_block = 16820852522665970781;
                                            }
                                        } else {
                                            current_block = 8869332144787829186;
                                        }
                                    }
                                } else if !bkt.is_null() {
                                    if (unsafe { (*bkt).origTargetNamespace }).is_null()
                                        && (unsafe { (*bkt).targetNamespace }) != sourceTargetNamespace
                                    {
                                        let mut chamel : * mut crate :: src :: xmlschemas :: _xmlSchemaBucket = 0 as * mut xmlSchemaBucket ;
                                        chamel = xmlSchemaGetChameleonSchemaBucket(
                                            pctxt,
                                            schemaLocation,
                                            sourceTargetNamespace,
                                        );
                                        if !chamel.is_null() {
                                            let fresh216 = unsafe { &mut ((*relation).bucket) };
                                            *fresh216 = chamel;
                                            current_block = 16820852522665970781;
                                        } else {
                                            bkt = 0 as xmlSchemaBucketPtr;
                                            current_block = 8869332144787829186;
                                        }
                                    } else {
                                        let fresh217 = unsafe { &mut ((*relation).bucket) };
                                        *fresh217 = bkt;
                                        current_block = 16820852522665970781;
                                    }
                                } else {
                                    current_block = 8869332144787829186;
                                }
                                match current_block {
                                    16820852522665970781 => {},
                                    _ => {
                                        if !bkt.is_null() && !(unsafe { (*bkt).doc }).is_null() {
                                            xmlSchemaInternalErr (pctxt as xmlSchemaAbstractCtxtPtr , b"xmlSchemaAddSchemaDoc\0" as * const u8 as * const i8 , b"trying to load a schema doc, but a doc is already assigned to the schema bucket\0" as * const u8 as * const i8 ,) ;
                                            current_block = 1545328529343146367;
                                        } else {
                                            current_block = 13370431095695323903;
                                        }
                                    },
                                }
                            },
                        }
                    },
                }
            },
        }
    }
    match current_block {
        13370431095695323903 => {
            if !schemaDoc.is_null() {
                doc = schemaDoc;
                preserveDoc = 1 as i32;
                if !(unsafe { (*schemaDoc).URL }).is_null() {
                    schemaLocation = unsafe { xmlDictLookup((*pctxt).dict, (*schemaDoc).URL, -(1 as i32)) };
                } else {
                    schemaLocation =
                        b"in_memory_buffer\0" as *const u8 as *const i8 as *mut xmlChar;
                }
                current_block = 14851765859726653900;
            } else if !schemaLocation.is_null() || !schemaBuffer.is_null() {
                let mut parserCtxt: *mut crate::src::tree::_xmlParserCtxt = 0 as *mut xmlParserCtxt;
                parserCtxt = unsafe { xmlNewParserCtxt() };
                if parserCtxt.is_null() {
                    xmlSchemaPErrMemory(
                        0 as xmlSchemaParserCtxtPtr,
                        b"xmlSchemaGetDoc, allocating a parser context\0" as *const u8 as *const i8,
                        0 as xmlNodePtr,
                    );
                    current_block = 1545328529343146367;
                } else {
                    if !(unsafe { (*pctxt).dict }).is_null() && !(unsafe { (*parserCtxt).dict }).is_null() {
                        (unsafe { xmlDictFree((*parserCtxt).dict) });
                        let fresh218 = unsafe { &mut ((*parserCtxt).dict) };
                        *fresh218 = unsafe { (*pctxt).dict };
                        (unsafe { xmlDictReference((*parserCtxt).dict) });
                    }
                    if !schemaLocation.is_null() {
                        doc = unsafe { xmlCtxtReadFile(
                            parserCtxt,
                            schemaLocation as *const i8,
                            0 as *const i8,
                            XML_PARSE_NOENT as i32,
                        ) };
                    } else if !schemaBuffer.is_null() {
                        doc = unsafe { xmlCtxtReadMemory(
                            parserCtxt,
                            schemaBuffer,
                            schemaBufferLen,
                            0 as *const i8,
                            0 as *const i8,
                            XML_PARSE_NOENT as i32,
                        ) };
                        schemaLocation =
                            b"in_memory_buffer\0" as *const u8 as *const i8 as *mut xmlChar;
                        if !doc.is_null() {
                            let fresh219 = unsafe { &mut ((*doc).URL) };
                            *fresh219 = xmlStrdup(schemaLocation);
                        }
                    }
                    if doc.is_null() {
                        let mut lerr: *mut crate::src::threads::_xmlError =
                            0 as *mut crate::src::threads::_xmlError;
                        lerr = unsafe { xmlGetLastError() };
                        if lerr.is_null() || (unsafe { (*lerr).domain }) != XML_FROM_IO as i32 {
                            located = 1 as i32;
                            res = XML_SCHEMAP_SRC_IMPORT_2_1 as i32;
                            xmlSchemaCustomErr(
                                pctxt as xmlSchemaAbstractCtxtPtr,
                                res as xmlParserErrors,
                                invokingNode,
                                0 as xmlSchemaBasicItemPtr,
                                b"Failed to parse the XML resource '%s'\0" as *const u8
                                    as *const i8,
                                schemaLocation,
                                0 as *const xmlChar,
                            );
                        }
                    }
                    (unsafe { xmlFreeParserCtxt(parserCtxt) });
                    if doc.is_null() && located != 0 {
                        current_block = 5528773336718582786;
                    } else {
                        current_block = 14851765859726653900;
                    }
                }
            } else {
                xmlSchemaPErr (pctxt , 0 as xmlNodePtr , XML_SCHEMAP_NOTHING_TO_PARSE as i32 , b"No information for parsing was provided with the given schema parser context.\n\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
                current_block = 1545328529343146367;
            }
            match current_block {
                1545328529343146367 => {},
                _ => {
                    match current_block {
                        14851765859726653900 => {
                            if !doc.is_null() {
                                let mut docElem: *mut crate::src::threads::_xmlNode =
                                    0 as xmlNodePtr;
                                located = 1 as i32;
                                docElem = xmlDocGetRootElement(doc as *const xmlDoc);
                                if docElem.is_null() {
                                    xmlSchemaCustomErr(
                                        pctxt as xmlSchemaAbstractCtxtPtr,
                                        XML_SCHEMAP_NOROOT,
                                        invokingNode,
                                        0 as xmlSchemaBasicItemPtr,
                                        b"The document '%s' has no document element\0" as *const u8
                                            as *const i8,
                                        schemaLocation,
                                        0 as *const xmlChar,
                                    );
                                    current_block = 5528773336718582786;
                                } else {
                                    xmlSchemaCleanupDoc(pctxt, docElem);
                                    if !(!docElem.is_null()
                                        && !(unsafe { (*docElem).ns }).is_null()
                                        && xmlStrEqual(
                                            unsafe { (*docElem).name },
                                            b"schema\0" as *const u8 as *const i8 as *const xmlChar,
                                        ) != 0
                                        && xmlStrEqual(unsafe { (*(*docElem).ns).href }, unsafe { xmlSchemaNs }) != 0)
                                    {
                                        xmlSchemaCustomErr(
                                            pctxt as xmlSchemaAbstractCtxtPtr,
                                            XML_SCHEMAP_NOT_SCHEMA,
                                            invokingNode,
                                            0 as xmlSchemaBasicItemPtr,
                                            b"The XML document '%s' is not a schema document\0"
                                                as *const u8
                                                as *const i8,
                                            schemaLocation,
                                            0 as *const xmlChar,
                                        );
                                        current_block = 5528773336718582786;
                                    } else {
                                        targetNamespace = xmlSchemaGetProp(
                                            pctxt,
                                            docElem,
                                            b"targetNamespace\0" as *const u8 as *const i8,
                                        );
                                        current_block = 2956972668325154207;
                                    }
                                }
                            } else {
                                current_block = 2956972668325154207;
                            }
                            match current_block {
                                5528773336718582786 => {},
                                _ => {
                                    if bkt.is_null() && located != 0 {
                                        bkt = xmlSchemaBucketCreate(pctxt, type_0, targetNamespace);
                                        if bkt.is_null() {
                                            current_block = 1545328529343146367;
                                        } else {
                                            current_block = 13505557363059842426;
                                        }
                                    } else {
                                        current_block = 13505557363059842426;
                                    }
                                    match current_block {
                                        1545328529343146367 => {},
                                        _ => {
                                            if !bkt.is_null() {
                                                let fresh220 = unsafe { &mut ((*bkt).schemaLocation) };
                                                *fresh220 = schemaLocation;
                                                (unsafe { (*bkt).located = located });
                                                if !doc.is_null() {
                                                    let fresh221 = unsafe { &mut ((*bkt).doc) };
                                                    *fresh221 = doc;
                                                    let fresh222 = unsafe { &mut ((*bkt).targetNamespace) };
                                                    *fresh222 = targetNamespace;
                                                    let fresh223 =
                                                        unsafe { &mut ((*bkt).origTargetNamespace) };
                                                    *fresh223 = targetNamespace;
                                                    if preserveDoc != 0 {
                                                        (unsafe { (*bkt).preserveDoc = 1 as i32 });
                                                    }
                                                }
                                                if type_0 == 0 as i32 || type_0 == 1 as i32 {
                                                    let fresh224 = unsafe { &mut ((*bkt).imported) };
                                                    *fresh224 += 1;
                                                }
                                                if !relation.is_null() {
                                                    let fresh225 = unsafe { &mut ((*relation).bucket) };
                                                    *fresh225 = bkt;
                                                }
                                            }
                                            current_block = 16820852522665970781;
                                        },
                                    }
                                },
                            }
                        },
                        _ => {},
                    }
                    match current_block {
                        16820852522665970781 => {},
                        1545328529343146367 => {},
                        _ => {
                            if !doc.is_null() && preserveDoc == 0 {
                                xmlFreeDoc(doc);
                                if !bkt.is_null() {
                                    let fresh226 = unsafe { &mut ((*bkt).doc) };
                                    *fresh226 = 0 as xmlDocPtr;
                                }
                            }
                            return unsafe { (*pctxt).err };
                        },
                    }
                },
            }
        },
        _ => {},
    }
    match current_block {
        1545328529343146367 => {
            if !doc.is_null() && preserveDoc == 0 {
                xmlFreeDoc(doc);
                if !bkt.is_null() {
                    let fresh227 = unsafe { &mut ((*bkt).doc) };
                    *fresh227 = 0 as xmlDocPtr;
                }
            }
            return -(1 as i32);
        },
        _ => {
            if !borrow(&bucket).is_none() {
                *(borrow_mut(&mut bucket)).unwrap() = bkt;
            }
            return 0 as i32;
        },
    };
}
extern "C" fn xmlSchemaParseImport<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> i32
where
    'a2: 'a1,
    'a1: 'a2,
    'a1: 'static,
{
    let mut child: *mut crate::src::threads::_xmlNode = 0 as *mut xmlNode;
    let mut namespaceName: *const u8 = 0 as *const xmlChar;
    let mut schemaLocation: *const u8 = 0 as *const xmlChar;
    let mut thisTargetNamespace: *const u8 = 0 as *const xmlChar;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    let mut ret: i32 = 0 as i32;
    let mut bucket: *mut crate::src::xmlschemas::_xmlSchemaBucket = 0 as xmlSchemaBucketPtr;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return -(1 as i32);
    }
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"namespace\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"schemaLocation\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    if xmlSchemaPValAttr(
        pctxt,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"namespace\0" as *const u8 as *const i8,
        xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
        &mut namespaceName,
    ) != 0 as i32
    {
        xmlSchemaPSimpleTypeErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            node,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
            0 as *const i8,
            namespaceName,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return unsafe { (*pctxt).err };
    }
    if xmlSchemaPValAttr(
        pctxt,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"schemaLocation\0" as *const u8 as *const i8,
        xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
        &mut schemaLocation,
    ) != 0 as i32
    {
        xmlSchemaPSimpleTypeErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
            0 as xmlSchemaBasicItemPtr,
            node,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
            0 as *const i8,
            schemaLocation,
            0 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return unsafe { (*pctxt).err };
    }
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        child = unsafe { (*child).next };
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            pctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?)\0" as *const u8 as *const i8,
        );
    }
    thisTargetNamespace = unsafe { (*(*(*pctxt).constructor).bucket).origTargetNamespace };
    if !namespaceName.is_null() {
        if xmlStrEqual(thisTargetNamespace, namespaceName) != 0 {
            xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_SRC_IMPORT_1_1 , 0 as xmlSchemaBasicItemPtr , node , b"The value of the attribute 'namespace' must not match the target namespace '%s' of the importing schema\0" as * const u8 as * const i8 , thisTargetNamespace ,) ;
            return unsafe { (*pctxt).err };
        }
    } else if thisTargetNamespace.is_null() {
        xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_SRC_IMPORT_1_2 , 0 as xmlSchemaBasicItemPtr , node , b"The attribute 'namespace' must be existent if the importing schema has no target namespace\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
        return unsafe { (*pctxt).err };
    }
    if !schemaLocation.is_null() {
        schemaLocation = xmlSchemaBuildAbsoluteURI(unsafe { (*pctxt).dict }, schemaLocation, node);
    }
    ret = xmlSchemaAddSchemaDoc(
        pctxt,
        1 as i32,
        schemaLocation,
        0 as xmlDocPtr,
        0 as *const i8,
        0 as i32,
        node,
        thisTargetNamespace,
        namespaceName,
        Some(&mut bucket),
    );
    if ret != 0 as i32 {
        return ret;
    }
    if bucket.is_null() && !schemaLocation.is_null() {
        xmlSchemaCustomWarning(
            pctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_WARN_UNLOCATED_SCHEMA,
            node,
            Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaType<'_>>::None,
            b"Failed to locate a schema at location '%s'. Skipping the import\0" as *const u8
                as *const i8,
            schemaLocation,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
    }
    if !bucket.is_null() && (!(unsafe { (*bucket).doc }).is_null() && (unsafe { (*bucket).parsed }) == 0 as i32) {
        ret = xmlSchemaParseNewDoc(pctxt, schema, bucket);
    }
    return ret;
}
extern "C" fn xmlSchemaParseIncludeOrRedefineAttrs<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut schemaLocation: *mut *mut u8,
    mut type_0: i32,
) -> i32 {
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    if pctxt.is_null() || schema.is_null() || node.is_null() || schemaLocation.is_null() {
        return -(1 as i32);
    }
    (unsafe { *schemaLocation = 0 as *mut xmlChar });
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"schemaLocation\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    pctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                pctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    xmlSchemaPValAttrID(
        pctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    attr = xmlSchemaGetPropNode(node, b"schemaLocation\0" as *const u8 as *const i8);
    if !attr.is_null() {
        let mut base: *mut u8 = 0 as *mut xmlChar;
        let mut uri: *mut u8 = 0 as *mut xmlChar;
        if !(xmlSchemaPValAttrNode(
            pctxt,
            0 as xmlSchemaBasicItemPtr,
            attr,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYURI),
            schemaLocation as *mut *const xmlChar,
        ) != 0 as i32)
        {
            base = xmlNodeGetBase(unsafe { (*node).doc }, node as *const xmlNode);
            if base.is_null() {
                uri = xmlBuildURI(unsafe { *schemaLocation }, unsafe { (*(*node).doc).URL });
            } else {
                uri = xmlBuildURI(unsafe { *schemaLocation }, base);
                (unsafe { xmlFree.expect("non-null function pointer")(base as *mut libc::c_void) });
            }
            if uri.is_null() {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaParseIncludeOrRedefine\0" as *const u8 as *const i8,
                    b"could not build an URI from the schemaLocation\0" as *const u8 as *const i8,
                );
                return -(1 as i32);
            } else {
                (unsafe { *schemaLocation = xmlDictLookup((*pctxt).dict, uri, -(1 as i32)) as *mut xmlChar });
                (unsafe { xmlFree.expect("non-null function pointer")(uri as *mut libc::c_void) });
                if xmlStrEqual(unsafe { *schemaLocation }, unsafe { (*pctxt).URL }) != 0 {
                    if type_0 == 3 as i32 {
                        xmlSchemaPCustomErr(
                            pctxt,
                            XML_SCHEMAP_SRC_REDEFINE,
                            0 as xmlSchemaBasicItemPtr,
                            node,
                            b"The schema document '%s' cannot redefine itself.\0" as *const u8
                                as *const i8,
                            unsafe { *schemaLocation },
                        );
                    } else {
                        xmlSchemaPCustomErr(
                            pctxt,
                            XML_SCHEMAP_SRC_INCLUDE,
                            0 as xmlSchemaBasicItemPtr,
                            node,
                            b"The schema document '%s' cannot include itself.\0" as *const u8
                                as *const i8,
                            unsafe { *schemaLocation },
                        );
                    }
                } else {
                    return 0 as i32;
                }
            }
        }
    } else {
        xmlSchemaPMissingAttrErr(
            pctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"schemaLocation\0" as *const u8 as *const i8,
            0 as *const i8,
        );
    }
    return unsafe { (*pctxt).err };
}
extern "C" fn xmlSchemaParseIncludeOrRedefine<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut type_0: i32,
) -> i32
where
    'a1: 'a2,
    'a1: 'static,
    'a2: 'a1,
{
    let mut current_block: u64;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut schemaLocation: *const u8 = 0 as *const xmlChar;
    let mut res: i32 = 0 as i32;
    let mut isChameleon: i32 = 0 as i32;
    let mut wasChameleon: i32 = 0 as i32;
    let mut bucket: *mut crate::src::xmlschemas::_xmlSchemaBucket = 0 as xmlSchemaBucketPtr;
    if pctxt.is_null() || schema.is_null() || node.is_null() {
        return -(1 as i32);
    }
    res = xmlSchemaParseIncludeOrRedefineAttrs(
        pctxt,
        schema,
        node,
        &mut schemaLocation as *mut *const xmlChar as *mut *mut xmlChar,
        type_0,
    );
    if res != 0 as i32 {
        return res;
    }
    res = xmlSchemaAddSchemaDoc(
        pctxt,
        type_0,
        schemaLocation,
        0 as xmlDocPtr,
        0 as *const i8,
        0 as i32,
        node,
        unsafe { (*pctxt).targetNamespace },
        0 as *const xmlChar,
        Some(&mut bucket),
    );
    if res != 0 as i32 {
        return res;
    }
    if bucket.is_null() || (unsafe { (*bucket).doc }).is_null() {
        if type_0 == 2 as i32 {
            res = XML_SCHEMAP_SRC_INCLUDE as i32;
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                res as xmlParserErrors,
                node,
                0 as xmlSchemaBasicItemPtr,
                b"Failed to load the document '%s' for inclusion\0" as *const u8 as *const i8,
                schemaLocation,
                0 as *const xmlChar,
            );
        } else {
            res = XML_SCHEMAP_SRC_REDEFINE as i32;
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                res as xmlParserErrors,
                node,
                0 as xmlSchemaBasicItemPtr,
                b"Failed to load the document '%s' for redefinition\0" as *const u8 as *const i8,
                schemaLocation,
                0 as *const xmlChar,
            );
        }
    } else {
        if !(unsafe { (*bucket).origTargetNamespace }).is_null() {
            if (unsafe { (*pctxt).targetNamespace }).is_null() {
                xmlSchemaCustomErr (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_SRC_INCLUDE , node , 0 as xmlSchemaBasicItemPtr , b"The target namespace of the included/redefined schema '%s' has to be absent, since the including/redefining schema has no target namespace\0" as * const u8 as * const i8 , schemaLocation , 0 as * const xmlChar ,) ;
                current_block = 2122687029741063289;
            } else if xmlStrEqual(unsafe { (*bucket).origTargetNamespace }, unsafe { (*pctxt).targetNamespace }) == 0 {
                xmlSchemaPCustomErrExt (pctxt , XML_SCHEMAP_SRC_INCLUDE , 0 as xmlSchemaBasicItemPtr , node , b"The target namespace '%s' of the included/redefined schema '%s' differs from '%s' of the including/redefining schema\0" as * const u8 as * const i8 , unsafe { (* bucket) . origTargetNamespace } , schemaLocation , unsafe { (* pctxt) . targetNamespace } ,) ;
                current_block = 2122687029741063289;
            } else {
                current_block = 8693738493027456495;
            }
        } else if !(unsafe { (*pctxt).targetNamespace }).is_null() {
            isChameleon = 1 as i32;
            if (unsafe { (*bucket).parsed }) != 0 && !(unsafe { (*bucket).origTargetNamespace }).is_null() {
                xmlSchemaCustomErr (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_SRC_INCLUDE , node , 0 as xmlSchemaBasicItemPtr , b"The target namespace of the included/redefined schema '%s' has to be absent or the same as the including/redefining schema's target namespace\0" as * const u8 as * const i8 , schemaLocation , 0 as * const xmlChar ,) ;
                current_block = 2122687029741063289;
            } else {
                let fresh228 = unsafe { &mut ((*bucket).targetNamespace) };
                *fresh228 = unsafe { (*pctxt).targetNamespace };
                current_block = 8693738493027456495;
            }
        } else {
            current_block = 8693738493027456495;
        }
        match current_block {
            8693738493027456495 => {},
            _ => return unsafe { (*pctxt).err },
        }
    }
    if !bucket.is_null() && (unsafe { (*bucket).parsed }) == 0 && !(unsafe { (*bucket).doc }).is_null() {
        if isChameleon != 0 {
            if (unsafe { (*schema).flags }) & (1 as i32) << 9 as i32 == 0 as i32 {
                (unsafe { (*schema).flags |= (1 as i32) << 9 as i32 });
            } else {
                wasChameleon = 1 as i32;
            }
        }
        xmlSchemaParseNewDoc(pctxt, schema, bucket);
        if isChameleon != 0 && wasChameleon == 0 {
            (unsafe { (*schema).flags ^= (1 as i32) << 9 as i32 });
        }
    }
    child = unsafe { (*node).children };
    if type_0 == 3 as i32 {
        let fresh229 = unsafe { &mut ((*pctxt).redefined) };
        *fresh229 = bucket;
        (unsafe { (*pctxt).isRedefine = 1 as i32 });
        while !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"complexType\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"group\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"attributeGroup\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            if !(!child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0)
            {
                if !child.is_null()
                    && !(unsafe { (*child).ns }).is_null()
                    && xmlStrEqual(
                        unsafe { (*child).name },
                        b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0
                    && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                {
                    xmlSchemaParseSimpleType(pctxt, schema, child, 1 as i32);
                } else if !child.is_null()
                    && !(unsafe { (*child).ns }).is_null()
                    && xmlStrEqual(
                        unsafe { (*child).name },
                        b"complexType\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0
                    && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                {
                    xmlSchemaParseComplexType(pctxt, schema, child, 1 as i32);
                } else if !child.is_null()
                    && !(unsafe { (*child).ns }).is_null()
                    && xmlStrEqual(
                        unsafe { (*child).name },
                        b"group\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0
                    && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                {
                    xmlSchemaParseModelGroupDefinition(pctxt, schema, child);
                } else if !child.is_null()
                    && !(unsafe { (*child).ns }).is_null()
                    && xmlStrEqual(
                        unsafe { (*child).name },
                        b"attributeGroup\0" as *const u8 as *const i8 as *const xmlChar,
                    ) != 0
                    && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
                {
                    xmlSchemaParseAttributeGroupDefinition(pctxt, schema, child);
                }
            }
            child = unsafe { (*child).next };
        }
        let fresh230 = unsafe { &mut ((*pctxt).redefined) };
        *fresh230 = 0 as xmlSchemaBucketPtr;
        (unsafe { (*pctxt).isRedefine = 0 as i32 });
    } else if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        child = unsafe { (*child).next };
    }
    if !child.is_null() {
        res = XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED as i32;
        if type_0 == 3 as i32 {
            xmlSchemaPContentErr(
                pctxt,
                res as xmlParserErrors,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"(annotation | (simpleType | complexType | group | attributeGroup))*\0"
                    as *const u8 as *const i8,
            );
        } else {
            xmlSchemaPContentErr(
                pctxt,
                res as xmlParserErrors,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"(annotation?)\0" as *const u8 as *const i8,
            );
        }
    }
    return res;
}
extern "C" fn xmlSchemaParseRedefine<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> i32
where
    'a1: 'a2,
    'a1: 'static,
    'a2: 'a1,
{
    let mut res: i32 = 0;
    res = xmlSchemaParseIncludeOrRedefine(pctxt, schema, node, 3 as i32);
    if res != 0 as i32 {
        return res;
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaParseInclude<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
) -> i32
where
    'a2: 'a1,
    'a1: 'a2,
    'a1: 'static,
{
    let mut res: i32 = 0;
    res = xmlSchemaParseIncludeOrRedefine(pctxt, schema, node, 2 as i32);
    if res != 0 as i32 {
        return res;
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaParseModelGroup<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut type_0: u32,
    mut withParticle: i32,
) -> *mut crate::src::xmlschemas::_xmlSchemaTreeItem
where
    'a1: 'static,
{
    let mut item: *mut crate::src::xmlschemas::_xmlSchemaModelGroup<'_> =
        0 as *mut xmlSchemaModelGroup;
    let mut particle: *mut crate::src::xmlschemas::_xmlSchemaParticle = 0 as xmlSchemaParticlePtr;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    let mut min: i32 = 1 as i32;
    let mut max: i32 = 1 as i32;
    let mut isElemRef: i32 = 0;
    let mut hasRefs: i32 = 0 as i32;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTreeItemPtr;
    }
    item = xmlSchemaAddModelGroup(ctxt, schema, type_0, node);
    if item.is_null() {
        return 0 as xmlSchemaTreeItemPtr;
    }
    if withParticle != 0 {
        if type_0 as u32 == XML_SCHEMA_TYPE_ALL as i32 as u32 {
            min = xmlGetMinOccurs(
                ctxt,
                node,
                0 as i32,
                1 as i32,
                1 as i32,
                b"(0 | 1)\0" as *const u8 as *const i8,
            );
            max = xmlGetMaxOccurs(
                ctxt,
                node,
                1 as i32,
                1 as i32,
                1 as i32,
                b"1\0" as *const u8 as *const i8,
            );
        } else {
            min = xmlGetMinOccurs(
                ctxt,
                node,
                0 as i32,
                -(1 as i32),
                1 as i32,
                b"xs:nonNegativeInteger\0" as *const u8 as *const i8,
            );
            max = xmlGetMaxOccurs(
                ctxt,
                node,
                0 as i32,
                (1 as i32) << 30 as i32,
                1 as i32,
                b"(xs:nonNegativeInteger | unbounded)\0" as *const u8 as *const i8,
            );
        }
        xmlSchemaPCheckParticleCorrect_2(ctxt, 0 as xmlSchemaParticlePtr, node, min, max);
        particle = xmlSchemaAddParticle(ctxt, node, min, max);
        if particle.is_null() {
            return 0 as xmlSchemaTreeItemPtr;
        }
        let fresh231 = unsafe { &mut ((*particle).children) };
        *fresh231 = item as xmlSchemaTreeItemPtr;
        attr = unsafe { (*node).properties };
        while !attr.is_null() {
            if (unsafe { (*attr).ns }).is_null() {
                if xmlStrEqual(
                    unsafe { (*attr).name },
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                    && xmlStrEqual(
                        unsafe { (*attr).name },
                        b"maxOccurs\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) == 0
                    && xmlStrEqual(
                        unsafe { (*attr).name },
                        b"minOccurs\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) == 0
                {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                        attr,
                    );
                }
            } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
            attr = unsafe { (*attr).next };
        }
    } else {
        attr = unsafe { (*node).properties };
        while !attr.is_null() {
            if (unsafe { (*attr).ns }).is_null() {
                if xmlStrEqual(
                    unsafe { (*attr).name },
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
                {
                    xmlSchemaPIllegalAttrErr(
                        ctxt,
                        XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                        Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                        attr,
                    );
                }
            } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
            attr = unsafe { (*attr).next };
        }
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        let fresh232 = unsafe { &mut ((*item).annot) };
        *fresh232 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = unsafe { (*child).next };
    }
    if type_0 as u32 == XML_SCHEMA_TYPE_ALL as i32 as u32 {
        let mut part: *mut crate::src::xmlschemas::_xmlSchemaParticle = 0 as *mut xmlSchemaParticle;
        let mut last: *mut crate::src::xmlschemas::_xmlSchemaParticle = 0 as xmlSchemaParticlePtr;
        while !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"element\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            part = xmlSchemaParseElement(ctxt, schema, child, Some(&mut isElemRef), 0 as i32)
                as xmlSchemaParticlePtr;
            if !part.is_null() {
                if isElemRef != 0 {
                    hasRefs += 1;
                }
                if (unsafe { (*part).minOccurs }) > 1 as i32 {
                    xmlSchemaPCustomErr(
                        ctxt,
                        XML_SCHEMAP_COS_ALL_LIMITED,
                        0 as xmlSchemaBasicItemPtr,
                        child,
                        b"Invalid value for minOccurs (must be 0 or 1)\0" as *const u8 as *const i8,
                        0 as *const xmlChar,
                    );
                    (unsafe { (*part).minOccurs = 1 as i32 });
                }
                if (unsafe { (*part).maxOccurs }) > 1 as i32 {
                    xmlSchemaPCustomErr(
                        ctxt,
                        XML_SCHEMAP_COS_ALL_LIMITED,
                        0 as xmlSchemaBasicItemPtr,
                        child,
                        b"Invalid value for maxOccurs (must be 0 or 1)\0" as *const u8 as *const i8,
                        0 as *const xmlChar,
                    );
                    (unsafe { (*part).maxOccurs = 1 as i32 });
                }
                if last.is_null() {
                    let fresh233 = unsafe { &mut ((*item).children) };
                    *fresh233 = part as xmlSchemaTreeItemPtr;
                } else {
                    let fresh234 = unsafe { &mut ((*last).next) };
                    *fresh234 = part as xmlSchemaTreeItemPtr;
                }
                last = part;
            }
            child = unsafe { (*child).next };
        }
        if !child.is_null() {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"(annotation?, (annotation?, element*)\0" as *const u8 as *const i8,
            );
        }
    } else {
        let mut part_0: *mut crate::src::xmlschemas::_xmlSchemaTreeItem = 0 as xmlSchemaTreeItemPtr;
        let mut last_0: *mut crate::src::xmlschemas::_xmlSchemaTreeItem = 0 as xmlSchemaTreeItemPtr;
        while !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"element\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"group\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"any\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"choice\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"sequence\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            if !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"element\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            {
                part_0 = xmlSchemaParseElement(ctxt, schema, child, Some(&mut isElemRef), 0 as i32)
                    as xmlSchemaTreeItemPtr;
                if !part_0.is_null() && isElemRef != 0 {
                    hasRefs += 1;
                }
            } else if !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"group\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            {
                part_0 = xmlSchemaParseModelGroupDefRef(ctxt, schema, child);
                if !part_0.is_null() {
                    hasRefs += 1;
                }
                if (unsafe { (*ctxt).isRedefine }) != 0
                    && !(unsafe { (*ctxt).redef }).is_null()
                    && (unsafe { (*(*(*ctxt).redef).item).type_0 }) as u32 == XML_SCHEMA_TYPE_GROUP as i32 as u32
                    && !part_0.is_null()
                    && !(unsafe { (*part_0).children }).is_null()
                {
                    if (unsafe { (*((*part_0).children as xmlSchemaQNameRefPtr)).name })
                        == (unsafe { (*(*ctxt).redef).refName })
                        && (unsafe { (*((*part_0).children as xmlSchemaQNameRefPtr)).targetNamespace })
                            == (unsafe { (*(*ctxt).redef).refTargetNs })
                    {
                        if (unsafe { (*ctxt).redefCounter }) != 0 as i32 {
                            let mut str: *mut u8 = 0 as *mut xmlChar;
                            xmlSchemaCustomErr (ctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_SRC_REDEFINE , child , 0 as xmlSchemaBasicItemPtr , b"The redefining model group definition '%s' must not contain more than one reference to the redefined definition\0" as * const u8 as * const i8 , xmlSchemaFormatQName (Some (& mut str) , unsafe { (* (* ctxt) . redef) . refTargetNs } , unsafe { (* (* ctxt) . redef) . refName } ,) , 0 as * const xmlChar ,) ;
                            if !str.is_null() {
                                (unsafe { xmlFree.expect("non-null function pointer")(
                                    str as *mut libc::c_void,
                                ) });
                                str = 0 as *mut xmlChar;
                            }
                            part_0 = 0 as xmlSchemaTreeItemPtr;
                        } else if (unsafe { (*(part_0 as xmlSchemaParticlePtr)).minOccurs }) != 1 as i32
                            || (unsafe { (*(part_0 as xmlSchemaParticlePtr)).maxOccurs }) != 1 as i32
                        {
                            let mut str_0: *mut u8 = 0 as *mut xmlChar;
                            xmlSchemaCustomErr (ctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_SRC_REDEFINE , child , 0 as xmlSchemaBasicItemPtr , b"The redefining model group definition '%s' must not contain a reference to the redefined definition with a maxOccurs/minOccurs other than 1\0" as * const u8 as * const i8 , xmlSchemaFormatQName (Some (& mut str_0) , unsafe { (* (* ctxt) . redef) . refTargetNs } , unsafe { (* (* ctxt) . redef) . refName } ,) , 0 as * const xmlChar ,) ;
                            if !str_0.is_null() {
                                (unsafe { xmlFree.expect("non-null function pointer")(
                                    str_0 as *mut libc::c_void,
                                ) });
                                str_0 = 0 as *mut xmlChar;
                            }
                            part_0 = 0 as xmlSchemaTreeItemPtr;
                        }
                        let fresh235 = unsafe { &mut ((*(*ctxt).redef).reference) };
                        *fresh235 = part_0 as xmlSchemaBasicItemPtr;
                        let fresh236 = unsafe { &mut ((*ctxt).redefCounter) };
                        *fresh236 += 1;
                    }
                }
            } else if !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"any\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            {
                part_0 = xmlSchemaParseAny(ctxt, schema, child) as xmlSchemaTreeItemPtr;
            } else if !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"choice\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            {
                part_0 =
                    xmlSchemaParseModelGroup(ctxt, schema, child, XML_SCHEMA_TYPE_CHOICE, 1 as i32);
            } else if !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"sequence\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            {
                part_0 = xmlSchemaParseModelGroup(
                    ctxt,
                    schema,
                    child,
                    XML_SCHEMA_TYPE_SEQUENCE,
                    1 as i32,
                );
            }
            if !part_0.is_null() {
                if last_0.is_null() {
                    let fresh237 = unsafe { &mut ((*item).children) };
                    *fresh237 = part_0;
                } else {
                    let fresh238 = unsafe { &mut ((*last_0).next) };
                    *fresh238 = part_0;
                }
                last_0 = part_0;
            }
            child = unsafe { (*child).next };
        }
        if !child.is_null() {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"(annotation?, (element | group | choice | sequence | any)*)\0" as *const u8
                    as *const i8,
            );
        }
    }
    if max == 0 as i32 && min == 0 as i32 {
        return 0 as xmlSchemaTreeItemPtr;
    }
    if hasRefs != 0 {
        xmlSchemaAddItemSize(
            Some(unsafe { &mut (*(*ctxt).constructor).pending }),
            10 as i32,
            item as *mut libc::c_void,
        );
    }
    if withParticle != 0 {
        return particle as xmlSchemaTreeItemPtr;
    } else {
        return item as xmlSchemaTreeItemPtr;
    };
}
extern "C" fn xmlSchemaParseRestriction<'a1, 'a2, 'a3, 'a4>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut parentType: u32,
) -> Option<&'a3 mut crate::src::xmlschemas::_xmlSchemaType<'a4>>
where
    'a1: 'static,
{
    let mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaType<'_>>::None;
    }
    type_0 = unsafe { (*ctxt).ctxtType };
    (unsafe { (*type_0).flags |= (1 as i32) << 2 as i32 });
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"base\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    if xmlSchemaPValAttrQName(
        ctxt,
        schema,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"base\0" as *const u8 as *const i8,
        Some(unsafe { &mut (*type_0).baseNs }),
        Some(unsafe { &mut (*type_0).base }),
    ) == 0 as i32
    {
        if (unsafe { (*type_0).base }).is_null()
            && (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        {
            xmlSchemaPMissingAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"base\0" as *const u8 as *const i8,
                0 as *const i8,
            );
        } else if (unsafe { (*ctxt).isRedefine }) != 0 && (unsafe { (*type_0).flags }) & (1 as i32) << 3 as i32 != 0 {
            if (unsafe { (*type_0).base }).is_null() {
                xmlSchemaPMissingAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_MISSING,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    b"base\0" as *const u8 as *const i8,
                    0 as *const i8,
                );
            } else if xmlStrEqual(unsafe { (*type_0).base }, unsafe { (*type_0).name }) == 0
                || xmlStrEqual(unsafe { (*type_0).baseNs }, unsafe { (*type_0).targetNamespace }) == 0
            {
                let mut str1: *mut u8 = 0 as *mut xmlChar;
                let mut str2: *mut u8 = 0 as *mut xmlChar;
                xmlSchemaPCustomErrExt (ctxt , XML_SCHEMAP_SRC_REDEFINE , 0 as xmlSchemaBasicItemPtr , node , b"This is a redefinition, but the QName value '%s' of the 'base' attribute does not match the type's designation '%s'\0" as * const u8 as * const i8 , xmlSchemaFormatQName (Some (& mut str1) , unsafe { (* type_0) . baseNs } , unsafe { (* type_0) . base }) , xmlSchemaFormatQName (Some (& mut str2) , unsafe { (* type_0) . targetNamespace } , unsafe { (* type_0) . name } ,) , 0 as * const xmlChar ,) ;
                if !str1.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str1 as *mut libc::c_void) });
                    str1 = 0 as *mut xmlChar;
                }
                if !str2.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str2 as *mut libc::c_void) });
                    str2 = 0 as *mut xmlChar;
                }
                let fresh239 = unsafe { &mut ((*type_0).base) };
                *fresh239 = 0 as *const xmlChar;
                let fresh240 = unsafe { &mut ((*type_0).baseNs) };
                *fresh240 = 0 as *const xmlChar;
            }
        }
    }
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as i32),
        );
        child = unsafe { (*child).next };
    }
    if parentType as u32 == XML_SCHEMA_TYPE_SIMPLE as i32 as u32 {
        if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            if !(unsafe { (*type_0).base }).is_null() {
                xmlSchemaPContentErr(
                    ctxt,
                    XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE,
                    0 as xmlSchemaBasicItemPtr,
                    node,
                    child,
                    b"The attribute 'base' and the <simpleType> child are mutually exclusive\0"
                        as *const u8 as *const i8,
                    0 as *const i8,
                );
            } else {
                let fresh241 = unsafe { &mut ((*type_0).baseType) };
                *fresh241 = xmlSchemaParseSimpleType(ctxt, schema, child, 0 as i32);
            }
            child = unsafe { (*child).next };
        } else if (unsafe { (*type_0).base }).is_null() {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                b"Either the attribute 'base' or a <simpleType> child must be present\0"
                    as *const u8 as *const i8,
                0 as *const i8,
            );
        }
    } else if parentType as u32 == XML_SCHEMA_TYPE_COMPLEX_CONTENT as i32 as u32 {
        if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"all\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            let fresh242 = unsafe { &mut ((*type_0).subtypes) };
            *fresh242 = xmlSchemaParseModelGroup(ctxt, schema, child, XML_SCHEMA_TYPE_ALL, 1 as i32)
                as xmlSchemaTypePtr;
            child = unsafe { (*child).next };
        } else if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"choice\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            let fresh243 = unsafe { &mut ((*type_0).subtypes) };
            *fresh243 =
                xmlSchemaParseModelGroup(ctxt, schema, child, XML_SCHEMA_TYPE_CHOICE, 1 as i32)
                    as xmlSchemaTypePtr;
            child = unsafe { (*child).next };
        } else if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"sequence\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            let fresh244 = unsafe { &mut ((*type_0).subtypes) };
            *fresh244 =
                xmlSchemaParseModelGroup(ctxt, schema, child, XML_SCHEMA_TYPE_SEQUENCE, 1 as i32)
                    as xmlSchemaTypePtr;
            child = unsafe { (*child).next };
        } else if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"group\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            let fresh245 = unsafe { &mut ((*type_0).subtypes) };
            *fresh245 = xmlSchemaParseModelGroupDefRef(ctxt, schema, child) as xmlSchemaTypePtr;
            child = unsafe { (*child).next };
        }
    } else if parentType as u32 == XML_SCHEMA_TYPE_SIMPLE_CONTENT as i32 as u32 {
        if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"simpleType\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            let fresh246 = unsafe { &mut ((*type_0).contentTypeDef) };
            *fresh246 = xmlSchemaParseSimpleType(ctxt, schema, child, 0 as i32);
            if (unsafe { (*type_0).contentTypeDef }).is_null() {
                return Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaType<'_>>::None;
            }
            child = unsafe { (*child).next };
        }
    }
    if parentType as u32 == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
        || parentType as u32 == XML_SCHEMA_TYPE_SIMPLE_CONTENT as i32 as u32
    {
        let mut facet: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as *mut xmlSchemaFacet;
        let mut lastfacet: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> =
            0 as xmlSchemaFacetPtr;
        while !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"minInclusive\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"minExclusive\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"maxInclusive\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"maxExclusive\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"totalDigits\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"fractionDigits\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"pattern\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"enumeration\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"whiteSpace\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"length\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"maxLength\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
            || !child.is_null()
                && !(unsafe { (*child).ns }).is_null()
                && xmlStrEqual(
                    unsafe { (*child).name },
                    b"minLength\0" as *const u8 as *const i8 as *const xmlChar,
                ) != 0
                && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            facet = xmlSchemaParseFacet(ctxt, schema, child);
            if !facet.is_null() {
                if lastfacet.is_null() {
                    let fresh247 = unsafe { &mut ((*type_0).facets) };
                    *fresh247 = facet;
                } else {
                    let fresh248 = unsafe { &mut ((*lastfacet).next) };
                    *fresh248 = facet;
                }
                lastfacet = facet;
                let fresh249 = unsafe { &mut ((*lastfacet).next) };
                *fresh249 = 0 as *mut _xmlSchemaFacet;
            }
            child = unsafe { (*child).next };
        }
        if !(unsafe { (*type_0).facets }).is_null() {
            let mut facetLink: *mut crate::src::xmlschemas::_xmlSchemaFacetLink<'_> =
                0 as *mut xmlSchemaFacetLink;
            let mut lastFacetLink: *mut crate::src::xmlschemas::_xmlSchemaFacetLink<'_> =
                0 as xmlSchemaFacetLinkPtr;
            facet = unsafe { (*type_0).facets };
            loop {
                facetLink = (unsafe { xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<
                    xmlSchemaFacetLink,
                >()
                    as u64) }) as xmlSchemaFacetLinkPtr;
                if facetLink.is_null() {
                    xmlSchemaPErrMemory(
                        ctxt,
                        b"allocating a facet link\0" as *const u8 as *const i8,
                        0 as xmlNodePtr,
                    );
                    (unsafe { xmlFree.expect("non-null function pointer")(facetLink as *mut libc::c_void) });
                    return Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaType<'_>>::None;
                }
                let fresh250 = unsafe { &mut ((*facetLink).facet) };
                *fresh250 = facet;
                let fresh251 = unsafe { &mut ((*facetLink).next) };
                *fresh251 = 0 as *mut _xmlSchemaFacetLink;
                if lastFacetLink.is_null() {
                    let fresh252 = unsafe { &mut ((*type_0).facetSet) };
                    *fresh252 = facetLink;
                } else {
                    let fresh253 = unsafe { &mut ((*lastFacetLink).next) };
                    *fresh253 = facetLink;
                }
                lastFacetLink = facetLink;
                facet = unsafe { (*facet).next };
                if facet.is_null() {
                    break;
                }
            }
        }
    }
    if (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32 {
        if xmlSchemaParseLocalAttributes(
            ctxt,
            schema,
            Some(&mut child),
            (unsafe { &mut (*type_0).attrUses }) as *mut *mut libc::c_void as *mut xmlSchemaItemListPtr,
            XML_SCHEMA_TYPE_RESTRICTION as i32,
            Option::<&'_ mut i32>::None,
        ) == -(1 as i32)
        {
            return Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaType<'_>>::None;
        }
        if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"anyAttribute\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            let fresh254 = unsafe { &mut ((*type_0).attributeWildcard) };
            *fresh254 = xmlSchemaParseAnyAttribute(ctxt, schema, child);
            child = unsafe { (*child).next };
        }
    }
    if !child.is_null() {
        if parentType as u32 == XML_SCHEMA_TYPE_COMPLEX_CONTENT as i32 as u32 {
            xmlSchemaPContentErr (ctxt , XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED , 0 as xmlSchemaBasicItemPtr , node , child , 0 as * const i8 , b"annotation?, (group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?))\0" as * const u8 as * const i8 ,) ;
        } else if parentType as u32 == XML_SCHEMA_TYPE_SIMPLE_CONTENT as i32 as u32 {
            xmlSchemaPContentErr (ctxt , XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED , 0 as xmlSchemaBasicItemPtr , node , child , 0 as * const i8 , b"(annotation?, (simpleType?, (minExclusive | minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | length | minLength | maxLength | enumeration | whiteSpace | pattern)*)?, ((attribute | attributeGroup)*, anyAttribute?))\0" as * const u8 as * const i8 ,) ;
        } else {
            xmlSchemaPContentErr (ctxt , XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED , 0 as xmlSchemaBasicItemPtr , node , child , 0 as * const i8 , b"(annotation?, (simpleType?, (minExclusive | minInclusive | maxExclusive | maxInclusive | totalDigits | fractionDigits | length | minLength | maxLength | enumeration | whiteSpace | pattern)*))\0" as * const u8 as * const i8 ,) ;
        }
    }
    return Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaType<'_>>::None;
}
extern "C" fn xmlSchemaParseExtension<'a1, 'a2, 'a3, 'a4>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut parentType: u32,
) -> Option<&'a3 mut crate::src::xmlschemas::_xmlSchemaType<'a4>>
where
    'a1: 'static,
{
    let mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaType<'_>>::None;
    }
    type_0 = unsafe { (*ctxt).ctxtType };
    (unsafe { (*type_0).flags |= (1 as i32) << 1 as i32 });
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"base\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    if xmlSchemaPValAttrQName(
        ctxt,
        schema,
        0 as xmlSchemaBasicItemPtr,
        node,
        b"base\0" as *const u8 as *const i8,
        Some(unsafe { &mut (*type_0).baseNs }),
        Some(unsafe { &mut (*type_0).base }),
    ) == 0 as i32
        && (unsafe { (*type_0).base }).is_null()
    {
        xmlSchemaPMissingAttrErr(
            ctxt,
            XML_SCHEMAP_S4S_ATTR_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            b"base\0" as *const u8 as *const i8,
            0 as *const i8,
        );
    }
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as i32),
        );
        child = unsafe { (*child).next };
    }
    if parentType as u32 == XML_SCHEMA_TYPE_COMPLEX_CONTENT as i32 as u32 {
        if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"all\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            let fresh255 = unsafe { &mut ((*type_0).subtypes) };
            *fresh255 = xmlSchemaParseModelGroup(ctxt, schema, child, XML_SCHEMA_TYPE_ALL, 1 as i32)
                as xmlSchemaTypePtr;
            child = unsafe { (*child).next };
        } else if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"choice\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            let fresh256 = unsafe { &mut ((*type_0).subtypes) };
            *fresh256 =
                xmlSchemaParseModelGroup(ctxt, schema, child, XML_SCHEMA_TYPE_CHOICE, 1 as i32)
                    as xmlSchemaTypePtr;
            child = unsafe { (*child).next };
        } else if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"sequence\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            let fresh257 = unsafe { &mut ((*type_0).subtypes) };
            *fresh257 =
                xmlSchemaParseModelGroup(ctxt, schema, child, XML_SCHEMA_TYPE_SEQUENCE, 1 as i32)
                    as xmlSchemaTypePtr;
            child = unsafe { (*child).next };
        } else if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"group\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            let fresh258 = unsafe { &mut ((*type_0).subtypes) };
            *fresh258 = xmlSchemaParseModelGroupDefRef(ctxt, schema, child) as xmlSchemaTypePtr;
            child = unsafe { (*child).next };
        }
    }
    if !child.is_null() {
        if xmlSchemaParseLocalAttributes(
            ctxt,
            schema,
            Some(&mut child),
            (unsafe { &mut (*type_0).attrUses }) as *mut *mut libc::c_void as *mut xmlSchemaItemListPtr,
            XML_SCHEMA_TYPE_EXTENSION as i32,
            Option::<&'_ mut i32>::None,
        ) == -(1 as i32)
        {
            return Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaType<'_>>::None;
        }
        if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"anyAttribute\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            let fresh259 = unsafe { &mut ((*(*ctxt).ctxtType).attributeWildcard) };
            *fresh259 = xmlSchemaParseAnyAttribute(ctxt, schema, child);
            child = unsafe { (*child).next };
        }
    }
    if !child.is_null() {
        if parentType as u32 == XML_SCHEMA_TYPE_COMPLEX_CONTENT as i32 as u32 {
            xmlSchemaPContentErr (ctxt , XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED , 0 as xmlSchemaBasicItemPtr , node , child , 0 as * const i8 , b"(annotation?, ((group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?)))\0" as * const u8 as * const i8 ,) ;
        } else {
            xmlSchemaPContentErr(
                ctxt,
                XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
                0 as xmlSchemaBasicItemPtr,
                node,
                child,
                0 as *const i8,
                b"(annotation?, ((attribute | attributeGroup)*, anyAttribute?))\0" as *const u8
                    as *const i8,
            );
        }
    }
    return Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaType<'_>>::None;
}
extern "C" fn xmlSchemaParseSimpleContent<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut hasRestrictionOrExtension: Option<&'a3 mut i32>,
) -> i32
where
    'a1: 'static,
{
    let mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    if ctxt.is_null()
        || schema.is_null()
        || node.is_null()
        || borrow(&hasRestrictionOrExtension).is_none()
    {
        return -(1 as i32);
    }
    *(borrow_mut(&mut hasRestrictionOrExtension)).unwrap() = 0 as i32;
    type_0 = unsafe { (*ctxt).ctxtType };
    (unsafe { (*type_0).contentType = XML_SCHEMA_CONTENT_SIMPLE });
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as i32),
        );
        child = unsafe { (*child).next };
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            0 as xmlNodePtr,
            0 as *const i8,
            b"(annotation?, (restriction | extension))\0" as *const u8 as *const i8,
        );
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            0 as xmlNodePtr,
            0 as *const i8,
            b"(annotation?, (restriction | extension))\0" as *const u8 as *const i8,
        );
    }
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"restriction\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        borrow(&xmlSchemaParseRestriction(
            ctxt,
            schema,
            child,
            XML_SCHEMA_TYPE_SIMPLE_CONTENT,
        ));
        *(borrow_mut(&mut hasRestrictionOrExtension)).unwrap() = 1 as i32;
        child = unsafe { (*child).next };
    } else if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"extension\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        borrow(&xmlSchemaParseExtension(
            ctxt,
            schema,
            child,
            XML_SCHEMA_TYPE_SIMPLE_CONTENT,
        ));
        *(borrow_mut(&mut hasRestrictionOrExtension)).unwrap() = 1 as i32;
        child = unsafe { (*child).next };
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, (restriction | extension))\0" as *const u8 as *const i8,
        );
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaParseComplexContent<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut hasRestrictionOrExtension: Option<&'a3 mut i32>,
) -> i32
where
    'a1: 'static,
{
    let mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    if ctxt.is_null()
        || schema.is_null()
        || node.is_null()
        || borrow(&hasRestrictionOrExtension).is_none()
    {
        return -(1 as i32);
    }
    *(borrow_mut(&mut hasRestrictionOrExtension)).unwrap() = 0 as i32;
    type_0 = unsafe { (*ctxt).ctxtType };
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) == 0
                && xmlStrEqual(
                    unsafe { (*attr).name },
                    b"mixed\0" as *const u8 as *const i8 as *mut xmlChar,
                ) == 0
            {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    xmlSchemaPValAttrID(
        ctxt,
        node,
        b"id\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    if xmlGetBooleanProp(ctxt, node, b"mixed\0" as *const u8 as *const i8, 0 as i32) != 0 {
        if (unsafe { (*type_0).flags }) & (1 as i32) << 0 as i32 == 0 as i32 {
            (unsafe { (*type_0).flags |= (1 as i32) << 0 as i32 });
        }
    }
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        xmlSchemaAddAnnotation(
            type_0 as xmlSchemaAnnotItemPtr,
            xmlSchemaParseAnnotation(ctxt, child, 1 as i32),
        );
        child = unsafe { (*child).next };
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            0 as xmlNodePtr,
            0 as *const i8,
            b"(annotation?, (restriction | extension))\0" as *const u8 as *const i8,
        );
    }
    if child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_MISSING,
            0 as xmlSchemaBasicItemPtr,
            node,
            0 as xmlNodePtr,
            0 as *const i8,
            b"(annotation?, (restriction | extension))\0" as *const u8 as *const i8,
        );
    }
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"restriction\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        borrow(&xmlSchemaParseRestriction(
            ctxt,
            schema,
            child,
            XML_SCHEMA_TYPE_COMPLEX_CONTENT,
        ));
        *(borrow_mut(&mut hasRestrictionOrExtension)).unwrap() = 1 as i32;
        child = unsafe { (*child).next };
    } else if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"extension\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        borrow(&xmlSchemaParseExtension(
            ctxt,
            schema,
            child,
            XML_SCHEMA_TYPE_COMPLEX_CONTENT,
        ));
        *(borrow_mut(&mut hasRestrictionOrExtension)).unwrap() = 1 as i32;
        child = unsafe { (*child).next };
    }
    if !child.is_null() {
        xmlSchemaPContentErr(
            ctxt,
            XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED,
            0 as xmlSchemaBasicItemPtr,
            node,
            child,
            0 as *const i8,
            b"(annotation?, (restriction | extension))\0" as *const u8 as *const i8,
        );
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaParseComplexType<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut topLevel: i32,
) -> *mut crate::src::xmlschemas::_xmlSchemaType<'a3>
where
    'a1: 'a3,
    'a3: 'a1,
    'a3: 'static,
{
    let mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut ctxtType: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut child: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    let mut name: *const u8 = 0 as *const xmlChar;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    let mut attrValue: *const u8 = 0 as *const xmlChar;
    let mut final_0: i32 = 0 as i32;
    let mut block: i32 = 0 as i32;
    let mut hasRestrictionOrExtension: i32 = 0 as i32;
    if ctxt.is_null() || schema.is_null() || node.is_null() {
        return 0 as xmlSchemaTypePtr;
    }
    ctxtType = unsafe { (*ctxt).ctxtType };
    if topLevel != 0 {
        attr = xmlSchemaGetPropNode(node, b"name\0" as *const u8 as *const i8);
        if attr.is_null() {
            xmlSchemaPMissingAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_MISSING,
                0 as xmlSchemaBasicItemPtr,
                node,
                b"name\0" as *const u8 as *const i8,
                0 as *const i8,
            );
            return 0 as xmlSchemaTypePtr;
        } else {
            if xmlSchemaPValAttrNode(
                ctxt,
                0 as xmlSchemaBasicItemPtr,
                attr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_NCNAME),
                &mut name,
            ) != 0 as i32
            {
                return 0 as xmlSchemaTypePtr;
            }
        }
    }
    if topLevel == 0 as i32 {
        type_0 = xmlSchemaAddType(
            ctxt,
            schema,
            XML_SCHEMA_TYPE_COMPLEX,
            0 as *const xmlChar,
            unsafe { (*ctxt).targetNamespace },
            node,
            0 as i32,
        );
        if type_0.is_null() {
            return 0 as xmlSchemaTypePtr;
        }
        name = unsafe { (*type_0).name };
        let fresh260 = unsafe { &mut ((*type_0).node) };
        *fresh260 = node;
        (unsafe { (*type_0).type_0 = XML_SCHEMA_TYPE_COMPLEX });
    } else {
        type_0 = xmlSchemaAddType(
            ctxt,
            schema,
            XML_SCHEMA_TYPE_COMPLEX,
            name,
            unsafe { (*ctxt).targetNamespace },
            node,
            1 as i32,
        );
        if type_0.is_null() {
            return 0 as xmlSchemaTypePtr;
        }
        let fresh261 = unsafe { &mut ((*type_0).node) };
        *fresh261 = node;
        (unsafe { (*type_0).type_0 = XML_SCHEMA_TYPE_COMPLEX });
        (unsafe { (*type_0).flags |= (1 as i32) << 3 as i32 });
    }
    let fresh262 = unsafe { &mut ((*type_0).targetNamespace) };
    *fresh262 = unsafe { (*ctxt).targetNamespace };
    attr = unsafe { (*node).properties };
    while !attr.is_null() {
        if (unsafe { (*attr).ns }).is_null() {
            if xmlStrEqual(
                unsafe { (*attr).name },
                b"id\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
                xmlSchemaPValAttrID(
                    ctxt,
                    node,
                    b"id\0" as *const u8 as *const i8 as *mut xmlChar,
                );
            } else if xmlStrEqual(
                unsafe { (*attr).name },
                b"mixed\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
                if xmlSchemaPGetBoolNodeValue(ctxt, 0 as xmlSchemaBasicItemPtr, attr as xmlNodePtr)
                    != 0
                {
                    (unsafe { (*type_0).flags |= (1 as i32) << 0 as i32 });
                }
            } else if topLevel != 0 {
                if !(xmlStrEqual(
                    unsafe { (*attr).name },
                    b"name\0" as *const u8 as *const i8 as *mut xmlChar,
                ) != 0)
                {
                    if xmlStrEqual(
                        unsafe { (*attr).name },
                        b"abstract\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) != 0
                    {
                        if xmlSchemaPGetBoolNodeValue(
                            ctxt,
                            0 as xmlSchemaBasicItemPtr,
                            attr as xmlNodePtr,
                        ) != 0
                        {
                            (unsafe { (*type_0).flags |= (1 as i32) << 20 as i32 });
                        }
                    } else if xmlStrEqual(
                        unsafe { (*attr).name },
                        b"final\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) != 0
                    {
                        attrValue = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if xmlSchemaPValAttrBlockFinal(
                            attrValue,
                            Some(unsafe { &mut (*type_0).flags }),
                            -(1 as i32),
                            (1 as i32) << 9 as i32,
                            (1 as i32) << 10 as i32,
                            -(1 as i32),
                            -(1 as i32),
                            -(1 as i32),
                        ) != 0 as i32
                        {
                            xmlSchemaPSimpleTypeErr(
                                ctxt,
                                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr,
                                0 as xmlSchemaTypePtr,
                                b"(#all | List of (extension | restriction))\0" as *const u8
                                    as *const i8,
                                attrValue,
                                0 as *const i8,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        } else {
                            final_0 = 1 as i32;
                        }
                    } else if xmlStrEqual(
                        unsafe { (*attr).name },
                        b"block\0" as *const u8 as *const i8 as *mut xmlChar,
                    ) != 0
                    {
                        attrValue = xmlSchemaGetNodeContent(ctxt, attr as xmlNodePtr);
                        if xmlSchemaPValAttrBlockFinal(
                            attrValue,
                            Some(unsafe { &mut (*type_0).flags }),
                            -(1 as i32),
                            (1 as i32) << 18 as i32,
                            (1 as i32) << 19 as i32,
                            -(1 as i32),
                            -(1 as i32),
                            -(1 as i32),
                        ) != 0 as i32
                        {
                            xmlSchemaPSimpleTypeErr(
                                ctxt,
                                XML_SCHEMAP_S4S_ATTR_INVALID_VALUE,
                                0 as xmlSchemaBasicItemPtr,
                                attr as xmlNodePtr,
                                0 as xmlSchemaTypePtr,
                                b"(#all | List of (extension | restriction)) \0" as *const u8
                                    as *const i8,
                                attrValue,
                                0 as *const i8,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        } else {
                            block = 1 as i32;
                        }
                    } else {
                        xmlSchemaPIllegalAttrErr(
                            ctxt,
                            XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                            Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                            attr,
                        );
                    }
                }
            } else {
                xmlSchemaPIllegalAttrErr(
                    ctxt,
                    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                    Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                    attr,
                );
            }
        } else if xmlStrEqual(unsafe { (*(*attr).ns).href }, unsafe { xmlSchemaNs }) != 0 {
            xmlSchemaPIllegalAttrErr(
                ctxt,
                XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED,
                Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_>>::None,
                attr,
            );
        }
        attr = unsafe { (*attr).next };
    }
    if block == 0 {
        if (unsafe { (*schema).flags }) & (1 as i32) << 7 as i32 != 0 {
            (unsafe { (*type_0).flags |= (1 as i32) << 19 as i32 });
        }
        if (unsafe { (*schema).flags }) & (1 as i32) << 6 as i32 != 0 {
            (unsafe { (*type_0).flags |= (1 as i32) << 18 as i32 });
        }
    }
    if final_0 == 0 {
        if (unsafe { (*schema).flags }) & (1 as i32) << 3 as i32 != 0 {
            (unsafe { (*type_0).flags |= (1 as i32) << 10 as i32 });
        }
        if (unsafe { (*schema).flags }) & (1 as i32) << 2 as i32 != 0 {
            (unsafe { (*type_0).flags |= (1 as i32) << 9 as i32 });
        }
    }
    child = unsafe { (*node).children };
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"annotation\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        let fresh263 = unsafe { &mut ((*type_0).annot) };
        *fresh263 = xmlSchemaParseAnnotation(ctxt, child, 1 as i32);
        child = unsafe { (*child).next };
    }
    let fresh264 = unsafe { &mut ((*ctxt).ctxtType) };
    *fresh264 = type_0;
    if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"simpleContent\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        if (unsafe { (*type_0).flags }) & (1 as i32) << 0 as i32 != 0 {
            (unsafe { (*type_0).flags ^= (1 as i32) << 0 as i32 });
        }
        xmlSchemaParseSimpleContent(ctxt, schema, child, Some(&mut hasRestrictionOrExtension));
        child = unsafe { (*child).next };
    } else if !child.is_null()
        && !(unsafe { (*child).ns }).is_null()
        && xmlStrEqual(
            unsafe { (*child).name },
            b"complexContent\0" as *const u8 as *const i8 as *const xmlChar,
        ) != 0
        && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
    {
        (unsafe { (*type_0).contentType = XML_SCHEMA_CONTENT_EMPTY });
        xmlSchemaParseComplexContent(ctxt, schema, child, Some(&mut hasRestrictionOrExtension));
        child = unsafe { (*child).next };
    } else {
        let fresh265 = unsafe { &mut ((*type_0).baseType) };
        *fresh265 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
        (unsafe { (*type_0).flags |= (1 as i32) << 2 as i32 });
        if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"all\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            let fresh266 = unsafe { &mut ((*type_0).subtypes) };
            *fresh266 = xmlSchemaParseModelGroup(ctxt, schema, child, XML_SCHEMA_TYPE_ALL, 1 as i32)
                as xmlSchemaTypePtr;
            child = unsafe { (*child).next };
        } else if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"choice\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            let fresh267 = unsafe { &mut ((*type_0).subtypes) };
            *fresh267 =
                xmlSchemaParseModelGroup(ctxt, schema, child, XML_SCHEMA_TYPE_CHOICE, 1 as i32)
                    as xmlSchemaTypePtr;
            child = unsafe { (*child).next };
        } else if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"sequence\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            let fresh268 = unsafe { &mut ((*type_0).subtypes) };
            *fresh268 =
                xmlSchemaParseModelGroup(ctxt, schema, child, XML_SCHEMA_TYPE_SEQUENCE, 1 as i32)
                    as xmlSchemaTypePtr;
            child = unsafe { (*child).next };
        } else if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"group\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            let fresh269 = unsafe { &mut ((*type_0).subtypes) };
            *fresh269 = xmlSchemaParseModelGroupDefRef(ctxt, schema, child) as xmlSchemaTypePtr;
            child = unsafe { (*child).next };
        }
        if xmlSchemaParseLocalAttributes(
            ctxt,
            schema,
            Some(&mut child),
            (unsafe { &mut (*type_0).attrUses }) as *mut *mut libc::c_void as *mut xmlSchemaItemListPtr,
            XML_SCHEMA_TYPE_RESTRICTION as i32,
            Option::<&'_ mut i32>::None,
        ) == -(1 as i32)
        {
            return 0 as xmlSchemaTypePtr;
        }
        if !child.is_null()
            && !(unsafe { (*child).ns }).is_null()
            && xmlStrEqual(
                unsafe { (*child).name },
                b"anyAttribute\0" as *const u8 as *const i8 as *const xmlChar,
            ) != 0
            && xmlStrEqual(unsafe { (*(*child).ns).href }, unsafe { xmlSchemaNs }) != 0
        {
            let fresh270 = unsafe { &mut ((*type_0).attributeWildcard) };
            *fresh270 = xmlSchemaParseAnyAttribute(ctxt, schema, child);
            child = unsafe { (*child).next };
        }
    }
    if !child.is_null() {
        xmlSchemaPContentErr (ctxt , XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED , 0 as xmlSchemaBasicItemPtr , node , child , 0 as * const i8 , b"(annotation?, (simpleContent | complexContent | ((group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?))))\0" as * const u8 as * const i8 ,) ;
    }
    if topLevel != 0 && (unsafe { (*ctxt).isRedefine }) != 0 && hasRestrictionOrExtension == 0 {
        xmlSchemaPCustomErr (ctxt , XML_SCHEMAP_SRC_REDEFINE , 0 as xmlSchemaBasicItemPtr , node , b"This is a redefinition, thus the <complexType> must have a <restriction> or <extension> grand-child\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
    }
    let fresh271 = unsafe { &mut ((*ctxt).ctxtType) };
    *fresh271 = ctxtType;
    return type_0;
}
#[no_mangle]
pub extern "C" fn xmlSchemaNewParserCtxt<'a1>(
    mut URL: *const i8,
) -> *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'_> =
        0 as *mut xmlSchemaParserCtxt;
    if URL.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    ret = xmlSchemaParserCtxtCreate();
    if ret.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    let fresh272 = unsafe { &mut ((*ret).dict) };
    *fresh272 = unsafe { xmlDictCreate() };
    let fresh273 = unsafe { &mut ((*ret).URL) };
    *fresh273 = unsafe { xmlDictLookup((*ret).dict, URL as *const xmlChar, -(1 as i32)) };
    return ret;
}
#[no_mangle]
pub extern "C" fn xmlSchemaNewMemParserCtxt<'a1>(
    mut buffer: *const i8,
    mut size: i32,
) -> *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'_> =
        0 as *mut xmlSchemaParserCtxt;
    if buffer.is_null() || size <= 0 as i32 {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    ret = xmlSchemaParserCtxtCreate();
    if ret.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    let fresh274 = unsafe { &mut ((*ret).buffer) };
    *fresh274 = buffer;
    (unsafe { (*ret).size = size });
    let fresh275 = unsafe { &mut ((*ret).dict) };
    *fresh275 = unsafe { xmlDictCreate() };
    return ret;
}
#[no_mangle]
pub extern "C" fn xmlSchemaNewDocParserCtxt<'a1>(
    mut doc: *mut crate::src::threads::_xmlDoc,
) -> *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1> {
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'_> =
        0 as *mut xmlSchemaParserCtxt;
    if doc.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    ret = xmlSchemaParserCtxtCreate();
    if ret.is_null() {
        return 0 as xmlSchemaParserCtxtPtr;
    }
    let fresh276 = unsafe { &mut ((*ret).doc) };
    *fresh276 = doc;
    let fresh277 = unsafe { &mut ((*ret).dict) };
    *fresh277 = unsafe { xmlDictCreate() };
    (unsafe { (*ret).preserve = 1 as i32 });
    return ret;
}
#[no_mangle]
pub extern "C" fn xmlSchemaFreeParserCtxt<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
) {
    if ctxt.is_null() {
        return;
    }
    if !(unsafe { (*ctxt).doc }).is_null() && (unsafe { (*ctxt).preserve }) == 0 {
        xmlFreeDoc(unsafe { (*ctxt).doc });
    }
    if !(unsafe { (*ctxt).vctxt }).is_null() {
        xmlSchemaFreeValidCtxt(unsafe { (*ctxt).vctxt });
    }
    if (unsafe { (*ctxt).ownsConstructor }) != 0 && !(unsafe { (*ctxt).constructor }).is_null() {
        xmlSchemaConstructionCtxtFree(unsafe { (*ctxt).constructor });
        let fresh278 = unsafe { &mut ((*ctxt).constructor) };
        *fresh278 = 0 as xmlSchemaConstructionCtxtPtr;
        (unsafe { (*ctxt).ownsConstructor = 0 as i32 });
    }
    if !(unsafe { (*ctxt).attrProhibs }).is_null() {
        xmlSchemaItemListFree(unsafe { (*ctxt).attrProhibs });
    }
    (unsafe { xmlDictFree((*ctxt).dict) });
    (unsafe { xmlFree.expect("non-null function pointer")(ctxt as *mut libc::c_void) });
}
extern "C" fn xmlSchemaBuildContentModelForSubstGroup<'a1>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut particle: *mut crate::src::xmlschemas::_xmlSchemaParticle,
    mut counter: i32,
    mut end: *mut crate::src::xmlregexp::_xmlAutomataState,
) -> i32 {
    let mut start: *mut crate::src::xmlregexp::_xmlAutomataState = 0 as *mut xmlAutomataState;
    let mut tmp: *mut crate::src::xmlregexp::_xmlAutomataState = 0 as *mut xmlAutomataState;
    let mut elemDecl: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> =
        0 as *mut xmlSchemaElement;
    let mut member: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> = 0 as *mut xmlSchemaElement;
    let mut substGroup: *mut crate::src::xmlschemas::_xmlSchemaSubstGroup<'_> =
        0 as *mut xmlSchemaSubstGroup;
    let mut i: i32 = 0;
    let mut ret: i32 = 0 as i32;
    elemDecl = (unsafe { (*particle).children }) as xmlSchemaElementPtr;
    start = unsafe { (*pctxt).state };
    if end.is_null() {
        end = xmlAutomataNewState(unsafe { (*pctxt).am });
    }
    substGroup = xmlSchemaSubstGroupGet(pctxt, elemDecl);
    if substGroup.is_null() {
        xmlSchemaPErr (pctxt , xmlSchemaGetComponentNode (particle as xmlSchemaBasicItemPtr) , XML_SCHEMAP_INTERNAL as i32 , b"Internal error: xmlSchemaBuildContentModelForSubstGroup, declaration is marked having a subst. group but none available.\n\0" as * const u8 as * const i8 , unsafe { (* elemDecl) . name } , 0 as * const xmlChar ,) ;
        return 0 as i32;
    }
    if counter >= 0 as i32 {
        tmp = xmlAutomataNewCountedTrans(unsafe { (*pctxt).am }, start, 0 as xmlAutomataStatePtr, counter);
        xmlAutomataNewTransition2(
            unsafe { (*pctxt).am },
            tmp,
            end,
            unsafe { (*elemDecl).name },
            unsafe { (*elemDecl).targetNamespace },
            elemDecl as *mut libc::c_void,
        );
        i = 0 as i32;
        while i < (unsafe { (*(*substGroup).members).nbItems }) {
            member = (unsafe { *((*(*substGroup).members).items).offset(i as isize) }) as xmlSchemaElementPtr;
            xmlAutomataNewTransition2(
                unsafe { (*pctxt).am },
                tmp,
                end,
                unsafe { (*member).name },
                unsafe { (*member).targetNamespace },
                member as *mut libc::c_void,
            );
            i += 1;
        }
    } else if (unsafe { (*particle).maxOccurs }) == 1 as i32 {
        xmlAutomataNewEpsilon(
            unsafe { (*pctxt).am },
            xmlAutomataNewTransition2(
                unsafe { (*pctxt).am },
                start,
                0 as xmlAutomataStatePtr,
                unsafe { (*elemDecl).name },
                unsafe { (*elemDecl).targetNamespace },
                elemDecl as *mut libc::c_void,
            ),
            end,
        );
        i = 0 as i32;
        while i < (unsafe { (*(*substGroup).members).nbItems }) {
            member = (unsafe { *((*(*substGroup).members).items).offset(i as isize) }) as xmlSchemaElementPtr;
            tmp = xmlAutomataNewTransition2(
                unsafe { (*pctxt).am },
                start,
                0 as xmlAutomataStatePtr,
                unsafe { (*member).name },
                unsafe { (*member).targetNamespace },
                member as *mut libc::c_void,
            );
            xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, tmp, end);
            i += 1;
        }
    } else {
        let mut hop: *mut crate::src::xmlregexp::_xmlAutomataState = 0 as *mut xmlAutomataState;
        let mut maxOccurs: i32 = if (unsafe { (*particle).maxOccurs }) == (1 as i32) << 30 as i32 {
            (1 as i32) << 30 as i32
        } else {
            (unsafe { (*particle).maxOccurs }) - 1 as i32
        };
        let mut minOccurs: i32 = if (unsafe { (*particle).minOccurs }) < 1 as i32 {
            0 as i32
        } else {
            (unsafe { (*particle).minOccurs }) - 1 as i32
        };
        counter = xmlAutomataNewCounter(unsafe { (*pctxt).am }, minOccurs, maxOccurs);
        hop = xmlAutomataNewState(unsafe { (*pctxt).am });
        xmlAutomataNewEpsilon(
            unsafe { (*pctxt).am },
            xmlAutomataNewTransition2(
                unsafe { (*pctxt).am },
                start,
                0 as xmlAutomataStatePtr,
                unsafe { (*elemDecl).name },
                unsafe { (*elemDecl).targetNamespace },
                elemDecl as *mut libc::c_void,
            ),
            hop,
        );
        i = 0 as i32;
        while i < (unsafe { (*(*substGroup).members).nbItems }) {
            member = (unsafe { *((*(*substGroup).members).items).offset(i as isize) }) as xmlSchemaElementPtr;
            xmlAutomataNewEpsilon(
                unsafe { (*pctxt).am },
                xmlAutomataNewTransition2(
                    unsafe { (*pctxt).am },
                    start,
                    0 as xmlAutomataStatePtr,
                    unsafe { (*member).name },
                    unsafe { (*member).targetNamespace },
                    member as *mut libc::c_void,
                ),
                hop,
            );
            i += 1;
        }
        xmlAutomataNewCountedTrans(unsafe { (*pctxt).am }, hop, start, counter);
        xmlAutomataNewCounterTrans(unsafe { (*pctxt).am }, hop, end, counter);
    }
    if (unsafe { (*particle).minOccurs }) == 0 as i32 {
        xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, start, end);
        ret = 1 as i32;
    }
    let fresh279 = unsafe { &mut ((*pctxt).state) };
    *fresh279 = end;
    return ret;
}
extern "C" fn xmlSchemaBuildContentModelForElement<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut particle: *mut crate::src::xmlschemas::_xmlSchemaParticle,
) -> i32 {
    let mut ret: i32 = 0 as i32;
    if (unsafe { (*((*particle).children as xmlSchemaElementPtr)).flags }) & (1 as i32) << 17 as i32 != 0 {
        ret = xmlSchemaBuildContentModelForSubstGroup(
            ctxt,
            particle,
            -(1 as i32),
            0 as xmlAutomataStatePtr,
        );
    } else {
        let mut elemDecl: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> =
            0 as *mut xmlSchemaElement;
        let mut start: *mut crate::src::xmlregexp::_xmlAutomataState = 0 as *mut xmlAutomataState;
        elemDecl = (unsafe { (*particle).children }) as xmlSchemaElementPtr;
        if (unsafe { (*elemDecl).flags }) & (1 as i32) << 4 as i32 != 0 {
            return 0 as i32;
        }
        if (unsafe { (*particle).maxOccurs }) == 1 as i32 {
            start = unsafe { (*ctxt).state };
            let fresh280 = unsafe { &mut ((*ctxt).state) };
            *fresh280 = xmlAutomataNewTransition2(
                unsafe { (*ctxt).am },
                start,
                0 as xmlAutomataStatePtr,
                unsafe { (*elemDecl).name },
                unsafe { (*elemDecl).targetNamespace },
                elemDecl as *mut libc::c_void,
            );
        } else if (unsafe { (*particle).maxOccurs }) >= (1 as i32) << 30 as i32
            && (unsafe { (*particle).minOccurs }) < 2 as i32
        {
            start = unsafe { (*ctxt).state };
            let fresh281 = unsafe { &mut ((*ctxt).state) };
            *fresh281 = xmlAutomataNewTransition2(
                unsafe { (*ctxt).am },
                start,
                0 as xmlAutomataStatePtr,
                unsafe { (*elemDecl).name },
                unsafe { (*elemDecl).targetNamespace },
                elemDecl as *mut libc::c_void,
            );
            let fresh282 = unsafe { &mut ((*ctxt).state) };
            *fresh282 = xmlAutomataNewTransition2(
                unsafe { (*ctxt).am },
                unsafe { (*ctxt).state },
                unsafe { (*ctxt).state },
                unsafe { (*elemDecl).name },
                unsafe { (*elemDecl).targetNamespace },
                elemDecl as *mut libc::c_void,
            );
        } else {
            let mut counter: i32 = 0;
            let mut maxOccurs: i32 = if (unsafe { (*particle).maxOccurs }) == (1 as i32) << 30 as i32 {
                (1 as i32) << 30 as i32
            } else {
                (unsafe { (*particle).maxOccurs }) - 1 as i32
            };
            let mut minOccurs: i32 = if (unsafe { (*particle).minOccurs }) < 1 as i32 {
                0 as i32
            } else {
                (unsafe { (*particle).minOccurs }) - 1 as i32
            };
            start = xmlAutomataNewEpsilon(unsafe { (*ctxt).am }, unsafe { (*ctxt).state }, 0 as xmlAutomataStatePtr);
            counter = xmlAutomataNewCounter(unsafe { (*ctxt).am }, minOccurs, maxOccurs);
            let fresh283 = unsafe { &mut ((*ctxt).state) };
            *fresh283 = xmlAutomataNewTransition2(
                unsafe { (*ctxt).am },
                start,
                0 as xmlAutomataStatePtr,
                unsafe { (*elemDecl).name },
                unsafe { (*elemDecl).targetNamespace },
                elemDecl as *mut libc::c_void,
            );
            xmlAutomataNewCountedTrans(unsafe { (*ctxt).am }, unsafe { (*ctxt).state }, start, counter);
            let fresh284 = unsafe { &mut ((*ctxt).state) };
            *fresh284 = xmlAutomataNewCounterTrans(
                unsafe { (*ctxt).am },
                unsafe { (*ctxt).state },
                0 as xmlAutomataStatePtr,
                counter,
            );
        }
        if (unsafe { (*particle).minOccurs }) == 0 as i32 {
            xmlAutomataNewEpsilon(unsafe { (*ctxt).am }, start, unsafe { (*ctxt).state });
            ret = 1 as i32;
        }
    }
    return ret;
}
extern "C" fn xmlSchemaBuildAContentModel<'a1>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut particle: *mut crate::src::xmlschemas::_xmlSchemaParticle,
) -> i32 {
    let mut ret: i32 = 0 as i32;
    let mut tmp2: i32 = 0;
    if particle.is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaBuildAContentModel\0" as *const u8 as *const i8,
            b"particle is NULL\0" as *const u8 as *const i8,
        );
        return 1 as i32;
    }
    if (unsafe { (*particle).children }).is_null() {
        return 1 as i32;
    }
    match (unsafe { (*(*particle).children).type_0 }) as u32 {
        2 => {
            let mut start: *mut crate::src::xmlregexp::_xmlAutomataState =
                0 as *mut xmlAutomataState;
            let mut end: *mut crate::src::xmlregexp::_xmlAutomataState = 0 as *mut xmlAutomataState;
            let mut wild: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'_> =
                0 as *mut xmlSchemaWildcard;
            let mut ns: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs =
                0 as *mut xmlSchemaWildcardNs;
            wild = (unsafe { (*particle).children }) as xmlSchemaWildcardPtr;
            start = unsafe { (*pctxt).state };
            end = xmlAutomataNewState(unsafe { (*pctxt).am });
            if (unsafe { (*particle).maxOccurs }) == 1 as i32 {
                if (unsafe { (*wild).any }) == 1 as i32 {
                    let fresh285 = unsafe { &mut ((*pctxt).state) };
                    *fresh285 = xmlAutomataNewTransition2(
                        unsafe { (*pctxt).am },
                        start,
                        0 as xmlAutomataStatePtr,
                        b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                        b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                        wild as *mut libc::c_void,
                    );
                    xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, unsafe { (*pctxt).state }, end);
                    let fresh286 = unsafe { &mut ((*pctxt).state) };
                    *fresh286 = xmlAutomataNewTransition2(
                        unsafe { (*pctxt).am },
                        start,
                        0 as xmlAutomataStatePtr,
                        b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                        0 as *const xmlChar,
                        wild as *mut libc::c_void,
                    );
                    xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, unsafe { (*pctxt).state }, end);
                } else if !(unsafe { (*wild).nsSet }).is_null() {
                    ns = unsafe { (*wild).nsSet };
                    loop {
                        let fresh287 = unsafe { &mut ((*pctxt).state) };
                        *fresh287 = start;
                        let fresh288 = unsafe { &mut ((*pctxt).state) };
                        *fresh288 = xmlAutomataNewTransition2(
                            unsafe { (*pctxt).am },
                            unsafe { (*pctxt).state },
                            0 as xmlAutomataStatePtr,
                            b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                            unsafe { (*ns).value },
                            wild as *mut libc::c_void,
                        );
                        xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, unsafe { (*pctxt).state }, end);
                        ns = unsafe { (*ns).next };
                        if ns.is_null() {
                            break;
                        }
                    }
                } else if !(unsafe { (*wild).negNsSet }).is_null() {
                    let fresh289 = unsafe { &mut ((*pctxt).state) };
                    *fresh289 = xmlAutomataNewNegTrans(
                        unsafe { (*pctxt).am },
                        start,
                        end,
                        b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                        unsafe { (*(*wild).negNsSet).value },
                        wild as *mut libc::c_void,
                    );
                }
            } else {
                let mut counter: i32 = 0;
                let mut hop: *mut crate::src::xmlregexp::_xmlAutomataState =
                    0 as *mut xmlAutomataState;
                let mut maxOccurs: i32 = if (unsafe { (*particle).maxOccurs }) == (1 as i32) << 30 as i32 {
                    (1 as i32) << 30 as i32
                } else {
                    (unsafe { (*particle).maxOccurs }) - 1 as i32
                };
                let mut minOccurs: i32 = if (unsafe { (*particle).minOccurs }) < 1 as i32 {
                    0 as i32
                } else {
                    (unsafe { (*particle).minOccurs }) - 1 as i32
                };
                counter = xmlAutomataNewCounter(unsafe { (*pctxt).am }, minOccurs, maxOccurs);
                hop = xmlAutomataNewState(unsafe { (*pctxt).am });
                if (unsafe { (*wild).any }) == 1 as i32 {
                    let fresh290 = unsafe { &mut ((*pctxt).state) };
                    *fresh290 = xmlAutomataNewTransition2(
                        unsafe { (*pctxt).am },
                        start,
                        0 as xmlAutomataStatePtr,
                        b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                        b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                        wild as *mut libc::c_void,
                    );
                    xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, unsafe { (*pctxt).state }, hop);
                    let fresh291 = unsafe { &mut ((*pctxt).state) };
                    *fresh291 = xmlAutomataNewTransition2(
                        unsafe { (*pctxt).am },
                        start,
                        0 as xmlAutomataStatePtr,
                        b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                        0 as *const xmlChar,
                        wild as *mut libc::c_void,
                    );
                    xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, unsafe { (*pctxt).state }, hop);
                } else if !(unsafe { (*wild).nsSet }).is_null() {
                    ns = unsafe { (*wild).nsSet };
                    loop {
                        let fresh292 = unsafe { &mut ((*pctxt).state) };
                        *fresh292 = xmlAutomataNewTransition2(
                            unsafe { (*pctxt).am },
                            start,
                            0 as xmlAutomataStatePtr,
                            b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                            unsafe { (*ns).value },
                            wild as *mut libc::c_void,
                        );
                        xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, unsafe { (*pctxt).state }, hop);
                        ns = unsafe { (*ns).next };
                        if ns.is_null() {
                            break;
                        }
                    }
                } else if !(unsafe { (*wild).negNsSet }).is_null() {
                    let fresh293 = unsafe { &mut ((*pctxt).state) };
                    *fresh293 = xmlAutomataNewNegTrans(
                        unsafe { (*pctxt).am },
                        start,
                        hop,
                        b"*\0" as *const u8 as *const i8 as *mut xmlChar,
                        unsafe { (*(*wild).negNsSet).value },
                        wild as *mut libc::c_void,
                    );
                }
                xmlAutomataNewCountedTrans(unsafe { (*pctxt).am }, hop, start, counter);
                xmlAutomataNewCounterTrans(unsafe { (*pctxt).am }, hop, end, counter);
            }
            if (unsafe { (*particle).minOccurs }) == 0 as i32 {
                xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, start, end);
                ret = 1 as i32;
            }
            let fresh294 = unsafe { &mut ((*pctxt).state) };
            *fresh294 = end;
        },
        14 => {
            ret = xmlSchemaBuildContentModelForElement(pctxt, particle);
        },
        6 => {
            let mut sub: *mut crate::src::xmlschemas::_xmlSchemaTreeItem =
                0 as *mut xmlSchemaTreeItem;
            ret = 1 as i32;
            if (unsafe { (*particle).minOccurs }) == 1 as i32 && (unsafe { (*particle).maxOccurs }) == 1 as i32 {
                sub = unsafe { (*(*particle).children).children };
                while !sub.is_null() {
                    tmp2 = xmlSchemaBuildAContentModel(pctxt, sub as xmlSchemaParticlePtr);
                    if tmp2 != 1 as i32 {
                        ret = 0 as i32;
                    }
                    sub = unsafe { (*sub).next };
                }
            } else {
                let mut oldstate: *mut crate::src::xmlregexp::_xmlAutomataState = unsafe { (*pctxt).state };
                if (unsafe { (*particle).maxOccurs }) >= (1 as i32) << 30 as i32 {
                    if (unsafe { (*particle).minOccurs }) > 1 as i32 {
                        let mut tmp: *mut crate::src::xmlregexp::_xmlAutomataState =
                            0 as *mut xmlAutomataState;
                        let mut counter_0: i32 = 0;
                        let fresh295 = unsafe { &mut ((*pctxt).state) };
                        *fresh295 =
                            xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, oldstate, 0 as xmlAutomataStatePtr);
                        oldstate = unsafe { (*pctxt).state };
                        counter_0 = xmlAutomataNewCounter(
                            unsafe { (*pctxt).am },
                            (unsafe { (*particle).minOccurs }) - 1 as i32,
                            (1 as i32) << 30 as i32,
                        );
                        sub = unsafe { (*(*particle).children).children };
                        while !sub.is_null() {
                            tmp2 = xmlSchemaBuildAContentModel(pctxt, sub as xmlSchemaParticlePtr);
                            if tmp2 != 1 as i32 {
                                ret = 0 as i32;
                            }
                            sub = unsafe { (*sub).next };
                        }
                        tmp = unsafe { (*pctxt).state };
                        xmlAutomataNewCountedTrans(unsafe { (*pctxt).am }, tmp, oldstate, counter_0);
                        let fresh296 = unsafe { &mut ((*pctxt).state) };
                        *fresh296 = xmlAutomataNewCounterTrans(
                            unsafe { (*pctxt).am },
                            tmp,
                            0 as xmlAutomataStatePtr,
                            counter_0,
                        );
                        if ret == 1 as i32 {
                            xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, oldstate, unsafe { (*pctxt).state });
                        }
                    } else {
                        let fresh297 = unsafe { &mut ((*pctxt).state) };
                        *fresh297 =
                            xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, oldstate, 0 as xmlAutomataStatePtr);
                        oldstate = unsafe { (*pctxt).state };
                        sub = unsafe { (*(*particle).children).children };
                        while !sub.is_null() {
                            tmp2 = xmlSchemaBuildAContentModel(pctxt, sub as xmlSchemaParticlePtr);
                            if tmp2 != 1 as i32 {
                                ret = 0 as i32;
                            }
                            sub = unsafe { (*sub).next };
                        }
                        xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, unsafe { (*pctxt).state }, oldstate);
                        let fresh298 = unsafe { &mut ((*pctxt).state) };
                        *fresh298 = xmlAutomataNewEpsilon(
                            unsafe { (*pctxt).am },
                            unsafe { (*pctxt).state },
                            0 as xmlAutomataStatePtr,
                        );
                        if (unsafe { (*particle).minOccurs }) == 0 as i32 {
                            xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, oldstate, unsafe { (*pctxt).state });
                            ret = 1 as i32;
                        }
                    }
                } else if (unsafe { (*particle).maxOccurs }) > 1 as i32 || (unsafe { (*particle).minOccurs }) > 1 as i32 {
                    let mut tmp_0: *mut crate::src::xmlregexp::_xmlAutomataState =
                        0 as *mut xmlAutomataState;
                    let mut counter_1: i32 = 0;
                    let fresh299 = unsafe { &mut ((*pctxt).state) };
                    *fresh299 =
                        xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, oldstate, 0 as xmlAutomataStatePtr);
                    oldstate = unsafe { (*pctxt).state };
                    counter_1 = xmlAutomataNewCounter(
                        unsafe { (*pctxt).am },
                        (unsafe { (*particle).minOccurs }) - 1 as i32,
                        (unsafe { (*particle).maxOccurs }) - 1 as i32,
                    );
                    sub = unsafe { (*(*particle).children).children };
                    while !sub.is_null() {
                        tmp2 = xmlSchemaBuildAContentModel(pctxt, sub as xmlSchemaParticlePtr);
                        if tmp2 != 1 as i32 {
                            ret = 0 as i32;
                        }
                        sub = unsafe { (*sub).next };
                    }
                    tmp_0 = unsafe { (*pctxt).state };
                    xmlAutomataNewCountedTrans(unsafe { (*pctxt).am }, tmp_0, oldstate, counter_1);
                    let fresh300 = unsafe { &mut ((*pctxt).state) };
                    *fresh300 = xmlAutomataNewCounterTrans(
                        unsafe { (*pctxt).am },
                        tmp_0,
                        0 as xmlAutomataStatePtr,
                        counter_1,
                    );
                    if (unsafe { (*particle).minOccurs }) == 0 as i32 || ret == 1 as i32 {
                        xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, oldstate, unsafe { (*pctxt).state });
                        ret = 1 as i32;
                    }
                } else {
                    sub = unsafe { (*(*particle).children).children };
                    while !sub.is_null() {
                        tmp2 = xmlSchemaBuildAContentModel(pctxt, sub as xmlSchemaParticlePtr);
                        if tmp2 != 1 as i32 {
                            ret = 0 as i32;
                        }
                        sub = unsafe { (*sub).next };
                    }
                    let fresh301 = unsafe { &mut ((*pctxt).state) };
                    *fresh301 = xmlAutomataNewEpsilon(
                        unsafe { (*pctxt).am },
                        unsafe { (*pctxt).state },
                        0 as xmlAutomataStatePtr,
                    );
                    if (unsafe { (*particle).minOccurs }) == 0 as i32 {
                        xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, oldstate, unsafe { (*pctxt).state });
                        ret = 1 as i32;
                    }
                }
            }
        },
        7 => {
            let mut sub_0: *mut crate::src::xmlschemas::_xmlSchemaTreeItem =
                0 as *mut xmlSchemaTreeItem;
            let mut start_0: *mut crate::src::xmlregexp::_xmlAutomataState =
                0 as *mut xmlAutomataState;
            let mut end_0: *mut crate::src::xmlregexp::_xmlAutomataState =
                0 as *mut xmlAutomataState;
            ret = 0 as i32;
            start_0 = unsafe { (*pctxt).state };
            end_0 = xmlAutomataNewState(unsafe { (*pctxt).am });
            if (unsafe { (*particle).maxOccurs }) == 1 as i32 {
                sub_0 = unsafe { (*(*particle).children).children };
                while !sub_0.is_null() {
                    let fresh302 = unsafe { &mut ((*pctxt).state) };
                    *fresh302 = start_0;
                    tmp2 = xmlSchemaBuildAContentModel(pctxt, sub_0 as xmlSchemaParticlePtr);
                    if tmp2 == 1 as i32 {
                        ret = 1 as i32;
                    }
                    xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, unsafe { (*pctxt).state }, end_0);
                    sub_0 = unsafe { (*sub_0).next };
                }
            } else {
                let mut counter_2: i32 = 0;
                let mut hop_0: *mut crate::src::xmlregexp::_xmlAutomataState =
                    0 as *mut xmlAutomataState;
                let mut base: *mut crate::src::xmlregexp::_xmlAutomataState =
                    0 as *mut xmlAutomataState;
                let mut maxOccurs_0: i32 = if (unsafe { (*particle).maxOccurs }) == (1 as i32) << 30 as i32 {
                    (1 as i32) << 30 as i32
                } else {
                    (unsafe { (*particle).maxOccurs }) - 1 as i32
                };
                let mut minOccurs_0: i32 = if (unsafe { (*particle).minOccurs }) < 1 as i32 {
                    0 as i32
                } else {
                    (unsafe { (*particle).minOccurs }) - 1 as i32
                };
                counter_2 = xmlAutomataNewCounter(unsafe { (*pctxt).am }, minOccurs_0, maxOccurs_0);
                hop_0 = xmlAutomataNewState(unsafe { (*pctxt).am });
                base = xmlAutomataNewState(unsafe { (*pctxt).am });
                sub_0 = unsafe { (*(*particle).children).children };
                while !sub_0.is_null() {
                    let fresh303 = unsafe { &mut ((*pctxt).state) };
                    *fresh303 = base;
                    tmp2 = xmlSchemaBuildAContentModel(pctxt, sub_0 as xmlSchemaParticlePtr);
                    if tmp2 == 1 as i32 {
                        ret = 1 as i32;
                    }
                    xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, unsafe { (*pctxt).state }, hop_0);
                    sub_0 = unsafe { (*sub_0).next };
                }
                xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, start_0, base);
                xmlAutomataNewCountedTrans(unsafe { (*pctxt).am }, hop_0, base, counter_2);
                xmlAutomataNewCounterTrans(unsafe { (*pctxt).am }, hop_0, end_0, counter_2);
                if ret == 1 as i32 {
                    xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, base, end_0);
                }
            }
            if (unsafe { (*particle).minOccurs }) == 0 as i32 {
                xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, start_0, end_0);
                ret = 1 as i32;
            }
            let fresh304 = unsafe { &mut ((*pctxt).state) };
            *fresh304 = end_0;
        },
        8 => {
            let mut start_1: *mut crate::src::xmlregexp::_xmlAutomataState =
                0 as *mut xmlAutomataState;
            let mut tmp_1: *mut crate::src::xmlregexp::_xmlAutomataState =
                0 as *mut xmlAutomataState;
            let mut sub_1: *mut crate::src::xmlschemas::_xmlSchemaParticle =
                0 as *mut xmlSchemaParticle;
            let mut elemDecl: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> =
                0 as *mut xmlSchemaElement;
            ret = 1 as i32;
            sub_1 = (unsafe { (*(*particle).children).children }) as xmlSchemaParticlePtr;
            if !sub_1.is_null() {
                ret = 0 as i32;
                start_1 = unsafe { (*pctxt).state };
                tmp_1 = xmlAutomataNewState(unsafe { (*pctxt).am });
                xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, unsafe { (*pctxt).state }, tmp_1);
                let fresh305 = unsafe { &mut ((*pctxt).state) };
                *fresh305 = tmp_1;
                while !sub_1.is_null() {
                    let fresh306 = unsafe { &mut ((*pctxt).state) };
                    *fresh306 = tmp_1;
                    elemDecl = (unsafe { (*sub_1).children }) as xmlSchemaElementPtr;
                    if elemDecl.is_null() {
                        xmlSchemaInternalErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaBuildAContentModel\0" as *const u8 as *const i8,
                            b"<element> particle has no term\0" as *const u8 as *const i8,
                        );
                        return ret;
                    }
                    if (unsafe { (*elemDecl).flags }) & (1 as i32) << 17 as i32 != 0 {
                        let mut counter_3: i32 = 0;
                        counter_3 = xmlAutomataNewCounter(
                            unsafe { (*pctxt).am },
                            unsafe { (*sub_1).minOccurs },
                            unsafe { (*sub_1).maxOccurs },
                        );
                        xmlSchemaBuildContentModelForSubstGroup(
                            pctxt,
                            sub_1,
                            counter_3,
                            unsafe { (*pctxt).state },
                        );
                    } else if (unsafe { (*sub_1).minOccurs }) == 1 as i32 && (unsafe { (*sub_1).maxOccurs }) == 1 as i32 {
                        xmlAutomataNewOnceTrans2(
                            unsafe { (*pctxt).am },
                            unsafe { (*pctxt).state },
                            unsafe { (*pctxt).state },
                            unsafe { (*elemDecl).name },
                            unsafe { (*elemDecl).targetNamespace },
                            1 as i32,
                            1 as i32,
                            elemDecl as *mut libc::c_void,
                        );
                    } else if (unsafe { (*sub_1).minOccurs }) == 0 as i32 && (unsafe { (*sub_1).maxOccurs }) == 1 as i32 {
                        xmlAutomataNewCountTrans2(
                            unsafe { (*pctxt).am },
                            unsafe { (*pctxt).state },
                            unsafe { (*pctxt).state },
                            unsafe { (*elemDecl).name },
                            unsafe { (*elemDecl).targetNamespace },
                            0 as i32,
                            1 as i32,
                            elemDecl as *mut libc::c_void,
                        );
                    }
                    sub_1 = (unsafe { (*sub_1).next }) as xmlSchemaParticlePtr;
                }
                let fresh307 = unsafe { &mut ((*pctxt).state) };
                *fresh307 = xmlAutomataNewAllTrans(
                    unsafe { (*pctxt).am },
                    unsafe { (*pctxt).state },
                    0 as xmlAutomataStatePtr,
                    0 as i32,
                );
                if (unsafe { (*particle).minOccurs }) == 0 as i32 {
                    xmlAutomataNewEpsilon(unsafe { (*pctxt).am }, start_1, unsafe { (*pctxt).state });
                    ret = 1 as i32;
                }
            }
        },
        17 => {
            ret = 1 as i32;
        },
        _ => {
            xmlSchemaInternalErr2(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaBuildAContentModel\0" as *const u8 as *const i8,
                b"found unexpected term of type '%s' in content model\0" as *const u8 as *const i8,
                xmlSchemaGetComponentTypeStr((unsafe { (*particle).children }) as xmlSchemaBasicItemPtr),
                0 as *const xmlChar,
            );
            return ret;
        },
    }
    return ret;
}
extern "C" fn xmlSchemaBuildContentModel<'a1, 'a2>(
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a1>,
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a2>,
) {
    if (unsafe { (*type_0).type_0 }) as u32 != XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        || !(unsafe { (*type_0).contModel }).is_null()
        || (unsafe { (*type_0).contentType }) as u32 != XML_SCHEMA_CONTENT_ELEMENTS as i32 as u32
            && (unsafe { (*type_0).contentType }) as u32 != XML_SCHEMA_CONTENT_MIXED as i32 as u32
    {
        return;
    }
    let fresh308 = unsafe { &mut ((*ctxt).am) };
    *fresh308 = 0 as xmlAutomataPtr;
    let fresh309 = unsafe { &mut ((*ctxt).am) };
    *fresh309 = xmlNewAutomata();
    if (unsafe { (*ctxt).am }).is_null() {
        (unsafe { (*__xmlGenericError()).expect("non-null function pointer")(
            *__xmlGenericErrorContext(),
            b"Cannot create automata for complex type %s\n\0" as *const u8 as *const i8,
            (*type_0).name,
        ) });
        return;
    }
    let fresh310 = unsafe { &mut ((*ctxt).state) };
    *fresh310 = xmlAutomataGetInitState(unsafe { (*ctxt).am });
    xmlSchemaBuildAContentModel(ctxt, (unsafe { (*type_0).subtypes }) as xmlSchemaParticlePtr);
    xmlAutomataSetFinalState(unsafe { (*ctxt).am }, unsafe { (*ctxt).state });
    let fresh311 = unsafe { &mut ((*type_0).contModel) };
    *fresh311 = xmlAutomataCompile(unsafe { (*ctxt).am });
    if (unsafe { (*type_0).contModel }).is_null() {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_INTERNAL,
            type_0 as xmlSchemaBasicItemPtr,
            unsafe { (*type_0).node },
            b"Failed to compile the content model\0" as *const u8 as *const i8,
            0 as *const xmlChar,
        );
    } else if xmlRegexpIsDeterminist(unsafe { (*type_0).contModel }) != 1 as i32 {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_NOT_DETERMINISTIC,
            type_0 as xmlSchemaBasicItemPtr,
            unsafe { (*type_0).node },
            b"The content model is not determinist\0" as *const u8 as *const i8,
            0 as *const xmlChar,
        );
    }
    let fresh312 = unsafe { &mut ((*ctxt).state) };
    *fresh312 = 0 as xmlAutomataStatePtr;
    xmlFreeAutomata(unsafe { (*ctxt).am });
    let fresh313 = unsafe { &mut ((*ctxt).am) };
    *fresh313 = 0 as xmlAutomataPtr;
}
extern "C" fn xmlSchemaResolveElementReferences<'a1, 'a2>(
    mut elemDecl: *mut crate::src::xmlschemas::_xmlSchemaElement<'a1>,
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a2>,
) where
    'a1: 'static,
{
    if ctxt.is_null()
        || elemDecl.is_null()
        || !elemDecl.is_null() && (unsafe { (*elemDecl).flags }) & (1 as i32) << 8 as i32 != 0
    {
        return;
    }
    (unsafe { (*elemDecl).flags |= (1 as i32) << 8 as i32 });
    if (unsafe { (*elemDecl).subtypes }).is_null() && !(unsafe { (*elemDecl).namedType }).is_null() {
        let mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
        type_0 = xmlSchemaGetType(
            unsafe { (*ctxt).schema },
            unsafe { (*elemDecl).namedType },
            unsafe { (*elemDecl).namedTypeNs },
        );
        if type_0.is_null() {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                elemDecl as xmlSchemaBasicItemPtr,
                unsafe { (*elemDecl).node },
                b"type\0" as *const u8 as *const i8,
                unsafe { (*elemDecl).namedType },
                unsafe { (*elemDecl).namedTypeNs },
                XML_SCHEMA_TYPE_BASIC,
                b"type definition\0" as *const u8 as *const i8,
            );
        } else {
            let fresh314 = unsafe { &mut ((*elemDecl).subtypes) };
            *fresh314 = type_0;
        }
    }
    if !(unsafe { (*elemDecl).substGroup }).is_null() {
        let mut substHead: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> =
            0 as *mut xmlSchemaElement;
        substHead = xmlSchemaGetElem(
            unsafe { (*ctxt).schema },
            unsafe { (*elemDecl).substGroup },
            unsafe { (*elemDecl).substGroupNs },
        );
        if substHead.is_null() {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                elemDecl as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"substitutionGroup\0" as *const u8 as *const i8,
                unsafe { (*elemDecl).substGroup },
                unsafe { (*elemDecl).substGroupNs },
                XML_SCHEMA_TYPE_ELEMENT,
                0 as *const i8,
            );
        } else {
            xmlSchemaResolveElementReferences(substHead, ctxt);
            let fresh315 = unsafe { &mut ((*elemDecl).refDecl) };
            *fresh315 = substHead;
            if (unsafe { (*elemDecl).subtypes }).is_null() {
                let fresh316 = unsafe { &mut ((*elemDecl).subtypes) };
                *fresh316 = unsafe { (*substHead).subtypes };
            }
        }
    }
    if (unsafe { (*elemDecl).subtypes }).is_null()
        && (unsafe { (*elemDecl).namedType }).is_null()
        && (unsafe { (*elemDecl).substGroup }).is_null()
    {
        let fresh317 = unsafe { &mut ((*elemDecl).subtypes) };
        *fresh317 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
    }
}
extern "C" fn xmlSchemaResolveUnionMemberTypes<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
) -> i32 {
    let mut link: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'_> = 0 as *mut xmlSchemaTypeLink;
    let mut lastLink: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'_> =
        0 as *mut xmlSchemaTypeLink;
    let mut newLink: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'_> =
        0 as *mut xmlSchemaTypeLink;
    let mut memberType: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    link = unsafe { (*type_0).memberTypes };
    lastLink = 0 as xmlSchemaTypeLinkPtr;
    while !link.is_null() {
        let mut name: *const u8 = 0 as *const xmlChar;
        let mut nsName: *const u8 = 0 as *const xmlChar;
        name = unsafe { (*((*link).type_0 as xmlSchemaQNameRefPtr)).name };
        nsName = unsafe { (*((*link).type_0 as xmlSchemaQNameRefPtr)).targetNamespace };
        memberType = xmlSchemaGetType(unsafe { (*ctxt).schema }, name, nsName);
        if memberType.is_null()
            || !((unsafe { (*memberType).type_0 }) as u32 == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                || (unsafe { (*memberType).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
                    && (unsafe { (*memberType).builtInType }) != XML_SCHEMAS_ANYTYPE as i32)
        {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                type_0 as xmlSchemaBasicItemPtr,
                unsafe { (*type_0).node },
                b"memberTypes\0" as *const u8 as *const i8,
                name,
                nsName,
                XML_SCHEMA_TYPE_SIMPLE,
                0 as *const i8,
            );
            if lastLink.is_null() {
                let fresh318 = unsafe { &mut ((*type_0).memberTypes) };
                *fresh318 = unsafe { (*link).next };
            } else {
                let fresh319 = unsafe { &mut ((*lastLink).next) };
                *fresh319 = unsafe { (*link).next };
            }
            newLink = link;
            link = unsafe { (*link).next };
            (unsafe { xmlFree.expect("non-null function pointer")(newLink as *mut libc::c_void) });
        } else {
            let fresh320 = unsafe { &mut ((*link).type_0) };
            *fresh320 = memberType;
            lastLink = link;
            link = unsafe { (*link).next };
        }
    }
    memberType = unsafe { (*type_0).subtypes };
    while !memberType.is_null() {
        link = (unsafe { xmlMalloc.expect("non-null function pointer")(
            ::std::mem::size_of::<xmlSchemaTypeLink>() as u64,
        ) }) as xmlSchemaTypeLinkPtr;
        if link.is_null() {
            xmlSchemaPErrMemory(
                ctxt,
                b"allocating a type link\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
        let fresh321 = unsafe { &mut ((*link).type_0) };
        *fresh321 = memberType;
        let fresh322 = unsafe { &mut ((*link).next) };
        *fresh322 = 0 as *mut _xmlSchemaTypeLink;
        if lastLink.is_null() {
            let fresh323 = unsafe { &mut ((*type_0).memberTypes) };
            *fresh323 = link;
        } else {
            let fresh324 = unsafe { &mut ((*lastLink).next) };
            *fresh324 = link;
        }
        lastLink = link;
        memberType = unsafe { (*memberType).next };
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaIsDerivedFromBuiltInType<'a1>(
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a1>,
    mut valType: i32,
) -> i32 {
    if type_0.is_null() {
        return 0 as i32;
    }
    if (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        || (unsafe { (*type_0).builtInType }) == XML_SCHEMAS_ANYTYPE as i32
    {
        return 0 as i32;
    }
    if (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32 {
        if (unsafe { (*type_0).builtInType }) == valType {
            return 1 as i32;
        }
        if (unsafe { (*type_0).builtInType }) == XML_SCHEMAS_ANYSIMPLETYPE as i32
            || (unsafe { (*type_0).builtInType }) == XML_SCHEMAS_ANYTYPE as i32
        {
            return 0 as i32;
        }
        return xmlSchemaIsDerivedFromBuiltInType(unsafe { (*type_0).subtypes }, valType);
    }
    return xmlSchemaIsDerivedFromBuiltInType(unsafe { (*type_0).subtypes }, valType);
}
extern "C" fn xmlSchemaGetPrimitiveType<'a1, 'a2>(
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a1>,
) -> *mut crate::src::xmlschemas::_xmlSchemaType<'a2>
where
    'a1: 'a2,
    'a2: 'a1,
{
    while !type_0.is_null() {
        if (unsafe { (*type_0).builtInType }) == XML_SCHEMAS_ANYSIMPLETYPE as i32
            || (unsafe { (*type_0).flags }) & (1 as i32) << 14 as i32 != 0
        {
            return type_0;
        }
        type_0 = unsafe { (*type_0).baseType };
    }
    return 0 as xmlSchemaTypePtr;
}
extern "C" fn xmlSchemaCloneWildcardNsConstraints<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut dest: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a2>,
    mut source: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a3>,
) -> i32 {
    let mut cur: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs = 0 as *mut xmlSchemaWildcardNs;
    let mut tmp: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs = 0 as *mut xmlSchemaWildcardNs;
    let mut last: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs = 0 as *mut xmlSchemaWildcardNs;
    if source.is_null() || dest.is_null() {
        return -(1 as i32);
    }
    (unsafe { (*dest).any = (*source).any });
    cur = unsafe { (*source).nsSet };
    last = 0 as xmlSchemaWildcardNsPtr;
    while !cur.is_null() {
        tmp = xmlSchemaNewWildcardNsConstraint(ctxt);
        if tmp.is_null() {
            return -(1 as i32);
        }
        let fresh325 = unsafe { &mut ((*tmp).value) };
        *fresh325 = unsafe { (*cur).value };
        if last.is_null() {
            let fresh326 = unsafe { &mut ((*dest).nsSet) };
            *fresh326 = tmp;
        } else {
            let fresh327 = unsafe { &mut ((*last).next) };
            *fresh327 = tmp;
        }
        last = tmp;
        cur = unsafe { (*cur).next };
    }
    if !(unsafe { (*dest).negNsSet }).is_null() {
        xmlSchemaFreeWildcardNsSet(unsafe { (*dest).negNsSet });
    }
    if !(unsafe { (*source).negNsSet }).is_null() {
        let fresh328 = unsafe { &mut ((*dest).negNsSet) };
        *fresh328 = xmlSchemaNewWildcardNsConstraint(ctxt);
        if (unsafe { (*dest).negNsSet }).is_null() {
            return -(1 as i32);
        }
        let fresh329 = unsafe { &mut ((*(*dest).negNsSet).value) };
        *fresh329 = unsafe { (*(*source).negNsSet).value };
    } else {
        let fresh330 = unsafe { &mut ((*dest).negNsSet) };
        *fresh330 = 0 as xmlSchemaWildcardNsPtr;
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaUnionWildcards<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut completeWild: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a2>,
    mut curWild: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a3>,
) -> i32 {
    let mut cur: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs = 0 as *mut xmlSchemaWildcardNs;
    let mut curB: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs = 0 as *mut xmlSchemaWildcardNs;
    let mut tmp: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs = 0 as *mut xmlSchemaWildcardNs;
    if (unsafe { (*completeWild).any }) == (unsafe { (*curWild).any })
        && ((unsafe { (*completeWild).nsSet }) == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr) as i32
            == ((unsafe { (*curWild).nsSet }) == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr) as i32
        && ((unsafe { (*completeWild).negNsSet }) == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr) as i32
            == ((unsafe { (*curWild).negNsSet }) == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr) as i32
    {
        if (unsafe { (*completeWild).negNsSet }).is_null()
            || (unsafe { (*(*completeWild).negNsSet).value }) == (unsafe { (*(*curWild).negNsSet).value })
        {
            if !(unsafe { (*completeWild).nsSet }).is_null() {
                let mut found: i32 = 0 as i32;
                cur = unsafe { (*completeWild).nsSet };
                while !cur.is_null() {
                    found = 0 as i32;
                    curB = unsafe { (*curWild).nsSet };
                    while !curB.is_null() {
                        if (unsafe { (*cur).value }) == (unsafe { (*curB).value }) {
                            found = 1 as i32;
                            break;
                        } else {
                            curB = unsafe { (*curB).next };
                        }
                    }
                    if found == 0 {
                        break;
                    }
                    cur = unsafe { (*cur).next };
                }
                if found != 0 {
                    return 0 as i32;
                }
            } else {
                return 0 as i32;
            }
        }
    }
    if (unsafe { (*completeWild).any }) != (unsafe { (*curWild).any }) {
        if (unsafe { (*completeWild).any }) == 0 as i32 {
            (unsafe { (*completeWild).any = 1 as i32 });
            if !(unsafe { (*completeWild).nsSet }).is_null() {
                xmlSchemaFreeWildcardNsSet(unsafe { (*completeWild).nsSet });
                let fresh331 = unsafe { &mut ((*completeWild).nsSet) };
                *fresh331 = 0 as xmlSchemaWildcardNsPtr;
            }
            if !(unsafe { (*completeWild).negNsSet }).is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(
                    (*completeWild).negNsSet as *mut libc::c_void,
                ) });
                let fresh332 = unsafe { &mut ((*completeWild).negNsSet) };
                *fresh332 = 0 as xmlSchemaWildcardNsPtr;
            }
        }
        return 0 as i32;
    }
    if !(unsafe { (*completeWild).nsSet }).is_null() && !(unsafe { (*curWild).nsSet }).is_null() {
        let mut found_0: i32 = 0;
        let mut start: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs =
            0 as *mut xmlSchemaWildcardNs;
        cur = unsafe { (*curWild).nsSet };
        start = unsafe { (*completeWild).nsSet };
        while !cur.is_null() {
            found_0 = 0 as i32;
            curB = start;
            while !curB.is_null() {
                if (unsafe { (*cur).value }) == (unsafe { (*curB).value }) {
                    found_0 = 1 as i32;
                    break;
                } else {
                    curB = unsafe { (*curB).next };
                }
            }
            if found_0 == 0 {
                tmp = xmlSchemaNewWildcardNsConstraint(ctxt);
                if tmp.is_null() {
                    return -(1 as i32);
                }
                let fresh333 = unsafe { &mut ((*tmp).value) };
                *fresh333 = unsafe { (*cur).value };
                let fresh334 = unsafe { &mut ((*tmp).next) };
                *fresh334 = unsafe { (*completeWild).nsSet };
                let fresh335 = unsafe { &mut ((*completeWild).nsSet) };
                *fresh335 = tmp;
            }
            cur = unsafe { (*cur).next };
        }
        return 0 as i32;
    }
    if !(unsafe { (*completeWild).negNsSet }).is_null()
        && !(unsafe { (*curWild).negNsSet }).is_null()
        && (unsafe { (*(*completeWild).negNsSet).value }) != (unsafe { (*(*curWild).negNsSet).value })
    {
        let fresh336 = unsafe { &mut ((*(*completeWild).negNsSet).value) };
        *fresh336 = 0 as *const xmlChar;
        return 0 as i32;
    }
    if !(unsafe { (*completeWild).negNsSet }).is_null()
        && !(unsafe { (*(*completeWild).negNsSet).value }).is_null()
        && !(unsafe { (*curWild).nsSet }).is_null()
        || !(unsafe { (*curWild).negNsSet }).is_null()
            && !(unsafe { (*(*curWild).negNsSet).value }).is_null()
            && !(unsafe { (*completeWild).nsSet }).is_null()
    {
        let mut nsFound: i32 = 0;
        let mut absentFound: i32 = 0 as i32;
        if !(unsafe { (*completeWild).nsSet }).is_null() {
            cur = unsafe { (*completeWild).nsSet };
            curB = unsafe { (*curWild).negNsSet };
        } else {
            cur = unsafe { (*curWild).nsSet };
            curB = unsafe { (*completeWild).negNsSet };
        }
        nsFound = 0 as i32;
        while !cur.is_null() {
            if (unsafe { (*cur).value }).is_null() {
                absentFound = 1 as i32;
            } else if (unsafe { (*cur).value }) == (unsafe { (*curB).value }) {
                nsFound = 1 as i32;
            }
            if nsFound != 0 && absentFound != 0 {
                break;
            }
            cur = unsafe { (*cur).next };
        }
        if nsFound != 0 && absentFound != 0 {
            (unsafe { (*completeWild).any = 1 as i32 });
            if !(unsafe { (*completeWild).nsSet }).is_null() {
                xmlSchemaFreeWildcardNsSet(unsafe { (*completeWild).nsSet });
                let fresh337 = unsafe { &mut ((*completeWild).nsSet) };
                *fresh337 = 0 as xmlSchemaWildcardNsPtr;
            }
            if !(unsafe { (*completeWild).negNsSet }).is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(
                    (*completeWild).negNsSet as *mut libc::c_void,
                ) });
                let fresh338 = unsafe { &mut ((*completeWild).negNsSet) };
                *fresh338 = 0 as xmlSchemaWildcardNsPtr;
            }
        } else if nsFound != 0 && absentFound == 0 {
            if !(unsafe { (*completeWild).nsSet }).is_null() {
                xmlSchemaFreeWildcardNsSet(unsafe { (*completeWild).nsSet });
                let fresh339 = unsafe { &mut ((*completeWild).nsSet) };
                *fresh339 = 0 as xmlSchemaWildcardNsPtr;
            }
            if (unsafe { (*completeWild).negNsSet }).is_null() {
                let fresh340 = unsafe { &mut ((*completeWild).negNsSet) };
                *fresh340 = xmlSchemaNewWildcardNsConstraint(ctxt);
                if (unsafe { (*completeWild).negNsSet }).is_null() {
                    return -(1 as i32);
                }
            }
            let fresh341 = unsafe { &mut ((*(*completeWild).negNsSet).value) };
            *fresh341 = 0 as *const xmlChar;
        } else if nsFound == 0 && absentFound != 0 {
            xmlSchemaPErr(
                ctxt,
                unsafe { (*completeWild).node },
                XML_SCHEMAP_UNION_NOT_EXPRESSIBLE as i32,
                b"The union of the wildcard is not expressible.\n\0" as *const u8 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return XML_SCHEMAP_UNION_NOT_EXPRESSIBLE as i32;
        } else {
            if nsFound == 0 && absentFound == 0 {
                if (unsafe { (*completeWild).negNsSet }).is_null() {
                    if !(unsafe { (*completeWild).nsSet }).is_null() {
                        xmlSchemaFreeWildcardNsSet(unsafe { (*completeWild).nsSet });
                        let fresh342 = unsafe { &mut ((*completeWild).nsSet) };
                        *fresh342 = 0 as xmlSchemaWildcardNsPtr;
                    }
                    let fresh343 = unsafe { &mut ((*completeWild).negNsSet) };
                    *fresh343 = xmlSchemaNewWildcardNsConstraint(ctxt);
                    if (unsafe { (*completeWild).negNsSet }).is_null() {
                        return -(1 as i32);
                    }
                    let fresh344 = unsafe { &mut ((*(*completeWild).negNsSet).value) };
                    *fresh344 = unsafe { (*(*curWild).negNsSet).value };
                }
            }
        }
        return 0 as i32;
    }
    if !(unsafe { (*completeWild).negNsSet }).is_null()
        && (unsafe { (*(*completeWild).negNsSet).value }).is_null()
        && !(unsafe { (*curWild).nsSet }).is_null()
        || !(unsafe { (*curWild).negNsSet }).is_null()
            && (unsafe { (*(*curWild).negNsSet).value }).is_null()
            && !(unsafe { (*completeWild).nsSet }).is_null()
    {
        if !(unsafe { (*completeWild).nsSet }).is_null() {
            cur = unsafe { (*completeWild).nsSet };
        } else {
            cur = unsafe { (*curWild).nsSet };
        }
        while !cur.is_null() {
            if (unsafe { (*cur).value }).is_null() {
                (unsafe { (*completeWild).any = 1 as i32 });
                if !(unsafe { (*completeWild).nsSet }).is_null() {
                    xmlSchemaFreeWildcardNsSet(unsafe { (*completeWild).nsSet });
                    let fresh345 = unsafe { &mut ((*completeWild).nsSet) };
                    *fresh345 = 0 as xmlSchemaWildcardNsPtr;
                }
                if !(unsafe { (*completeWild).negNsSet }).is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(
                        (*completeWild).negNsSet as *mut libc::c_void,
                    ) });
                    let fresh346 = unsafe { &mut ((*completeWild).negNsSet) };
                    *fresh346 = 0 as xmlSchemaWildcardNsPtr;
                }
                return 0 as i32;
            }
            cur = unsafe { (*cur).next };
        }
        if (unsafe { (*completeWild).negNsSet }).is_null() {
            if !(unsafe { (*completeWild).nsSet }).is_null() {
                xmlSchemaFreeWildcardNsSet(unsafe { (*completeWild).nsSet });
                let fresh347 = unsafe { &mut ((*completeWild).nsSet) };
                *fresh347 = 0 as xmlSchemaWildcardNsPtr;
            }
            let fresh348 = unsafe { &mut ((*completeWild).negNsSet) };
            *fresh348 = xmlSchemaNewWildcardNsConstraint(ctxt);
            if (unsafe { (*completeWild).negNsSet }).is_null() {
                return -(1 as i32);
            }
            let fresh349 = unsafe { &mut ((*(*completeWild).negNsSet).value) };
            *fresh349 = 0 as *const xmlChar;
        }
        return 0 as i32;
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaIntersectWildcards<'a1, 'a2, 'a3>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut completeWild: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a2>,
    mut curWild: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a3>,
) -> i32 {
    let mut cur: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs = 0 as *mut xmlSchemaWildcardNs;
    let mut curB: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs = 0 as *mut xmlSchemaWildcardNs;
    let mut prev: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs = 0 as *mut xmlSchemaWildcardNs;
    let mut tmp: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs = 0 as *mut xmlSchemaWildcardNs;
    if (unsafe { (*completeWild).any }) == (unsafe { (*curWild).any })
        && ((unsafe { (*completeWild).nsSet }) == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr) as i32
            == ((unsafe { (*curWild).nsSet }) == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr) as i32
        && ((unsafe { (*completeWild).negNsSet }) == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr) as i32
            == ((unsafe { (*curWild).negNsSet }) == 0 as *mut libc::c_void as xmlSchemaWildcardNsPtr) as i32
    {
        if (unsafe { (*completeWild).negNsSet }).is_null()
            || (unsafe { (*(*completeWild).negNsSet).value }) == (unsafe { (*(*curWild).negNsSet).value })
        {
            if !(unsafe { (*completeWild).nsSet }).is_null() {
                let mut found: i32 = 0 as i32;
                cur = unsafe { (*completeWild).nsSet };
                while !cur.is_null() {
                    found = 0 as i32;
                    curB = unsafe { (*curWild).nsSet };
                    while !curB.is_null() {
                        if (unsafe { (*cur).value }) == (unsafe { (*curB).value }) {
                            found = 1 as i32;
                            break;
                        } else {
                            curB = unsafe { (*curB).next };
                        }
                    }
                    if found == 0 {
                        break;
                    }
                    cur = unsafe { (*cur).next };
                }
                if found != 0 {
                    return 0 as i32;
                }
            } else {
                return 0 as i32;
            }
        }
    }
    if (unsafe { (*completeWild).any }) != (unsafe { (*curWild).any }) && (unsafe { (*completeWild).any }) != 0 {
        if xmlSchemaCloneWildcardNsConstraints(ctxt, completeWild, curWild) == -(1 as i32) {
            return -(1 as i32);
        }
        return 0 as i32;
    }
    if !(unsafe { (*completeWild).negNsSet }).is_null() && !(unsafe { (*curWild).nsSet }).is_null()
        || !(unsafe { (*curWild).negNsSet }).is_null() && !(unsafe { (*completeWild).nsSet }).is_null()
    {
        let mut neg: *const u8 = 0 as *const xmlChar;
        if (unsafe { (*completeWild).nsSet }).is_null() {
            neg = unsafe { (*(*completeWild).negNsSet).value };
            if xmlSchemaCloneWildcardNsConstraints(ctxt, completeWild, curWild) == -(1 as i32) {
                return -(1 as i32);
            }
        } else {
            neg = unsafe { (*(*curWild).negNsSet).value };
        }
        prev = 0 as xmlSchemaWildcardNsPtr;
        cur = unsafe { (*completeWild).nsSet };
        while !cur.is_null() {
            if (unsafe { (*cur).value }).is_null() {
                if prev.is_null() {
                    let fresh350 = unsafe { &mut ((*completeWild).nsSet) };
                    *fresh350 = unsafe { (*cur).next };
                } else {
                    let fresh351 = unsafe { &mut ((*prev).next) };
                    *fresh351 = unsafe { (*cur).next };
                }
                (unsafe { xmlFree.expect("non-null function pointer")(cur as *mut libc::c_void) });
                break;
            } else {
                prev = cur;
                cur = unsafe { (*cur).next };
            }
        }
        if !neg.is_null() {
            prev = 0 as xmlSchemaWildcardNsPtr;
            cur = unsafe { (*completeWild).nsSet };
            while !cur.is_null() {
                if (unsafe { (*cur).value }) == neg {
                    if prev.is_null() {
                        let fresh352 = unsafe { &mut ((*completeWild).nsSet) };
                        *fresh352 = unsafe { (*cur).next };
                    } else {
                        let fresh353 = unsafe { &mut ((*prev).next) };
                        *fresh353 = unsafe { (*cur).next };
                    }
                    (unsafe { xmlFree.expect("non-null function pointer")(cur as *mut libc::c_void) });
                    break;
                } else {
                    prev = cur;
                    cur = unsafe { (*cur).next };
                }
            }
        }
        return 0 as i32;
    }
    if !(unsafe { (*completeWild).nsSet }).is_null() && !(unsafe { (*curWild).nsSet }).is_null() {
        let mut found_0: i32 = 0;
        cur = unsafe { (*completeWild).nsSet };
        prev = 0 as xmlSchemaWildcardNsPtr;
        while !cur.is_null() {
            found_0 = 0 as i32;
            curB = unsafe { (*curWild).nsSet };
            while !curB.is_null() {
                if (unsafe { (*cur).value }) == (unsafe { (*curB).value }) {
                    found_0 = 1 as i32;
                    break;
                } else {
                    curB = unsafe { (*curB).next };
                }
            }
            if found_0 == 0 {
                if prev.is_null() {
                    let fresh354 = unsafe { &mut ((*completeWild).nsSet) };
                    *fresh354 = unsafe { (*cur).next };
                } else {
                    let fresh355 = unsafe { &mut ((*prev).next) };
                    *fresh355 = unsafe { (*cur).next };
                }
                tmp = unsafe { (*cur).next };
                (unsafe { xmlFree.expect("non-null function pointer")(cur as *mut libc::c_void) });
                cur = tmp;
            } else {
                prev = cur;
                cur = unsafe { (*cur).next };
            }
        }
        return 0 as i32;
    }
    if !(unsafe { (*completeWild).negNsSet }).is_null()
        && !(unsafe { (*curWild).negNsSet }).is_null()
        && (unsafe { (*(*completeWild).negNsSet).value }) != (unsafe { (*(*curWild).negNsSet).value })
        && !(unsafe { (*(*completeWild).negNsSet).value }).is_null()
        && !(unsafe { (*(*curWild).negNsSet).value }).is_null()
    {
        xmlSchemaPErr(
            ctxt,
            unsafe { (*completeWild).node },
            XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE as i32,
            b"The intersection of the wildcard is not expressible.\n\0" as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE as i32;
    }
    if !(unsafe { (*completeWild).negNsSet }).is_null()
        && !(unsafe { (*curWild).negNsSet }).is_null()
        && (unsafe { (*(*completeWild).negNsSet).value }) != (unsafe { (*(*curWild).negNsSet).value })
        && (unsafe { (*(*completeWild).negNsSet).value }).is_null()
    {
        let fresh356 = unsafe { &mut ((*(*completeWild).negNsSet).value) };
        *fresh356 = unsafe { (*(*curWild).negNsSet).value };
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaCheckCOSNSSubset<'a1, 'a2>(
    mut sub: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a1>,
    mut super_0: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a2>,
) -> i32 {
    if (unsafe { (*super_0).any }) != 0 {
        return 0 as i32;
    }
    if !(unsafe { (*sub).negNsSet }).is_null()
        && !(unsafe { (*super_0).negNsSet }).is_null()
        && (unsafe { (*(*sub).negNsSet).value }) == (unsafe { (*(*super_0).negNsSet).value })
    {
        return 0 as i32;
    }
    if !(unsafe { (*sub).nsSet }).is_null() {
        if !(unsafe { (*super_0).nsSet }).is_null() {
            let mut cur: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs =
                0 as *mut xmlSchemaWildcardNs;
            let mut curB: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs =
                0 as *mut xmlSchemaWildcardNs;
            let mut found: i32 = 0 as i32;
            cur = unsafe { (*sub).nsSet };
            while !cur.is_null() {
                found = 0 as i32;
                curB = unsafe { (*super_0).nsSet };
                while !curB.is_null() {
                    if (unsafe { (*cur).value }) == (unsafe { (*curB).value }) {
                        found = 1 as i32;
                        break;
                    } else {
                        curB = unsafe { (*curB).next };
                    }
                }
                if found == 0 {
                    return 1 as i32;
                }
                cur = unsafe { (*cur).next };
            }
            if found != 0 {
                return 0 as i32;
            }
        } else if !(unsafe { (*super_0).negNsSet }).is_null() {
            let mut cur_0: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs =
                0 as *mut xmlSchemaWildcardNs;
            cur_0 = unsafe { (*sub).nsSet };
            while !cur_0.is_null() {
                if (unsafe { (*cur_0).value }) == (unsafe { (*(*super_0).negNsSet).value }) {
                    return 1 as i32;
                }
                cur_0 = unsafe { (*cur_0).next };
            }
            return 0 as i32;
        }
    }
    return 1 as i32;
}
extern "C" fn xmlSchemaGetEffectiveValueConstraint<'a1, 'a2, 'a3, 'a4>(
    mut attruse: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'a1>,
    mut fixed: Option<&'a2 mut i32>,
    mut value: Option<&'a3 mut *const u8>,
    mut val: Option<&'a4 mut *mut crate::src::xmlschemastypes::_xmlSchemaVal>,
) -> i32 {
    *(borrow_mut(&mut fixed)).unwrap() = 0 as i32;
    *(borrow_mut(&mut value)).unwrap() = 0 as *const xmlChar;
    if !borrow(&val).is_none() {
        *(borrow_mut(&mut val)).unwrap() = 0 as xmlSchemaValPtr;
    }
    if !(unsafe { (*attruse).defValue }).is_null() {
        *(borrow_mut(&mut value)).unwrap() = unsafe { (*attruse).defValue };
        if !borrow(&val).is_none() {
            *(borrow_mut(&mut val)).unwrap() = unsafe { (*attruse).defVal };
        }
        if (unsafe { (*attruse).flags }) & (1 as i32) << 0 as i32 != 0 {
            *(borrow_mut(&mut fixed)).unwrap() = 1 as i32;
        }
        return 1 as i32;
    } else {
        if !(unsafe { (*attruse).attrDecl }).is_null() && !(unsafe { (*(*attruse).attrDecl).defValue }).is_null() {
            *(borrow_mut(&mut value)).unwrap() = unsafe { (*(*attruse).attrDecl).defValue };
            if !borrow(&val).is_none() {
                *(borrow_mut(&mut val)).unwrap() = unsafe { (*(*attruse).attrDecl).defVal };
            }
            if (unsafe { (*(*attruse).attrDecl).flags }) & (1 as i32) << 9 as i32 != 0 {
                *(borrow_mut(&mut fixed)).unwrap() = 1 as i32;
            }
            return 1 as i32;
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaCheckCVCWildcardNamespace<'a1>(
    mut wild: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a1>,
    mut ns: *const u8,
) -> i32 {
    if wild.is_null() {
        return -(1 as i32);
    }
    if (unsafe { (*wild).any }) != 0 {
        return 0 as i32;
    } else {
        if !(unsafe { (*wild).nsSet }).is_null() {
            let mut cur: *mut crate::src::xmlschemas::_xmlSchemaWildcardNs =
                0 as *mut xmlSchemaWildcardNs;
            cur = unsafe { (*wild).nsSet };
            while !cur.is_null() {
                if xmlStrEqual(unsafe { (*cur).value }, ns) != 0 {
                    return 0 as i32;
                }
                cur = unsafe { (*cur).next };
            }
        } else if !(unsafe { (*wild).negNsSet }).is_null()
            && !ns.is_null()
            && xmlStrEqual(unsafe { (*(*wild).negNsSet).value }, ns) == 0
        {
            return 0 as i32;
        }
    }
    return 1 as i32;
}
extern "C" fn xmlSchemaCheckDerivationOKRestriction2to4<'a1, 'a2, 'a3, 'a4, 'a5>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut action: i32,
    mut item: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2>,
    mut baseItem: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a3>,
    mut uses: *mut crate::src::xmlschemas::_xmlSchemaItemList,
    mut baseUses: *mut crate::src::xmlschemas::_xmlSchemaItemList,
    mut wild: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a4>,
    mut baseWild: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a5>,
) -> i32 {
    let mut cur: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_> =
        0 as xmlSchemaAttributeUsePtr;
    let mut bcur: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_> =
        0 as *mut xmlSchemaAttributeUse;
    let mut i: i32 = 0;
    let mut j: i32 = 0;
    let mut found: i32 = 0;
    let mut bEffValue: *const u8 = 0 as *const xmlChar;
    let mut effFixed: i32 = 0;
    if !uses.is_null() {
        i = 0 as i32;
        while i < (unsafe { (*uses).nbItems }) {
            cur = (unsafe { *((*uses).items).offset(i as isize) }) as xmlSchemaAttributeUsePtr;
            found = 0 as i32;
            if !baseUses.is_null() {
                j = 0 as i32;
                while j < (unsafe { (*baseUses).nbItems }) {
                    bcur = (unsafe { *((*baseUses).items).offset(j as isize) }) as xmlSchemaAttributeUsePtr;
                    if (unsafe { (*(*cur).attrDecl).name }) == (unsafe { (*(*bcur).attrDecl).name })
                        && (unsafe { (*(*cur).attrDecl).targetNamespace }) == (unsafe { (*(*bcur).attrDecl).targetNamespace })
                    {
                        found = 1 as i32;
                        if (unsafe { (*cur).occurs }) == 2 as i32 && (unsafe { (*bcur).occurs }) == 1 as i32 {
                            let mut str: *mut u8 = 0 as *mut xmlChar;
                            xmlSchemaPAttrUseErr4 (pctxt , XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1 , xmlSchemaGetComponentNode (item) , item , cur , b"The 'optional' attribute use is inconsistent with the corresponding 'required' attribute use of the %s %s\0" as * const u8 as * const i8 , if action == 0 as i32 { b"base\0" as * const u8 as * const i8 as * const xmlChar } else { b"redefined\0" as * const u8 as * const i8 as * const xmlChar } , xmlSchemaGetComponentDesignation (Some (& mut str) , baseItem as * mut libc :: c_void ,) , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
                            if !str.is_null() {
                                (unsafe { xmlFree.expect("non-null function pointer")(
                                    str as *mut libc::c_void,
                                ) });
                                str = 0 as *mut xmlChar;
                            }
                        } else if xmlSchemaCheckCOSSTDerivedOK(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            unsafe { (*(*cur).attrDecl).subtypes },
                            unsafe { (*(*bcur).attrDecl).subtypes },
                            0 as i32,
                        ) != 0 as i32
                        {
                            let mut strA: *mut u8 = 0 as *mut xmlChar;
                            let mut strB: *mut u8 = 0 as *mut xmlChar;
                            let mut strC: *mut u8 = 0 as *mut xmlChar;
                            xmlSchemaPAttrUseErr4 (pctxt , XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2 , xmlSchemaGetComponentNode (item) , item , cur , b"The attribute declaration's %s is not validly derived from the corresponding %s of the attribute declaration in the %s %s\0" as * const u8 as * const i8 , xmlSchemaGetComponentDesignation (Some (& mut strA) , (unsafe { (* (* cur) . attrDecl) . subtypes }) as * mut libc :: c_void ,) , xmlSchemaGetComponentDesignation (Some (& mut strB) , (unsafe { (* (* bcur) . attrDecl) . subtypes }) as * mut libc :: c_void ,) , if action == 0 as i32 { b"base\0" as * const u8 as * const i8 as * const xmlChar } else { b"redefined\0" as * const u8 as * const i8 as * const xmlChar } , xmlSchemaGetComponentDesignation (Some (& mut strC) , baseItem as * mut libc :: c_void ,) ,) ;
                            if !strA.is_null() {
                                (unsafe { xmlFree.expect("non-null function pointer")(
                                    strA as *mut libc::c_void,
                                ) });
                                strA = 0 as *mut xmlChar;
                            }
                            if !strB.is_null() {
                                (unsafe { xmlFree.expect("non-null function pointer")(
                                    strB as *mut libc::c_void,
                                ) });
                                strB = 0 as *mut xmlChar;
                            }
                            if !strC.is_null() {
                                (unsafe { xmlFree.expect("non-null function pointer")(
                                    strC as *mut libc::c_void,
                                ) });
                                strC = 0 as *mut xmlChar;
                            }
                        } else {
                            xmlSchemaGetEffectiveValueConstraint (bcur , Some (& mut effFixed) , Some (& mut bEffValue) , Option :: < & '_ mut * mut crate :: src :: xmlschemastypes :: _xmlSchemaVal > :: None ,) ;
                            if !bEffValue.is_null() && effFixed == 1 as i32 {
                                let mut rEffValue: *const u8 = 0 as *const xmlChar;
                                xmlSchemaGetEffectiveValueConstraint (bcur , Some (& mut effFixed) , Some (& mut rEffValue) , Option :: < & '_ mut * mut crate :: src :: xmlschemastypes :: _xmlSchemaVal > :: None ,) ;
                                if effFixed == 0 as i32 || !(rEffValue == bEffValue) {
                                    let mut str_0: *mut u8 = 0 as *mut xmlChar;
                                    xmlSchemaPAttrUseErr4 (pctxt , XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3 , xmlSchemaGetComponentNode (item) , item , cur , b"The effective value constraint of the attribute use is inconsistent with its correspondent in the %s %s\0" as * const u8 as * const i8 , if action == 0 as i32 { b"base\0" as * const u8 as * const i8 as * const xmlChar } else { b"redefined\0" as * const u8 as * const i8 as * const xmlChar } , xmlSchemaGetComponentDesignation (Some (& mut str_0) , baseItem as * mut libc :: c_void ,) , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
                                    if !str_0.is_null() {
                                        (unsafe { xmlFree.expect("non-null function pointer")(
                                            str_0 as *mut libc::c_void,
                                        ) });
                                        str_0 = 0 as *mut xmlChar;
                                    }
                                }
                            }
                        }
                        break;
                    } else {
                        j += 1;
                    }
                }
            }
            if found == 0 {
                if baseWild.is_null()
                    || xmlSchemaCheckCVCWildcardNamespace(
                        baseWild,
                        unsafe { (*(*cur).attrDecl).targetNamespace },
                    ) != 0 as i32
                {
                    let mut str_1: *mut u8 = 0 as *mut xmlChar;
                    xmlSchemaPAttrUseErr4 (pctxt , XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2 , xmlSchemaGetComponentNode (item) , item , cur , b"Neither a matching attribute use, nor a matching wildcard exists in the %s %s\0" as * const u8 as * const i8 , if action == 0 as i32 { b"base\0" as * const u8 as * const i8 as * const xmlChar } else { b"redefined\0" as * const u8 as * const i8 as * const xmlChar } , xmlSchemaGetComponentDesignation (Some (& mut str_1) , baseItem as * mut libc :: c_void ,) , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
                    if !str_1.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(str_1 as *mut libc::c_void) });
                        str_1 = 0 as *mut xmlChar;
                    }
                }
            }
            i += 1;
        }
    }
    if !baseUses.is_null() {
        j = 0 as i32;
        while j < (unsafe { (*baseUses).nbItems }) {
            bcur = (unsafe { *((*baseUses).items).offset(j as isize) }) as xmlSchemaAttributeUsePtr;
            if !((unsafe { (*bcur).occurs }) != 1 as i32) {
                found = 0 as i32;
                if !uses.is_null() {
                    i = 0 as i32;
                    while i < (unsafe { (*uses).nbItems }) {
                        cur = (unsafe { *((*uses).items).offset(i as isize) }) as xmlSchemaAttributeUsePtr;
                        if (unsafe { (*(*cur).attrDecl).name }) == (unsafe { (*(*bcur).attrDecl).name })
                            && (unsafe { (*(*cur).attrDecl).targetNamespace })
                                == (unsafe { (*(*bcur).attrDecl).targetNamespace })
                        {
                            found = 1 as i32;
                            break;
                        } else {
                            i += 1;
                        }
                    }
                }
                if found == 0 {
                    let mut strA_0: *mut u8 = 0 as *mut xmlChar;
                    let mut strB_0: *mut u8 = 0 as *mut xmlChar;
                    xmlSchemaCustomErr4(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3,
                        0 as xmlNodePtr,
                        item,
                        b"A matching attribute use for the 'required' %s of the %s %s is missing\0"
                            as *const u8 as *const i8,
                        xmlSchemaGetComponentDesignation(
                            Some(&mut strA_0),
                            bcur as *mut libc::c_void,
                        ),
                        if action == 0 as i32 {
                            b"base\0" as *const u8 as *const i8 as *const xmlChar
                        } else {
                            b"redefined\0" as *const u8 as *const i8 as *const xmlChar
                        },
                        xmlSchemaGetComponentDesignation(
                            Some(&mut strB_0),
                            baseItem as *mut libc::c_void,
                        ),
                        0 as *const xmlChar,
                    );
                    if !strA_0.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(strA_0 as *mut libc::c_void) });
                        strA_0 = 0 as *mut xmlChar;
                    }
                    if !strB_0.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(strB_0 as *mut libc::c_void) });
                        strB_0 = 0 as *mut xmlChar;
                    }
                }
            }
            j += 1;
        }
    }
    if !wild.is_null() {
        if baseWild.is_null() {
            let mut str_2: *mut u8 = 0 as *mut xmlChar;
            xmlSchemaCustomErr4(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1,
                0 as xmlNodePtr,
                item,
                b"The %s has an attribute wildcard, but the %s %s '%s' does not have one\0"
                    as *const u8 as *const i8,
                xmlSchemaGetComponentTypeStr(item),
                if action == 0 as i32 {
                    b"base\0" as *const u8 as *const i8 as *const xmlChar
                } else {
                    b"redefined\0" as *const u8 as *const i8 as *const xmlChar
                },
                xmlSchemaGetComponentTypeStr(baseItem),
                xmlSchemaGetComponentQName(Some(&mut str_2), baseItem as *mut libc::c_void),
            );
            if !str_2.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(str_2 as *mut libc::c_void) });
                str_2 = 0 as *mut xmlChar;
            }
            return unsafe { (*pctxt).err };
        } else {
            if (unsafe { (*baseWild).any }) == 0 as i32 && xmlSchemaCheckCOSNSSubset(wild, baseWild) != 0 {
                let mut str_3: *mut u8 = 0 as *mut xmlChar;
                xmlSchemaCustomErr4 (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2 , 0 as xmlNodePtr , item , b"The attribute wildcard is not a valid subset of the wildcard in the %s %s '%s'\0" as * const u8 as * const i8 , if action == 0 as i32 { b"base\0" as * const u8 as * const i8 as * const xmlChar } else { b"redefined\0" as * const u8 as * const i8 as * const xmlChar } , xmlSchemaGetComponentTypeStr (baseItem) , xmlSchemaGetComponentQName (Some (& mut str_3) , baseItem as * mut libc :: c_void ,) , 0 as * const xmlChar ,) ;
                if !str_3.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str_3 as *mut libc::c_void) });
                    str_3 = 0 as *mut xmlChar;
                }
                return unsafe { (*pctxt).err };
            }
        }
        if !((unsafe { (*baseItem).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (unsafe { (*(baseItem as xmlSchemaTypePtr)).builtInType }) == XML_SCHEMAS_ANYTYPE as i32)
            && (unsafe { (*wild).processContents }) < (unsafe { (*baseWild).processContents })
        {
            let mut str_4: *mut u8 = 0 as *mut xmlChar;
            xmlSchemaCustomErr4 (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3 , 0 as xmlNodePtr , baseItem , b"The {process contents} of the attribute wildcard is weaker than the one in the %s %s '%s'\0" as * const u8 as * const i8 , if action == 0 as i32 { b"base\0" as * const u8 as * const i8 as * const xmlChar } else { b"redefined\0" as * const u8 as * const i8 as * const xmlChar } , xmlSchemaGetComponentTypeStr (baseItem) , xmlSchemaGetComponentQName (Some (& mut str_4) , baseItem as * mut libc :: c_void) , 0 as * const xmlChar ,) ;
            if !str_4.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(str_4 as *mut libc::c_void) });
                str_4 = 0 as *mut xmlChar;
            }
            return unsafe { (*pctxt).err };
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaFixupTypeAttributeUses<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
) -> i32
where
    'a2: 'static,
{
    let mut current_block: u64;
    let mut baseType: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as xmlSchemaTypePtr;
    let mut use_0: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_> =
        0 as *mut xmlSchemaAttributeUse;
    let mut uses: *mut crate::src::xmlschemas::_xmlSchemaItemList = 0 as *mut xmlSchemaItemList;
    let mut baseUses: *mut crate::src::xmlschemas::_xmlSchemaItemList =
        0 as *mut crate::src::xmlschemas::_xmlSchemaItemList;
    let mut prohibs: *mut crate::src::xmlschemas::_xmlSchemaItemList = 0 as xmlSchemaItemListPtr;
    if (unsafe { (*type_0).baseType }).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaFixupTypeAttributeUses\0" as *const u8 as *const i8,
            b"no base type\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    baseType = unsafe { (*type_0).baseType };
    if (unsafe { (*baseType).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (unsafe { (*baseType).flags }) & (1 as i32) << 22 as i32 == 0 as i32
    {
        if xmlSchemaTypeFixup(baseType, pctxt as xmlSchemaAbstractCtxtPtr) == -(1 as i32) {
            return -(1 as i32);
        }
    }
    uses = (unsafe { (*type_0).attrUses }) as xmlSchemaItemListPtr;
    baseUses = (unsafe { (*baseType).attrUses }) as xmlSchemaItemListPtr;
    if !uses.is_null() {
        if (unsafe { (*type_0).flags }) & (1 as i32) << 2 as i32 != 0 {
            if xmlSchemaExpandAttributeGroupRefs(
                pctxt,
                type_0 as xmlSchemaBasicItemPtr,
                Some(unsafe { &mut (*type_0).attributeWildcard }),
                uses,
                unsafe { (*pctxt).attrProhibs },
            ) == -(1 as i32)
            {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaFixupTypeAttributeUses\0" as *const u8 as *const i8,
                    b"failed to expand attributes\0" as *const u8 as *const i8,
                );
            }
            if (unsafe { (*(*pctxt).attrProhibs).nbItems }) != 0 as i32 {
                prohibs = unsafe { (*pctxt).attrProhibs };
            }
        } else if xmlSchemaExpandAttributeGroupRefs(
            pctxt,
            type_0 as xmlSchemaBasicItemPtr,
            Some(unsafe { &mut (*type_0).attributeWildcard }),
            uses,
            0 as xmlSchemaItemListPtr,
        ) == -(1 as i32)
        {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaFixupTypeAttributeUses\0" as *const u8 as *const i8,
                b"failed to expand attributes\0" as *const u8 as *const i8,
            );
        }
    }
    if !baseUses.is_null() {
        let mut i: i32 = 0;
        let mut j: i32 = 0;
        let mut pro: *mut crate::src::xmlschemas::_xmlSchemaAttributeUseProhib =
            0 as *mut crate::src::xmlschemas::_xmlSchemaAttributeUseProhib;
        if (unsafe { (*type_0).flags }) & (1 as i32) << 2 as i32 != 0 {
            let mut usesCount: i32 = 0;
            let mut tmp: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_> =
                0 as *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_>;
            if !uses.is_null() {
                usesCount = unsafe { (*uses).nbItems };
            } else {
                usesCount = 0 as i32;
            }
            i = 0 as i32;
            loop {
                if !(i < (unsafe { (*baseUses).nbItems })) {
                    current_block = 1874315696050160458;
                    break;
                }
                use_0 = (unsafe { *((*baseUses).items).offset(i as isize) }) as xmlSchemaAttributeUsePtr;
                if !prohibs.is_null() {
                    j = 0 as i32;
                    loop {
                        if !(j < (unsafe { (*prohibs).nbItems })) {
                            current_block = 572715077006366937;
                            break;
                        }
                        pro = (unsafe { *((*prohibs).items).offset(j as isize) })
                            as xmlSchemaAttributeUseProhibPtr;
                        if (unsafe { (*(*use_0).attrDecl).name }) == (unsafe { (*pro).name })
                            && (unsafe { (*(*use_0).attrDecl).targetNamespace }) == (unsafe { (*pro).targetNamespace })
                        {
                            current_block = 3275366147856559585;
                            break;
                        }
                        j += 1;
                    }
                } else {
                    current_block = 572715077006366937;
                }
                match current_block {
                    572715077006366937 => {
                        if usesCount != 0 {
                            j = 0 as i32;
                            loop {
                                if !(j < usesCount) {
                                    current_block = 11763295167351361500;
                                    break;
                                }
                                tmp =
                                    (unsafe { *((*uses).items).offset(j as isize) }) as xmlSchemaAttributeUsePtr;
                                if (unsafe { (*(*use_0).attrDecl).name }) == (unsafe { (*(*tmp).attrDecl).name })
                                    && (unsafe { (*(*use_0).attrDecl).targetNamespace })
                                        == (unsafe { (*(*tmp).attrDecl).targetNamespace })
                                {
                                    current_block = 3275366147856559585;
                                    break;
                                }
                                j += 1;
                            }
                        } else {
                            current_block = 11763295167351361500;
                        }
                        match current_block {
                            3275366147856559585 => {},
                            _ => {
                                if uses.is_null() {
                                    let fresh357 = unsafe { &mut ((*type_0).attrUses) };
                                    *fresh357 = xmlSchemaItemListCreate() as *mut libc::c_void;
                                    if (unsafe { (*type_0).attrUses }).is_null() {
                                        current_block = 6737818789714211697;
                                        break;
                                    }
                                    uses = (unsafe { (*type_0).attrUses }) as xmlSchemaItemListPtr;
                                }
                                xmlSchemaItemListAddSize(
                                    uses,
                                    2 as i32,
                                    use_0 as *mut libc::c_void,
                                );
                            },
                        }
                    },
                    _ => {},
                }
                i += 1;
            }
        } else {
            i = 0 as i32;
            loop {
                if !(i < (unsafe { (*baseUses).nbItems })) {
                    current_block = 1874315696050160458;
                    break;
                }
                use_0 = (unsafe { *((*baseUses).items).offset(i as isize) }) as xmlSchemaAttributeUsePtr;
                if uses.is_null() {
                    let fresh358 = unsafe { &mut ((*type_0).attrUses) };
                    *fresh358 = xmlSchemaItemListCreate() as *mut libc::c_void;
                    if (unsafe { (*type_0).attrUses }).is_null() {
                        current_block = 6737818789714211697;
                        break;
                    }
                    uses = (unsafe { (*type_0).attrUses }) as xmlSchemaItemListPtr;
                }
                xmlSchemaItemListAddSize(uses, unsafe { (*baseUses).nbItems }, use_0 as *mut libc::c_void);
                i += 1;
            }
        }
    } else {
        current_block = 1874315696050160458;
    }
    match current_block {
        1874315696050160458 => {
            if !uses.is_null() {
                if (unsafe { (*uses).nbItems }) == 0 as i32 {
                    xmlSchemaItemListFree(uses);
                    let fresh359 = unsafe { &mut ((*type_0).attrUses) };
                    *fresh359 = 0 as *mut libc::c_void;
                }
            }
            if (unsafe { (*type_0).flags }) & (1 as i32) << 1 as i32 != 0 {
                if !(unsafe { (*baseType).attributeWildcard }).is_null() {
                    if !(unsafe { (*type_0).attributeWildcard }).is_null() {
                        if xmlSchemaUnionWildcards(
                            pctxt,
                            unsafe { (*type_0).attributeWildcard },
                            unsafe { (*baseType).attributeWildcard },
                        ) == -(1 as i32)
                        {
                            current_block = 6737818789714211697;
                        } else {
                            current_block = 9705665520141849625;
                        }
                    } else {
                        let fresh360 = unsafe { &mut ((*type_0).attributeWildcard) };
                        *fresh360 = unsafe { (*baseType).attributeWildcard };
                        current_block = 9705665520141849625;
                    }
                } else {
                    current_block = 9705665520141849625;
                }
            } else {
                current_block = 9705665520141849625;
            }
            match current_block {
                6737818789714211697 => {},
                _ => return 0 as i32,
            }
        },
        _ => {},
    }
    return -(1 as i32);
}
extern "C" fn xmlSchemaTypeFinalContains<'a1>(
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a1>,
    mut final_0: i32,
) -> i32 {
    if type_0.is_null() {
        return 0 as i32;
    }
    if (unsafe { (*type_0).flags }) & final_0 != 0 {
        return 1 as i32;
    } else {
        return 0 as i32;
    };
}
extern "C" fn xmlSchemaGetUnionSimpleTypeMemberTypes<'a1, 'a2>(
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a1>,
) -> *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'a2>
where
    'a2: 'a1,
    'a1: 'a2,
{
    while !type_0.is_null() && (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_SIMPLE as i32 as u32 {
        if !(unsafe { (*type_0).memberTypes }).is_null() {
            return unsafe { (*type_0).memberTypes };
        } else {
            type_0 = unsafe { (*type_0).baseType };
        }
    }
    return 0 as xmlSchemaTypeLinkPtr;
}
extern "C" fn xmlSchemaGetParticleEmptiable(
    mut particle: *mut crate::src::xmlschemas::_xmlSchemaParticle,
) -> i32 {
    let mut part: *mut crate::src::xmlschemas::_xmlSchemaParticle = 0 as *mut xmlSchemaParticle;
    let mut emptiable: i32 = 0;
    if (unsafe { (*particle).children }).is_null() || (unsafe { (*particle).minOccurs }) == 0 as i32 {
        return 1 as i32;
    }
    part = (unsafe { (*(*particle).children).children }) as xmlSchemaParticlePtr;
    if part.is_null() {
        return 1 as i32;
    }
    while !part.is_null() {
        if (unsafe { (*(*part).children).type_0 }) as u32 == XML_SCHEMA_TYPE_ELEMENT as i32 as u32
            || (unsafe { (*(*part).children).type_0 }) as u32 == XML_SCHEMA_TYPE_ANY as i32 as u32
        {
            emptiable = ((unsafe { (*part).minOccurs }) == 0 as i32) as i32;
        } else {
            emptiable = xmlSchemaGetParticleEmptiable(part);
        }
        if (unsafe { (*(*particle).children).type_0 }) as u32 == XML_SCHEMA_TYPE_CHOICE as i32 as u32 {
            if emptiable != 0 {
                return 1 as i32;
            }
        } else if emptiable == 0 {
            return 0 as i32;
        }
        part = (unsafe { (*part).next }) as xmlSchemaParticlePtr;
    }
    if (unsafe { (*(*particle).children).type_0 }) as u32 == XML_SCHEMA_TYPE_CHOICE as i32 as u32 {
        return 0 as i32;
    } else {
        return 1 as i32;
    };
}
extern "C" fn xmlSchemaIsParticleEmptiable(
    mut particle: *mut crate::src::xmlschemas::_xmlSchemaParticle,
) -> i32 {
    if particle.is_null() || (unsafe { (*particle).minOccurs }) == 0 as i32 || (unsafe { (*particle).children }).is_null() {
        return 1 as i32;
    }
    if (unsafe { (*(*particle).children).type_0 }) as u32 == XML_SCHEMA_TYPE_SEQUENCE as i32 as u32
        || (unsafe { (*(*particle).children).type_0 }) as u32 == XML_SCHEMA_TYPE_CHOICE as i32 as u32
        || (unsafe { (*(*particle).children).type_0 }) as u32 == XML_SCHEMA_TYPE_ALL as i32 as u32
    {
        return xmlSchemaGetParticleEmptiable(particle);
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaCheckCOSSTDerivedOK<'a1, 'a2, 'a3>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
    mut baseType: *mut crate::src::xmlschemas::_xmlSchemaType<'a3>,
    mut subset: i32,
) -> i32
where
    'a3: 'a2,
    'a3: 'static,
    'a2: 'static,
    'a2: 'a3,
{
    if type_0 == baseType {
        return 0 as i32;
    }
    if (unsafe { (*type_0).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (unsafe { (*type_0).flags }) & (1 as i32) << 22 as i32 == 0 as i32
    {
        if xmlSchemaTypeFixup(type_0, actxt) == -(1 as i32) {
            return -(1 as i32);
        }
    }
    if (unsafe { (*baseType).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (unsafe { (*baseType).flags }) & (1 as i32) << 22 as i32 == 0 as i32
    {
        if xmlSchemaTypeFixup(baseType, actxt) == -(1 as i32) {
            return -(1 as i32);
        }
    }
    if subset & (1 as i32) << 0 as i32 != 0
        || xmlSchemaTypeFinalContains(unsafe { (*type_0).baseType }, (1 as i32) << 10 as i32) != 0
    {
        return XML_SCHEMAP_COS_ST_DERIVED_OK_2_1 as i32;
    }
    if (unsafe { (*type_0).baseType }) == baseType {
        return 0 as i32;
    }
    if !((unsafe { (*(*type_0).baseType).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (unsafe { (*(*type_0).baseType).builtInType }) == XML_SCHEMAS_ANYTYPE as i32)
        && xmlSchemaCheckCOSSTDerivedOK(actxt, unsafe { (*type_0).baseType }, baseType, subset) == 0 as i32
    {
        return 0 as i32;
    }
    if (unsafe { (*baseType).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (unsafe { (*baseType).builtInType }) == XML_SCHEMAS_ANYSIMPLETYPE as i32
        && ((unsafe { (*type_0).flags }) & (1 as i32) << 6 as i32 != 0
            || (unsafe { (*type_0).flags }) & (1 as i32) << 7 as i32 != 0)
    {
        return 0 as i32;
    }
    if (unsafe { (*baseType).flags }) & (1 as i32) << 7 as i32 != 0 {
        let mut cur: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'_> =
            0 as *mut xmlSchemaTypeLink;
        cur = unsafe { (*baseType).memberTypes };
        while !cur.is_null() {
            if (unsafe { (*(*cur).type_0).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32
                && (unsafe { (*(*cur).type_0).flags }) & (1 as i32) << 22 as i32 == 0 as i32
            {
                if xmlSchemaTypeFixup(unsafe { (*cur).type_0 }, actxt) == -(1 as i32) {
                    return -(1 as i32);
                }
            }
            if xmlSchemaCheckCOSSTDerivedOK(actxt, type_0, unsafe { (*cur).type_0 }, subset) == 0 as i32 {
                return 0 as i32;
            }
            cur = unsafe { (*cur).next };
        }
    }
    return XML_SCHEMAP_COS_ST_DERIVED_OK_2_2 as i32;
}
extern "C" fn xmlSchemaCheckTypeDefCircularInternal<'a1, 'a2, 'a3>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut ctxtType: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
    mut ancestor: *mut crate::src::xmlschemas::_xmlSchemaType<'a3>,
) -> i32
where
    'a2: 'a3,
    'a3: 'a2,
{
    let mut ret: i32 = 0;
    if ancestor.is_null() || (unsafe { (*ancestor).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32 {
        return 0 as i32;
    }
    if ctxtType == ancestor {
        xmlSchemaPCustomErr(
            pctxt,
            XML_SCHEMAP_ST_PROPS_CORRECT_2,
            ctxtType as xmlSchemaBasicItemPtr,
            xmlSchemaGetComponentNode(ctxtType as xmlSchemaBasicItemPtr),
            b"The definition is circular\0" as *const u8 as *const i8,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_ST_PROPS_CORRECT_2 as i32;
    }
    if (unsafe { (*ancestor).flags }) & (1 as i32) << 16 as i32 != 0 {
        return 0 as i32;
    }
    (unsafe { (*ancestor).flags |= (1 as i32) << 16 as i32 });
    ret = xmlSchemaCheckTypeDefCircularInternal(pctxt, ctxtType, unsafe { (*ancestor).baseType });
    (unsafe { (*ancestor).flags ^= (1 as i32) << 16 as i32 });
    return ret;
}
extern "C" fn xmlSchemaCheckTypeDefCircular<'a1, 'a2>(
    mut item: *mut crate::src::xmlschemas::_xmlSchemaType<'a1>,
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a2>,
) {
    if item.is_null()
        || (unsafe { (*item).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
        || (unsafe { (*item).baseType }).is_null()
    {
        return;
    }
    xmlSchemaCheckTypeDefCircularInternal(ctxt, item, unsafe { (*item).baseType });
}
extern "C" fn xmlSchemaCheckUnionTypeDefCircularRecur<'a1, 'a2, 'a3>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut ctxType: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
    mut members: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'a3>,
) -> i32
where
    'a2: 'a3,
    'a3: 'a2,
{
    let mut member: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'_> =
        0 as *mut xmlSchemaTypeLink;
    let mut memberType: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    member = members;
    while !member.is_null() {
        memberType = unsafe { (*member).type_0 };
        while !memberType.is_null()
            && (unsafe { (*memberType).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32
        {
            if memberType == ctxType {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_SRC_SIMPLE_TYPE_4,
                    ctxType as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The union type definition is circular\0" as *const u8 as *const i8,
                    0 as *const xmlChar,
                );
                return XML_SCHEMAP_SRC_SIMPLE_TYPE_4 as i32;
            }
            if (unsafe { (*memberType).flags }) & (1 as i32) << 7 as i32 != 0
                && (unsafe { (*memberType).flags }) & (1 as i32) << 16 as i32 == 0 as i32
            {
                let mut res: i32 = 0;
                (unsafe { (*memberType).flags |= (1 as i32) << 16 as i32 });
                res = xmlSchemaCheckUnionTypeDefCircularRecur(
                    pctxt,
                    ctxType,
                    xmlSchemaGetUnionSimpleTypeMemberTypes(memberType),
                );
                (unsafe { (*memberType).flags ^= (1 as i32) << 16 as i32 });
                if res != 0 as i32 {
                    return res;
                }
            }
            memberType = unsafe { (*memberType).baseType };
        }
        member = unsafe { (*member).next };
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaCheckUnionTypeDefCircular<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
) -> i32 {
    if (unsafe { (*type_0).flags }) & (1 as i32) << 7 as i32 == 0 {
        return 0 as i32;
    }
    return xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, type_0, unsafe { (*type_0).memberTypes });
}
extern "C" fn xmlSchemaResolveTypeReferences<'a1, 'a2>(
    mut typeDef: *mut crate::src::xmlschemas::_xmlSchemaType<'a1>,
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a2>,
) {
    if typeDef.is_null() {
        return;
    }
    if (unsafe { (*typeDef).baseType }).is_null() {
        let fresh361 = unsafe { &mut ((*typeDef).baseType) };
        *fresh361 = xmlSchemaGetType(unsafe { (*ctxt).schema }, unsafe { (*typeDef).base }, unsafe { (*typeDef).baseNs });
        if (unsafe { (*typeDef).baseType }).is_null() {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                typeDef as xmlSchemaBasicItemPtr,
                unsafe { (*typeDef).node },
                b"base\0" as *const u8 as *const i8,
                unsafe { (*typeDef).base },
                unsafe { (*typeDef).baseNs },
                XML_SCHEMA_TYPE_SIMPLE,
                0 as *const i8,
            );
            return;
        }
    }
    if (unsafe { (*typeDef).type_0 }) as u32 == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
        || (unsafe { (*typeDef).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (unsafe { (*typeDef).builtInType }) != XML_SCHEMAS_ANYTYPE as i32
    {
        if (unsafe { (*typeDef).flags }) & (1 as i32) << 7 as i32 != 0 {
            xmlSchemaResolveUnionMemberTypes(ctxt, typeDef);
            return;
        } else {
            if (unsafe { (*typeDef).flags }) & (1 as i32) << 6 as i32 != 0 {
                if (unsafe { (*typeDef).subtypes }).is_null() && !(unsafe { (*typeDef).base }).is_null() {
                    let fresh362 = unsafe { &mut ((*typeDef).subtypes) };
                    *fresh362 =
                        xmlSchemaGetType(unsafe { (*ctxt).schema }, unsafe { (*typeDef).base }, unsafe { (*typeDef).baseNs });
                    if (unsafe { (*typeDef).subtypes }).is_null()
                        || !((unsafe { (*(*typeDef).subtypes).type_0 }) as u32
                            == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                            || (unsafe { (*(*typeDef).subtypes).type_0 }) as u32
                                == XML_SCHEMA_TYPE_BASIC as i32 as u32
                                && (unsafe { (*(*typeDef).subtypes).builtInType }) != XML_SCHEMAS_ANYTYPE as i32)
                    {
                        let fresh363 = unsafe { &mut ((*typeDef).subtypes) };
                        *fresh363 = 0 as xmlSchemaTypePtr;
                        xmlSchemaPResCompAttrErr(
                            ctxt,
                            XML_SCHEMAP_SRC_RESOLVE,
                            typeDef as xmlSchemaBasicItemPtr,
                            unsafe { (*typeDef).node },
                            b"itemType\0" as *const u8 as *const i8,
                            unsafe { (*typeDef).base },
                            unsafe { (*typeDef).baseNs },
                            XML_SCHEMA_TYPE_SIMPLE,
                            0 as *const i8,
                        );
                    }
                }
                return;
            }
        }
    } else if !(unsafe { (*typeDef).subtypes }).is_null()
        && (unsafe { (*(*typeDef).subtypes).type_0 }) as u32 == XML_SCHEMA_TYPE_PARTICLE as i32 as u32
        && !(unsafe { (*((*typeDef).subtypes as xmlSchemaParticlePtr)).children }).is_null()
        && (unsafe { (*(*((*typeDef).subtypes as xmlSchemaParticlePtr)).children).type_0 }) as u32
            == XML_SCHEMA_EXTRA_QNAMEREF as i32 as u32
    {
        let mut ref_0: *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'_> =
            (unsafe { (*((*typeDef).subtypes as xmlSchemaParticlePtr)).children }) as xmlSchemaQNameRefPtr;
        let mut groupDef: *mut crate::src::xmlschemas::_xmlSchemaModelGroupDef<'_> =
            0 as *mut xmlSchemaModelGroupDef;
        let fresh364 = unsafe { &mut ((*((*typeDef).subtypes as xmlSchemaParticlePtr)).children) };
        *fresh364 = 0 as xmlSchemaTreeItemPtr;
        groupDef = xmlSchemaGetNamedComponent(
            unsafe { (*ctxt).schema },
            unsafe { (*ref_0).itemType },
            unsafe { (*ref_0).name },
            unsafe { (*ref_0).targetNamespace },
        ) as xmlSchemaModelGroupDefPtr;
        if groupDef.is_null() {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                0 as xmlSchemaBasicItemPtr,
                xmlSchemaGetComponentNode(
                    (unsafe { (*typeDef).subtypes }) as xmlSchemaParticlePtr as xmlSchemaBasicItemPtr,
                ),
                b"ref\0" as *const u8 as *const i8,
                unsafe { (*ref_0).name },
                unsafe { (*ref_0).targetNamespace },
                unsafe { (*ref_0).itemType },
                0 as *const i8,
            );
            let fresh365 = unsafe { &mut ((*typeDef).subtypes) };
            *fresh365 = 0 as xmlSchemaTypePtr;
        } else if (unsafe { (*(groupDef as xmlSchemaModelGroupPtr)).children }).is_null() {
            let fresh366 = unsafe { &mut ((*typeDef).subtypes) };
            *fresh366 = 0 as xmlSchemaTypePtr;
        } else {
            let fresh367 = unsafe { &mut ((*((*typeDef).subtypes as xmlSchemaParticlePtr)).children) };
            *fresh367 = unsafe { (*(groupDef as xmlSchemaModelGroupPtr)).children };
            if (unsafe { (*(*(groupDef as xmlSchemaModelGroupPtr)).children).type_0 }) as u32
                == XML_SCHEMA_TYPE_ALL as i32 as u32
            {
                if (unsafe { (*((*typeDef).subtypes as xmlSchemaParticlePtr)).maxOccurs }) != 1 as i32 {
                    xmlSchemaCustomErr (ctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_COS_ALL_LIMITED , xmlSchemaGetComponentNode ((unsafe { (* typeDef) . subtypes }) as xmlSchemaParticlePtr as xmlSchemaBasicItemPtr ,) , 0 as xmlSchemaBasicItemPtr , b"The particle's {max occurs} must be 1, since the reference resolves to an 'all' model group\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
                }
            }
        }
    }
}
extern "C" fn xmlSchemaCheckSTPropsCorrect<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
) -> i32 {
    let mut baseType: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = unsafe { (*type_0).baseType };
    let mut str: *mut u8 = 0 as *mut xmlChar;
    if baseType.is_null() {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_ST_PROPS_CORRECT_1,
            type_0 as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"No base type existent\0" as *const u8 as *const i8,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_ST_PROPS_CORRECT_1 as i32;
    }
    if !((unsafe { (*baseType).type_0 }) as u32 == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
        || (unsafe { (*baseType).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (unsafe { (*baseType).builtInType }) != XML_SCHEMAS_ANYTYPE as i32)
    {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_ST_PROPS_CORRECT_1,
            type_0 as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"The base type '%s' is not a simple type\0" as *const u8 as *const i8,
            xmlSchemaGetComponentQName(Some(&mut str), baseType as *mut libc::c_void),
        );
        if !str.is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
            str = 0 as *mut xmlChar;
        }
        return XML_SCHEMAP_ST_PROPS_CORRECT_1 as i32;
    }
    if ((unsafe { (*type_0).flags }) & (1 as i32) << 6 as i32 != 0
        || (unsafe { (*type_0).flags }) & (1 as i32) << 7 as i32 != 0)
        && (unsafe { (*type_0).flags }) & (1 as i32) << 2 as i32 == 0 as i32
        && (!((unsafe { (*baseType).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (unsafe { (*baseType).builtInType }) == XML_SCHEMAS_ANYSIMPLETYPE as i32)
            && (unsafe { (*baseType).type_0 }) as u32 != XML_SCHEMA_TYPE_SIMPLE as i32 as u32)
    {
        xmlSchemaPCustomErr (ctxt , XML_SCHEMAP_ST_PROPS_CORRECT_1 , type_0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"A type, derived by list or union, must have the simple ur-type definition as base type, not '%s'\0" as * const u8 as * const i8 , xmlSchemaGetComponentQName (Some (& mut str) , baseType as * mut libc :: c_void) ,) ;
        if !str.is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
            str = 0 as *mut xmlChar;
        }
        return XML_SCHEMAP_ST_PROPS_CORRECT_1 as i32;
    }
    if (unsafe { (*type_0).flags }) & (1 as i32) << 8 as i32 == 0
        && (unsafe { (*type_0).flags }) & (1 as i32) << 7 as i32 == 0
        && (unsafe { (*type_0).flags }) & (1 as i32) << 6 as i32 == 0
    {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_ST_PROPS_CORRECT_1,
            type_0 as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"The variety is absent\0" as *const u8 as *const i8,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_ST_PROPS_CORRECT_1 as i32;
    }
    if xmlSchemaTypeFinalContains(baseType, (1 as i32) << 10 as i32) != 0 {
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_ST_PROPS_CORRECT_3,
            type_0 as xmlSchemaBasicItemPtr,
            0 as xmlNodePtr,
            b"The 'final' of its base type '%s' must not contain 'restriction'\0" as *const u8
                as *const i8,
            xmlSchemaGetComponentQName(Some(&mut str), baseType as *mut libc::c_void),
        );
        if !str.is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
            str = 0 as *mut xmlChar;
        }
        return XML_SCHEMAP_ST_PROPS_CORRECT_3 as i32;
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaCheckCOSSTRestricts<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
) -> i32
where
    'a2: 'static,
{
    let mut str: *mut u8 = 0 as *mut xmlChar;
    if (unsafe { (*type_0).type_0 }) as u32 != XML_SCHEMA_TYPE_SIMPLE as i32 as u32 {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaCheckCOSSTRestricts\0" as *const u8 as *const i8,
            b"given type is not a user-derived simpleType\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    if (unsafe { (*type_0).flags }) & (1 as i32) << 8 as i32 != 0 {
        let mut primitive: *mut crate::src::xmlschemas::_xmlSchemaType<'_> =
            0 as *mut xmlSchemaType;
        if (unsafe { (*(*type_0).baseType).flags }) & (1 as i32) << 8 as i32 == 0 {
            xmlSchemaPCustomErr(
                pctxt,
                XML_SCHEMAP_COS_ST_RESTRICTS_1_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The base type '%s' is not an atomic simple type\0" as *const u8 as *const i8,
                xmlSchemaGetComponentQName(Some(&mut str), (unsafe { (*type_0).baseType }) as *mut libc::c_void),
            );
            if !str.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                str = 0 as *mut xmlChar;
            }
            return XML_SCHEMAP_COS_ST_RESTRICTS_1_1 as i32;
        }
        if xmlSchemaTypeFinalContains(unsafe { (*type_0).baseType }, (1 as i32) << 10 as i32) != 0 {
            xmlSchemaPCustomErr(
                pctxt,
                XML_SCHEMAP_COS_ST_RESTRICTS_1_2,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The final of its base type '%s' must not contain 'restriction'\0" as *const u8
                    as *const i8,
                xmlSchemaGetComponentQName(Some(&mut str), (unsafe { (*type_0).baseType }) as *mut libc::c_void),
            );
            if !str.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                str = 0 as *mut xmlChar;
            }
            return XML_SCHEMAP_COS_ST_RESTRICTS_1_2 as i32;
        }
        if !(unsafe { (*type_0).facets }).is_null() {
            let mut facet: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> =
                0 as *mut xmlSchemaFacet;
            let mut ok: i32 = 1 as i32;
            primitive = xmlSchemaGetPrimitiveType(type_0);
            if primitive.is_null() {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaCheckCOSSTRestricts\0" as *const u8 as *const i8,
                    b"failed to get primitive type\0" as *const u8 as *const i8,
                );
                return -(1 as i32);
            }
            facet = unsafe { (*type_0).facets };
            loop {
                if xmlSchemaIsBuiltInTypeFacet(primitive, (unsafe { (*facet).type_0 }) as i32) == 0 as i32 {
                    ok = 0 as i32;
                    xmlSchemaPIllegalFacetAtomicErr(
                        pctxt,
                        XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1,
                        type_0,
                        primitive,
                        facet,
                    );
                }
                facet = unsafe { (*facet).next };
                if facet.is_null() {
                    break;
                }
            }
            if ok == 0 as i32 {
                return XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1 as i32;
            }
        }
    } else if (unsafe { (*type_0).flags }) & (1 as i32) << 6 as i32 != 0 {
        let mut itemType: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as xmlSchemaTypePtr;
        itemType = unsafe { (*type_0).subtypes };
        if itemType.is_null()
            || !((unsafe { (*itemType).type_0 }) as u32 == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                || (unsafe { (*itemType).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
                    && (unsafe { (*itemType).builtInType }) != XML_SCHEMAS_ANYTYPE as i32)
        {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaCheckCOSSTRestricts\0" as *const u8 as *const i8,
                b"failed to evaluate the item type\0" as *const u8 as *const i8,
            );
            return -(1 as i32);
        }
        if (unsafe { (*itemType).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (unsafe { (*itemType).flags }) & (1 as i32) << 22 as i32 == 0 as i32
        {
            xmlSchemaTypeFixup(itemType, pctxt as xmlSchemaAbstractCtxtPtr);
        }
        if (unsafe { (*itemType).flags }) & (1 as i32) << 8 as i32 == 0
            && (unsafe { (*itemType).flags }) & (1 as i32) << 7 as i32 == 0
        {
            xmlSchemaPCustomErr(
                pctxt,
                XML_SCHEMAP_COS_ST_RESTRICTS_2_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The item type '%s' does not have a variety of atomic or union\0" as *const u8
                    as *const i8,
                xmlSchemaGetComponentQName(Some(&mut str), itemType as *mut libc::c_void),
            );
            if !str.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                str = 0 as *mut xmlChar;
            }
            return XML_SCHEMAP_COS_ST_RESTRICTS_2_1 as i32;
        } else {
            if (unsafe { (*itemType).flags }) & (1 as i32) << 7 as i32 != 0 {
                let mut member: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'_> =
                    0 as *mut xmlSchemaTypeLink;
                member = unsafe { (*itemType).memberTypes };
                while !member.is_null() {
                    if (unsafe { (*(*member).type_0).flags }) & (1 as i32) << 8 as i32 == 0 {
                        xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_COS_ST_RESTRICTS_2_1 , type_0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"The item type is a union type, but the member type '%s' of this item type is not atomic\0" as * const u8 as * const i8 , xmlSchemaGetComponentQName (Some (& mut str) , (unsafe { (* member) . type_0 }) as * mut libc :: c_void ,) ,) ;
                        if !str.is_null() {
                            (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                            str = 0 as *mut xmlChar;
                        }
                        return XML_SCHEMAP_COS_ST_RESTRICTS_2_1 as i32;
                    }
                    member = unsafe { (*member).next };
                }
            }
        }
        if (unsafe { (*(*type_0).baseType).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (unsafe { (*(*type_0).baseType).builtInType }) == XML_SCHEMAS_ANYSIMPLETYPE as i32
        {
            let mut facet_0: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> =
                0 as *mut xmlSchemaFacet;
            if xmlSchemaTypeFinalContains(itemType, (1 as i32) << 11 as i32) != 0 {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The final of its item type '%s' must not contain 'list'\0" as *const u8
                        as *const i8,
                    xmlSchemaGetComponentQName(Some(&mut str), itemType as *mut libc::c_void),
                );
                if !str.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1 as i32;
            }
            if !(unsafe { (*type_0).facets }).is_null() {
                facet_0 = unsafe { (*type_0).facets };
                loop {
                    if (unsafe { (*facet_0).type_0 }) as u32 != XML_SCHEMA_FACET_WHITESPACE as i32 as u32 {
                        xmlSchemaPIllegalFacetListUnionErr(
                            pctxt,
                            XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2,
                            type_0,
                            facet_0,
                        );
                        return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2 as i32;
                    }
                    facet_0 = unsafe { (*facet_0).next };
                    if facet_0.is_null() {
                        break;
                    }
                }
            }
        } else {
            if (unsafe { (*(*type_0).baseType).flags }) & (1 as i32) << 6 as i32 == 0 {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The base type '%s' must be a list type\0" as *const u8 as *const i8,
                    xmlSchemaGetComponentQName(
                        Some(&mut str),
                        (unsafe { (*type_0).baseType }) as *mut libc::c_void,
                    ),
                );
                if !str.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1 as i32;
            }
            if xmlSchemaTypeFinalContains(unsafe { (*type_0).baseType }, (1 as i32) << 10 as i32) != 0 {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The 'final' of the base type '%s' must not contain 'restriction'\0"
                        as *const u8 as *const i8,
                    xmlSchemaGetComponentQName(
                        Some(&mut str),
                        (unsafe { (*type_0).baseType }) as *mut libc::c_void,
                    ),
                );
                if !str.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2 as i32;
            }
            let mut baseItemType: *mut crate::src::xmlschemas::_xmlSchemaType<'_> =
                0 as *mut xmlSchemaType;
            baseItemType = unsafe { (*(*type_0).baseType).subtypes };
            if baseItemType.is_null()
                || !((unsafe { (*baseItemType).type_0 }) as u32 == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                    || (unsafe { (*baseItemType).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
                        && (unsafe { (*baseItemType).builtInType }) != XML_SCHEMAS_ANYTYPE as i32)
            {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaCheckCOSSTRestricts\0" as *const u8 as *const i8,
                    b"failed to eval the item type of a base type\0" as *const u8 as *const i8,
                );
                return -(1 as i32);
            }
            if itemType != baseItemType
                && xmlSchemaCheckCOSSTDerivedOK(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    itemType,
                    baseItemType,
                    0 as i32,
                ) != 0 as i32
            {
                let mut strBIT: *mut u8 = 0 as *mut xmlChar;
                let mut strBT: *mut u8 = 0 as *mut xmlChar;
                xmlSchemaPCustomErrExt (pctxt , XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3 , type_0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"The item type '%s' is not validly derived from the item type '%s' of the base type '%s'\0" as * const u8 as * const i8 , xmlSchemaGetComponentQName (Some (& mut str) , itemType as * mut libc :: c_void) , xmlSchemaGetComponentQName (Some (& mut strBIT) , baseItemType as * mut libc :: c_void ,) , xmlSchemaGetComponentQName (Some (& mut strBT) , (unsafe { (* type_0) . baseType }) as * mut libc :: c_void ,) ,) ;
                if !str.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                    str = 0 as *mut xmlChar;
                }
                if !strBIT.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(strBIT as *mut libc::c_void) });
                    strBIT = 0 as *mut xmlChar;
                }
                if !strBT.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(strBT as *mut libc::c_void) });
                    strBT = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3 as i32;
            }
            if !(unsafe { (*type_0).facets }).is_null() {
                let mut facet_1: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> =
                    0 as *mut xmlSchemaFacet;
                let mut ok_0: i32 = 1 as i32;
                facet_1 = unsafe { (*type_0).facets };
                loop {
                    match (unsafe { (*facet_1).type_0 }) as u32 {
                        1009 | 1011 | 1010 | 1008 | 1006 | 1007 => {},
                        _ => {
                            xmlSchemaPIllegalFacetListUnionErr(
                                pctxt,
                                XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4,
                                type_0,
                                facet_1,
                            );
                            ok_0 = 0 as i32;
                        },
                    }
                    facet_1 = unsafe { (*facet_1).next };
                    if facet_1.is_null() {
                        break;
                    }
                }
                if ok_0 == 0 as i32 {
                    return XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4 as i32;
                }
            }
        }
    } else if (unsafe { (*type_0).flags }) & (1 as i32) << 7 as i32 != 0 {
        let mut member_0: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'_> =
            0 as *mut xmlSchemaTypeLink;
        member_0 = unsafe { (*type_0).memberTypes };
        while !member_0.is_null() {
            if (unsafe { (*(*member_0).type_0).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32
                && (unsafe { (*(*member_0).type_0).flags }) & (1 as i32) << 22 as i32 == 0 as i32
            {
                xmlSchemaTypeFixup(unsafe { (*member_0).type_0 }, pctxt as xmlSchemaAbstractCtxtPtr);
            }
            if (unsafe { (*(*member_0).type_0).flags }) & (1 as i32) << 8 as i32 == 0
                && (unsafe { (*(*member_0).type_0).flags }) & (1 as i32) << 6 as i32 == 0
            {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_3_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The member type '%s' is neither an atomic, nor a list type\0" as *const u8
                        as *const i8,
                    xmlSchemaGetComponentQName(
                        Some(&mut str),
                        (unsafe { (*member_0).type_0 }) as *mut libc::c_void,
                    ),
                );
                if !str.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_3_1 as i32;
            }
            member_0 = unsafe { (*member_0).next };
        }
        if (unsafe { (*(*type_0).baseType).builtInType }) == XML_SCHEMAS_ANYSIMPLETYPE as i32 {
            member_0 = unsafe { (*type_0).memberTypes };
            while !member_0.is_null() {
                if xmlSchemaTypeFinalContains(unsafe { (*member_0).type_0 }, (1 as i32) << 12 as i32) != 0 {
                    xmlSchemaPCustomErr(
                        pctxt,
                        XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1,
                        type_0 as xmlSchemaBasicItemPtr,
                        0 as xmlNodePtr,
                        b"The 'final' of member type '%s' contains 'union'\0" as *const u8
                            as *const i8,
                        xmlSchemaGetComponentQName(
                            Some(&mut str),
                            (unsafe { (*member_0).type_0 }) as *mut libc::c_void,
                        ),
                    );
                    if !str.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                        str = 0 as *mut xmlChar;
                    }
                    return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1 as i32;
                }
                member_0 = unsafe { (*member_0).next };
            }
            if !(unsafe { (*type_0).facetSet }).is_null() {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"No facets allowed\0" as *const u8 as *const i8,
                    0 as *const xmlChar,
                );
                return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2 as i32;
            }
        } else {
            if (unsafe { (*(*type_0).baseType).flags }) & (1 as i32) << 7 as i32 == 0 {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The base type '%s' is not a union type\0" as *const u8 as *const i8,
                    xmlSchemaGetComponentQName(
                        Some(&mut str),
                        (unsafe { (*type_0).baseType }) as *mut libc::c_void,
                    ),
                );
                if !str.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1 as i32;
            }
            if xmlSchemaTypeFinalContains(unsafe { (*type_0).baseType }, (1 as i32) << 10 as i32) != 0 {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"The 'final' of its base type '%s' must not contain 'restriction'\0"
                        as *const u8 as *const i8,
                    xmlSchemaGetComponentQName(
                        Some(&mut str),
                        (unsafe { (*type_0).baseType }) as *mut libc::c_void,
                    ),
                );
                if !str.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                    str = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2 as i32;
            }
            let mut baseMember: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'_> =
                0 as *mut xmlSchemaTypeLink;
            if !(unsafe { (*type_0).memberTypes }).is_null() {
                member_0 = unsafe { (*type_0).memberTypes };
                baseMember = xmlSchemaGetUnionSimpleTypeMemberTypes(unsafe { (*type_0).baseType });
                if member_0.is_null() && !baseMember.is_null() {
                    xmlSchemaInternalErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaCheckCOSSTRestricts\0" as *const u8 as *const i8,
                        b"different number of member types in base\0" as *const u8 as *const i8,
                    );
                }
                while !member_0.is_null() {
                    if baseMember.is_null() {
                        xmlSchemaInternalErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaCheckCOSSTRestricts\0" as *const u8 as *const i8,
                            b"different number of member types in base\0" as *const u8 as *const i8,
                        );
                    } else if (unsafe { (*member_0).type_0 }) != (unsafe { (*baseMember).type_0 })
                        && xmlSchemaCheckCOSSTDerivedOK(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            unsafe { (*member_0).type_0 },
                            unsafe { (*baseMember).type_0 },
                            0 as i32,
                        ) != 0 as i32
                    {
                        let mut strBMT: *mut u8 = 0 as *mut xmlChar;
                        let mut strBT_0: *mut u8 = 0 as *mut xmlChar;
                        xmlSchemaPCustomErrExt (pctxt , XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3 , type_0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"The member type %s is not validly derived from its corresponding member type %s of the base type %s\0" as * const u8 as * const i8 , xmlSchemaGetComponentQName (Some (& mut str) , (unsafe { (* member_0) . type_0 }) as * mut libc :: c_void ,) , xmlSchemaGetComponentQName (Some (& mut strBMT) , (unsafe { (* baseMember) . type_0 }) as * mut libc :: c_void ,) , xmlSchemaGetComponentQName (Some (& mut strBT_0) , (unsafe { (* type_0) . baseType }) as * mut libc :: c_void ,) ,) ;
                        if !str.is_null() {
                            (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                            str = 0 as *mut xmlChar;
                        }
                        if !strBMT.is_null() {
                            (unsafe { xmlFree.expect("non-null function pointer")(
                                strBMT as *mut libc::c_void,
                            ) });
                            strBMT = 0 as *mut xmlChar;
                        }
                        if !strBT_0.is_null() {
                            (unsafe { xmlFree.expect("non-null function pointer")(
                                strBT_0 as *mut libc::c_void,
                            ) });
                            strBT_0 = 0 as *mut xmlChar;
                        }
                        return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3 as i32;
                    }
                    member_0 = unsafe { (*member_0).next };
                    if !baseMember.is_null() {
                        baseMember = unsafe { (*baseMember).next };
                    }
                }
            }
            if !(unsafe { (*type_0).facets }).is_null() {
                let mut facet_2: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> =
                    0 as *mut xmlSchemaFacet;
                let mut ok_1: i32 = 1 as i32;
                facet_2 = unsafe { (*type_0).facets };
                loop {
                    if (unsafe { (*facet_2).type_0 }) as u32 != XML_SCHEMA_FACET_PATTERN as i32 as u32
                        && (unsafe { (*facet_2).type_0 }) as u32 != XML_SCHEMA_FACET_ENUMERATION as i32 as u32
                    {
                        xmlSchemaPIllegalFacetListUnionErr(
                            pctxt,
                            XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4,
                            type_0,
                            facet_2,
                        );
                        ok_1 = 0 as i32;
                    }
                    facet_2 = unsafe { (*facet_2).next };
                    if facet_2.is_null() {
                        break;
                    }
                }
                if ok_1 == 0 as i32 {
                    return XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4 as i32;
                }
            }
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaCreateVCtxtOnPCtxt<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
) -> i32 {
    if (unsafe { (*ctxt).vctxt }).is_null() {
        let fresh368 = unsafe { &mut ((*ctxt).vctxt) };
        *fresh368 = xmlSchemaNewValidCtxt(0 as xmlSchemaPtr);
        if (unsafe { (*ctxt).vctxt }).is_null() {
            xmlSchemaPErr (ctxt , 0 as xmlNodePtr , XML_SCHEMAP_INTERNAL as i32 , b"Internal error: xmlSchemaCreateVCtxtOnPCtxt, failed to create a temp. validation context.\n\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
            return -(1 as i32);
        }
        xmlSchemaSetValidErrors(
            unsafe { (*ctxt).vctxt },
            unsafe { (*ctxt).error },
            unsafe { (*ctxt).warning },
            unsafe { (*ctxt).errCtxt },
        );
        xmlSchemaSetValidStructuredErrors(unsafe { (*ctxt).vctxt }, unsafe { (*ctxt).serror }, unsafe { (*ctxt).errCtxt });
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaParseCheckCOSValidDefault<'a1, 'a2, 'a3>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
    mut value: *const u8,
    mut val: Option<&'a3 mut *mut crate::src::xmlschemastypes::_xmlSchemaVal>,
) -> i32
where
    'a2: 'static,
{
    let mut ret: i32 = 0 as i32;
    if (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        || (unsafe { (*type_0).builtInType }) == XML_SCHEMAS_ANYTYPE as i32
    {
        if !((unsafe { (*type_0).contentType }) as u32 == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
            || (unsafe { (*type_0).contentType }) as u32 == XML_SCHEMA_CONTENT_BASIC as i32 as u32)
            && (!((unsafe { (*type_0).contentType }) as u32 == XML_SCHEMA_CONTENT_MIXED as i32 as u32)
                || xmlSchemaIsParticleEmptiable((unsafe { (*type_0).subtypes }) as xmlSchemaParticlePtr) == 0)
        {
            xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_COS_VALID_DEFAULT_2_1 , type_0 as xmlSchemaBasicItemPtr , unsafe { (* type_0) . node } , b"For a string to be a valid default, the type definition must be a simple type or a complex type with mixed content and a particle emptiable\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
            return XML_SCHEMAP_COS_VALID_DEFAULT_2_1 as i32;
        }
    }
    if (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
        || (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (unsafe { (*type_0).builtInType }) != XML_SCHEMAS_ANYTYPE as i32
    {
        ret = xmlSchemaVCheckCVCSimpleType(
            pctxt as xmlSchemaAbstractCtxtPtr,
            node,
            type_0,
            value,
            borrow_mut(&mut val),
            1 as i32,
            1 as i32,
            0 as i32,
        );
    } else if (unsafe { (*type_0).contentType }) as u32 == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
        || (unsafe { (*type_0).contentType }) as u32 == XML_SCHEMA_CONTENT_BASIC as i32 as u32
    {
        ret = xmlSchemaVCheckCVCSimpleType(
            pctxt as xmlSchemaAbstractCtxtPtr,
            node,
            unsafe { (*type_0).contentTypeDef },
            value,
            borrow_mut(&mut val),
            1 as i32,
            1 as i32,
            0 as i32,
        );
    } else {
        return ret;
    }
    if ret < 0 as i32 {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaParseCheckCOSValidDefault\0" as *const u8 as *const i8,
            b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8 as *const i8,
        );
    }
    return ret;
}
extern "C" fn xmlSchemaCheckCTPropsCorrect<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
) -> i32 {
    let mut current_block: u64;
    if !(unsafe { (*type_0).baseType }).is_null()
        && ((unsafe { (*(*type_0).baseType).type_0 }) as u32 == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
            || (unsafe { (*(*type_0).baseType).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
                && (unsafe { (*(*type_0).baseType).builtInType }) != XML_SCHEMAS_ANYTYPE as i32)
        && (unsafe { (*type_0).flags }) & (1 as i32) << 1 as i32 == 0 as i32
    {
        xmlSchemaCustomErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_SRC_CT_1,
            0 as xmlNodePtr,
            type_0 as xmlSchemaBasicItemPtr,
            b"If the base type is a simple type, the derivation method must be 'extension'\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return XML_SCHEMAP_SRC_CT_1 as i32;
    }
    if !(unsafe { (*type_0).attrUses }).is_null()
        && (unsafe { (*((*type_0).attrUses as xmlSchemaItemListPtr)).nbItems }) > 1 as i32
    {
        let mut uses: *mut crate::src::xmlschemas::_xmlSchemaItemList =
            (unsafe { (*type_0).attrUses }) as xmlSchemaItemListPtr;
        let mut use_0: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_> =
            0 as *mut xmlSchemaAttributeUse;
        let mut tmp: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_> =
            0 as *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_>;
        let mut i: i32 = 0;
        let mut j: i32 = 0;
        let mut hasId: i32 = 0 as i32;
        i = (unsafe { (*uses).nbItems }) - 1 as i32;
        's_32: loop {
            if !(i >= 0 as i32) {
                current_block = 4090602189656566074;
                break;
            }
            use_0 = (unsafe { *((*uses).items).offset(i as isize) }) as xmlSchemaAttributeUsePtr;
            if i > 0 as i32 {
                j = i - 1 as i32;
                loop {
                    if !(j >= 0 as i32) {
                        current_block = 18317007320854588510;
                        break;
                    }
                    tmp = (unsafe { *((*uses).items).offset(j as isize) }) as xmlSchemaAttributeUsePtr;
                    if (unsafe { (*(*use_0).attrDecl).name }) == (unsafe { (*(*tmp).attrDecl).name })
                        && (unsafe { (*(*use_0).attrDecl).targetNamespace })
                            == (unsafe { (*(*tmp).attrDecl).targetNamespace })
                    {
                        let mut str: *mut u8 = 0 as *mut xmlChar;
                        xmlSchemaCustomErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            XML_SCHEMAP_AG_PROPS_CORRECT,
                            0 as xmlNodePtr,
                            type_0 as xmlSchemaBasicItemPtr,
                            b"Duplicate %s\0" as *const u8 as *const i8,
                            xmlSchemaGetComponentDesignation(
                                Some(&mut str),
                                use_0 as *mut libc::c_void,
                            ),
                            0 as *const xmlChar,
                        );
                        if !str.is_null() {
                            (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                            str = 0 as *mut xmlChar;
                        }
                        if xmlSchemaItemListRemove(uses, i) == -(1 as i32) {
                            current_block = 13937361906707278470;
                            break 's_32;
                        } else {
                            current_block = 2473556513754201174;
                            break;
                        }
                    } else {
                        j -= 1;
                    }
                }
            } else {
                current_block = 18317007320854588510;
            }
            match current_block {
                18317007320854588510 => {
                    if !(unsafe { (*(*use_0).attrDecl).subtypes }).is_null() {
                        if xmlSchemaIsDerivedFromBuiltInType(
                            unsafe { (*(*use_0).attrDecl).subtypes },
                            XML_SCHEMAS_ID as i32,
                        ) != 0
                        {
                            if hasId != 0 {
                                let mut str_0: *mut u8 = 0 as *mut xmlChar;
                                xmlSchemaCustomErr (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_AG_PROPS_CORRECT , 0 as xmlNodePtr , type_0 as xmlSchemaBasicItemPtr , b"There must not exist more than one attribute declaration of type 'xs:ID' (or derived from 'xs:ID'). The %s violates this constraint\0" as * const u8 as * const i8 , xmlSchemaGetComponentDesignation (Some (& mut str_0) , use_0 as * mut libc :: c_void ,) , 0 as * const xmlChar ,) ;
                                if !str_0.is_null() {
                                    (unsafe { xmlFree.expect("non-null function pointer")(
                                        str_0 as *mut libc::c_void,
                                    ) });
                                    str_0 = 0 as *mut xmlChar;
                                }
                                if xmlSchemaItemListRemove(uses, i) == -(1 as i32) {
                                    current_block = 13937361906707278470;
                                    break;
                                }
                            }
                            hasId = 1 as i32;
                        }
                    }
                },
                _ => {},
            }
            i -= 1;
        }
        match current_block {
            4090602189656566074 => {},
            _ => return -(1 as i32),
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaAreEqualTypes<'a1, 'a2>(
    mut typeA: *mut crate::src::xmlschemas::_xmlSchemaType<'a1>,
    mut typeB: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
) -> i32
where
    'a1: 'a2,
    'a2: 'a1,
{
    if typeA.is_null() || typeB.is_null() {
        return 0 as i32;
    }
    return (typeA == typeB) as i32;
}
extern "C" fn xmlSchemaCheckCOSCTDerivedOK<'a1, 'a2, 'a3>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
    mut baseType: *mut crate::src::xmlschemas::_xmlSchemaType<'a3>,
    mut set: i32,
) -> i32
where
    'a3: 'a2,
    'a2: 'a3,
    'a2: 'static,
{
    let mut equal: i32 = xmlSchemaAreEqualTypes(type_0, baseType);
    if equal == 0 {
        if set & (1 as i32) << 1 as i32 != 0 && (unsafe { (*type_0).flags }) & (1 as i32) << 1 as i32 != 0
            || set & (1 as i32) << 0 as i32 != 0 && (unsafe { (*type_0).flags }) & (1 as i32) << 2 as i32 != 0
        {
            return 1 as i32;
        }
    } else {
        return 0 as i32;
    }
    if (unsafe { (*type_0).baseType }) == baseType {
        return 0 as i32;
    }
    if (unsafe { (*(*type_0).baseType).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (unsafe { (*(*type_0).baseType).builtInType }) == XML_SCHEMAS_ANYTYPE as i32
    {
        return 1 as i32;
    }
    if (unsafe { (*(*type_0).baseType).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        || (unsafe { (*(*type_0).baseType).builtInType }) == XML_SCHEMAS_ANYTYPE as i32
    {
        return xmlSchemaCheckCOSCTDerivedOK(actxt, unsafe { (*type_0).baseType }, baseType, set);
    } else {
        return xmlSchemaCheckCOSSTDerivedOK(actxt, unsafe { (*type_0).baseType }, baseType, set);
    };
}
extern "C" fn xmlSchemaCheckCOSDerivedOK<'a1, 'a2, 'a3>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
    mut baseType: *mut crate::src::xmlschemas::_xmlSchemaType<'a3>,
    mut set: i32,
) -> i32
where
    'a2: 'a3,
    'a2: 'static,
    'a3: 'a2,
{
    if (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
        || (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (unsafe { (*type_0).builtInType }) != XML_SCHEMAS_ANYTYPE as i32
    {
        return xmlSchemaCheckCOSSTDerivedOK(actxt, type_0, baseType, set);
    } else {
        return xmlSchemaCheckCOSCTDerivedOK(actxt, type_0, baseType, set);
    };
}
extern "C" fn xmlSchemaCheckCOSCTExtends<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
) -> i32 {
    let mut base: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = unsafe { (*type_0).baseType };
    if (unsafe { (*base).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        || (unsafe { (*base).builtInType }) == XML_SCHEMAS_ANYTYPE as i32
    {
        if (unsafe { (*base).flags }) & (1 as i32) << 9 as i32 != 0 {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The 'final' of the base type definition contains 'extension'\0" as *const u8
                    as *const i8,
                0 as *const xmlChar,
            );
            return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as i32;
        }
        if !(!(unsafe { (*type_0).contentTypeDef }).is_null()
            && (unsafe { (*type_0).contentTypeDef }) == (unsafe { (*base).contentTypeDef }))
        {
            if !((unsafe { (*type_0).contentType }) as u32 == XML_SCHEMA_CONTENT_EMPTY as i32 as u32
                && (unsafe { (*base).contentType }) as u32 == XML_SCHEMA_CONTENT_EMPTY as i32 as u32)
            {
                if (unsafe { (*type_0).subtypes }).is_null() {
                    xmlSchemaPCustomErr(
                        ctxt,
                        XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                        type_0 as xmlSchemaBasicItemPtr,
                        0 as xmlNodePtr,
                        b"The content type must specify a particle\0" as *const u8 as *const i8,
                        0 as *const xmlChar,
                    );
                    return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as i32;
                }
                if !((unsafe { (*base).contentType }) as u32 == XML_SCHEMA_CONTENT_EMPTY as i32 as u32) {
                    if (unsafe { (*type_0).contentType }) as u32 != (unsafe { (*base).contentType }) as u32
                        || (unsafe { (*type_0).contentType }) as u32 != XML_SCHEMA_CONTENT_MIXED as i32 as u32
                            && (unsafe { (*type_0).contentType }) as u32
                                != XML_SCHEMA_CONTENT_ELEMENTS as i32 as u32
                    {
                        xmlSchemaPCustomErr (ctxt , XML_SCHEMAP_COS_CT_EXTENDS_1_1 , type_0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"The content type of both, the type and its base type, must either 'mixed' or 'element-only'\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
                        return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as i32;
                    }
                }
            }
        }
    } else {
        if (unsafe { (*type_0).contentTypeDef }) != base {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The content type must be the simple base type\0" as *const u8 as *const i8,
                0 as *const xmlChar,
            );
            return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as i32;
        }
        if (unsafe { (*base).flags }) & (1 as i32) << 9 as i32 != 0 {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_COS_CT_EXTENDS_1_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The 'final' of the base type definition contains 'extension'\0" as *const u8
                    as *const i8,
                0 as *const xmlChar,
            );
            return XML_SCHEMAP_COS_CT_EXTENDS_1_1 as i32;
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaCheckDerivationOKRestriction<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
) -> i32
where
    'a2: 'static,
{
    let mut base: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    base = unsafe { (*type_0).baseType };
    if !((unsafe { (*base).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        || (unsafe { (*base).builtInType }) == XML_SCHEMAS_ANYTYPE as i32)
    {
        xmlSchemaCustomErr(
            ctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
            unsafe { (*type_0).node },
            type_0 as xmlSchemaBasicItemPtr,
            b"The base type must be a complex type\0" as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return unsafe { (*ctxt).err };
    }
    if (unsafe { (*base).flags }) & (1 as i32) << 10 as i32 != 0 {
        xmlSchemaCustomErr(
            ctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
            unsafe { (*type_0).node },
            type_0 as xmlSchemaBasicItemPtr,
            b"The 'final' of the base type definition contains 'restriction'\0" as *const u8
                as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return unsafe { (*ctxt).err };
    }
    if xmlSchemaCheckDerivationOKRestriction2to4(
        ctxt,
        0 as i32,
        type_0 as xmlSchemaBasicItemPtr,
        base as xmlSchemaBasicItemPtr,
        (unsafe { (*type_0).attrUses }) as xmlSchemaItemListPtr,
        (unsafe { (*base).attrUses }) as xmlSchemaItemListPtr,
        unsafe { (*type_0).attributeWildcard },
        unsafe { (*base).attributeWildcard },
    ) == -(1 as i32)
    {
        return -(1 as i32);
    }
    if !((unsafe { (*base).builtInType }) == XML_SCHEMAS_ANYTYPE as i32) {
        if (unsafe { (*type_0).contentType }) as u32 == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
            || (unsafe { (*type_0).contentType }) as u32 == XML_SCHEMA_CONTENT_BASIC as i32 as u32
        {
            if (unsafe { (*base).contentType }) as u32 == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
                || (unsafe { (*base).contentType }) as u32 == XML_SCHEMA_CONTENT_BASIC as i32 as u32
            {
                let mut err: i32 = 0;
                err = xmlSchemaCheckCOSSTDerivedOK(
                    ctxt as xmlSchemaAbstractCtxtPtr,
                    unsafe { (*type_0).contentTypeDef },
                    unsafe { (*base).contentTypeDef },
                    0 as i32,
                );
                if err != 0 as i32 {
                    let mut strA: *mut u8 = 0 as *mut xmlChar;
                    let mut strB: *mut u8 = 0 as *mut xmlChar;
                    if err == -(1 as i32) {
                        return -(1 as i32);
                    }
                    xmlSchemaCustomErr (ctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1 , 0 as xmlNodePtr , type_0 as xmlSchemaBasicItemPtr , b"The {content type} %s is not validly derived from the base type's {content type} %s\0" as * const u8 as * const i8 , xmlSchemaGetComponentDesignation (Some (& mut strA) , (unsafe { (* type_0) . contentTypeDef }) as * mut libc :: c_void ,) , xmlSchemaGetComponentDesignation (Some (& mut strB) , (unsafe { (* base) . contentTypeDef }) as * mut libc :: c_void ,) ,) ;
                    if !strA.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(strA as *mut libc::c_void) });
                        strA = 0 as *mut xmlChar;
                    }
                    if !strB.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(strB as *mut libc::c_void) });
                        strB = 0 as *mut xmlChar;
                    }
                    return unsafe { (*ctxt).err };
                }
            } else if (unsafe { (*base).contentType }) as u32 == XML_SCHEMA_CONTENT_MIXED as i32 as u32
                && xmlSchemaIsParticleEmptiable((unsafe { (*base).subtypes }) as xmlSchemaParticlePtr) != 0
            {
            } else {
                xmlSchemaPCustomErr (ctxt , XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1 , type_0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"The content type of the base type must be either a simple type or 'mixed' and an emptiable particle\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
                return unsafe { (*ctxt).err };
            }
        } else if (unsafe { (*type_0).contentType }) as u32 == XML_SCHEMA_CONTENT_EMPTY as i32 as u32 {
            if !((unsafe { (*base).contentType }) as u32 == XML_SCHEMA_CONTENT_EMPTY as i32 as u32) {
                if ((unsafe { (*base).contentType }) as u32 == XML_SCHEMA_CONTENT_ELEMENTS as i32 as u32
                    || (unsafe { (*base).contentType }) as u32 == XML_SCHEMA_CONTENT_MIXED as i32 as u32)
                    && xmlSchemaIsParticleEmptiable((unsafe { (*base).subtypes }) as xmlSchemaParticlePtr) != 0
                {
                } else {
                    xmlSchemaPCustomErr (ctxt , XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1 , type_0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"The content type of the base type must be either empty or 'mixed' (or 'elements-only') and an emptiable particle\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
                    return unsafe { (*ctxt).err };
                }
            }
        } else if (unsafe { (*type_0).contentType }) as u32 == XML_SCHEMA_CONTENT_ELEMENTS as i32 as u32
            || (unsafe { (*type_0).contentType }) as u32 == XML_SCHEMA_CONTENT_MIXED as i32 as u32
        {
            if (unsafe { (*type_0).contentType }) as u32 == XML_SCHEMA_CONTENT_MIXED as i32 as u32
                && !((unsafe { (*base).contentType }) as u32 == XML_SCHEMA_CONTENT_MIXED as i32 as u32)
            {
                xmlSchemaPCustomErr (ctxt , XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1 , type_0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"If the content type is 'mixed', then the content type of the base type must also be 'mixed'\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
                return unsafe { (*ctxt).err };
            }
        } else {
            xmlSchemaPCustomErr(
                ctxt,
                XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1,
                type_0 as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"The type is not a valid restriction of its base type\0" as *const u8 as *const i8,
                0 as *const xmlChar,
            );
            return unsafe { (*ctxt).err };
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaCheckCTComponent<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
) -> i32
where
    'a2: 'static,
{
    let mut ret: i32 = 0;
    ret = xmlSchemaCheckCTPropsCorrect(ctxt, type_0);
    if ret != 0 as i32 {
        return ret;
    }
    if (unsafe { (*type_0).flags }) & (1 as i32) << 1 as i32 != 0 {
        ret = xmlSchemaCheckCOSCTExtends(ctxt, type_0);
    } else {
        ret = xmlSchemaCheckDerivationOKRestriction(ctxt, type_0);
    }
    return ret;
}
extern "C" fn xmlSchemaCheckSRCCT<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
) -> i32 {
    let mut base: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut ret: i32 = 0 as i32;
    base = unsafe { (*type_0).baseType };
    if !((unsafe { (*type_0).contentType }) as u32 == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
        || (unsafe { (*type_0).contentType }) as u32 == XML_SCHEMA_CONTENT_BASIC as i32 as u32)
    {
        if !((unsafe { (*base).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
            || (unsafe { (*base).builtInType }) == XML_SCHEMAS_ANYTYPE as i32)
        {
            let mut str: *mut u8 = 0 as *mut xmlChar;
            xmlSchemaPCustomErr (ctxt , XML_SCHEMAP_SRC_CT_1 , type_0 as xmlSchemaBasicItemPtr , unsafe { (* type_0) . node } , b"If using <complexContent>, the base type is expected to be a complex type. The base type '%s' is a simple type\0" as * const u8 as * const i8 , xmlSchemaFormatQName (Some (& mut str) , unsafe { (* base) . targetNamespace } , unsafe { (* base) . name }) ,) ;
            if !str.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                str = 0 as *mut xmlChar;
            }
            return XML_SCHEMAP_SRC_CT_1 as i32;
        }
    } else {
        if (unsafe { (*base).type_0 }) as u32 == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
            || (unsafe { (*base).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
                && (unsafe { (*base).builtInType }) != XML_SCHEMAS_ANYTYPE as i32
        {
            if (unsafe { (*type_0).flags }) & (1 as i32) << 1 as i32 == 0 as i32 {
                let mut str_0: *mut u8 = 0 as *mut xmlChar;
                xmlSchemaPCustomErr (ctxt , XML_SCHEMAP_SRC_CT_1 , type_0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"If using <simpleContent> and <restriction>, the base type must be a complex type. The base type '%s' is a simple type\0" as * const u8 as * const i8 , xmlSchemaFormatQName (Some (& mut str_0) , unsafe { (* base) . targetNamespace } , unsafe { (* base) . name } ,) ,) ;
                if !str_0.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str_0 as *mut libc::c_void) });
                    str_0 = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_SRC_CT_1 as i32;
            }
        } else if (unsafe { (*base).contentType }) as u32 == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
            || (unsafe { (*base).contentType }) as u32 == XML_SCHEMA_CONTENT_BASIC as i32 as u32
        {
            if (unsafe { (*base).contentTypeDef }).is_null() {
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_INTERNAL,
                    type_0 as xmlSchemaBasicItemPtr,
                    0 as xmlNodePtr,
                    b"Internal error: xmlSchemaCheckSRCCT, '%s', base type has no content type\0"
                        as *const u8 as *const i8,
                    unsafe { (*type_0).name },
                );
                return -(1 as i32);
            }
        } else if (unsafe { (*base).contentType }) as u32 == XML_SCHEMA_CONTENT_MIXED as i32 as u32
            && (unsafe { (*type_0).flags }) & (1 as i32) << 2 as i32 != 0
        {
            if xmlSchemaIsParticleEmptiable((unsafe { (*base).subtypes }) as xmlSchemaParticlePtr) == 0 {
                ret = XML_SCHEMAP_SRC_CT_1 as i32;
            } else if (unsafe { (*type_0).contentTypeDef }).is_null() {
                let mut str_1: *mut u8 = 0 as *mut xmlChar;
                xmlSchemaPCustomErr (ctxt , XML_SCHEMAP_SRC_CT_1 , type_0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"A <simpleType> is expected among the children of <restriction>, if <simpleContent> is used and the base type '%s' is a complex type\0" as * const u8 as * const i8 , xmlSchemaFormatQName (Some (& mut str_1) , unsafe { (* base) . targetNamespace } , unsafe { (* base) . name } ,) ,) ;
                if !str_1.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str_1 as *mut libc::c_void) });
                    str_1 = 0 as *mut xmlChar;
                }
                return XML_SCHEMAP_SRC_CT_1 as i32;
            }
        } else {
            ret = XML_SCHEMAP_SRC_CT_1 as i32;
        }
        if ret > 0 as i32 {
            let mut str_2: *mut u8 = 0 as *mut xmlChar;
            if (unsafe { (*type_0).flags }) & (1 as i32) << 2 as i32 != 0 {
                xmlSchemaPCustomErr (ctxt , XML_SCHEMAP_SRC_CT_1 , type_0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"If <simpleContent> and <restriction> is used, the base type must be a simple type or a complex type with mixed content and particle emptiable. The base type '%s' is none of those\0" as * const u8 as * const i8 , xmlSchemaFormatQName (Some (& mut str_2) , unsafe { (* base) . targetNamespace } , unsafe { (* base) . name } ,) ,) ;
            } else {
                xmlSchemaPCustomErr (ctxt , XML_SCHEMAP_SRC_CT_1 , type_0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"If <simpleContent> and <extension> is used, the base type must be a simple type. The base type '%s' is a complex type\0" as * const u8 as * const i8 , xmlSchemaFormatQName (Some (& mut str_2) , unsafe { (* base) . targetNamespace } , unsafe { (* base) . name } ,) ,) ;
            }
            if !str_2.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(str_2 as *mut libc::c_void) });
                str_2 = 0 as *mut xmlChar;
            }
        }
    }
    return ret;
}
extern "C" fn xmlSchemaDeriveFacetErr<'a1, 'a2, 'a3>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut facet1: *mut crate::src::xmlschemas::_xmlSchemaFacet<'a2>,
    mut facet2: *mut crate::src::xmlschemas::_xmlSchemaFacet<'a3>,
    mut lessGreater: i32,
    mut orEqual: i32,
    mut ofBase: i32,
) {
    let mut msg: *mut u8 = 0 as *mut xmlChar;
    msg = xmlStrdup(b"'\0" as *const u8 as *const i8 as *mut xmlChar);
    msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(unsafe { (*facet1).type_0 }));
    msg = xmlStrcat(
        msg,
        b"' has to be\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    if lessGreater == 0 as i32 {
        msg = xmlStrcat(
            msg,
            b" equal to\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    if lessGreater == 1 as i32 {
        msg = xmlStrcat(
            msg,
            b" greater than\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    } else {
        msg = xmlStrcat(
            msg,
            b" less than\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    if orEqual != 0 {
        msg = xmlStrcat(
            msg,
            b" or equal to\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    }
    msg = xmlStrcat(msg, b" '\0" as *const u8 as *const i8 as *mut xmlChar);
    msg = xmlStrcat(msg, xmlSchemaFacetTypeToString(unsafe { (*facet2).type_0 }));
    if ofBase != 0 {
        msg = xmlStrcat(
            msg,
            b"' of the base type\0" as *const u8 as *const i8 as *mut xmlChar,
        );
    } else {
        msg = xmlStrcat(msg, b"'\0" as *const u8 as *const i8 as *mut xmlChar);
    }
    xmlSchemaPCustomErr(
        pctxt,
        XML_SCHEMAP_INVALID_FACET_VALUE,
        facet1 as xmlSchemaBasicItemPtr,
        0 as xmlNodePtr,
        msg as *const i8,
        0 as *const xmlChar,
    );
    if !msg.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(msg as *mut libc::c_void) });
    }
}
extern "C" fn xmlSchemaDeriveAndValidateFacets<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
) -> i32 {
    let mut current_block: u64;
    let mut base: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = unsafe { (*type_0).baseType };
    let mut link: *mut crate::src::xmlschemas::_xmlSchemaFacetLink<'_> =
        0 as *mut xmlSchemaFacetLink;
    let mut cur: *mut crate::src::xmlschemas::_xmlSchemaFacetLink<'_> =
        0 as *mut xmlSchemaFacetLink;
    let mut last: *mut crate::src::xmlschemas::_xmlSchemaFacetLink<'_> = 0 as xmlSchemaFacetLinkPtr;
    let mut facet: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as *mut xmlSchemaFacet;
    let mut bfacet: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as *mut xmlSchemaFacet;
    let mut flength: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut ftotdig: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut ffracdig: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut fmaxlen: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut fminlen: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut fmininc: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut fmaxinc: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut fminexc: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut fmaxexc: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut bflength: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut bftotdig: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut bffracdig: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut bfmaxlen: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut bfminlen: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut bfmininc: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut bfmaxinc: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut bfminexc: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut bfmaxexc: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as xmlSchemaFacetPtr;
    let mut res: i32 = 0;
    if (unsafe { (*type_0).facetSet }).is_null() && (unsafe { (*base).facetSet }).is_null() {
        return 0 as i32;
    }
    last = unsafe { (*type_0).facetSet };
    if !last.is_null() {
        while !(unsafe { (*last).next }).is_null() {
            last = unsafe { (*last).next };
        }
    }
    cur = unsafe { (*type_0).facetSet };
    while !cur.is_null() {
        facet = unsafe { (*cur).facet };
        match (unsafe { (*facet).type_0 }) as u32 {
            1009 => {
                flength = facet;
            },
            1011 => {
                fminlen = facet;
            },
            1000 => {
                fmininc = facet;
            },
            1001 => {
                fminexc = facet;
            },
            1010 => {
                fmaxlen = facet;
            },
            1002 => {
                fmaxinc = facet;
            },
            1003 => {
                fmaxexc = facet;
            },
            1004 => {
                ftotdig = facet;
            },
            1005 => {
                ffracdig = facet;
            },
            _ => {},
        }
        cur = unsafe { (*cur).next };
    }
    cur = unsafe { (*base).facetSet };
    while !cur.is_null() {
        facet = unsafe { (*cur).facet };
        match (unsafe { (*facet).type_0 }) as u32 {
            1009 => {
                bflength = facet;
            },
            1011 => {
                bfminlen = facet;
            },
            1000 => {
                bfmininc = facet;
            },
            1001 => {
                bfminexc = facet;
            },
            1010 => {
                bfmaxlen = facet;
            },
            1002 => {
                bfmaxinc = facet;
            },
            1003 => {
                bfmaxexc = facet;
            },
            1004 => {
                bftotdig = facet;
            },
            1005 => {
                bffracdig = facet;
            },
            _ => {},
        }
        cur = unsafe { (*cur).next };
    }
    if !flength.is_null() && (!fminlen.is_null() || !fmaxlen.is_null()) {
        xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_INVALID_FACET_VALUE , flength as xmlSchemaBasicItemPtr , unsafe { (* flength) . node } , b"It is an error for both 'length' and either of 'minLength' or 'maxLength' to be specified on the same type definition\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
    }
    if !fmaxinc.is_null() && !fmaxexc.is_null() {
        xmlSchemaPCustomErrExt(
            pctxt,
            XML_SCHEMAP_INVALID_FACET_VALUE,
            fmaxinc as xmlSchemaBasicItemPtr,
            unsafe { (*fmaxinc).node },
            b"It is an error for both '%s' and '%s' to be specified on the same type definition\0"
                as *const u8 as *const i8,
            xmlSchemaFacetTypeToString(unsafe { (*fmaxinc).type_0 }) as *mut xmlChar,
            xmlSchemaFacetTypeToString(unsafe { (*fmaxexc).type_0 }) as *mut xmlChar,
            0 as *const xmlChar,
        );
    }
    if !fmininc.is_null() && !fminexc.is_null() {
        xmlSchemaPCustomErrExt(
            pctxt,
            XML_SCHEMAP_INVALID_FACET_VALUE,
            fmininc as xmlSchemaBasicItemPtr,
            unsafe { (*fmininc).node },
            b"It is an error for both '%s' and '%s' to be specified on the same type definition\0"
                as *const u8 as *const i8,
            xmlSchemaFacetTypeToString(unsafe { (*fmininc).type_0 }) as *mut xmlChar,
            xmlSchemaFacetTypeToString(unsafe { (*fminexc).type_0 }) as *mut xmlChar,
            0 as *const xmlChar,
        );
    }
    if !flength.is_null() && !bflength.is_null() {
        res = xmlSchemaCompareValues(unsafe { (*flength).val }, unsafe { (*bflength).val });
        if res == -(2 as i32) {
            current_block = 6717603523453139513;
        } else {
            if res != 0 as i32 {
                xmlSchemaDeriveFacetErr(pctxt, flength, bflength, 0 as i32, 0 as i32, 1 as i32);
            }
            if res != 0 as i32 && (unsafe { (*bflength).fixed }) != 0 {
                xmlSchemaPCustomErr(
                    pctxt,
                    XML_SCHEMAP_INVALID_FACET_VALUE,
                    flength as xmlSchemaBasicItemPtr,
                    unsafe { (*flength).node },
                    b"The base type's facet is 'fixed', thus the value must not differ\0"
                        as *const u8 as *const i8,
                    0 as *const xmlChar,
                );
            }
            current_block = 317151059986244064;
        }
    } else {
        current_block = 317151059986244064;
    }
    match current_block {
        317151059986244064 => {
            if !fminlen.is_null() && !bfminlen.is_null() {
                res = xmlSchemaCompareValues(unsafe { (*fminlen).val }, unsafe { (*bfminlen).val });
                if res == -(2 as i32) {
                    current_block = 6717603523453139513;
                } else {
                    if res == -(1 as i32) {
                        xmlSchemaDeriveFacetErr(
                            pctxt, fminlen, bfminlen, 1 as i32, 1 as i32, 1 as i32,
                        );
                    }
                    if res != 0 as i32 && (unsafe { (*bfminlen).fixed }) != 0 {
                        xmlSchemaPCustomErr(
                            pctxt,
                            XML_SCHEMAP_INVALID_FACET_VALUE,
                            fminlen as xmlSchemaBasicItemPtr,
                            unsafe { (*fminlen).node },
                            b"The base type's facet is 'fixed', thus the value must not differ\0"
                                as *const u8 as *const i8,
                            0 as *const xmlChar,
                        );
                    }
                    current_block = 7385833325316299293;
                }
            } else {
                current_block = 7385833325316299293;
            }
            match current_block {
                6717603523453139513 => {},
                _ => {
                    if !fmaxlen.is_null() && !bfmaxlen.is_null() {
                        res = xmlSchemaCompareValues(unsafe { (*fmaxlen).val }, unsafe { (*bfmaxlen).val });
                        if res == -(2 as i32) {
                            current_block = 6717603523453139513;
                        } else {
                            if res == 1 as i32 {
                                xmlSchemaDeriveFacetErr(
                                    pctxt,
                                    fmaxlen,
                                    bfmaxlen,
                                    -(1 as i32),
                                    1 as i32,
                                    1 as i32,
                                );
                            }
                            if res != 0 as i32 && (unsafe { (*bfmaxlen).fixed }) != 0 {
                                xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_INVALID_FACET_VALUE , fmaxlen as xmlSchemaBasicItemPtr , unsafe { (* fmaxlen) . node } , b"The base type's facet is 'fixed', thus the value must not differ\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
                            }
                            current_block = 8732226822098929438;
                        }
                    } else {
                        current_block = 8732226822098929438;
                    }
                    match current_block {
                        6717603523453139513 => {},
                        _ => {
                            if flength.is_null() {
                                flength = bflength;
                            }
                            if !flength.is_null() {
                                if fminlen.is_null() {
                                    fminlen = bfminlen;
                                }
                                if !fminlen.is_null() {
                                    res = xmlSchemaCompareValues(unsafe { (*flength).val }, unsafe { (*fminlen).val });
                                    if res == -(2 as i32) {
                                        current_block = 6717603523453139513;
                                    } else {
                                        if res == -(1 as i32) {
                                            xmlSchemaDeriveFacetErr(
                                                pctxt, flength, fminlen, 1 as i32, 1 as i32,
                                                0 as i32,
                                            );
                                        }
                                        current_block = 2798392256336243897;
                                    }
                                } else {
                                    current_block = 2798392256336243897;
                                }
                                match current_block {
                                    6717603523453139513 => {},
                                    _ => {
                                        if fmaxlen.is_null() {
                                            fmaxlen = bfmaxlen;
                                        }
                                        if !fmaxlen.is_null() {
                                            res = xmlSchemaCompareValues(
                                                unsafe { (*flength).val },
                                                unsafe { (*fmaxlen).val },
                                            );
                                            if res == -(2 as i32) {
                                                current_block = 6717603523453139513;
                                            } else {
                                                if res == 1 as i32 {
                                                    xmlSchemaDeriveFacetErr(
                                                        pctxt,
                                                        flength,
                                                        fmaxlen,
                                                        -(1 as i32),
                                                        1 as i32,
                                                        0 as i32,
                                                    );
                                                }
                                                current_block = 2945622622075328793;
                                            }
                                        } else {
                                            current_block = 2945622622075328793;
                                        }
                                    },
                                }
                            } else {
                                current_block = 2945622622075328793;
                            }
                            match current_block {
                                6717603523453139513 => {},
                                _ => {
                                    if !fmaxinc.is_null() {
                                        if !fmininc.is_null() {
                                            res = xmlSchemaCompareValues(
                                                unsafe { (*fmaxinc).val },
                                                unsafe { (*fmininc).val },
                                            );
                                            if res == -(2 as i32) {
                                                current_block = 6717603523453139513;
                                            } else {
                                                if res == -(1 as i32) {
                                                    xmlSchemaDeriveFacetErr(
                                                        pctxt, fmaxinc, fmininc, 1 as i32,
                                                        1 as i32, 0 as i32,
                                                    );
                                                }
                                                current_block = 3024367268842933116;
                                            }
                                        } else {
                                            current_block = 3024367268842933116;
                                        }
                                        match current_block {
                                            6717603523453139513 => {},
                                            _ => {
                                                if !bfmaxinc.is_null() {
                                                    res = xmlSchemaCompareValues(
                                                        unsafe { (*fmaxinc).val },
                                                        unsafe { (*bfmaxinc).val },
                                                    );
                                                    if res == -(2 as i32) {
                                                        current_block = 6717603523453139513;
                                                    } else {
                                                        if res == 1 as i32 {
                                                            xmlSchemaDeriveFacetErr(
                                                                pctxt,
                                                                fmaxinc,
                                                                bfmaxinc,
                                                                -(1 as i32),
                                                                1 as i32,
                                                                1 as i32,
                                                            );
                                                        }
                                                        if res != 0 as i32 && (unsafe { (*bfmaxinc).fixed }) != 0
                                                        {
                                                            xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_INVALID_FACET_VALUE , fmaxinc as xmlSchemaBasicItemPtr , unsafe { (* fmaxinc) . node } , b"The base type's facet is 'fixed', thus the value must not differ\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
                                                        }
                                                        current_block = 16778110326724371720;
                                                    }
                                                } else {
                                                    current_block = 16778110326724371720;
                                                }
                                                match current_block {
                                                    6717603523453139513 => {},
                                                    _ => {
                                                        if !bfmaxexc.is_null() {
                                                            res = xmlSchemaCompareValues(
                                                                unsafe { (*fmaxinc).val },
                                                                unsafe { (*bfmaxexc).val },
                                                            );
                                                            if res == -(2 as i32) {
                                                                current_block = 6717603523453139513;
                                                            } else {
                                                                if res != -(1 as i32) {
                                                                    xmlSchemaDeriveFacetErr(
                                                                        pctxt,
                                                                        fmaxinc,
                                                                        bfmaxexc,
                                                                        -(1 as i32),
                                                                        0 as i32,
                                                                        1 as i32,
                                                                    );
                                                                }
                                                                current_block = 9180031981464905198;
                                                            }
                                                        } else {
                                                            current_block = 9180031981464905198;
                                                        }
                                                        match current_block {
                                                            6717603523453139513 => {},
                                                            _ => {
                                                                if !bfmininc.is_null() {
                                                                    res = xmlSchemaCompareValues(
                                                                        unsafe { (*fmaxinc).val },
                                                                        unsafe { (*bfmininc).val },
                                                                    );
                                                                    if res == -(2 as i32) {
                                                                        current_block =
                                                                            6717603523453139513;
                                                                    } else {
                                                                        if res == -(1 as i32) {
                                                                            xmlSchemaDeriveFacetErr(
                                                                                pctxt, fmaxinc,
                                                                                bfmininc, 1 as i32,
                                                                                1 as i32, 1 as i32,
                                                                            );
                                                                        }
                                                                        current_block =
                                                                            6584656659744957450;
                                                                    }
                                                                } else {
                                                                    current_block =
                                                                        6584656659744957450;
                                                                }
                                                                match current_block {
                                                                    6717603523453139513 => {},
                                                                    _ => {
                                                                        if !bfminexc.is_null() {
                                                                            res = xmlSchemaCompareValues (unsafe { (* fmaxinc) . val } , unsafe { (* bfminexc) . val } ,) ;
                                                                            if res == -(2 as i32) {
                                                                                current_block = 6717603523453139513 ;
                                                                            } else {
                                                                                if res != 1 as i32 {
                                                                                    xmlSchemaDeriveFacetErr (pctxt , fmaxinc , bfminexc , 1 as i32 , 0 as i32 , 1 as i32 ,) ;
                                                                                }
                                                                                current_block = 10938659635288570931 ;
                                                                            }
                                                                        } else {
                                                                            current_block = 10938659635288570931 ;
                                                                        }
                                                                    },
                                                                }
                                                            },
                                                        }
                                                    },
                                                }
                                            },
                                        }
                                    } else {
                                        current_block = 10938659635288570931;
                                    }
                                    match current_block {
                                        6717603523453139513 => {},
                                        _ => {
                                            if !fmaxexc.is_null() {
                                                if !fminexc.is_null() {
                                                    res = xmlSchemaCompareValues(
                                                        unsafe { (*fmaxexc).val },
                                                        unsafe { (*fminexc).val },
                                                    );
                                                    if res == -(2 as i32) {
                                                        current_block = 6717603523453139513;
                                                    } else {
                                                        if res == -(1 as i32) {
                                                            xmlSchemaDeriveFacetErr(
                                                                pctxt, fmaxexc, fminexc, 1 as i32,
                                                                1 as i32, 0 as i32,
                                                            );
                                                        }
                                                        current_block = 7545150590528655645;
                                                    }
                                                } else {
                                                    current_block = 7545150590528655645;
                                                }
                                                match current_block {
                                                    6717603523453139513 => {},
                                                    _ => {
                                                        if !bfmaxexc.is_null() {
                                                            res = xmlSchemaCompareValues(
                                                                unsafe { (*fmaxexc).val },
                                                                unsafe { (*bfmaxexc).val },
                                                            );
                                                            if res == -(2 as i32) {
                                                                current_block = 6717603523453139513;
                                                            } else {
                                                                if res == 1 as i32 {
                                                                    xmlSchemaDeriveFacetErr(
                                                                        pctxt,
                                                                        fmaxexc,
                                                                        bfmaxexc,
                                                                        -(1 as i32),
                                                                        1 as i32,
                                                                        1 as i32,
                                                                    );
                                                                }
                                                                if res != 0 as i32
                                                                    && (unsafe { (*bfmaxexc).fixed }) != 0
                                                                {
                                                                    xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_INVALID_FACET_VALUE , fmaxexc as xmlSchemaBasicItemPtr , unsafe { (* fmaxexc) . node } , b"The base type's facet is 'fixed', thus the value must not differ\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
                                                                }
                                                                current_block = 1421636490742020198;
                                                            }
                                                        } else {
                                                            current_block = 1421636490742020198;
                                                        }
                                                        match current_block {
                                                            6717603523453139513 => {},
                                                            _ => {
                                                                if !bfmaxinc.is_null() {
                                                                    res = xmlSchemaCompareValues(
                                                                        unsafe { (*fmaxexc).val },
                                                                        unsafe { (*bfmaxinc).val },
                                                                    );
                                                                    if res == -(2 as i32) {
                                                                        current_block =
                                                                            6717603523453139513;
                                                                    } else {
                                                                        if res == 1 as i32 {
                                                                            xmlSchemaDeriveFacetErr(
                                                                                pctxt,
                                                                                fmaxexc,
                                                                                bfmaxinc,
                                                                                -(1 as i32),
                                                                                1 as i32,
                                                                                1 as i32,
                                                                            );
                                                                        }
                                                                        current_block =
                                                                            12129449210080749085;
                                                                    }
                                                                } else {
                                                                    current_block =
                                                                        12129449210080749085;
                                                                }
                                                                match current_block {
                                                                    6717603523453139513 => {},
                                                                    _ => {
                                                                        if !bfmininc.is_null() {
                                                                            res = xmlSchemaCompareValues (unsafe { (* fmaxexc) . val } , unsafe { (* bfmininc) . val } ,) ;
                                                                            if res == -(2 as i32) {
                                                                                current_block = 6717603523453139513 ;
                                                                            } else {
                                                                                if res != 1 as i32 {
                                                                                    xmlSchemaDeriveFacetErr (pctxt , fmaxexc , bfmininc , 1 as i32 , 0 as i32 , 1 as i32 ,) ;
                                                                                }
                                                                                current_block = 11508203296038873488 ;
                                                                            }
                                                                        } else {
                                                                            current_block = 11508203296038873488 ;
                                                                        }
                                                                        match current_block {
                                                                            6717603523453139513 => {
                                                                            },
                                                                            _ => {
                                                                                if !bfminexc
                                                                                    .is_null()
                                                                                {
                                                                                    res = xmlSchemaCompareValues (unsafe { (* fmaxexc) . val } , unsafe { (* bfminexc) . val } ,) ;
                                                                                    if res
                                                                                        == -(2
                                                                                            as i32)
                                                                                    {
                                                                                        current_block = 6717603523453139513 ;
                                                                                    } else {
                                                                                        if res != 1
                                                                                            as i32
                                                                                        {
                                                                                            xmlSchemaDeriveFacetErr (pctxt , fmaxexc , bfminexc , 1 as i32 , 0 as i32 , 1 as i32 ,) ;
                                                                                        }
                                                                                        current_block = 5482373152242628851 ;
                                                                                    }
                                                                                } else {
                                                                                    current_block = 5482373152242628851 ;
                                                                                }
                                                                            },
                                                                        }
                                                                    },
                                                                }
                                                            },
                                                        }
                                                    },
                                                }
                                            } else {
                                                current_block = 5482373152242628851;
                                            }
                                            match current_block {
                                                6717603523453139513 => {},
                                                _ => {
                                                    if !fminexc.is_null() {
                                                        if !fmaxinc.is_null() {
                                                            res = xmlSchemaCompareValues(
                                                                unsafe { (*fminexc).val },
                                                                unsafe { (*fmaxinc).val },
                                                            );
                                                            if res == -(2 as i32) {
                                                                current_block = 6717603523453139513;
                                                            } else {
                                                                if res != -(1 as i32) {
                                                                    xmlSchemaDeriveFacetErr(
                                                                        pctxt,
                                                                        fminexc,
                                                                        fmaxinc,
                                                                        -(1 as i32),
                                                                        0 as i32,
                                                                        0 as i32,
                                                                    );
                                                                }
                                                                current_block = 2925215368761540503;
                                                            }
                                                        } else {
                                                            current_block = 2925215368761540503;
                                                        }
                                                        match current_block {
                                                            6717603523453139513 => {},
                                                            _ => {
                                                                if !bfminexc.is_null() {
                                                                    res = xmlSchemaCompareValues(
                                                                        unsafe { (*fminexc).val },
                                                                        unsafe { (*bfminexc).val },
                                                                    );
                                                                    if res == -(2 as i32) {
                                                                        current_block =
                                                                            6717603523453139513;
                                                                    } else {
                                                                        if res == -(1 as i32) {
                                                                            xmlSchemaDeriveFacetErr(
                                                                                pctxt, fminexc,
                                                                                bfminexc, 1 as i32,
                                                                                1 as i32, 1 as i32,
                                                                            );
                                                                        }
                                                                        if res != 0 as i32
                                                                            && (unsafe { (*bfminexc).fixed })
                                                                                != 0
                                                                        {
                                                                            xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_INVALID_FACET_VALUE , fminexc as xmlSchemaBasicItemPtr , unsafe { (* fminexc) . node } , b"The base type's facet is 'fixed', thus the value must not differ\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
                                                                        }
                                                                        current_block =
                                                                            12299212226970775842;
                                                                    }
                                                                } else {
                                                                    current_block =
                                                                        12299212226970775842;
                                                                }
                                                                match current_block {
                                                                    6717603523453139513 => {},
                                                                    _ => {
                                                                        if !bfmaxinc.is_null() {
                                                                            res = xmlSchemaCompareValues (unsafe { (* fminexc) . val } , unsafe { (* bfmaxinc) . val } ,) ;
                                                                            if res == -(2 as i32) {
                                                                                current_block = 6717603523453139513 ;
                                                                            } else {
                                                                                if res == 1 as i32 {
                                                                                    xmlSchemaDeriveFacetErr (pctxt , fminexc , bfmaxinc , - (1 as i32) , 1 as i32 , 1 as i32 ,) ;
                                                                                }
                                                                                current_block = 16813369756331276724 ;
                                                                            }
                                                                        } else {
                                                                            current_block = 16813369756331276724 ;
                                                                        }
                                                                        match current_block {
                                                                            6717603523453139513 => {
                                                                            },
                                                                            _ => {
                                                                                if !bfmininc
                                                                                    .is_null()
                                                                                {
                                                                                    res = xmlSchemaCompareValues (unsafe { (* fminexc) . val } , unsafe { (* bfmininc) . val } ,) ;
                                                                                    if res
                                                                                        == -(2
                                                                                            as i32)
                                                                                    {
                                                                                        current_block = 6717603523453139513 ;
                                                                                    } else {
                                                                                        if res == - (1 as i32) { xmlSchemaDeriveFacetErr (pctxt , fminexc , bfmininc , 1 as i32 , 1 as i32 , 1 as i32 ,) ; }
                                                                                        current_block = 5267916556966421873 ;
                                                                                    }
                                                                                } else {
                                                                                    current_block = 5267916556966421873 ;
                                                                                }
                                                                                match current_block { 6717603523453139513 => { } _ => { if ! bfmaxexc . is_null () { res = xmlSchemaCompareValues (unsafe { (* fminexc) . val } , unsafe { (* bfmaxexc) . val } ,) ; if res == - (2 as i32) { current_block = 6717603523453139513 ; } else { if res != - (1 as i32) { xmlSchemaDeriveFacetErr (pctxt , fminexc , bfmaxexc , - (1 as i32) , 0 as i32 , 1 as i32 ,) ; } current_block = 6091595930016798176 ; } } else { current_block = 6091595930016798176 ; } } }
                                                                            },
                                                                        }
                                                                    },
                                                                }
                                                            },
                                                        }
                                                    } else {
                                                        current_block = 6091595930016798176;
                                                    }
                                                    match current_block {
                                                        6717603523453139513 => {},
                                                        _ => {
                                                            if !fmininc.is_null() {
                                                                if !fmaxexc.is_null() {
                                                                    res = xmlSchemaCompareValues(
                                                                        unsafe { (*fmininc).val },
                                                                        unsafe { (*fmaxexc).val },
                                                                    );
                                                                    if res == -(2 as i32) {
                                                                        current_block =
                                                                            6717603523453139513;
                                                                    } else {
                                                                        if res != -(1 as i32) {
                                                                            xmlSchemaDeriveFacetErr(
                                                                                pctxt,
                                                                                fmininc,
                                                                                fmaxexc,
                                                                                -(1 as i32),
                                                                                0 as i32,
                                                                                0 as i32,
                                                                            );
                                                                        }
                                                                        current_block =
                                                                            6497888915984600225;
                                                                    }
                                                                } else {
                                                                    current_block =
                                                                        6497888915984600225;
                                                                }
                                                                match current_block {
                                                                    6717603523453139513 => {},
                                                                    _ => {
                                                                        if !bfmininc.is_null() {
                                                                            res = xmlSchemaCompareValues (unsafe { (* fmininc) . val } , unsafe { (* bfmininc) . val } ,) ;
                                                                            if res == -(2 as i32) {
                                                                                current_block = 6717603523453139513 ;
                                                                            } else {
                                                                                if res
                                                                                    == -(1 as i32)
                                                                                {
                                                                                    xmlSchemaDeriveFacetErr (pctxt , fmininc , bfmininc , 1 as i32 , 1 as i32 , 1 as i32 ,) ;
                                                                                }
                                                                                if res != 0 as i32
                                                                                    && (unsafe { (*bfmininc)
                                                                                        .fixed })
                                                                                        != 0
                                                                                {
                                                                                    xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_INVALID_FACET_VALUE , fmininc as xmlSchemaBasicItemPtr , unsafe { (* fmininc) . node } , b"The base type's facet is 'fixed', thus the value must not differ\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
                                                                                }
                                                                                current_block = 9350489878244555550 ;
                                                                            }
                                                                        } else {
                                                                            current_block =
                                                                                9350489878244555550;
                                                                        }
                                                                        match current_block {
                                                                            6717603523453139513 => {
                                                                            },
                                                                            _ => {
                                                                                if !bfmaxinc
                                                                                    .is_null()
                                                                                {
                                                                                    res = xmlSchemaCompareValues (unsafe { (* fmininc) . val } , unsafe { (* bfmaxinc) . val } ,) ;
                                                                                    if res
                                                                                        == -(2
                                                                                            as i32)
                                                                                    {
                                                                                        current_block = 6717603523453139513 ;
                                                                                    } else {
                                                                                        if res == 1
                                                                                            as i32
                                                                                        {
                                                                                            xmlSchemaDeriveFacetErr (pctxt , fmininc , bfmaxinc , - (1 as i32) , 1 as i32 , 1 as i32 ,) ;
                                                                                        }
                                                                                        current_block = 11364608634565542496 ;
                                                                                    }
                                                                                } else {
                                                                                    current_block = 11364608634565542496 ;
                                                                                }
                                                                                match current_block { 6717603523453139513 => { } _ => { if ! bfminexc . is_null () { res = xmlSchemaCompareValues (unsafe { (* fmininc) . val } , unsafe { (* bfminexc) . val } ,) ; if res == - (2 as i32) { current_block = 6717603523453139513 ; } else { if res != 1 as i32 { xmlSchemaDeriveFacetErr (pctxt , fmininc , bfminexc , 1 as i32 , 0 as i32 , 1 as i32 ,) ; } current_block = 3304481414499905106 ; } } else { current_block = 3304481414499905106 ; } match current_block { 6717603523453139513 => { } _ => { if ! bfmaxexc . is_null () { res = xmlSchemaCompareValues (unsafe { (* fmininc) . val } , unsafe { (* bfmaxexc) . val } ,) ; if res == - (2 as i32) { current_block = 6717603523453139513 ; } else { if res != - (1 as i32) { xmlSchemaDeriveFacetErr (pctxt , fmininc , bfmaxexc , - (1 as i32) , 0 as i32 , 1 as i32 ,) ; } current_block = 1707335883933721018 ; } } else { current_block = 1707335883933721018 ; } } } } }
                                                                            },
                                                                        }
                                                                    },
                                                                }
                                                            } else {
                                                                current_block = 1707335883933721018;
                                                            }
                                                            match current_block {
                                                                6717603523453139513 => {},
                                                                _ => {
                                                                    if !ftotdig.is_null()
                                                                        && !bftotdig.is_null()
                                                                    {
                                                                        res =
                                                                            xmlSchemaCompareValues(
                                                                                unsafe { (*ftotdig).val },
                                                                                unsafe { (*bftotdig).val },
                                                                            );
                                                                        if res == -(2 as i32) {
                                                                            current_block =
                                                                                6717603523453139513;
                                                                        } else {
                                                                            if res == 1 as i32 {
                                                                                xmlSchemaDeriveFacetErr (pctxt , ftotdig , bftotdig , - (1 as i32) , 1 as i32 , 1 as i32 ,) ;
                                                                            }
                                                                            if res != 0 as i32
                                                                                && (unsafe { (*bftotdig).fixed })
                                                                                    != 0
                                                                            {
                                                                                xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_INVALID_FACET_VALUE , ftotdig as xmlSchemaBasicItemPtr , unsafe { (* ftotdig) . node } , b"The base type's facet is 'fixed', thus the value must not differ\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
                                                                            }
                                                                            current_block =
                                                                                2606663910910355487;
                                                                        }
                                                                    } else {
                                                                        current_block =
                                                                            2606663910910355487;
                                                                    }
                                                                    match current_block {
                                                                        6717603523453139513 => {},
                                                                        _ => {
                                                                            if !ffracdig.is_null()
                                                                                && !bffracdig
                                                                                    .is_null()
                                                                            {
                                                                                res = xmlSchemaCompareValues (unsafe { (* ffracdig) . val } , unsafe { (* bffracdig) . val } ,) ;
                                                                                if res
                                                                                    == -(2 as i32)
                                                                                {
                                                                                    current_block = 6717603523453139513 ;
                                                                                } else {
                                                                                    if res
                                                                                        == 1 as i32
                                                                                    {
                                                                                        xmlSchemaDeriveFacetErr (pctxt , ffracdig , bffracdig , - (1 as i32) , 1 as i32 , 1 as i32 ,) ;
                                                                                    }
                                                                                    if res != 0 as i32 && (unsafe { (* bffracdig) . fixed }) != 0 { xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_INVALID_FACET_VALUE , ffracdig as xmlSchemaBasicItemPtr , unsafe { (* ffracdig) . node } , b"The base type's facet is 'fixed', thus the value must not differ\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ; }
                                                                                    current_block = 5913497314667414582 ;
                                                                                }
                                                                            } else {
                                                                                current_block = 5913497314667414582 ;
                                                                            }
                                                                            match current_block { 6717603523453139513 => { } _ => { if ftotdig . is_null () { ftotdig = bftotdig ; } if ffracdig . is_null () { ffracdig = bffracdig ; } if ! ftotdig . is_null () && ! ffracdig . is_null () { res = xmlSchemaCompareValues (unsafe { (* ffracdig) . val } , unsafe { (* ftotdig) . val } ,) ; if res == - (2 as i32) { current_block = 6717603523453139513 ; } else { if res == 1 as i32 { xmlSchemaDeriveFacetErr (pctxt , ffracdig , ftotdig , - (1 as i32) , 1 as i32 , 0 as i32 ,) ; } current_block = 9190931632177426379 ; } } else { current_block = 9190931632177426379 ; } match current_block { 6717603523453139513 => { } _ => { cur = unsafe { (* base) . facetSet } ; while ! cur . is_null () { bfacet = unsafe { (* cur) . facet } ; if ! ((unsafe { (* bfacet) . type_0 }) as u32 == XML_SCHEMA_FACET_PATTERN as i32 as u32 || (unsafe { (* bfacet) . type_0 }) as u32 == XML_SCHEMA_FACET_ENUMERATION as i32 as u32) { link = unsafe { (* type_0) . facetSet } ; while ! link . is_null () { facet = unsafe { (* link) . facet } ; if (unsafe { (* facet) . type_0 }) as u32 == (unsafe { (* bfacet) . type_0 }) as u32 { match (unsafe { (* facet) . type_0 }) as u32 { 1008 => { if (unsafe { (* facet) . whitespace }) < (unsafe { (* bfacet) . whitespace }) { xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_INVALID_FACET_VALUE , facet as xmlSchemaBasicItemPtr , unsafe { (* facet) . node } , b"The 'whitespace' value has to be equal to or stronger than the 'whitespace' value of the base type\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ; } if (unsafe { (* bfacet) . fixed }) != 0 && (unsafe { (* facet) . whitespace }) != (unsafe { (* bfacet) . whitespace }) { xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_INVALID_FACET_VALUE , facet as xmlSchemaBasicItemPtr , unsafe { (* facet) . node } , b"The base type's facet is 'fixed', thus the value must not differ\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ; } } _ => { } } break ; } else { link = unsafe { (* link) . next } ; } } if link . is_null () { link = (unsafe { xmlMalloc . expect ("non-null function pointer" ,) (:: std :: mem :: size_of :: < xmlSchemaFacetLink > () as u64 ,) }) as xmlSchemaFacetLinkPtr ; if link . is_null () { xmlSchemaPErrMemory (pctxt , b"deriving facets, creating a facet link\0" as * const u8 as * const i8 , 0 as xmlNodePtr ,) ; return - (1 as i32) ; } let fresh369 = unsafe { & mut ((* link) . facet) } ; * fresh369 = unsafe { (* cur) . facet } ; let fresh370 = unsafe { & mut ((* link) . next) } ; * fresh370 = 0 as * mut _xmlSchemaFacetLink ; if last . is_null () { let fresh371 = unsafe { & mut ((* type_0) . facetSet) } ; * fresh371 = link ; } else { let fresh372 = unsafe { & mut ((* last) . next) } ; * fresh372 = link ; } last = link ; } } cur = unsafe { (* cur) . next } ; } return 0 as i32 ; } } } }
                                                                        },
                                                                    }
                                                                },
                                                            }
                                                        },
                                                    }
                                                },
                                            }
                                        },
                                    }
                                },
                            }
                        },
                    }
                },
            }
        },
        _ => {},
    }
    xmlSchemaInternalErr(
        pctxt as xmlSchemaAbstractCtxtPtr,
        b"xmlSchemaDeriveAndValidateFacets\0" as *const u8 as *const i8,
        b"an error occurred\0" as *const u8 as *const i8,
    );
    return -(1 as i32);
}
extern "C" fn xmlSchemaFinishMemberTypeDefinitionsProperty<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
) -> i32
where
    'a2: 'static,
{
    let mut link: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'_> = 0 as *mut xmlSchemaTypeLink;
    let mut lastLink: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'_> =
        0 as *mut xmlSchemaTypeLink;
    let mut prevLink: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'_> =
        0 as *mut xmlSchemaTypeLink;
    let mut subLink: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'_> =
        0 as *mut xmlSchemaTypeLink;
    let mut newLink: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'_> =
        0 as *mut xmlSchemaTypeLink;
    link = unsafe { (*type_0).memberTypes };
    while !link.is_null() {
        if (unsafe { (*(*link).type_0).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (unsafe { (*(*link).type_0).flags }) & (1 as i32) << 22 as i32 == 0 as i32
        {
            xmlSchemaTypeFixup(unsafe { (*link).type_0 }, pctxt as xmlSchemaAbstractCtxtPtr);
        }
        if (unsafe { (*(*link).type_0).flags }) & (1 as i32) << 7 as i32 != 0 {
            subLink = xmlSchemaGetUnionSimpleTypeMemberTypes(unsafe { (*link).type_0 });
            if !subLink.is_null() {
                let fresh373 = unsafe { &mut ((*link).type_0) };
                *fresh373 = unsafe { (*subLink).type_0 };
                if !(unsafe { (*subLink).next }).is_null() {
                    lastLink = unsafe { (*link).next };
                    subLink = unsafe { (*subLink).next };
                    prevLink = link;
                    while !subLink.is_null() {
                        newLink =
                            (unsafe { xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<
                                xmlSchemaTypeLink,
                            >(
                            )
                                as u64) }) as xmlSchemaTypeLinkPtr;
                        if newLink.is_null() {
                            xmlSchemaPErrMemory(
                                pctxt,
                                b"allocating a type link\0" as *const u8 as *const i8,
                                0 as xmlNodePtr,
                            );
                            return -(1 as i32);
                        }
                        let fresh374 = unsafe { &mut ((*newLink).type_0) };
                        *fresh374 = unsafe { (*subLink).type_0 };
                        let fresh375 = unsafe { &mut ((*prevLink).next) };
                        *fresh375 = newLink;
                        prevLink = newLink;
                        let fresh376 = unsafe { &mut ((*newLink).next) };
                        *fresh376 = lastLink;
                        subLink = unsafe { (*subLink).next };
                    }
                }
            }
        }
        link = unsafe { (*link).next };
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaTypeFixupOptimFacets<'a1>(
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a1>,
) {
    let mut has: i32 = 0 as i32;
    let mut needVal: i32 = 0 as i32;
    let mut normVal: i32 = 0 as i32;
    has = if (unsafe { (*(*type_0).baseType).flags }) & (1 as i32) << 27 as i32 != 0 {
        1 as i32
    } else {
        0 as i32
    };
    if has != 0 {
        needVal = if (unsafe { (*(*type_0).baseType).flags }) & (1 as i32) << 21 as i32 != 0 {
            1 as i32
        } else {
            0 as i32
        };
        normVal = if (unsafe { (*(*type_0).baseType).flags }) & (1 as i32) << 28 as i32 != 0 {
            1 as i32
        } else {
            0 as i32
        };
    }
    if !(unsafe { (*type_0).facets }).is_null() {
        let mut fac: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as *mut xmlSchemaFacet;
        fac = unsafe { (*type_0).facets };
        while !fac.is_null() {
            match (unsafe { (*fac).type_0 }) as u32 {
                1008 => {},
                1006 => {
                    normVal = 1 as i32;
                    has = 1 as i32;
                },
                1007 => {
                    needVal = 1 as i32;
                    normVal = 1 as i32;
                    has = 1 as i32;
                },
                _ => {
                    has = 1 as i32;
                },
            }
            fac = unsafe { (*fac).next };
        }
    }
    if normVal != 0 {
        (unsafe { (*type_0).flags |= (1 as i32) << 28 as i32 });
    }
    if needVal != 0 {
        (unsafe { (*type_0).flags |= (1 as i32) << 21 as i32 });
    }
    if has != 0 {
        (unsafe { (*type_0).flags |= (1 as i32) << 27 as i32 });
    }
    if has != 0 && needVal == 0 && (unsafe { (*type_0).flags }) & (1 as i32) << 8 as i32 != 0 {
        let mut prim: *mut crate::src::xmlschemas::_xmlSchemaType<'_> =
            xmlSchemaGetPrimitiveType(type_0);
        if (unsafe { (*prim).builtInType }) != XML_SCHEMAS_ANYSIMPLETYPE as i32
            && (unsafe { (*prim).builtInType }) != XML_SCHEMAS_STRING as i32
        {
            (unsafe { (*type_0).flags |= (1 as i32) << 21 as i32 });
        }
    }
}
extern "C" fn xmlSchemaTypeFixupWhitespace<'a1>(
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a1>,
) -> i32 {
    if (unsafe { (*type_0).flags }) & (1 as i32) << 6 as i32 != 0 {
        (unsafe { (*type_0).flags |= (1 as i32) << 26 as i32 });
        return 0 as i32;
    } else {
        if (unsafe { (*type_0).flags }) & (1 as i32) << 7 as i32 != 0 {
            return 0 as i32;
        }
    }
    if !(unsafe { (*type_0).facetSet }).is_null() {
        let mut lin: *mut crate::src::xmlschemas::_xmlSchemaFacetLink<'_> =
            0 as *mut xmlSchemaFacetLink;
        lin = unsafe { (*type_0).facetSet };
        while !lin.is_null() {
            if (unsafe { (*(*lin).facet).type_0 }) as u32 == XML_SCHEMA_FACET_WHITESPACE as i32 as u32 {
                match unsafe { (*(*lin).facet).whitespace } {
                    1 => {
                        (unsafe { (*type_0).flags |= (1 as i32) << 24 as i32 });
                    },
                    2 => {
                        (unsafe { (*type_0).flags |= (1 as i32) << 25 as i32 });
                    },
                    3 => {
                        (unsafe { (*type_0).flags |= (1 as i32) << 26 as i32 });
                    },
                    _ => return -(1 as i32),
                }
                return 0 as i32;
            }
            lin = unsafe { (*lin).next };
        }
    }
    let mut anc: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    anc = unsafe { (*type_0).baseType };
    while !anc.is_null() && (unsafe { (*anc).builtInType }) != XML_SCHEMAS_ANYTYPE as i32 {
        if (unsafe { (*anc).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32 {
            if (unsafe { (*anc).builtInType }) == XML_SCHEMAS_NORMSTRING as i32 {
                (unsafe { (*type_0).flags |= (1 as i32) << 25 as i32 });
            } else if (unsafe { (*anc).builtInType }) == XML_SCHEMAS_STRING as i32
                || (unsafe { (*anc).builtInType }) == XML_SCHEMAS_ANYSIMPLETYPE as i32
            {
                (unsafe { (*type_0).flags |= (1 as i32) << 24 as i32 });
            } else {
                (unsafe { (*type_0).flags |= (1 as i32) << 26 as i32 });
            }
            break;
        } else {
            anc = unsafe { (*anc).baseType };
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaFixupSimpleTypeStageOne<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
) -> i32 {
    if (unsafe { (*type_0).type_0 }) as u32 != XML_SCHEMA_TYPE_SIMPLE as i32 as u32 {
        return 0 as i32;
    }
    if !((unsafe { (*type_0).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (unsafe { (*type_0).flags }) & (1 as i32) << 29 as i32 == 0 as i32)
    {
        return 0 as i32;
    }
    (unsafe { (*type_0).flags |= (1 as i32) << 29 as i32 });
    if (unsafe { (*type_0).flags }) & (1 as i32) << 6 as i32 != 0 {
        if (unsafe { (*type_0).subtypes }).is_null() {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaFixupSimpleTypeStageOne\0" as *const u8 as *const i8,
                b"list type has no item-type assigned\0" as *const u8 as *const i8,
            );
            return -(1 as i32);
        }
    } else if (unsafe { (*type_0).flags }) & (1 as i32) << 7 as i32 != 0 {
        if (unsafe { (*type_0).memberTypes }).is_null() {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaFixupSimpleTypeStageOne\0" as *const u8 as *const i8,
                b"union type has no member-types assigned\0" as *const u8 as *const i8,
            );
            return -(1 as i32);
        }
    } else {
        if (unsafe { (*type_0).baseType }).is_null() {
            xmlSchemaInternalErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaFixupSimpleTypeStageOne\0" as *const u8 as *const i8,
                b"type has no base-type assigned\0" as *const u8 as *const i8,
            );
            return -(1 as i32);
        }
        if (unsafe { (*(*type_0).baseType).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (unsafe { (*(*type_0).baseType).flags }) & (1 as i32) << 29 as i32 == 0 as i32
        {
            if xmlSchemaFixupSimpleTypeStageOne(pctxt, unsafe { (*type_0).baseType }) == -(1 as i32) {
                return -(1 as i32);
            }
        }
        if (unsafe { (*(*type_0).baseType).flags }) & (1 as i32) << 8 as i32 != 0 {
            (unsafe { (*type_0).flags |= (1 as i32) << 8 as i32 });
        } else if (unsafe { (*(*type_0).baseType).flags }) & (1 as i32) << 6 as i32 != 0 {
            (unsafe { (*type_0).flags |= (1 as i32) << 6 as i32 });
            let fresh377 = unsafe { &mut ((*type_0).subtypes) };
            *fresh377 = unsafe { (*(*type_0).baseType).subtypes };
        } else if (unsafe { (*(*type_0).baseType).flags }) & (1 as i32) << 7 as i32 != 0 {
            (unsafe { (*type_0).flags |= (1 as i32) << 7 as i32 });
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaFixupSimpleTypeStageTwo<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
) -> i32
where
    'a2: 'static,
{
    let mut current_block: u64;
    let mut res: i32 = 0;
    let mut olderrs: i32 = unsafe { (*pctxt).nberrors };
    if (unsafe { (*type_0).type_0 }) as u32 != XML_SCHEMA_TYPE_SIMPLE as i32 as u32 {
        return -(1 as i32);
    }
    if !((unsafe { (*type_0).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (unsafe { (*type_0).flags }) & (1 as i32) << 22 as i32 == 0 as i32)
    {
        return 0 as i32;
    }
    (unsafe { (*type_0).flags |= (1 as i32) << 22 as i32 });
    (unsafe { (*type_0).contentType = XML_SCHEMA_CONTENT_SIMPLE });
    if (unsafe { (*type_0).baseType }).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaFixupSimpleTypeStageTwo\0" as *const u8 as *const i8,
            b"missing baseType\0" as *const u8 as *const i8,
        );
    } else {
        if (unsafe { (*(*type_0).baseType).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (unsafe { (*(*type_0).baseType).flags }) & (1 as i32) << 22 as i32 == 0 as i32
        {
            xmlSchemaTypeFixup(unsafe { (*type_0).baseType }, pctxt as xmlSchemaAbstractCtxtPtr);
        }
        if !(unsafe { (*type_0).memberTypes }).is_null()
            && xmlSchemaFinishMemberTypeDefinitionsProperty(pctxt, type_0) == -(1 as i32)
        {
            return -(1 as i32);
        }
        res = xmlSchemaCheckSTPropsCorrect(pctxt, type_0);
        if !(res == -(1 as i32)) {
            if res != 0 as i32 {
                current_block = 16935711101380438426;
            } else {
                res = xmlSchemaCheckCOSSTRestricts(pctxt, type_0);
                if res == -(1 as i32) {
                    current_block = 7438021731138147780;
                } else if res != 0 as i32 {
                    current_block = 16935711101380438426;
                } else {
                    res = xmlSchemaCheckFacetValues(type_0, pctxt);
                    if res == -(1 as i32) {
                        current_block = 7438021731138147780;
                    } else if res != 0 as i32 {
                        current_block = 16935711101380438426;
                    } else {
                        if !(unsafe { (*type_0).facetSet }).is_null()
                            || !(unsafe { (*(*type_0).baseType).facetSet }).is_null()
                        {
                            res = xmlSchemaDeriveAndValidateFacets(pctxt, type_0);
                            if res == -(1 as i32) {
                                current_block = 7438021731138147780;
                            } else if res != 0 as i32 {
                                current_block = 16935711101380438426;
                            } else {
                                current_block = 4068382217303356765;
                            }
                        } else {
                            current_block = 4068382217303356765;
                        }
                        match current_block {
                            16935711101380438426 => {},
                            7438021731138147780 => {},
                            _ => {
                                res = xmlSchemaTypeFixupWhitespace(type_0);
                                if res == -(1 as i32) {
                                    current_block = 7438021731138147780;
                                } else if res != 0 as i32 {
                                    current_block = 16935711101380438426;
                                } else {
                                    xmlSchemaTypeFixupOptimFacets(type_0);
                                    current_block = 16935711101380438426;
                                }
                            },
                        }
                    }
                }
            }
            match current_block {
                7438021731138147780 => {},
                _ => {
                    if olderrs != (unsafe { (*pctxt).nberrors }) {
                        return unsafe { (*pctxt).err };
                    }
                    return 0 as i32;
                },
            }
        }
    }
    return -(1 as i32);
}
extern "C" fn xmlSchemaFixupComplexType<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
) -> i32
where
    'a2: 'static,
{
    let mut current_block: u64;
    let mut res: i32 = 0 as i32;
    let mut olderrs: i32 = unsafe { (*pctxt).nberrors };
    let mut baseType: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = unsafe { (*type_0).baseType };
    if !((unsafe { (*type_0).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (unsafe { (*type_0).flags }) & (1 as i32) << 22 as i32 == 0 as i32)
    {
        return 0 as i32;
    }
    (unsafe { (*type_0).flags |= (1 as i32) << 22 as i32 });
    if baseType.is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaFixupComplexType\0" as *const u8 as *const i8,
            b"missing baseType\0" as *const u8 as *const i8,
        );
    } else {
        if (unsafe { (*baseType).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (unsafe { (*baseType).flags }) & (1 as i32) << 22 as i32 == 0 as i32
        {
            xmlSchemaTypeFixup(baseType, pctxt as xmlSchemaAbstractCtxtPtr);
        }
        if (unsafe { (*baseType).flags }) & (1 as i32) << 23 as i32 != 0 {
            return 0 as i32;
        }
        res = xmlSchemaCheckSRCCT(pctxt, type_0);
        if !(res == -(1 as i32)) {
            if res != 0 as i32 {
                current_block = 6926858937233525393;
            } else {
                if (unsafe { (*type_0).contentType }) as u32 == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32 {
                    if ((unsafe { (*baseType).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                        || (unsafe { (*baseType).builtInType }) == XML_SCHEMAS_ANYTYPE as i32)
                        && !(unsafe { (*baseType).contentTypeDef }).is_null()
                        && (unsafe { (*type_0).flags }) & (1 as i32) << 2 as i32 != 0
                    {
                        let mut contentBase: *mut crate::src::xmlschemas::_xmlSchemaType<'_> =
                            0 as *mut xmlSchemaType;
                        let mut content: *mut crate::src::xmlschemas::_xmlSchemaType<'_> =
                            0 as *mut xmlSchemaType;
                        if !(unsafe { (*type_0).contentTypeDef }).is_null() {
                            contentBase = unsafe { (*type_0).contentTypeDef };
                            let fresh378 = unsafe { &mut ((*type_0).contentTypeDef) };
                            *fresh378 = 0 as xmlSchemaTypePtr;
                        } else {
                            contentBase = unsafe { (*baseType).contentTypeDef };
                        }
                        content = xmlSchemaAddType(
                            pctxt,
                            unsafe { (*pctxt).schema },
                            XML_SCHEMA_TYPE_SIMPLE,
                            0 as *const xmlChar,
                            unsafe { (*type_0).targetNamespace },
                            unsafe { (*type_0).node },
                            0 as i32,
                        );
                        if content.is_null() {
                            current_block = 345336241299298347;
                        } else {
                            (unsafe { (*content).type_0 = XML_SCHEMA_TYPE_SIMPLE });
                            let fresh379 = unsafe { &mut ((*content).baseType) };
                            *fresh379 = contentBase;
                            let fresh380 = unsafe { &mut ((*content).facets) };
                            *fresh380 = unsafe { (*type_0).facets };
                            let fresh381 = unsafe { &mut ((*type_0).facets) };
                            *fresh381 = 0 as xmlSchemaFacetPtr;
                            let fresh382 = unsafe { &mut ((*content).facetSet) };
                            *fresh382 = unsafe { (*type_0).facetSet };
                            let fresh383 = unsafe { &mut ((*type_0).facetSet) };
                            *fresh383 = 0 as xmlSchemaFacetLinkPtr;
                            let fresh384 = unsafe { &mut ((*type_0).contentTypeDef) };
                            *fresh384 = content;
                            if (unsafe { (*contentBase).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32
                                && (unsafe { (*contentBase).flags }) & (1 as i32) << 22 as i32 == 0 as i32
                            {
                                xmlSchemaTypeFixup(contentBase, pctxt as xmlSchemaAbstractCtxtPtr);
                            }
                            res = xmlSchemaFixupSimpleTypeStageOne(pctxt, content);
                            if res == -(1 as i32) {
                                current_block = 345336241299298347;
                            } else if res != 0 as i32 {
                                current_block = 6926858937233525393;
                            } else {
                                res = xmlSchemaFixupSimpleTypeStageTwo(pctxt, content);
                                if res == -(1 as i32) {
                                    current_block = 345336241299298347;
                                } else if res != 0 as i32 {
                                    current_block = 6926858937233525393;
                                } else {
                                    current_block = 5265702136860997526;
                                }
                            }
                        }
                    } else if ((unsafe { (*baseType).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                        || (unsafe { (*baseType).builtInType }) == XML_SCHEMAS_ANYTYPE as i32)
                        && (unsafe { (*baseType).contentType }) as u32 == XML_SCHEMA_CONTENT_MIXED as i32 as u32
                        && (unsafe { (*type_0).flags }) & (1 as i32) << 2 as i32 != 0
                    {
                        if (unsafe { (*type_0).contentTypeDef }).is_null()
                            || (unsafe { (*(*type_0).contentTypeDef).baseType }).is_null()
                        {
                            xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_INTERNAL , type_0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"Internal error: xmlSchemaTypeFixup, complex type '%s': the <simpleContent><restriction> is missing a <simpleType> child, but was not caught by xmlSchemaCheckSRCCT()\0" as * const u8 as * const i8 , unsafe { (* type_0) . name } ,) ;
                            current_block = 345336241299298347;
                        } else {
                            current_block = 5265702136860997526;
                        }
                    } else if ((unsafe { (*baseType).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                        || (unsafe { (*baseType).builtInType }) == XML_SCHEMAS_ANYTYPE as i32)
                        && (unsafe { (*type_0).flags }) & (1 as i32) << 1 as i32 != 0
                    {
                        if (unsafe { (*baseType).contentTypeDef }).is_null() {
                            xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_INTERNAL , type_0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"Internal error: xmlSchemaTypeFixup, complex type '%s': the <extension>ed base type is a complex type with no simple content type\0" as * const u8 as * const i8 , unsafe { (* type_0) . name } ,) ;
                            current_block = 345336241299298347;
                        } else {
                            let fresh385 = unsafe { &mut ((*type_0).contentTypeDef) };
                            *fresh385 = unsafe { (*baseType).contentTypeDef };
                            current_block = 5265702136860997526;
                        }
                    } else if ((unsafe { (*baseType).type_0 }) as u32 == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                        || (unsafe { (*baseType).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
                            && (unsafe { (*baseType).builtInType }) != XML_SCHEMAS_ANYTYPE as i32)
                        && (unsafe { (*type_0).flags }) & (1 as i32) << 1 as i32 != 0
                    {
                        let fresh386 = unsafe { &mut ((*type_0).contentTypeDef) };
                        *fresh386 = baseType;
                        current_block = 5265702136860997526;
                    } else {
                        xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_INTERNAL , type_0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"Internal error: xmlSchemaTypeFixup, complex type '%s' with <simpleContent>: unhandled derivation case\0" as * const u8 as * const i8 , unsafe { (* type_0) . name } ,) ;
                        current_block = 345336241299298347;
                    }
                } else {
                    let mut dummySequence: i32 = 0 as i32;
                    let mut particle: *mut crate::src::xmlschemas::_xmlSchemaParticle =
                        (unsafe { (*type_0).subtypes }) as xmlSchemaParticlePtr;
                    if particle.is_null()
                        || (unsafe { (*particle).type_0 }) as u32 == XML_SCHEMA_TYPE_PARTICLE as i32 as u32
                            && ((unsafe { (*(*particle).children).type_0 }) as u32
                                == XML_SCHEMA_TYPE_ALL as i32 as u32
                                || (unsafe { (*(*particle).children).type_0 }) as u32
                                    == XML_SCHEMA_TYPE_SEQUENCE as i32 as u32
                                || (unsafe { (*(*particle).children).type_0 }) as u32
                                    == XML_SCHEMA_TYPE_CHOICE as i32 as u32
                                    && (unsafe { (*particle).minOccurs }) == 0 as i32)
                            && (unsafe { (*(*particle).children).children }).is_null()
                    {
                        if (unsafe { (*type_0).flags }) & (1 as i32) << 0 as i32 != 0 {
                            if particle.is_null()
                                || (unsafe { (*(*particle).children).type_0 }) as u32
                                    != XML_SCHEMA_TYPE_SEQUENCE as i32 as u32
                            {
                                particle =
                                    xmlSchemaAddParticle(pctxt, unsafe { (*type_0).node }, 1 as i32, 1 as i32);
                                if particle.is_null() {
                                    current_block = 345336241299298347;
                                } else {
                                    let fresh387 = unsafe { &mut ((*particle).children) };
                                    *fresh387 = xmlSchemaAddModelGroup(
                                        pctxt,
                                        unsafe { (*pctxt).schema },
                                        XML_SCHEMA_TYPE_SEQUENCE,
                                        unsafe { (*type_0).node },
                                    )
                                        as xmlSchemaTreeItemPtr;
                                    if (unsafe { (*particle).children }).is_null() {
                                        current_block = 345336241299298347;
                                    } else {
                                        let fresh388 = unsafe { &mut ((*type_0).subtypes) };
                                        *fresh388 = particle as xmlSchemaTypePtr;
                                        current_block = 17075014677070940716;
                                    }
                                }
                            } else {
                                current_block = 17075014677070940716;
                            }
                            match current_block {
                                345336241299298347 => {},
                                _ => {
                                    dummySequence = 1 as i32;
                                    (unsafe { (*type_0).contentType = XML_SCHEMA_CONTENT_ELEMENTS });
                                    current_block = 4216521074440650966;
                                },
                            }
                        } else {
                            (unsafe { (*type_0).contentType = XML_SCHEMA_CONTENT_EMPTY });
                            current_block = 4216521074440650966;
                        }
                    } else {
                        (unsafe { (*type_0).contentType = XML_SCHEMA_CONTENT_ELEMENTS });
                        current_block = 4216521074440650966;
                    }
                    match current_block {
                        345336241299298347 => {},
                        _ => {
                            if (unsafe { (*type_0).flags }) & (1 as i32) << 2 as i32 != 0 {
                                if (unsafe { (*type_0).contentType }) as u32
                                    != XML_SCHEMA_CONTENT_EMPTY as i32 as u32
                                {
                                    if (unsafe { (*type_0).flags }) & (1 as i32) << 0 as i32 != 0 {
                                        (unsafe { (*type_0).contentType = XML_SCHEMA_CONTENT_MIXED });
                                    }
                                }
                                current_block = 5265702136860997526;
                            } else if (unsafe { (*type_0).contentType }) as u32
                                == XML_SCHEMA_CONTENT_EMPTY as i32 as u32
                            {
                                (unsafe { (*type_0).contentType = (*baseType).contentType });
                                let fresh389 = unsafe { &mut ((*type_0).subtypes) };
                                *fresh389 = unsafe { (*baseType).subtypes };
                                let fresh390 = unsafe { &mut ((*type_0).contentTypeDef) };
                                *fresh390 = unsafe { (*baseType).contentTypeDef };
                                current_block = 5265702136860997526;
                            } else if (unsafe { (*baseType).contentType }) as u32
                                == XML_SCHEMA_CONTENT_EMPTY as i32 as u32
                            {
                                if (unsafe { (*type_0).flags }) & (1 as i32) << 0 as i32 != 0 {
                                    (unsafe { (*type_0).contentType = XML_SCHEMA_CONTENT_MIXED });
                                }
                                current_block = 5265702136860997526;
                            } else {
                                if (unsafe { (*type_0).flags }) & (1 as i32) << 0 as i32 != 0 {
                                    (unsafe { (*type_0).contentType = XML_SCHEMA_CONTENT_MIXED });
                                }
                                if !((unsafe { (*type_0).subtypes }) as xmlSchemaParticlePtr).is_null()
                                    && !(unsafe { (*((*type_0).subtypes as xmlSchemaParticlePtr)).children })
                                        .is_null()
                                    && (unsafe { (*(*((*type_0).subtypes as xmlSchemaParticlePtr)).children)
                                        .type_0 }) as u32
                                        == XML_SCHEMA_TYPE_ALL as i32 as u32
                                {
                                    xmlSchemaCustomErr (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_COS_ALL_LIMITED , xmlSchemaGetComponentNode (type_0 as xmlSchemaBasicItemPtr) , 0 as xmlSchemaBasicItemPtr , b"The type has an 'all' model group in its {content type} and thus cannot be derived from a non-empty type, since this would produce a 'sequence' model group containing the 'all' model group; 'all' model groups are not allowed to appear inside other model groups\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
                                    current_block = 5265702136860997526;
                                } else if !((unsafe { (*baseType).subtypes }) as xmlSchemaParticlePtr).is_null()
                                    && !(unsafe { (*((*baseType).subtypes as xmlSchemaParticlePtr)).children })
                                        .is_null()
                                    && (unsafe { (*(*((*baseType).subtypes as xmlSchemaParticlePtr)).children)
                                        .type_0 }) as u32
                                        == XML_SCHEMA_TYPE_ALL as i32 as u32
                                {
                                    xmlSchemaCustomErr (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_COS_ALL_LIMITED , xmlSchemaGetComponentNode (type_0 as xmlSchemaBasicItemPtr) , 0 as xmlSchemaBasicItemPtr , b"A type cannot be derived by extension from a type which has an 'all' model group in its {content type}, since this would produce a 'sequence' model group containing the 'all' model group; 'all' model groups are not allowed to appear inside other model groups\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
                                    current_block = 5265702136860997526;
                                } else if dummySequence == 0 {
                                    let mut effectiveContent : * mut crate :: src :: xmlschemas :: _xmlSchemaTreeItem = (unsafe { (* type_0) . subtypes }) as xmlSchemaTreeItemPtr ;
                                    particle = xmlSchemaAddParticle(
                                        pctxt,
                                        unsafe { (*type_0).node },
                                        1 as i32,
                                        1 as i32,
                                    );
                                    if particle.is_null() {
                                        current_block = 345336241299298347;
                                    } else {
                                        let fresh391 = unsafe { &mut ((*particle).children) };
                                        *fresh391 = xmlSchemaAddModelGroup(
                                            pctxt,
                                            unsafe { (*pctxt).schema },
                                            XML_SCHEMA_TYPE_SEQUENCE,
                                            unsafe { (*type_0).node },
                                        )
                                            as xmlSchemaTreeItemPtr;
                                        if (unsafe { (*particle).children }).is_null() {
                                            current_block = 345336241299298347;
                                        } else {
                                            let fresh392 = unsafe { &mut ((*type_0).subtypes) };
                                            *fresh392 = particle as xmlSchemaTypePtr;
                                            let fresh393 = unsafe { &mut ((*(*particle).children).children) };
                                            *fresh393 = xmlSchemaAddParticle(
                                                pctxt,
                                                unsafe { (*type_0).node },
                                                unsafe { (*((*baseType).subtypes as xmlSchemaParticlePtr))
                                                    .minOccurs },
                                                unsafe { (*((*baseType).subtypes as xmlSchemaParticlePtr))
                                                    .maxOccurs },
                                            )
                                                as xmlSchemaTreeItemPtr;
                                            if (unsafe { (*(*particle).children).children }).is_null() {
                                                current_block = 345336241299298347;
                                            } else {
                                                particle = (unsafe { (*(*particle).children).children })
                                                    as xmlSchemaParticlePtr;
                                                let fresh394 = unsafe { &mut ((*particle).children) };
                                                *fresh394 = unsafe { (*((*baseType).subtypes
                                                    as xmlSchemaParticlePtr))
                                                    .children };
                                                let fresh395 = unsafe { &mut ((*particle).next) };
                                                *fresh395 = effectiveContent;
                                                current_block = 5265702136860997526;
                                            }
                                        }
                                    }
                                } else {
                                    let fresh396 = unsafe { &mut ((*(*particle).children).children) };
                                    *fresh396 = (unsafe { (*baseType).subtypes }) as xmlSchemaTreeItemPtr;
                                    current_block = 5265702136860997526;
                                }
                            }
                        },
                    }
                }
                match current_block {
                    345336241299298347 => {},
                    6926858937233525393 => {},
                    _ => {
                        res = xmlSchemaFixupTypeAttributeUses(pctxt, type_0);
                        if res == -(1 as i32) {
                            current_block = 345336241299298347;
                        } else if res != 0 as i32 {
                            current_block = 6926858937233525393;
                        } else {
                            res = xmlSchemaCheckCTComponent(pctxt, type_0);
                            if res == -(1 as i32) {
                                current_block = 345336241299298347;
                            } else if res != 0 as i32 {
                                current_block = 6926858937233525393;
                            } else if olderrs != (unsafe { (*pctxt).nberrors }) {
                                return unsafe { (*pctxt).err };
                            } else {
                                return 0 as i32;
                            }
                        }
                    },
                }
            }
            match current_block {
                345336241299298347 => {},
                _ => {
                    (unsafe { (*type_0).flags |= (1 as i32) << 23 as i32 });
                    return unsafe { (*pctxt).err };
                },
            }
        }
    }
    (unsafe { (*type_0).flags |= (1 as i32) << 23 as i32 });
    return -(1 as i32);
}
extern "C" fn xmlSchemaTypeFixup<'a1, 'a2>(
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a1>,
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a2>,
) -> i32
where
    'a1: 'static,
{
    if type_0.is_null() {
        return 0 as i32;
    }
    if (unsafe { (*actxt).type_0 }) != 1 as i32 {
        xmlSchemaInternalErr(
            actxt,
            b"xmlSchemaTypeFixup\0" as *const u8 as *const i8,
            b"this function needs a parser context\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    if !((unsafe { (*type_0).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (unsafe { (*type_0).flags }) & (1 as i32) << 22 as i32 == 0 as i32)
    {
        return 0 as i32;
    }
    if (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32 {
        return xmlSchemaFixupComplexType(actxt as xmlSchemaParserCtxtPtr, type_0);
    } else {
        if (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_SIMPLE as i32 as u32 {
            return xmlSchemaFixupSimpleTypeStageTwo(actxt as xmlSchemaParserCtxtPtr, type_0);
        }
    }
    return 0 as i32;
}
#[no_mangle]
pub extern "C" fn xmlSchemaCheckFacet<'a1, 'a2, 'a3>(
    mut facet: *mut crate::src::xmlschemas::_xmlSchemaFacet<'a1>,
    mut typeDecl: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a3>,
    mut _name: *const u8,
) -> i32
where
    'a2: 'static,
{
    let mut current_block: u64;
    let mut ret: i32 = 0 as i32;
    let mut ctxtGiven: i32 = 0;
    if facet.is_null() || typeDecl.is_null() {
        return -(1 as i32);
    }
    if pctxt.is_null() {
        ctxtGiven = 0 as i32;
    } else {
        ctxtGiven = 1 as i32;
    }
    match (unsafe { (*facet).type_0 }) as u32 {
        1000 | 1001 | 1002 | 1003 | 1007 => {
            let mut base: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
            if (unsafe { (*typeDecl).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32 {
                base = unsafe { (*typeDecl).baseType };
                if base.is_null() {
                    xmlSchemaInternalErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaCheckFacet\0" as *const u8 as *const i8,
                        b"a type user derived type has no base type\0" as *const u8 as *const i8,
                    );
                    return -(1 as i32);
                }
            } else {
                base = typeDecl;
            }
            if ctxtGiven == 0 {
                pctxt = xmlSchemaNewParserCtxt(b"*\0" as *const u8 as *const i8);
                if pctxt.is_null() {
                    return -(1 as i32);
                }
            }
            ret = xmlSchemaVCheckCVCSimpleType(
                pctxt as xmlSchemaAbstractCtxtPtr,
                unsafe { (*facet).node },
                base,
                unsafe { (*facet).value },
                Some(unsafe { &mut (*facet).val }),
                1 as i32,
                1 as i32,
                0 as i32,
            );
            if ret != 0 as i32 {
                if ret < 0 as i32 {
                    if ctxtGiven != 0 {
                        xmlSchemaCustomErr (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_INTERNAL , unsafe { (* facet) . node } , 0 as xmlSchemaBasicItemPtr , b"Internal error: xmlSchemaCheckFacet, failed to validate the value '%s' of the facet '%s' against the base type\0" as * const u8 as * const i8 , unsafe { (* facet) . value } , xmlSchemaFacetTypeToString (unsafe { (* facet) . type_0 }) ,) ;
                    }
                    current_block = 5348683486121694512;
                } else {
                    ret = XML_SCHEMAP_INVALID_FACET_VALUE as i32;
                    if ctxtGiven != 0 {
                        let mut str: *mut u8 = 0 as *mut xmlChar;
                        xmlSchemaCustomErr (pctxt as xmlSchemaAbstractCtxtPtr , ret as xmlParserErrors , unsafe { (* facet) . node } , facet as xmlSchemaBasicItemPtr , b"The value '%s' of the facet does not validate against the base type '%s'\0" as * const u8 as * const i8 , unsafe { (* facet) . value } , xmlSchemaFormatQName (Some (& mut str) , unsafe { (* base) . targetNamespace } , unsafe { (* base) . name } ,) ,) ;
                        if !str.is_null() {
                            (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                            str = 0 as *mut xmlChar;
                        }
                    }
                    current_block = 15604527402135937264;
                }
            } else {
                if (unsafe { (*facet).val }).is_null() {
                    if ctxtGiven != 0 {
                        xmlSchemaInternalErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaCheckFacet\0" as *const u8 as *const i8,
                            b"value was not computed\0" as *const u8 as *const i8,
                        );
                    }
                    (unsafe { (*__xmlGenericError()).expect("non-null function pointer")(
                        *__xmlGenericErrorContext(),
                        b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
                        b"xmlschemas.c\0" as *const u8 as *const i8,
                        18869 as i32,
                    ) });
                }
                current_block = 15604527402135937264;
            }
        },
        1006 => {
            let fresh397 = unsafe { &mut ((*facet).regexp) };
            *fresh397 = xmlRegexpCompile(unsafe { (*facet).value });
            if (unsafe { (*facet).regexp }).is_null() {
                ret = XML_SCHEMAP_REGEXP_INVALID as i32;
                if ctxtGiven != 0 {
                    xmlSchemaCustomErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        ret as xmlParserErrors,
                        unsafe { (*facet).node },
                        typeDecl as xmlSchemaBasicItemPtr,
                        b"The value '%s' of the facet 'pattern' is not a valid regular expression\0"
                            as *const u8 as *const i8,
                        unsafe { (*facet).value },
                        0 as *const xmlChar,
                    );
                }
            }
            current_block = 15604527402135937264;
        },
        1004 | 1005 | 1009 | 1010 | 1011 => {
            if (unsafe { (*facet).type_0 }) as u32 == XML_SCHEMA_FACET_TOTALDIGITS as i32 as u32 {
                ret = xmlSchemaValidatePredefinedType(
                    xmlSchemaGetBuiltInType(XML_SCHEMAS_PINTEGER),
                    unsafe { (*facet).value },
                    Some(unsafe { &mut (*facet).val }),
                );
            } else {
                ret = xmlSchemaValidatePredefinedType(
                    xmlSchemaGetBuiltInType(XML_SCHEMAS_NNINTEGER),
                    unsafe { (*facet).value },
                    Some(unsafe { &mut (*facet).val }),
                );
            }
            if ret != 0 as i32 {
                if ret < 0 as i32 {
                    if ctxtGiven != 0 {
                        xmlSchemaInternalErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaCheckFacet\0" as *const u8 as *const i8,
                            b"validating facet value\0" as *const u8 as *const i8,
                        );
                    }
                    current_block = 5348683486121694512;
                } else {
                    ret = XML_SCHEMAP_INVALID_FACET_VALUE as i32;
                    if ctxtGiven != 0 {
                        xmlSchemaCustomErr4(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            ret as xmlParserErrors,
                            unsafe { (*facet).node },
                            typeDecl as xmlSchemaBasicItemPtr,
                            b"The value '%s' of the facet '%s' is not a valid '%s'\0" as *const u8
                                as *const i8,
                            unsafe { (*facet).value },
                            xmlSchemaFacetTypeToString(unsafe { (*facet).type_0 }),
                            if (unsafe { (*facet).type_0 }) as u32 != XML_SCHEMA_FACET_TOTALDIGITS as i32 as u32
                            {
                                b"nonNegativeInteger\0" as *const u8 as *const i8 as *mut xmlChar
                            } else {
                                b"positiveInteger\0" as *const u8 as *const i8 as *mut xmlChar
                            },
                            0 as *const xmlChar,
                        );
                    }
                    current_block = 15604527402135937264;
                }
            } else {
                current_block = 15604527402135937264;
            }
        },
        1008 => {
            if xmlStrEqual(
                unsafe { (*facet).value },
                b"preserve\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
                (unsafe { (*facet).whitespace = 1 as i32 });
            } else if xmlStrEqual(
                unsafe { (*facet).value },
                b"replace\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
                (unsafe { (*facet).whitespace = 2 as i32 });
            } else if xmlStrEqual(
                unsafe { (*facet).value },
                b"collapse\0" as *const u8 as *const i8 as *mut xmlChar,
            ) != 0
            {
                (unsafe { (*facet).whitespace = 3 as i32 });
            } else {
                ret = XML_SCHEMAP_INVALID_FACET_VALUE as i32;
                if ctxtGiven != 0 {
                    xmlSchemaCustomErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        ret as xmlParserErrors,
                        unsafe { (*facet).node },
                        typeDecl as xmlSchemaBasicItemPtr,
                        b"The value '%s' of the facet 'whitespace' is not valid\0" as *const u8
                            as *const i8,
                        unsafe { (*facet).value },
                        0 as *const xmlChar,
                    );
                }
            }
            current_block = 15604527402135937264;
        },
        _ => {
            current_block = 15604527402135937264;
        },
    }
    match current_block {
        5348683486121694512 => {
            if ctxtGiven == 0 && !pctxt.is_null() {
                xmlSchemaFreeParserCtxt(pctxt);
            }
            return -(1 as i32);
        },
        _ => {
            if ctxtGiven == 0 && !pctxt.is_null() {
                xmlSchemaFreeParserCtxt(pctxt);
            }
            return ret;
        },
    };
}
extern "C" fn xmlSchemaCheckFacetValues<'a1, 'a2>(
    mut typeDecl: *mut crate::src::xmlschemas::_xmlSchemaType<'a1>,
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a2>,
) -> i32
where
    'a1: 'static,
{
    let mut current_block: u64;
    let mut res: i32 = 0;
    let mut olderrs: i32 = unsafe { (*pctxt).nberrors };
    let mut name: *const u8 = unsafe { (*typeDecl).name };
    if !(unsafe { (*typeDecl).facets }).is_null() {
        let mut facet: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = unsafe { (*typeDecl).facets };
        if (unsafe { (*pctxt).vctxt }).is_null() {
            if xmlSchemaCreateVCtxtOnPCtxt(pctxt) == -(1 as i32) {
                return -(1 as i32);
            }
        }
        let fresh398 = unsafe { &mut ((*(*pctxt).vctxt).schema) };
        *fresh398 = unsafe { (*pctxt).schema };
        loop {
            if facet.is_null() {
                current_block = 7746791466490516765;
                break;
            }
            res = xmlSchemaCheckFacet(facet, typeDecl, pctxt, name);
            if res == -(1 as i32) {
                current_block = 966742325134978464;
                break;
            }
            facet = unsafe { (*facet).next };
        }
        match current_block {
            966742325134978464 => return -(1 as i32),
            _ => {
                let fresh399 = unsafe { &mut ((*(*pctxt).vctxt).schema) };
                *fresh399 = 0 as xmlSchemaPtr;
            },
        }
    }
    if olderrs != (unsafe { (*pctxt).nberrors }) {
        return unsafe { (*pctxt).err };
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaGetCircModelGrDefRef<'a1>(
    mut groupDef: *mut crate::src::xmlschemas::_xmlSchemaModelGroupDef<'a1>,
    mut particle: *mut crate::src::xmlschemas::_xmlSchemaTreeItem,
) -> *mut crate::src::xmlschemas::_xmlSchemaTreeItem {
    let mut circ: *mut crate::src::xmlschemas::_xmlSchemaTreeItem = 0 as xmlSchemaTreeItemPtr;
    let mut term: *mut crate::src::xmlschemas::_xmlSchemaTreeItem = 0 as *mut xmlSchemaTreeItem;
    let mut gdef: *mut crate::src::xmlschemas::_xmlSchemaModelGroupDef<'_> =
        0 as *mut xmlSchemaModelGroupDef;
    let mut current_block_13: u64;
    while !particle.is_null() {
        term = unsafe { (*particle).children };
        if !term.is_null() {
            match (unsafe { (*term).type_0 }) as u32 {
                17 => {
                    current_block_13 = 17757133326439237465;
                    match current_block_13 {
                        7522209452724882128 => {
                            circ = xmlSchemaGetCircModelGrDefRef(groupDef, unsafe { (*term).children });
                            if !circ.is_null() {
                                return circ;
                            }
                        },
                        _ => {
                            gdef = term as xmlSchemaModelGroupDefPtr;
                            if gdef == groupDef {
                                return particle;
                            }
                            if !((unsafe { (*gdef).flags }) & (1 as i32) << 0 as i32 != 0) {
                                if !(unsafe { (*gdef).children }).is_null() {
                                    (unsafe { (*gdef).flags |= (1 as i32) << 0 as i32 });
                                    circ = xmlSchemaGetCircModelGrDefRef(
                                        groupDef,
                                        unsafe { (*(*gdef).children).children },
                                    );
                                    (unsafe { (*gdef).flags ^= (1 as i32) << 0 as i32 });
                                    if !circ.is_null() {
                                        return circ;
                                    }
                                }
                            }
                        },
                    }
                },
                6 | 7 | 8 => {
                    current_block_13 = 7522209452724882128;
                    match current_block_13 {
                        7522209452724882128 => {
                            circ = xmlSchemaGetCircModelGrDefRef(groupDef, unsafe { (*term).children });
                            if !circ.is_null() {
                                return circ;
                            }
                        },
                        _ => {
                            gdef = term as xmlSchemaModelGroupDefPtr;
                            if gdef == groupDef {
                                return particle;
                            }
                            if !((unsafe { (*gdef).flags }) & (1 as i32) << 0 as i32 != 0) {
                                if !(unsafe { (*gdef).children }).is_null() {
                                    (unsafe { (*gdef).flags |= (1 as i32) << 0 as i32 });
                                    circ = xmlSchemaGetCircModelGrDefRef(
                                        groupDef,
                                        unsafe { (*(*gdef).children).children },
                                    );
                                    (unsafe { (*gdef).flags ^= (1 as i32) << 0 as i32 });
                                    if !circ.is_null() {
                                        return circ;
                                    }
                                }
                            }
                        },
                    }
                },
                _ => {},
            }
        }
        particle = unsafe { (*particle).next };
    }
    return 0 as xmlSchemaTreeItemPtr;
}
extern "C" fn xmlSchemaCheckGroupDefCircular<'a1, 'a2>(
    mut item: *mut crate::src::xmlschemas::_xmlSchemaModelGroupDef<'a1>,
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a2>,
) {
    if item.is_null()
        || (unsafe { (*item).type_0 }) as u32 != XML_SCHEMA_TYPE_GROUP as i32 as u32
        || (unsafe { (*item).children }).is_null()
    {
        return;
    }
    let mut circ: *mut crate::src::xmlschemas::_xmlSchemaTreeItem = 0 as *mut xmlSchemaTreeItem;
    circ = xmlSchemaGetCircModelGrDefRef(item, unsafe { (*(*item).children).children });
    if !circ.is_null() {
        let mut str: *mut u8 = 0 as *mut xmlChar;
        xmlSchemaPCustomErr(
            ctxt,
            XML_SCHEMAP_MG_PROPS_CORRECT_2,
            0 as xmlSchemaBasicItemPtr,
            xmlSchemaGetComponentNode(circ as xmlSchemaBasicItemPtr),
            b"Circular reference to the model group definition '%s' defined\0" as *const u8
                as *const i8,
            xmlSchemaFormatQName(Some(&mut str), unsafe { (*item).targetNamespace }, unsafe { (*item).name }),
        );
        if !str.is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
            str = 0 as *mut xmlChar;
        }
        let fresh400 = unsafe { &mut ((*circ).children) };
        *fresh400 = 0 as xmlSchemaTreeItemPtr;
    }
}
extern "C" fn xmlSchemaModelGroupToModelGroupDefFixup<'a1, 'a2>(
    mut _ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut mg: *mut crate::src::xmlschemas::_xmlSchemaModelGroup<'a2>,
) {
    let mut particle: *mut crate::src::xmlschemas::_xmlSchemaParticle =
        (unsafe { (*mg).children }) as xmlSchemaParticlePtr;
    while !particle.is_null() {
        if (unsafe { (*particle).children }).is_null()
            || (unsafe { (*(*particle).children).type_0 }) as u32 != XML_SCHEMA_TYPE_GROUP as i32 as u32
        {
            particle = (unsafe { (*particle).next }) as xmlSchemaParticlePtr;
        } else if (unsafe { (*((*particle).children as xmlSchemaModelGroupPtr)).children }).is_null() {
            let fresh401 = unsafe { &mut ((*particle).children) };
            *fresh401 = 0 as xmlSchemaTreeItemPtr;
            particle = (unsafe { (*particle).next }) as xmlSchemaParticlePtr;
        } else {
            let fresh402 = unsafe { &mut ((*particle).children) };
            *fresh402 = unsafe { (*((*particle).children as xmlSchemaModelGroupPtr)).children };
            particle = (unsafe { (*particle).next }) as xmlSchemaParticlePtr;
        }
    }
}
extern "C" fn xmlSchemaCheckAttrGroupCircularRecur<'a1, 'a2>(
    mut ctxtGr: *mut crate::src::xmlschemas::_xmlSchemaAttributeGroup<'a1>,
    mut list: *mut crate::src::xmlschemas::_xmlSchemaItemList,
) -> *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'a2> {
    let mut gr: *mut crate::src::xmlschemas::_xmlSchemaAttributeGroup<'_> =
        0 as *mut xmlSchemaAttributeGroup;
    let mut ref_0: *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'_> =
        0 as *mut xmlSchemaQNameRef;
    let mut circ: *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'_> = 0 as *mut xmlSchemaQNameRef;
    let mut i: i32 = 0;
    i = 0 as i32;
    while i < (unsafe { (*list).nbItems }) {
        ref_0 = (unsafe { *((*list).items).offset(i as isize) }) as xmlSchemaQNameRefPtr;
        if (unsafe { (*ref_0).type_0 }) as u32 == XML_SCHEMA_EXTRA_QNAMEREF as i32 as u32
            && (unsafe { (*ref_0).itemType }) as u32 == XML_SCHEMA_TYPE_ATTRIBUTEGROUP as i32 as u32
            && !(unsafe { (*ref_0).item }).is_null()
        {
            gr = (unsafe { (*ref_0).item }) as xmlSchemaAttributeGroupPtr;
            if gr == ctxtGr {
                return ref_0;
            }
            if !((unsafe { (*gr).flags }) & (1 as i32) << 2 as i32 != 0) {
                if !(unsafe { (*gr).attrUses }).is_null() && (unsafe { (*gr).flags }) & (1 as i32) << 4 as i32 != 0 {
                    (unsafe { (*gr).flags |= (1 as i32) << 2 as i32 });
                    circ = xmlSchemaCheckAttrGroupCircularRecur(
                        ctxtGr,
                        (unsafe { (*gr).attrUses }) as xmlSchemaItemListPtr,
                    );
                    (unsafe { (*gr).flags ^= (1 as i32) << 2 as i32 });
                    if !circ.is_null() {
                        return circ;
                    }
                }
            }
        }
        i += 1;
    }
    return 0 as xmlSchemaQNameRefPtr;
}
extern "C" fn xmlSchemaCheckAttrGroupCircular<'a1, 'a2>(
    mut attrGr: *mut crate::src::xmlschemas::_xmlSchemaAttributeGroup<'a1>,
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a2>,
) -> i32 {
    if (unsafe { (*attrGr).attrUses }).is_null() {
        return 0 as i32;
    } else {
        if (unsafe { (*attrGr).flags }) & (1 as i32) << 4 as i32 == 0 as i32 {
            return 0 as i32;
        } else {
            let mut circ: *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'_> =
                0 as *mut xmlSchemaQNameRef;
            circ = xmlSchemaCheckAttrGroupCircularRecur(
                attrGr,
                (unsafe { (*attrGr).attrUses }) as xmlSchemaItemListPtr,
            );
            if !circ.is_null() {
                let mut str: *mut u8 = 0 as *mut xmlChar;
                xmlSchemaPCustomErr(
                    ctxt,
                    XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3,
                    0 as xmlSchemaBasicItemPtr,
                    xmlSchemaGetComponentNode(circ as xmlSchemaBasicItemPtr),
                    b"Circular reference to the attribute group '%s' defined\0" as *const u8
                        as *const i8,
                    xmlSchemaGetComponentQName(Some(&mut str), attrGr as *mut libc::c_void),
                );
                if !str.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                    str = 0 as *mut xmlChar;
                }
                let fresh403 = unsafe { &mut ((*circ).item) };
                *fresh403 = 0 as xmlSchemaBasicItemPtr;
                return unsafe { (*ctxt).err };
            }
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaExpandAttributeGroupRefs<'a1, 'a2, 'a3, 'a4>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut item: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'a2>,
    mut completeWild: Option<&'a3 mut *mut crate::src::xmlschemas::_xmlSchemaWildcard<'a4>>,
    mut list: *mut crate::src::xmlschemas::_xmlSchemaItemList,
    mut prohibs: *mut crate::src::xmlschemas::_xmlSchemaItemList,
) -> i32 {
    let mut gr: *mut crate::src::xmlschemas::_xmlSchemaAttributeGroup<'_> =
        0 as *mut xmlSchemaAttributeGroup;
    let mut use_0: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_> =
        0 as *mut xmlSchemaAttributeUse;
    let mut sublist: *mut crate::src::xmlschemas::_xmlSchemaItemList =
        0 as *mut crate::src::xmlschemas::_xmlSchemaItemList;
    let mut i: i32 = 0;
    let mut j: i32 = 0;
    let mut created: i32 = if (*(borrow_mut(&mut completeWild)).unwrap()).is_null() {
        0 as i32
    } else {
        1 as i32
    };
    if !prohibs.is_null() {
        (unsafe { (*prohibs).nbItems = 0 as i32 });
    }
    i = 0 as i32;
    while i < (unsafe { (*list).nbItems }) {
        use_0 = (unsafe { *((*list).items).offset(i as isize) }) as xmlSchemaAttributeUsePtr;
        if (unsafe { (*use_0).type_0 }) as u32 == XML_SCHEMA_EXTRA_ATTR_USE_PROHIB as i32 as u32 {
            if prohibs.is_null() {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaExpandAttributeGroupRefs\0" as *const u8 as *const i8,
                    b"unexpected attr prohibition found\0" as *const u8 as *const i8,
                );
                return -(1 as i32);
            }
            if xmlSchemaItemListRemove(list, i) == -(1 as i32) {
                return -(1 as i32);
            }
            i -= 1;
            xmlSchemaItemListAddSize(prohibs, 2 as i32, use_0 as *mut libc::c_void);
        } else if (unsafe { (*use_0).type_0 }) as u32 == XML_SCHEMA_EXTRA_QNAMEREF as i32 as u32
            && (unsafe { (*(use_0 as xmlSchemaQNameRefPtr)).itemType }) as u32
                == XML_SCHEMA_TYPE_ATTRIBUTEGROUP as i32 as u32
        {
            if (unsafe { (*(use_0 as xmlSchemaQNameRefPtr)).item }).is_null() {
                return -(1 as i32);
            }
            gr = (unsafe { (*(use_0 as xmlSchemaQNameRefPtr)).item }) as xmlSchemaAttributeGroupPtr;
            if (unsafe { (*gr).flags }) & (1 as i32) << 0 as i32 == 0 as i32 {
                if xmlSchemaAttributeGroupExpandRefs(pctxt, gr) == -(1 as i32) {
                    return -(1 as i32);
                }
            }
            if !(unsafe { (*gr).attributeWildcard }).is_null() {
                if (*(borrow(&completeWild)).unwrap()).is_null() {
                    *(borrow_mut(&mut completeWild)).unwrap() = unsafe { (*gr).attributeWildcard };
                } else {
                    if created == 0 {
                        let mut tmpWild: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'_> =
                            0 as *mut xmlSchemaWildcard;
                        tmpWild = xmlSchemaAddWildcard(
                            pctxt,
                            unsafe { (*pctxt).schema },
                            XML_SCHEMA_TYPE_ANY_ATTRIBUTE,
                            xmlSchemaGetComponentNode(item),
                        );
                        if tmpWild.is_null() {
                            return -(1 as i32);
                        }
                        if xmlSchemaCloneWildcardNsConstraints(
                            pctxt,
                            tmpWild,
                            *(borrow_mut(&mut completeWild)).unwrap(),
                        ) == -(1 as i32)
                        {
                            return -(1 as i32);
                        }
                        (unsafe { (*tmpWild).processContents =
                            (**(borrow_mut(&mut completeWild)).unwrap()).processContents });
                        *(borrow_mut(&mut completeWild)).unwrap() = tmpWild;
                        created = 1 as i32;
                    }
                    if xmlSchemaIntersectWildcards(
                        pctxt,
                        *(borrow_mut(&mut completeWild)).unwrap(),
                        unsafe { (*gr).attributeWildcard },
                    ) == -(1 as i32)
                    {
                        return -(1 as i32);
                    }
                }
            }
            sublist = (unsafe { (*gr).attrUses }) as xmlSchemaItemListPtr;
            if sublist.is_null() || (unsafe { (*sublist).nbItems }) == 0 as i32 {
                if xmlSchemaItemListRemove(list, i) == -(1 as i32) {
                    return -(1 as i32);
                }
                i -= 1;
            } else {
                let fresh404 = unsafe { &mut (*((*list).items).offset(i as isize)) };
                *fresh404 = unsafe { *((*sublist).items).offset(0 as i32 as isize) };
                if (unsafe { (*sublist).nbItems }) != 1 as i32 {
                    j = 1 as i32;
                    while j < (unsafe { (*sublist).nbItems }) {
                        i += 1;
                        if xmlSchemaItemListInsert(list, unsafe { *((*sublist).items).offset(j as isize) }, i)
                            == -(1 as i32)
                        {
                            return -(1 as i32);
                        }
                        j += 1;
                    }
                }
            }
        }
        i += 1;
    }
    if !prohibs.is_null() && (unsafe { (*prohibs).nbItems }) != 0 as i32 && (unsafe { (*list).nbItems }) != 0 as i32 {
        let mut prohib: *mut crate::src::xmlschemas::_xmlSchemaAttributeUseProhib =
            0 as *mut crate::src::xmlschemas::_xmlSchemaAttributeUseProhib;
        i = (unsafe { (*prohibs).nbItems }) - 1 as i32;
        while i >= 0 as i32 {
            prohib = (unsafe { *((*prohibs).items).offset(i as isize) }) as xmlSchemaAttributeUseProhibPtr;
            j = 0 as i32;
            while j < (unsafe { (*list).nbItems }) {
                use_0 = (unsafe { *((*list).items).offset(j as isize) }) as xmlSchemaAttributeUsePtr;
                if (unsafe { (*prohib).name }) == (unsafe { (*(*use_0).attrDecl).name })
                    && (unsafe { (*prohib).targetNamespace }) == (unsafe { (*(*use_0).attrDecl).targetNamespace })
                {
                    let mut str: *mut u8 = 0 as *mut xmlChar;
                    xmlSchemaCustomWarning (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH , unsafe { (* prohib) . node } , Option :: < & '_ mut crate :: src :: xmlschemas :: _xmlSchemaType < '_ > > :: None , b"Skipping pointless attribute use prohibition '%s', since a corresponding attribute use exists already in the type definition\0" as * const u8 as * const i8 , xmlSchemaFormatQName (Some (& mut str) , unsafe { (* prohib) . targetNamespace } , unsafe { (* prohib) . name } ,) , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
                    if !str.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                        str = 0 as *mut xmlChar;
                    }
                    if xmlSchemaItemListRemove(prohibs, i) == -(1 as i32) {
                        return -(1 as i32);
                    }
                    break;
                } else {
                    j += 1;
                }
            }
            i -= 1;
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaAttributeGroupExpandRefs<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut attrGr: *mut crate::src::xmlschemas::_xmlSchemaAttributeGroup<'a2>,
) -> i32 {
    if (unsafe { (*attrGr).attrUses }).is_null() || (unsafe { (*attrGr).flags }) & (1 as i32) << 0 as i32 != 0 {
        return 0 as i32;
    }
    (unsafe { (*attrGr).flags |= (1 as i32) << 0 as i32 });
    if xmlSchemaExpandAttributeGroupRefs(
        pctxt,
        attrGr as xmlSchemaBasicItemPtr,
        Some(unsafe { &mut (*attrGr).attributeWildcard }),
        (unsafe { (*attrGr).attrUses }) as xmlSchemaItemListPtr,
        0 as xmlSchemaItemListPtr,
    ) == -(1 as i32)
    {
        return -(1 as i32);
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaCheckAGPropsCorrect<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut attrGr: *mut crate::src::xmlschemas::_xmlSchemaAttributeGroup<'a2>,
) -> i32 {
    if !(unsafe { (*attrGr).attrUses }).is_null()
        && (unsafe { (*((*attrGr).attrUses as xmlSchemaItemListPtr)).nbItems }) > 1 as i32
    {
        let mut uses: *mut crate::src::xmlschemas::_xmlSchemaItemList =
            (unsafe { (*attrGr).attrUses }) as xmlSchemaItemListPtr;
        let mut use_0: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_> =
            0 as *mut xmlSchemaAttributeUse;
        let mut tmp: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_> =
            0 as *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_>;
        let mut i: i32 = 0;
        let mut j: i32 = 0;
        let mut hasId: i32 = 0 as i32;
        i = (unsafe { (*uses).nbItems }) - 1 as i32;
        while i >= 0 as i32 {
            let mut current_block_27: u64;
            use_0 = (unsafe { *((*uses).items).offset(i as isize) }) as xmlSchemaAttributeUsePtr;
            if i > 0 as i32 {
                j = i - 1 as i32;
                loop {
                    if !(j >= 0 as i32) {
                        current_block_27 = 12124785117276362961;
                        break;
                    }
                    tmp = (unsafe { *((*uses).items).offset(j as isize) }) as xmlSchemaAttributeUsePtr;
                    if (unsafe { (*(*use_0).attrDecl).name }) == (unsafe { (*(*tmp).attrDecl).name })
                        && (unsafe { (*(*use_0).attrDecl).targetNamespace })
                            == (unsafe { (*(*tmp).attrDecl).targetNamespace })
                    {
                        let mut str: *mut u8 = 0 as *mut xmlChar;
                        xmlSchemaCustomErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            XML_SCHEMAP_AG_PROPS_CORRECT,
                            unsafe { (*attrGr).node },
                            attrGr as xmlSchemaBasicItemPtr,
                            b"Duplicate %s\0" as *const u8 as *const i8,
                            xmlSchemaGetComponentDesignation(
                                Some(&mut str),
                                use_0 as *mut libc::c_void,
                            ),
                            0 as *const xmlChar,
                        );
                        if !str.is_null() {
                            (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                            str = 0 as *mut xmlChar;
                        }
                        if xmlSchemaItemListRemove(uses, i) == -(1 as i32) {
                            return -(1 as i32);
                        }
                        current_block_27 = 7245201122033322888;
                        break;
                    } else {
                        j -= 1;
                    }
                }
            } else {
                current_block_27 = 12124785117276362961;
            }
            match current_block_27 {
                12124785117276362961 => {
                    if !(unsafe { (*(*use_0).attrDecl).subtypes }).is_null() {
                        if xmlSchemaIsDerivedFromBuiltInType(
                            unsafe { (*(*use_0).attrDecl).subtypes },
                            XML_SCHEMAS_ID as i32,
                        ) != 0
                        {
                            if hasId != 0 {
                                let mut str_0: *mut u8 = 0 as *mut xmlChar;
                                xmlSchemaCustomErr (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_AG_PROPS_CORRECT , unsafe { (* attrGr) . node } , attrGr as xmlSchemaBasicItemPtr , b"There must not exist more than one attribute declaration of type 'xs:ID' (or derived from 'xs:ID'). The %s violates this constraint\0" as * const u8 as * const i8 , xmlSchemaGetComponentDesignation (Some (& mut str_0) , use_0 as * mut libc :: c_void ,) , 0 as * const xmlChar ,) ;
                                if !str_0.is_null() {
                                    (unsafe { xmlFree.expect("non-null function pointer")(
                                        str_0 as *mut libc::c_void,
                                    ) });
                                    str_0 = 0 as *mut xmlChar;
                                }
                                if xmlSchemaItemListRemove(uses, i) == -(1 as i32) {
                                    return -(1 as i32);
                                }
                            }
                            hasId = 1 as i32;
                        }
                    }
                },
                _ => {},
            }
            i -= 1;
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaResolveAttrGroupReferences<'a1, 'a2>(
    mut ref_0: *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'a1>,
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a2>,
) -> i32 {
    let mut group: *mut crate::src::xmlschemas::_xmlSchemaAttributeGroup<'_> =
        0 as *mut xmlSchemaAttributeGroup;
    if !(unsafe { (*ref_0).item }).is_null() {
        return 0 as i32;
    }
    group = xmlSchemaGetAttributeGroup(unsafe { (*ctxt).schema }, unsafe { (*ref_0).name }, unsafe { (*ref_0).targetNamespace });
    if group.is_null() {
        xmlSchemaPResCompAttrErr(
            ctxt,
            XML_SCHEMAP_SRC_RESOLVE,
            0 as xmlSchemaBasicItemPtr,
            unsafe { (*ref_0).node },
            b"ref\0" as *const u8 as *const i8,
            unsafe { (*ref_0).name },
            unsafe { (*ref_0).targetNamespace },
            unsafe { (*ref_0).itemType },
            0 as *const i8,
        );
        return unsafe { (*ctxt).err };
    }
    let fresh405 = unsafe { &mut ((*ref_0).item) };
    *fresh405 = group as xmlSchemaBasicItemPtr;
    return 0 as i32;
}
extern "C" fn xmlSchemaCheckAttrPropsCorrect<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut attr: *mut crate::src::xmlschemas::_xmlSchemaAttribute<'a2>,
) -> i32
where
    'a2: 'static,
{
    if (unsafe { (*attr).subtypes }).is_null() {
        return 0 as i32;
    }
    if !(unsafe { (*attr).defValue }).is_null() {
        let mut ret: i32 = 0;
        if xmlSchemaIsDerivedFromBuiltInType(unsafe { (*attr).subtypes }, XML_SCHEMAS_ID as i32) != 0 {
            xmlSchemaCustomErr (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_A_PROPS_CORRECT_3 , 0 as xmlNodePtr , attr as xmlSchemaBasicItemPtr , b"Value constraints are not allowed if the type definition is or is derived from xs:ID\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
            return unsafe { (*pctxt).err };
        }
        ret = xmlSchemaVCheckCVCSimpleType(
            pctxt as xmlSchemaAbstractCtxtPtr,
            unsafe { (*attr).node },
            unsafe { (*attr).subtypes },
            unsafe { (*attr).defValue },
            Some(unsafe { &mut (*attr).defVal }),
            1 as i32,
            1 as i32,
            0 as i32,
        );
        if ret != 0 as i32 {
            if ret < 0 as i32 {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaCheckAttrPropsCorrect\0" as *const u8 as *const i8,
                    b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8 as *const i8,
                );
                return -(1 as i32);
            }
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_A_PROPS_CORRECT_2,
                0 as xmlNodePtr,
                attr as xmlSchemaBasicItemPtr,
                b"The value of the value constraint is not valid\0" as *const u8 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return unsafe { (*pctxt).err };
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaCheckSubstGroupCircular<'a1, 'a2, 'a3>(
    mut elemDecl: *mut crate::src::xmlschemas::_xmlSchemaElement<'a1>,
    mut ancestor: *mut crate::src::xmlschemas::_xmlSchemaElement<'a2>,
) -> *mut crate::src::xmlschemas::_xmlSchemaElement<'a3>
where
    'a1: 'a2,
    'a3: 'a2,
    'a2: 'a3,
    'a2: 'a1,
{
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> = 0 as *mut xmlSchemaElement;
    if (unsafe { (*ancestor).refDecl }).is_null() {
        return 0 as xmlSchemaElementPtr;
    }
    if (unsafe { (*ancestor).refDecl }) == elemDecl {
        return ancestor;
    }
    if (unsafe { (*(*ancestor).refDecl).flags }) & (1 as i32) << 9 as i32 != 0 {
        return 0 as xmlSchemaElementPtr;
    }
    (unsafe { (*(*ancestor).refDecl).flags |= (1 as i32) << 9 as i32 });
    ret = xmlSchemaCheckSubstGroupCircular(elemDecl, unsafe { (*ancestor).refDecl });
    (unsafe { (*(*ancestor).refDecl).flags ^= (1 as i32) << 9 as i32 });
    return ret;
}
extern "C" fn xmlSchemaCheckElemPropsCorrect<'a1, 'a2>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut elemDecl: *mut crate::src::xmlschemas::_xmlSchemaElement<'a2>,
) -> i32
where
    'a2: 'static,
{
    let mut ret: i32 = 0 as i32;
    let mut typeDef: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = unsafe { (*elemDecl).subtypes };
    if !(unsafe { (*elemDecl).refDecl }).is_null() {
        let mut head: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> = unsafe { (*elemDecl).refDecl };
        let mut circ: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> =
            0 as *mut xmlSchemaElement;
        xmlSchemaCheckElementDeclComponent(head, pctxt);
        if (unsafe { (*elemDecl).flags }) & (1 as i32) << 1 as i32 == 0 as i32 {
            xmlSchemaPCustomErr(
                pctxt,
                XML_SCHEMAP_E_PROPS_CORRECT_3,
                elemDecl as xmlSchemaBasicItemPtr,
                0 as xmlNodePtr,
                b"Only global element declarations can have a substitution group affiliation\0"
                    as *const u8 as *const i8,
                0 as *const xmlChar,
            );
            ret = XML_SCHEMAP_E_PROPS_CORRECT_3 as i32;
        }
        if head == elemDecl {
            circ = head;
        } else if !(unsafe { (*head).refDecl }).is_null() {
            circ = xmlSchemaCheckSubstGroupCircular(head, head);
        } else {
            circ = 0 as xmlSchemaElementPtr;
        }
        if !circ.is_null() {
            let mut strA: *mut u8 = 0 as *mut xmlChar;
            let mut strB: *mut u8 = 0 as *mut xmlChar;
            xmlSchemaPCustomErrExt (pctxt , XML_SCHEMAP_E_PROPS_CORRECT_6 , circ as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"The element declaration '%s' defines a circular substitution group to element declaration '%s'\0" as * const u8 as * const i8 , xmlSchemaGetComponentQName (Some (& mut strA) , circ as * mut libc :: c_void) , xmlSchemaGetComponentQName (Some (& mut strB) , head as * mut libc :: c_void) , 0 as * const xmlChar ,) ;
            if !strA.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(strA as *mut libc::c_void) });
                strA = 0 as *mut xmlChar;
            }
            if !strB.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(strB as *mut libc::c_void) });
                strB = 0 as *mut xmlChar;
            }
            ret = XML_SCHEMAP_E_PROPS_CORRECT_6 as i32;
        }
        if typeDef != (unsafe { (*(*elemDecl).refDecl).subtypes }) {
            let mut set: i32 = 0 as i32;
            if (unsafe { (*head).flags }) & (1 as i32) << 15 as i32 != 0 {
                set |= (1 as i32) << 1 as i32;
            }
            if (unsafe { (*head).flags }) & (1 as i32) << 16 as i32 != 0 {
                set |= (1 as i32) << 0 as i32;
            }
            if xmlSchemaCheckCOSDerivedOK(
                pctxt as xmlSchemaAbstractCtxtPtr,
                typeDef,
                unsafe { (*head).subtypes },
                set,
            ) != 0 as i32
            {
                let mut strA_0: *mut u8 = 0 as *mut xmlChar;
                let mut strB_0: *mut u8 = 0 as *mut xmlChar;
                let mut strC: *mut u8 = 0 as *mut xmlChar;
                ret = XML_SCHEMAP_E_PROPS_CORRECT_4 as i32;
                xmlSchemaPCustomErrExt (pctxt , XML_SCHEMAP_E_PROPS_CORRECT_4 , elemDecl as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"The type definition '%s' was either rejected by the substitution group affiliation '%s', or not validly derived from its type definition '%s'\0" as * const u8 as * const i8 , xmlSchemaGetComponentQName (Some (& mut strA_0) , typeDef as * mut libc :: c_void ,) , xmlSchemaGetComponentQName (Some (& mut strB_0) , head as * mut libc :: c_void) , xmlSchemaGetComponentQName (Some (& mut strC) , (unsafe { (* head) . subtypes }) as * mut libc :: c_void ,) ,) ;
                if !strA_0.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(strA_0 as *mut libc::c_void) });
                    strA_0 = 0 as *mut xmlChar;
                }
                if !strB_0.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(strB_0 as *mut libc::c_void) });
                    strB_0 = 0 as *mut xmlChar;
                }
                if !strC.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(strC as *mut libc::c_void) });
                    strC = 0 as *mut xmlChar;
                }
            }
        }
    }
    if !(unsafe { (*elemDecl).value }).is_null()
        && (((unsafe { (*typeDef).type_0 }) as u32 == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
            || (unsafe { (*typeDef).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
                && (unsafe { (*typeDef).builtInType }) != XML_SCHEMAS_ANYTYPE as i32)
            && xmlSchemaIsDerivedFromBuiltInType(typeDef, XML_SCHEMAS_ID as i32) != 0
            || ((unsafe { (*typeDef).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                || (unsafe { (*typeDef).builtInType }) == XML_SCHEMAS_ANYTYPE as i32)
                && ((unsafe { (*typeDef).contentType }) as u32 == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
                    || (unsafe { (*typeDef).contentType }) as u32 == XML_SCHEMA_CONTENT_BASIC as i32 as u32)
                && xmlSchemaIsDerivedFromBuiltInType(
                    unsafe { (*typeDef).contentTypeDef },
                    XML_SCHEMAS_ID as i32,
                ) != 0)
    {
        ret = XML_SCHEMAP_E_PROPS_CORRECT_5 as i32;
        xmlSchemaPCustomErr (pctxt , XML_SCHEMAP_E_PROPS_CORRECT_5 , elemDecl as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"The type definition (or type definition's content type) is or is derived from ID; value constraints are not allowed in conjunction with such a type definition\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
    } else if !(unsafe { (*elemDecl).value }).is_null() {
        let mut vcret: i32 = 0;
        let mut node: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
        if typeDef.is_null() {
            xmlSchemaPErr (pctxt , unsafe { (* elemDecl) . node } , XML_SCHEMAP_INTERNAL as i32 , b"Internal error: xmlSchemaCheckElemPropsCorrect, type is missing... skipping validation of the value constraint\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
            return -(1 as i32);
        }
        if !(unsafe { (*elemDecl).node }).is_null() {
            if (unsafe { (*elemDecl).flags }) & (1 as i32) << 3 as i32 != 0 {
                node = xmlHasProp(
                    (unsafe { (*elemDecl).node }) as *const xmlNode,
                    b"fixed\0" as *const u8 as *const i8 as *mut xmlChar,
                ) as xmlNodePtr;
            } else {
                node = xmlHasProp(
                    (unsafe { (*elemDecl).node }) as *const xmlNode,
                    b"default\0" as *const u8 as *const i8 as *mut xmlChar,
                ) as xmlNodePtr;
            }
        }
        vcret = xmlSchemaParseCheckCOSValidDefault(
            pctxt,
            node,
            typeDef,
            unsafe { (*elemDecl).value },
            Some(unsafe { &mut (*elemDecl).defVal }),
        );
        if vcret != 0 as i32 {
            if vcret < 0 as i32 {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaElemCheckValConstr\0" as *const u8 as *const i8,
                    b"failed to validate the value constraint of an element declaration\0"
                        as *const u8 as *const i8,
                );
                return -(1 as i32);
            }
            return vcret;
        }
    }
    return ret;
}
extern "C" fn xmlSchemaCheckElemSubstGroup<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut elemDecl: *mut crate::src::xmlschemas::_xmlSchemaElement<'a2>,
) {
    if (unsafe { (*elemDecl).refDecl }).is_null() || (unsafe { (*elemDecl).flags }) & (1 as i32) << 4 as i32 != 0 {
        return;
    }
    let mut head: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> = 0 as *mut xmlSchemaElement;
    let mut headType: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut set: i32 = 0;
    let mut methSet: i32 = 0;
    let mut current_block_28: u64;
    head = unsafe { (*elemDecl).refDecl };
    while !head.is_null() {
        set = 0 as i32;
        methSet = 0 as i32;
        if !((unsafe { (*head).flags }) & (1 as i32) << 13 as i32 != 0) {
            headType = unsafe { (*head).subtypes };
            type_0 = unsafe { (*elemDecl).subtypes };
            if headType == type_0 {
                current_block_28 = 12525254419223051704;
            } else {
                if (unsafe { (*head).flags }) & (1 as i32) << 12 as i32 != 0 {
                    set |= (1 as i32) << 19 as i32;
                }
                if (unsafe { (*head).flags }) & (1 as i32) << 11 as i32 != 0 {
                    set |= (1 as i32) << 18 as i32;
                }
                while !type_0.is_null() && type_0 != headType {
                    if (unsafe { (*type_0).flags }) & (1 as i32) << 1 as i32 != 0
                        && methSet & (1 as i32) << 19 as i32 == 0 as i32
                    {
                        methSet |= (1 as i32) << 18 as i32;
                    }
                    if (unsafe { (*type_0).flags }) & (1 as i32) << 2 as i32 != 0
                        && methSet & (1 as i32) << 19 as i32 == 0 as i32
                    {
                        methSet |= (1 as i32) << 19 as i32;
                    }
                    type_0 = unsafe { (*type_0).baseType };
                }
                type_0 = unsafe { (*(*elemDecl).subtypes).baseType };
                while !type_0.is_null() {
                    if !((unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                        || (unsafe { (*type_0).builtInType }) == XML_SCHEMAS_ANYTYPE as i32)
                    {
                        break;
                    }
                    if (unsafe { (*type_0).flags }) & (1 as i32) << 18 as i32 != 0
                        && set & (1 as i32) << 18 as i32 == 0 as i32
                    {
                        set |= (1 as i32) << 18 as i32;
                    }
                    if (unsafe { (*type_0).flags }) & (1 as i32) << 19 as i32 != 0
                        && set & (1 as i32) << 19 as i32 == 0 as i32
                    {
                        set |= (1 as i32) << 19 as i32;
                    }
                    if type_0 == headType {
                        break;
                    }
                    type_0 = unsafe { (*type_0).baseType };
                }
                if set != 0 as i32
                    && (set & (1 as i32) << 18 as i32 != 0
                        && methSet & (1 as i32) << 18 as i32 != 0
                        || set & (1 as i32) << 19 as i32 != 0
                            && methSet & (1 as i32) << 19 as i32 != 0)
                {
                    current_block_28 = 735147466149431745;
                } else {
                    current_block_28 = 12525254419223051704;
                }
            }
            match current_block_28 {
                735147466149431745 => {},
                _ => {
                    xmlSchemaAddElementSubstitutionMember(ctxt, head, elemDecl);
                    if (unsafe { (*head).flags }) & (1 as i32) << 17 as i32 == 0 as i32 {
                        (unsafe { (*head).flags |= (1 as i32) << 17 as i32 });
                    }
                },
            }
        }
        head = unsafe { (*head).refDecl };
    }
}
extern "C" fn xmlSchemaCheckElementDeclComponent<'a1, 'a2>(
    mut elemDecl: *mut crate::src::xmlschemas::_xmlSchemaElement<'a1>,
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a2>,
) where
    'a1: 'static,
{
    if elemDecl.is_null() {
        return;
    }
    if (unsafe { (*elemDecl).flags }) & (1 as i32) << 18 as i32 != 0 {
        return;
    }
    (unsafe { (*elemDecl).flags |= (1 as i32) << 18 as i32 });
    if xmlSchemaCheckElemPropsCorrect(ctxt, elemDecl) == 0 as i32 {
        xmlSchemaCheckElemSubstGroup(ctxt, elemDecl);
    }
}
extern "C" fn xmlSchemaResolveModelGroupParticleReferences<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut mg: *mut crate::src::xmlschemas::_xmlSchemaModelGroup<'a2>,
) {
    let mut particle: *mut crate::src::xmlschemas::_xmlSchemaParticle =
        (unsafe { (*mg).children }) as xmlSchemaParticlePtr;
    let mut ref_0: *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'_> =
        0 as *mut xmlSchemaQNameRef;
    let mut refItem: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_> =
        0 as *mut xmlSchemaBasicItem;
    while !particle.is_null() {
        if !((unsafe { (*particle).children }).is_null()
            || (unsafe { (*(*particle).children).type_0 }) as u32 != XML_SCHEMA_EXTRA_QNAMEREF as i32 as u32)
        {
            ref_0 = (unsafe { (*particle).children }) as xmlSchemaQNameRefPtr;
            let fresh406 = unsafe { &mut ((*particle).children) };
            *fresh406 = 0 as xmlSchemaTreeItemPtr;
            refItem = xmlSchemaGetNamedComponent(
                unsafe { (*ctxt).schema },
                unsafe { (*ref_0).itemType },
                unsafe { (*ref_0).name },
                unsafe { (*ref_0).targetNamespace },
            );
            if refItem.is_null() {
                xmlSchemaPResCompAttrErr(
                    ctxt,
                    XML_SCHEMAP_SRC_RESOLVE,
                    0 as xmlSchemaBasicItemPtr,
                    xmlSchemaGetComponentNode(particle as xmlSchemaBasicItemPtr),
                    b"ref\0" as *const u8 as *const i8,
                    unsafe { (*ref_0).name },
                    unsafe { (*ref_0).targetNamespace },
                    unsafe { (*ref_0).itemType },
                    0 as *const i8,
                );
            } else if (unsafe { (*refItem).type_0 }) as u32 == XML_SCHEMA_TYPE_GROUP as i32 as u32 {
                if !(unsafe { (*(refItem as xmlSchemaModelGroupPtr)).children }).is_null() {
                    if (unsafe { (*(*(refItem as xmlSchemaModelGroupPtr)).children).type_0 }) as u32
                        == XML_SCHEMA_TYPE_ALL as i32 as u32
                    {
                        xmlSchemaCustomErr (ctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_COS_ALL_LIMITED , xmlSchemaGetComponentNode (particle as xmlSchemaBasicItemPtr) , 0 as xmlSchemaBasicItemPtr , b"A model group definition is referenced, but it contains an 'all' model group, which cannot be contained by model groups\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
                    } else {
                        let fresh407 = unsafe { &mut ((*particle).children) };
                        *fresh407 = refItem as xmlSchemaTreeItemPtr;
                    }
                }
            } else {
                let fresh408 = unsafe { &mut ((*particle).children) };
                *fresh408 = refItem as xmlSchemaTreeItemPtr;
            }
        }
        particle = (unsafe { (*particle).next }) as xmlSchemaParticlePtr;
    }
}
extern "C" fn xmlSchemaAreValuesEqual(
    mut x: *mut crate::src::xmlschemastypes::_xmlSchemaVal,
    mut y: *mut crate::src::xmlschemastypes::_xmlSchemaVal,
) -> i32 {
    let mut tx: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut ty: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut ptx: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut pty: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut ret: i32 = 0;
    while !x.is_null() {
        tx = xmlSchemaGetBuiltInType(xmlSchemaGetValType(x));
        ty = xmlSchemaGetBuiltInType(xmlSchemaGetValType(y));
        ptx = xmlSchemaGetPrimitiveType(tx);
        pty = xmlSchemaGetPrimitiveType(ty);
        if ptx != pty {
            return 0 as i32;
        }
        if (unsafe { (*ptx).builtInType }) == XML_SCHEMAS_STRING as i32
            || (unsafe { (*ptx).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
                && (unsafe { (*ptx).builtInType }) == XML_SCHEMAS_ANYSIMPLETYPE as i32
        {
            if xmlStrEqual(xmlSchemaValueGetAsString(x), xmlSchemaValueGetAsString(y)) == 0 {
                return 0 as i32;
            }
        } else {
            ret = xmlSchemaCompareValuesWhtsp(
                x,
                XML_SCHEMA_WHITESPACE_PRESERVE,
                y,
                XML_SCHEMA_WHITESPACE_PRESERVE,
            );
            if ret == -(2 as i32) {
                return -(1 as i32);
            }
            if ret != 0 as i32 {
                return 0 as i32;
            }
        }
        x = xmlSchemaValueGetNext(x);
        if !x.is_null() {
            y = xmlSchemaValueGetNext(y);
            if y.is_null() {
                return 0 as i32;
            }
        } else if !(xmlSchemaValueGetNext(y)).is_null() {
            return 0 as i32;
        } else {
            return 1 as i32;
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaResolveAttrUseReferences<'a1, 'a2>(
    mut ause: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'a1>,
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a2>,
) -> i32 {
    if ctxt.is_null() || ause.is_null() {
        return -(1 as i32);
    }
    if (unsafe { (*ause).attrDecl }).is_null()
        || (unsafe { (*(*ause).attrDecl).type_0 }) as u32 != XML_SCHEMA_EXTRA_QNAMEREF as i32 as u32
    {
        return 0 as i32;
    }
    let mut ref_0: *mut crate::src::xmlschemas::_xmlSchemaQNameRef<'_> =
        (unsafe { (*ause).attrDecl }) as xmlSchemaQNameRefPtr;
    let fresh409 = unsafe { &mut ((*ause).attrDecl) };
    *fresh409 = xmlSchemaGetAttributeDecl(unsafe { (*ctxt).schema }, unsafe { (*ref_0).name }, unsafe { (*ref_0).targetNamespace });
    if (unsafe { (*ause).attrDecl }).is_null() {
        xmlSchemaPResCompAttrErr(
            ctxt,
            XML_SCHEMAP_SRC_RESOLVE,
            ause as xmlSchemaBasicItemPtr,
            unsafe { (*ause).node },
            b"ref\0" as *const u8 as *const i8,
            unsafe { (*ref_0).name },
            unsafe { (*ref_0).targetNamespace },
            XML_SCHEMA_TYPE_ATTRIBUTE,
            0 as *const i8,
        );
        return unsafe { (*ctxt).err };
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaCheckAttrUsePropsCorrect<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut use_0: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'a2>,
) -> i32
where
    'a2: 'static,
{
    if ctxt.is_null() || use_0.is_null() {
        return -(1 as i32);
    }
    if (unsafe { (*use_0).defValue }).is_null()
        || (unsafe { (*use_0).attrDecl }).is_null()
        || (unsafe { (*(*use_0).attrDecl).type_0 }) as u32 != XML_SCHEMA_TYPE_ATTRIBUTE as i32 as u32
    {
        return 0 as i32;
    }
    if !(unsafe { (*(*use_0).attrDecl).defValue }).is_null()
        && (unsafe { (*(*use_0).attrDecl).flags }) & (1 as i32) << 9 as i32 != 0
        && (unsafe { (*use_0).flags }) & (1 as i32) << 0 as i32 == 0 as i32
    {
        xmlSchemaPCustomErr (ctxt , XML_SCHEMAP_AU_PROPS_CORRECT_2 , use_0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"The attribute declaration has a 'fixed' value constraint , thus the attribute use must also have a 'fixed' value constraint\0" as * const u8 as * const i8 , 0 as * const xmlChar ,) ;
        return unsafe { (*ctxt).err };
    }
    if !(unsafe { (*use_0).defVal }).is_null() && !(unsafe { (*(*use_0).attrDecl).subtypes }).is_null() {
        let mut ret: i32 = 0;
        if xmlSchemaIsDerivedFromBuiltInType(unsafe { (*(*use_0).attrDecl).subtypes }, XML_SCHEMAS_ID as i32)
            != 0
        {
            xmlSchemaCustomErr (ctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_AU_PROPS_CORRECT , 0 as xmlNodePtr , use_0 as xmlSchemaBasicItemPtr , b"Value constraints are not allowed if the type definition is or is derived from xs:ID\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
            return unsafe { (*ctxt).err };
        }
        ret = xmlSchemaVCheckCVCSimpleType(
            ctxt as xmlSchemaAbstractCtxtPtr,
            unsafe { (*use_0).node },
            unsafe { (*(*use_0).attrDecl).subtypes },
            unsafe { (*use_0).defValue },
            Some(unsafe { &mut (*use_0).defVal }),
            1 as i32,
            1 as i32,
            0 as i32,
        );
        if ret != 0 as i32 {
            if ret < 0 as i32 {
                xmlSchemaInternalErr(
                    ctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaCheckAttrUsePropsCorrect\0" as *const u8 as *const i8,
                    b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8 as *const i8,
                );
                return -(1 as i32);
            }
            xmlSchemaCustomErr(
                ctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_AU_PROPS_CORRECT,
                0 as xmlNodePtr,
                use_0 as xmlSchemaBasicItemPtr,
                b"The value of the value constraint is not valid\0" as *const u8 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
            return unsafe { (*ctxt).err };
        }
    }
    if !(unsafe { (*(*use_0).attrDecl).defVal }).is_null()
        && (unsafe { (*(*use_0).attrDecl).flags }) & (1 as i32) << 0 as i32 == 0 as i32
    {
        if xmlSchemaAreValuesEqual(unsafe { (*use_0).defVal }, unsafe { (*(*use_0).attrDecl).defVal }) == 0 {
            xmlSchemaPCustomErr (ctxt , XML_SCHEMAP_AU_PROPS_CORRECT_2 , use_0 as xmlSchemaBasicItemPtr , 0 as xmlNodePtr , b"The 'fixed' value constraint of the attribute use must match the attribute declaration's value constraint '%s'\0" as * const u8 as * const i8 , unsafe { (* (* use_0) . attrDecl) . defValue } ,) ;
        }
        return unsafe { (*ctxt).err };
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaResolveAttrTypeReferences<'a1, 'a2>(
    mut item: *mut crate::src::xmlschemas::_xmlSchemaAttribute<'a1>,
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a2>,
) -> i32
where
    'a1: 'static,
{
    if (unsafe { (*item).flags }) & (1 as i32) << 8 as i32 != 0 {
        return 0 as i32;
    }
    (unsafe { (*item).flags |= (1 as i32) << 8 as i32 });
    if !(unsafe { (*item).subtypes }).is_null() {
        return 0 as i32;
    }
    if !(unsafe { (*item).typeName }).is_null() {
        let mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
        type_0 = xmlSchemaGetType(unsafe { (*ctxt).schema }, unsafe { (*item).typeName }, unsafe { (*item).typeNs });
        if type_0.is_null()
            || !((unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                || (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
                    && (unsafe { (*type_0).builtInType }) != XML_SCHEMAS_ANYTYPE as i32)
        {
            xmlSchemaPResCompAttrErr(
                ctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                item as xmlSchemaBasicItemPtr,
                unsafe { (*item).node },
                b"type\0" as *const u8 as *const i8,
                unsafe { (*item).typeName },
                unsafe { (*item).typeNs },
                XML_SCHEMA_TYPE_SIMPLE,
                0 as *const i8,
            );
            return unsafe { (*ctxt).err };
        } else {
            let fresh410 = unsafe { &mut ((*item).subtypes) };
            *fresh410 = type_0;
        }
    } else {
        let fresh411 = unsafe { &mut ((*item).subtypes) };
        *fresh411 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYSIMPLETYPE);
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaResolveIDCKeyReferences<'a1, 'a2>(
    mut idc: *mut crate::src::xmlschemas::_xmlSchemaIDC<'a1>,
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a2>,
) -> i32 {
    if (unsafe { (*idc).type_0 }) as u32 != XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32 {
        return 0 as i32;
    }
    if !(unsafe { (*(*idc).ref_0).name }).is_null() {
        let fresh412 = unsafe { &mut ((*(*idc).ref_0).item) };
        *fresh412 = xmlSchemaGetIDC(
            unsafe { (*pctxt).schema },
            unsafe { (*(*idc).ref_0).name },
            unsafe { (*(*idc).ref_0).targetNamespace },
        ) as xmlSchemaBasicItemPtr;
        if (unsafe { (*(*idc).ref_0).item }).is_null() {
            xmlSchemaPResCompAttrErr(
                pctxt,
                XML_SCHEMAP_SRC_RESOLVE,
                idc as xmlSchemaBasicItemPtr,
                unsafe { (*idc).node },
                b"refer\0" as *const u8 as *const i8,
                unsafe { (*(*idc).ref_0).name },
                unsafe { (*(*idc).ref_0).targetNamespace },
                XML_SCHEMA_TYPE_IDC_KEY,
                0 as *const i8,
            );
            return unsafe { (*pctxt).err };
        } else {
            if (unsafe { (*(*(*idc).ref_0).item).type_0 }) as u32 == XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32 {
                xmlSchemaCustomErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    XML_SCHEMAP_C_PROPS_CORRECT,
                    0 as xmlNodePtr,
                    idc as xmlSchemaBasicItemPtr,
                    b"The keyref references a keyref\0" as *const u8 as *const i8,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
                let fresh413 = unsafe { &mut ((*(*idc).ref_0).item) };
                *fresh413 = 0 as xmlSchemaBasicItemPtr;
                return unsafe { (*pctxt).err };
            } else {
                if (unsafe { (*idc).nbFields }) != (unsafe { (*((*(*idc).ref_0).item as xmlSchemaIDCPtr)).nbFields }) {
                    let mut str: *mut u8 = 0 as *mut xmlChar;
                    let mut refer: *mut crate::src::xmlschemas::_xmlSchemaIDC<'_> =
                        0 as *mut xmlSchemaIDC;
                    refer = (unsafe { (*(*idc).ref_0).item }) as xmlSchemaIDCPtr;
                    xmlSchemaCustomErr (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_C_PROPS_CORRECT , 0 as xmlNodePtr , idc as xmlSchemaBasicItemPtr , b"The cardinality of the keyref differs from the cardinality of the referenced key/unique '%s'\0" as * const u8 as * const i8 , xmlSchemaFormatQName (Some (& mut str) , unsafe { (* refer) . targetNamespace } , unsafe { (* refer) . name } ,) , 0 as * const xmlChar ,) ;
                    if !str.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                        str = 0 as *mut xmlChar;
                    }
                    return unsafe { (*pctxt).err };
                }
            }
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaResolveAttrUseProhibReferences<'a1>(
    mut prohib: *mut crate::src::xmlschemas::_xmlSchemaAttributeUseProhib,
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
) -> i32 {
    if (xmlSchemaGetAttributeDecl(unsafe { (*pctxt).schema }, unsafe { (*prohib).name }, unsafe { (*prohib).targetNamespace }))
        .is_null()
    {
        xmlSchemaPResCompAttrErr(
            pctxt,
            XML_SCHEMAP_SRC_RESOLVE,
            0 as xmlSchemaBasicItemPtr,
            unsafe { (*prohib).node },
            b"ref\0" as *const u8 as *const i8,
            unsafe { (*prohib).name },
            unsafe { (*prohib).targetNamespace },
            XML_SCHEMA_TYPE_ATTRIBUTE,
            0 as *const i8,
        );
        return XML_SCHEMAP_SRC_RESOLVE as i32;
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaCheckSRCRedefineFirst<'a1>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
) -> i32 {
    let mut err: i32 = 0 as i32;
    let mut redef: *mut crate::src::xmlschemas::_xmlSchemaRedef<'_> =
        unsafe { (*(*pctxt).constructor).redefs };
    let mut prev: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_> =
        0 as *mut xmlSchemaBasicItem;
    let mut item: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_> =
        0 as *mut xmlSchemaBasicItem;
    let mut wasRedefined: i32 = 0;
    if redef.is_null() {
        return 0 as i32;
    }
    loop {
        item = unsafe { (*redef).item };
        prev = xmlSchemaFindRedefCompInGraph(
            unsafe { (*redef).targetBucket },
            unsafe { (*item).type_0 },
            unsafe { (*redef).refName },
            unsafe { (*redef).refTargetNs },
        );
        if prev.is_null() {
            let mut str: *mut u8 = 0 as *mut xmlChar;
            let mut node: *mut crate::src::threads::_xmlNode = 0 as *mut xmlNode;
            if !(unsafe { (*redef).reference }).is_null() {
                node = xmlSchemaGetComponentNode(unsafe { (*redef).reference });
            } else {
                node = xmlSchemaGetComponentNode(item);
            }
            xmlSchemaCustomErr(
                pctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAP_SRC_REDEFINE,
                node,
                0 as xmlSchemaBasicItemPtr,
                b"The %s '%s' to be redefined could not be found in the redefined schema\0"
                    as *const u8 as *const i8,
                xmlSchemaGetComponentTypeStr(item),
                xmlSchemaFormatQName(Some(&mut str), unsafe { (*redef).refTargetNs }, unsafe { (*redef).refName }),
            );
            if !str.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                str = 0 as *mut xmlChar;
            }
            err = unsafe { (*pctxt).err };
            redef = unsafe { (*redef).next };
        } else {
            wasRedefined = 0 as i32;
            match (unsafe { (*item).type_0 }) as u32 {
                5 | 4 => {
                    if (unsafe { (*(prev as xmlSchemaTypePtr)).flags }) & (1 as i32) << 30 as i32 != 0 {
                        wasRedefined = 1 as i32;
                    } else {
                        (unsafe { (*(prev as xmlSchemaTypePtr)).flags |= (1 as i32) << 30 as i32 });
                        let fresh414 = unsafe { &mut ((*(item as xmlSchemaTypePtr)).baseType) };
                        *fresh414 = prev as xmlSchemaTypePtr;
                    }
                },
                17 => {
                    if (unsafe { (*(prev as xmlSchemaModelGroupDefPtr)).flags }) & (1 as i32) << 1 as i32 != 0 {
                        wasRedefined = 1 as i32;
                    } else {
                        (unsafe { (*(prev as xmlSchemaModelGroupDefPtr)).flags |= (1 as i32) << 1 as i32 });
                        if !(unsafe { (*redef).reference }).is_null() {
                            let fresh415 =
                                unsafe { &mut ((*((*redef).reference as xmlSchemaParticlePtr)).children) };
                            *fresh415 = prev as xmlSchemaTreeItemPtr;
                        }
                        let fresh416 = unsafe { &mut ((*redef).target) };
                        *fresh416 = prev;
                    }
                },
                16 => {
                    if (unsafe { (*(prev as xmlSchemaAttributeGroupPtr)).flags }) & (1 as i32) << 3 as i32 != 0 {
                        wasRedefined = 1 as i32;
                    } else {
                        (unsafe { (*(prev as xmlSchemaAttributeGroupPtr)).flags |= (1 as i32) << 3 as i32 });
                        if !(unsafe { (*redef).reference }).is_null() {
                            let fresh417 =
                                unsafe { &mut ((*((*redef).reference as xmlSchemaQNameRefPtr)).item) };
                            *fresh417 = prev;
                            let fresh418 = unsafe { &mut ((*redef).target) };
                            *fresh418 = 0 as xmlSchemaBasicItemPtr;
                        } else {
                            let fresh419 = unsafe { &mut ((*redef).target) };
                            *fresh419 = prev;
                        }
                    }
                },
                _ => {
                    xmlSchemaInternalErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaResolveRedefReferences\0" as *const u8 as *const i8,
                        b"Unexpected redefined component type\0" as *const u8 as *const i8,
                    );
                    return -(1 as i32);
                },
            }
            if wasRedefined != 0 {
                let mut str_0: *mut u8 = 0 as *mut xmlChar;
                let mut node_0: *mut crate::src::threads::_xmlNode = 0 as *mut xmlNode;
                if !(unsafe { (*redef).reference }).is_null() {
                    node_0 = xmlSchemaGetComponentNode(unsafe { (*redef).reference });
                } else {
                    node_0 = xmlSchemaGetComponentNode(unsafe { (*redef).item });
                }
                xmlSchemaCustomErr (pctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAP_SRC_REDEFINE , node_0 , 0 as xmlSchemaBasicItemPtr , b"The referenced %s was already redefined. Multiple redefinition of the same component is not supported\0" as * const u8 as * const i8 , xmlSchemaGetComponentDesignation (Some (& mut str_0) , prev as * mut libc :: c_void ,) , 0 as * const xmlChar ,) ;
                if !str_0.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str_0 as *mut libc::c_void) });
                    str_0 = 0 as *mut xmlChar;
                }
                err = unsafe { (*pctxt).err };
                redef = unsafe { (*redef).next };
            } else {
                redef = unsafe { (*redef).next };
            }
        }
        if redef.is_null() {
            break;
        }
    }
    return err;
}
extern "C" fn xmlSchemaCheckSRCRedefineSecond<'a1>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
) -> i32 {
    let mut err: i32 = 0 as i32;
    let mut redef: *mut crate::src::xmlschemas::_xmlSchemaRedef<'_> =
        unsafe { (*(*pctxt).constructor).redefs };
    let mut item: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_> =
        0 as *mut xmlSchemaBasicItem;
    if redef.is_null() {
        return 0 as i32;
    }
    loop {
        if (unsafe { (*redef).target }).is_null() {
            redef = unsafe { (*redef).next };
        } else {
            item = unsafe { (*redef).item };
            match (unsafe { (*item).type_0 }) as u32 {
                4 | 5 => {
                    let fresh420 = unsafe { &mut ((*((*redef).target as xmlSchemaTypePtr)).name) };
                    *fresh420 = 0 as *const xmlChar;
                },
                16 => {
                    err = xmlSchemaCheckDerivationOKRestriction2to4(
                        pctxt,
                        1 as i32,
                        item,
                        unsafe { (*redef).target },
                        (unsafe { (*(item as xmlSchemaAttributeGroupPtr)).attrUses }) as xmlSchemaItemListPtr,
                        (unsafe { (*((*redef).target as xmlSchemaAttributeGroupPtr)).attrUses })
                            as xmlSchemaItemListPtr,
                        unsafe { (*(item as xmlSchemaAttributeGroupPtr)).attributeWildcard },
                        unsafe { (*((*redef).target as xmlSchemaAttributeGroupPtr)).attributeWildcard },
                    );
                    if err == -(1 as i32) {
                        return -(1 as i32);
                    }
                },
                17 | _ => {},
            }
            redef = unsafe { (*redef).next };
        }
        if redef.is_null() {
            break;
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaAddComponents<'a1>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut bucket: *mut crate::src::xmlschemas::_xmlSchemaBucket,
) -> i32 {
    let mut item: *mut crate::src::xmlschemas::_xmlSchemaBasicItem<'_> =
        0 as *mut xmlSchemaBasicItem;
    let mut err: i32 = 0;
    let mut table: Option<&'_ mut *mut crate::src::xmlsave::_xmlHashTable> =
        Option::<&'_ mut *mut crate::src::xmlsave::_xmlHashTable>::None;
    let mut name: *const u8 = 0 as *const xmlChar;
    let mut i: i32 = 0;
    if bucket.is_null() {
        return -(1 as i32);
    }
    if (unsafe { (*bucket).flags }) & (1 as i32) << 1 as i32 != 0 {
        return 0 as i32;
    }
    (unsafe { (*bucket).flags |= (1 as i32) << 1 as i32 });
    let mut current_block_61: u64;
    i = 0 as i32;
    while i < (unsafe { (*(*bucket).globals).nbItems }) {
        item = (unsafe { *((*(*bucket).globals).items).offset(i as isize) }) as xmlSchemaBasicItemPtr;
        table = Option::<&'_ mut *mut crate::src::xmlsave::_xmlHashTable>::None;
        match (unsafe { (*item).type_0 }) as u32 {
            5 | 4 => {
                if (unsafe { (*(item as xmlSchemaTypePtr)).flags }) & (1 as i32) << 30 as i32 != 0 {
                    current_block_61 = 6937071982253665452;
                } else {
                    name = unsafe { (*(item as xmlSchemaTypePtr)).name };
                    if (unsafe { (*bucket).type_0 }) == 0 as i32 || (unsafe { (*bucket).type_0 }) == 1 as i32 {
                        table = Some(unsafe { &mut (*(*(bucket as xmlSchemaImportPtr)).schema).typeDecl });
                    } else {
                        table = Some(
                            unsafe { &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport).schema)
                                .typeDecl },
                        );
                    }
                    current_block_61 = 2500484646272006982;
                }
            },
            14 => {
                name = unsafe { (*(item as xmlSchemaElementPtr)).name };
                if (unsafe { (*bucket).type_0 }) == 0 as i32 || (unsafe { (*bucket).type_0 }) == 1 as i32 {
                    table = Some(unsafe { &mut (*(*(bucket as xmlSchemaImportPtr)).schema).elemDecl });
                } else {
                    table = Some(
                        unsafe { &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport).schema).elemDecl },
                    );
                }
                current_block_61 = 2500484646272006982;
            },
            15 => {
                name = unsafe { (*(item as xmlSchemaAttributePtr)).name };
                if (unsafe { (*bucket).type_0 }) == 0 as i32 || (unsafe { (*bucket).type_0 }) == 1 as i32 {
                    table = Some(unsafe { &mut (*(*(bucket as xmlSchemaImportPtr)).schema).attrDecl });
                } else {
                    table = Some(
                        unsafe { &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport).schema).attrDecl },
                    );
                }
                current_block_61 = 2500484646272006982;
            },
            17 => {
                if (unsafe { (*(item as xmlSchemaModelGroupDefPtr)).flags }) & (1 as i32) << 1 as i32 != 0 {
                    current_block_61 = 6937071982253665452;
                } else {
                    name = unsafe { (*(item as xmlSchemaModelGroupDefPtr)).name };
                    if (unsafe { (*bucket).type_0 }) == 0 as i32 || (unsafe { (*bucket).type_0 }) == 1 as i32 {
                        table = Some(unsafe { &mut (*(*(bucket as xmlSchemaImportPtr)).schema).groupDecl });
                    } else {
                        table = Some(
                            unsafe { &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport).schema)
                                .groupDecl },
                        );
                    }
                    current_block_61 = 2500484646272006982;
                }
            },
            16 => {
                if (unsafe { (*(item as xmlSchemaAttributeGroupPtr)).flags }) & (1 as i32) << 3 as i32 != 0 {
                    current_block_61 = 6937071982253665452;
                } else {
                    name = unsafe { (*(item as xmlSchemaAttributeGroupPtr)).name };
                    if (unsafe { (*bucket).type_0 }) == 0 as i32 || (unsafe { (*bucket).type_0 }) == 1 as i32 {
                        table = Some(unsafe { &mut (*(*(bucket as xmlSchemaImportPtr)).schema).attrgrpDecl });
                    } else {
                        table = Some(
                            unsafe { &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport).schema)
                                .attrgrpDecl },
                        );
                    }
                    current_block_61 = 2500484646272006982;
                }
            },
            23 | 22 | 24 => {
                name = unsafe { (*(item as xmlSchemaIDCPtr)).name };
                if (unsafe { (*bucket).type_0 }) == 0 as i32 || (unsafe { (*bucket).type_0 }) == 1 as i32 {
                    table = Some(unsafe { &mut (*(*(bucket as xmlSchemaImportPtr)).schema).idcDef });
                } else {
                    table = Some(
                        unsafe { &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport).schema).idcDef },
                    );
                }
                current_block_61 = 2500484646272006982;
            },
            18 => {
                name = unsafe { (*(item as xmlSchemaNotationPtr)).name };
                if (unsafe { (*bucket).type_0 }) == 0 as i32 || (unsafe { (*bucket).type_0 }) == 1 as i32 {
                    table = Some(unsafe { &mut (*(*(bucket as xmlSchemaImportPtr)).schema).notaDecl });
                } else {
                    table = Some(
                        unsafe { &mut (*(*(*(bucket as xmlSchemaIncludePtr)).ownerImport).schema).notaDecl },
                    );
                }
                current_block_61 = 2500484646272006982;
            },
            _ => {
                xmlSchemaInternalErr(
                    pctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaAddComponents\0" as *const u8 as *const i8,
                    b"Unexpected global component type\0" as *const u8 as *const i8,
                );
                current_block_61 = 6937071982253665452;
            },
        }
        match current_block_61 {
            2500484646272006982 => {
                if (*(borrow_mut(&mut table)).unwrap()).is_null() {
                    *(borrow_mut(&mut table)).unwrap() =
                        unsafe { xmlHashCreateDict(10 as i32, (*pctxt).dict) };
                    if (*(borrow_mut(&mut table)).unwrap()).is_null() {
                        xmlSchemaInternalErr(
                            pctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaAddComponents\0" as *const u8 as *const i8,
                            b"failed to create a component hash table\0" as *const u8 as *const i8,
                        );
                        return -(1 as i32);
                    }
                }
                err = unsafe { xmlHashAddEntry(
                    *(borrow_mut(&mut table)).unwrap(),
                    name,
                    item as *mut libc::c_void,
                ) };
                if err != 0 as i32 {
                    let mut str: *mut u8 = 0 as *mut xmlChar;
                    xmlSchemaCustomErr(
                        pctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_REDEFINED_TYPE,
                        xmlSchemaGetComponentNode(item),
                        item,
                        b"A global %s '%s' does already exist\0" as *const u8 as *const i8,
                        xmlSchemaGetComponentTypeStr(item),
                        xmlSchemaGetComponentQName(Some(&mut str), item as *mut libc::c_void),
                    );
                    if !str.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                        str = 0 as *mut xmlChar;
                    }
                }
            },
            _ => {},
        }
        i += 1;
    }
    if !(unsafe { (*bucket).relations }).is_null() {
        let mut rel: *mut crate::src::xmlschemas::_xmlSchemaSchemaRelation = unsafe { (*bucket).relations };
        loop {
            if !(unsafe { (*rel).bucket }).is_null()
                && (unsafe { (*(*rel).bucket).flags }) & (1 as i32) << 1 as i32 == 0 as i32
            {
                if xmlSchemaAddComponents(pctxt, unsafe { (*rel).bucket }) == -(1 as i32) {
                    return -(1 as i32);
                }
            }
            rel = unsafe { (*rel).next };
            if rel.is_null() {
                break;
            }
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaFixupComponents<'a1>(
    mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut rootBucket: *mut crate::src::xmlschemas::_xmlSchemaBucket,
) -> i32 {
    let mut current_block: u64;
    let mut con: *mut crate::src::xmlschemas::_xmlSchemaConstructionCtxt<'_> = unsafe { (*pctxt).constructor };
    let mut item: *mut crate::src::xmlschemas::_xmlSchemaTreeItem = 0 as *mut xmlSchemaTreeItem;
    let mut items: *mut *mut crate::src::xmlschemas::_xmlSchemaTreeItem =
        0 as *mut xmlSchemaTreeItemPtr;
    let mut nbItems: i32 = 0;
    let mut i: i32 = 0;
    let mut ret: i32 = 0 as i32;
    let mut oldbucket: *mut crate::src::xmlschemas::_xmlSchemaBucket = unsafe { (*con).bucket };
    let mut elemDecl: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> =
        0 as *mut xmlSchemaElement;
    if (unsafe { (*con).pending }).is_null() || (unsafe { (*(*con).pending).nbItems }) == 0 as i32 {
        return 0 as i32;
    }
    if (unsafe { (*con).bucket }).is_null() {
        let fresh421 = unsafe { &mut ((*con).bucket) };
        *fresh421 = rootBucket;
    }
    xmlSchemaCheckSRCRedefineFirst(pctxt);
    xmlSchemaAddComponents(pctxt, rootBucket);
    let fresh422 = unsafe { &mut ((*pctxt).ctxtType) };
    *fresh422 = 0 as xmlSchemaTypePtr;
    items = (unsafe { (*(*con).pending).items }) as *mut xmlSchemaTreeItemPtr;
    nbItems = unsafe { (*(*con).pending).nbItems };
    i = 0 as i32;
    loop {
        if !(i < nbItems) {
            current_block = 1924505913685386279;
            break;
        }
        item = unsafe { *items.offset(i as isize) };
        match (unsafe { (*item).type_0 }) as u32 {
            14 => {
                xmlSchemaResolveElementReferences(item as xmlSchemaElementPtr, pctxt);
                if (unsafe { (*pctxt).err }) == XML_SCHEMAP_INTERNAL as i32 {
                    current_block = 2133922729242721719;
                    break;
                }
            },
            5 | 4 => {
                xmlSchemaResolveTypeReferences(item as xmlSchemaTypePtr, pctxt);
                if (unsafe { (*pctxt).err }) == XML_SCHEMAP_INTERNAL as i32 {
                    current_block = 2133922729242721719;
                    break;
                }
            },
            15 => {
                xmlSchemaResolveAttrTypeReferences(item as xmlSchemaAttributePtr, pctxt);
                if (unsafe { (*pctxt).err }) == XML_SCHEMAP_INTERNAL as i32 {
                    current_block = 2133922729242721719;
                    break;
                }
            },
            26 => {
                xmlSchemaResolveAttrUseReferences(item as xmlSchemaAttributeUsePtr, pctxt);
                if (unsafe { (*pctxt).err }) == XML_SCHEMAP_INTERNAL as i32 {
                    current_block = 2133922729242721719;
                    break;
                }
            },
            2000 => {
                if (unsafe { (*(item as xmlSchemaQNameRefPtr)).itemType }) as u32
                    == XML_SCHEMA_TYPE_ATTRIBUTEGROUP as i32 as u32
                {
                    xmlSchemaResolveAttrGroupReferences(item as xmlSchemaQNameRefPtr, pctxt);
                }
                if (unsafe { (*pctxt).err }) == XML_SCHEMAP_INTERNAL as i32 {
                    current_block = 2133922729242721719;
                    break;
                }
            },
            6 | 7 | 8 => {
                xmlSchemaResolveModelGroupParticleReferences(pctxt, item as xmlSchemaModelGroupPtr);
                if (unsafe { (*pctxt).err }) == XML_SCHEMAP_INTERNAL as i32 {
                    current_block = 2133922729242721719;
                    break;
                }
            },
            23 | 22 | 24 => {
                xmlSchemaResolveIDCKeyReferences(item as xmlSchemaIDCPtr, pctxt);
                if (unsafe { (*pctxt).err }) == XML_SCHEMAP_INTERNAL as i32 {
                    current_block = 2133922729242721719;
                    break;
                }
            },
            2001 => {
                xmlSchemaResolveAttrUseProhibReferences(
                    item as xmlSchemaAttributeUseProhibPtr,
                    pctxt,
                );
                if (unsafe { (*pctxt).err }) == XML_SCHEMAP_INTERNAL as i32 {
                    current_block = 2133922729242721719;
                    break;
                }
            },
            _ => {},
        }
        i += 1;
    }
    match current_block {
        1924505913685386279 => {
            if (unsafe { (*pctxt).nberrors }) != 0 as i32 {
                current_block = 3799963374263564300;
            } else {
                i = 0 as i32;
                loop {
                    if !(i < nbItems) {
                        current_block = 7330218953828964527;
                        break;
                    }
                    item = unsafe { *items.offset(i as isize) };
                    match (unsafe { (*item).type_0 }) as u32 {
                        5 | 4 => {
                            xmlSchemaCheckTypeDefCircular(item as xmlSchemaTypePtr, pctxt);
                            if (unsafe { (*pctxt).err }) == XML_SCHEMAP_INTERNAL as i32 {
                                current_block = 2133922729242721719;
                                break;
                            }
                            if (unsafe { (*pctxt).nberrors }) != 0 as i32 {
                                current_block = 3799963374263564300;
                                break;
                            }
                        },
                        17 => {
                            xmlSchemaCheckGroupDefCircular(
                                item as xmlSchemaModelGroupDefPtr,
                                pctxt,
                            );
                            if (unsafe { (*pctxt).err }) == XML_SCHEMAP_INTERNAL as i32 {
                                current_block = 2133922729242721719;
                                break;
                            }
                            if (unsafe { (*pctxt).nberrors }) != 0 as i32 {
                                current_block = 3799963374263564300;
                                break;
                            }
                        },
                        16 => {
                            xmlSchemaCheckAttrGroupCircular(
                                item as xmlSchemaAttributeGroupPtr,
                                pctxt,
                            );
                            if (unsafe { (*pctxt).err }) == XML_SCHEMAP_INTERNAL as i32 {
                                current_block = 2133922729242721719;
                                break;
                            }
                            if (unsafe { (*pctxt).nberrors }) != 0 as i32 {
                                current_block = 3799963374263564300;
                                break;
                            }
                        },
                        _ => {},
                    }
                    i += 1;
                }
                match current_block {
                    2133922729242721719 => {},
                    3799963374263564300 => {},
                    _ => {
                        if (unsafe { (*pctxt).nberrors }) != 0 as i32 {
                            current_block = 3799963374263564300;
                        } else {
                            i = 0 as i32;
                            while i < nbItems {
                                item = unsafe { *items.offset(i as isize) };
                                match (unsafe { (*item).type_0 }) as u32 {
                                    6 | 7 => {
                                        xmlSchemaModelGroupToModelGroupDefFixup(
                                            pctxt,
                                            item as xmlSchemaModelGroupPtr,
                                        );
                                    },
                                    _ => {},
                                }
                                i += 1;
                            }
                            if (unsafe { (*pctxt).nberrors }) != 0 as i32 {
                                current_block = 3799963374263564300;
                            } else {
                                i = 0 as i32;
                                loop {
                                    if !(i < nbItems) {
                                        current_block = 2798392256336243897;
                                        break;
                                    }
                                    item = unsafe { *items.offset(i as isize) };
                                    match (unsafe { (*item).type_0 }) as u32 {
                                        16 => {
                                            if (unsafe { (*(item as xmlSchemaAttributeGroupPtr)).flags })
                                                & (1 as i32) << 0 as i32
                                                == 0
                                                && (unsafe { (*(item as xmlSchemaAttributeGroupPtr)).flags })
                                                    & (1 as i32) << 4 as i32
                                                    != 0
                                            {
                                                xmlSchemaAttributeGroupExpandRefs(
                                                    pctxt,
                                                    item as xmlSchemaAttributeGroupPtr,
                                                );
                                                if (unsafe { (*pctxt).err }) == XML_SCHEMAP_INTERNAL as i32 {
                                                    current_block = 2133922729242721719;
                                                    break;
                                                }
                                            }
                                        },
                                        _ => {},
                                    }
                                    i += 1;
                                }
                                match current_block {
                                    2133922729242721719 => {},
                                    _ => {
                                        if (unsafe { (*pctxt).nberrors }) != 0 as i32 {
                                            current_block = 3799963374263564300;
                                        } else {
                                            i = 0 as i32;
                                            loop {
                                                if !(i < nbItems) {
                                                    current_block = 562309032768341766;
                                                    break;
                                                }
                                                item = unsafe { *items.offset(i as isize) };
                                                match (unsafe { (*item).type_0 }) as u32 {
                                                    4 => {
                                                        if (unsafe { (*(item as xmlSchemaTypePtr)).type_0 })
                                                            as u32
                                                            != XML_SCHEMA_TYPE_BASIC as i32 as u32
                                                            && (unsafe { (*(item as xmlSchemaTypePtr)).flags })
                                                                & (1 as i32) << 29 as i32
                                                                == 0 as i32
                                                        {
                                                            xmlSchemaFixupSimpleTypeStageOne(
                                                                pctxt,
                                                                item as xmlSchemaTypePtr,
                                                            );
                                                            if (unsafe { (*pctxt).err })
                                                                == XML_SCHEMAP_INTERNAL as i32
                                                            {
                                                                current_block = 2133922729242721719;
                                                                break;
                                                            }
                                                        }
                                                    },
                                                    _ => {},
                                                }
                                                i += 1;
                                            }
                                            match current_block {
                                                2133922729242721719 => {},
                                                _ => {
                                                    if (unsafe { (*pctxt).nberrors }) != 0 as i32 {
                                                        current_block = 3799963374263564300;
                                                    } else {
                                                        i = 0 as i32;
                                                        loop {
                                                            if !(i < nbItems) {
                                                                current_block =
                                                                    14612007084265645573;
                                                                break;
                                                            }
                                                            item = unsafe { *items.offset(i as isize) };
                                                            match (unsafe { (*item).type_0 }) as u32 {
                                                                4 => {
                                                                    if !(unsafe { (*(item
                                                                        as xmlSchemaTypePtr))
                                                                        .memberTypes })
                                                                        .is_null()
                                                                    {
                                                                        xmlSchemaCheckUnionTypeDefCircular (pctxt , item as xmlSchemaTypePtr ,) ;
                                                                        if (unsafe { (*pctxt).err })
                                                                            == XML_SCHEMAP_INTERNAL
                                                                                as i32
                                                                        {
                                                                            current_block =
                                                                                2133922729242721719;
                                                                            break;
                                                                        }
                                                                    }
                                                                },
                                                                _ => {},
                                                            }
                                                            i += 1;
                                                        }
                                                        match current_block {
                                                            2133922729242721719 => {},
                                                            _ => {
                                                                if (unsafe { (*pctxt).nberrors }) != 0 as i32 {
                                                                    current_block =
                                                                        3799963374263564300;
                                                                } else {
                                                                    i = 0 as i32;
                                                                    loop {
                                                                        if !(i < nbItems) {
                                                                            current_block =
                                                                                7079180960716815705;
                                                                            break;
                                                                        }
                                                                        item = unsafe { *items
                                                                            .offset(i as isize) };
                                                                        match (unsafe { (* item) . type_0 }) as u32 { 4 => { if (unsafe { (* (item as xmlSchemaTypePtr)) . type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32 && (unsafe { (* (item as xmlSchemaTypePtr)) . flags }) & (1 as i32) << 22 as i32 == 0 as i32 { xmlSchemaFixupSimpleTypeStageTwo (pctxt , item as xmlSchemaTypePtr ,) ; if (unsafe { (* pctxt) . err }) == XML_SCHEMAP_INTERNAL as i32 { current_block = 2133922729242721719 ; break ; } } } _ => { } }
                                                                        i += 1;
                                                                    }
                                                                    match current_block {
                                                                        2133922729242721719 => {},
                                                                        _ => {
                                                                            if (unsafe { (*pctxt).nberrors })
                                                                                != 0 as i32
                                                                            {
                                                                                current_block = 3799963374263564300 ;
                                                                            } else {
                                                                                i = 0 as i32;
                                                                                loop {
                                                                                    if !(i
                                                                                        < nbItems)
                                                                                    {
                                                                                        current_block = 5431927413890720344 ;
                                                                                        break;
                                                                                    }
                                                                                    item = unsafe { *items
                                                                                        .offset(
                                                                                        i as isize,
                                                                                    ) };
                                                                                    match (unsafe { (*item)
                                                                                        .type_0 })
                                                                                        as u32
                                                                                    {
                                                                                        15 => {
                                                                                            xmlSchemaCheckAttrPropsCorrect (pctxt , item as xmlSchemaAttributePtr ,) ;
                                                                                            if (unsafe { (* pctxt) . err }) == XML_SCHEMAP_INTERNAL as i32 { current_block = 2133922729242721719 ; break ; }
                                                                                        },
                                                                                        _ => {},
                                                                                    }
                                                                                    i += 1;
                                                                                }
                                                                                match current_block { 2133922729242721719 => { } _ => { if (unsafe { (* pctxt) . nberrors }) != 0 as i32 { current_block = 3799963374263564300 ; } else { i = 0 as i32 ; loop { if ! (i < nbItems) { current_block = 6215370584428403858 ; break ; } item = unsafe { * items . offset (i as isize) } ; match (unsafe { (* item) . type_0 }) as u32 { 26 => { if ! (unsafe { (* (item as xmlSchemaAttributeUsePtr)) . defValue }) . is_null () { xmlSchemaCheckAttrUsePropsCorrect (pctxt , item as xmlSchemaAttributeUsePtr ,) ; if (unsafe { (* pctxt) . err }) == XML_SCHEMAP_INTERNAL as i32 { current_block = 2133922729242721719 ; break ; } } } _ => { } } i += 1 ; } match current_block { 2133922729242721719 => { } _ => { if (unsafe { (* pctxt) . nberrors }) != 0 as i32 { current_block = 3799963374263564300 ; } else { i = 0 as i32 ; loop { if ! (i < nbItems) { current_block = 6662862405959679103 ; break ; } item = unsafe { * items . offset (i as isize) } ; match (unsafe { (* item) . type_0 }) as u32 { 16 => { if ! (unsafe { (* (item as xmlSchemaAttributeGroupPtr)) . attrUses }) . is_null () && (unsafe { (* ((* (item as xmlSchemaAttributeGroupPtr)) . attrUses as xmlSchemaItemListPtr)) . nbItems }) > 1 as i32 { xmlSchemaCheckAGPropsCorrect (pctxt , item as xmlSchemaAttributeGroupPtr ,) ; if (unsafe { (* pctxt) . err }) == XML_SCHEMAP_INTERNAL as i32 { current_block = 2133922729242721719 ; break ; } } } _ => { } } i += 1 ; } match current_block { 2133922729242721719 => { } _ => { if (unsafe { (* pctxt) . nberrors }) != 0 as i32 { current_block = 3799963374263564300 ; } else { if ! (unsafe { (* (* pctxt) . constructor) . redefs }) . is_null () { xmlSchemaCheckSRCRedefineSecond (pctxt) ; } if (unsafe { (* pctxt) . nberrors }) != 0 as i32 { current_block = 3799963374263564300 ; } else { i = 0 as i32 ; loop { if ! (i < nbItems) { current_block = 13598848910332274892 ; break ; } item = (unsafe { * ((* (* con) . pending) . items) . offset (i as isize) }) as xmlSchemaTreeItemPtr ; match (unsafe { (* item) . type_0 }) as u32 { 5 => { if (unsafe { (* (item as xmlSchemaTypePtr)) . type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32 && (unsafe { (* (item as xmlSchemaTypePtr)) . flags }) & (1 as i32) << 22 as i32 == 0 as i32 { xmlSchemaFixupComplexType (pctxt , item as xmlSchemaTypePtr) ; if (unsafe { (* pctxt) . err }) == XML_SCHEMAP_INTERNAL as i32 { current_block = 2133922729242721719 ; break ; } } } _ => { } } i += 1 ; } match current_block { 2133922729242721719 => { } _ => { if (unsafe { (* pctxt) . nberrors }) != 0 as i32 { current_block = 3799963374263564300 ; } else { items = (unsafe { (* (* con) . pending) . items }) as * mut xmlSchemaTreeItemPtr ; nbItems = unsafe { (* (* con) . pending) . nbItems } ; i = 0 as i32 ; loop { if ! (i < nbItems) { current_block = 2277602629737488951 ; break ; } item = unsafe { * items . offset (i as isize) } ; match (unsafe { (* item) . type_0 }) as u32 { 14 => { elemDecl = item as xmlSchemaElementPtr ; if (unsafe { (* elemDecl) . flags }) & (1 as i32) << 18 as i32 == 0 as i32 { xmlSchemaCheckElementDeclComponent (elemDecl , pctxt) ; if (unsafe { (* pctxt) . err }) == XML_SCHEMAP_INTERNAL as i32 { current_block = 2133922729242721719 ; break ; } } } _ => { } } i += 1 ; } match current_block { 2133922729242721719 => { } _ => { if (unsafe { (* pctxt) . nberrors }) != 0 as i32 { current_block = 3799963374263564300 ; } else { i = 0 as i32 ; while i < nbItems { item = unsafe { * items . offset (i as isize) } ; match (unsafe { (* item) . type_0 }) as u32 { 5 => { xmlSchemaBuildContentModel (item as xmlSchemaTypePtr , pctxt) ; } _ => { } } i += 1 ; } if (unsafe { (* pctxt) . nberrors }) != 0 as i32 { current_block = 3799963374263564300 ; } else { current_block = 17463883078150051418 ; } } } } } } } } } } } } } } } } }
                                                                            }
                                                                        },
                                                                    }
                                                                }
                                                            },
                                                        }
                                                    }
                                                },
                                            }
                                        }
                                    },
                                }
                            }
                        }
                    },
                }
            }
            match current_block {
                17463883078150051418 => {},
                2133922729242721719 => {},
                _ => {
                    ret = unsafe { (*pctxt).err };
                    current_block = 17463883078150051418;
                },
            }
        },
        _ => {},
    }
    match current_block {
        2133922729242721719 => {
            ret = -(1 as i32);
        },
        _ => {},
    }
    let fresh423 = unsafe { &mut ((*con).bucket) };
    *fresh423 = oldbucket;
    (unsafe { (*(*con).pending).nbItems = 0 as i32 });
    if !(unsafe { (*con).substGroups }).is_null() {
        (unsafe { xmlHashFree((*con).substGroups, Some(xmlSchemaSubstGroupFreeEntry)) });
        let fresh424 = unsafe { &mut ((*con).substGroups) };
        *fresh424 = 0 as xmlHashTablePtr;
    }
    if !(unsafe { (*con).redefs }).is_null() {
        xmlSchemaRedefListFree(unsafe { (*con).redefs });
        let fresh425 = unsafe { &mut ((*con).redefs) };
        *fresh425 = 0 as xmlSchemaRedefPtr;
    }
    return ret;
}
#[no_mangle]
pub extern "C" fn xmlSchemaParse<'a1, 'a2>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
) -> *mut crate::src::xmlschemas::_xmlSchema<'a2>
where
    'a2: 'a1,
    'a2: 'static,
    'a1: 'a2,
{
    let mut current_block: u64;
    let mut mainSchema: *mut crate::src::xmlschemas::_xmlSchema<'_> = 0 as xmlSchemaPtr;
    let mut bucket: *mut crate::src::xmlschemas::_xmlSchemaBucket = 0 as xmlSchemaBucketPtr;
    let mut res: i32 = 0;
    xmlSchemaInitTypes();
    if ctxt.is_null() {
        return 0 as xmlSchemaPtr;
    }
    (unsafe { (*ctxt).nberrors = 0 as i32 });
    (unsafe { (*ctxt).err = 0 as i32 });
    (unsafe { (*ctxt).counter = 0 as i32 });
    mainSchema = xmlSchemaNewSchema(ctxt);
    if !mainSchema.is_null() {
        if (unsafe { (*ctxt).constructor }).is_null() {
            let fresh426 = unsafe { &mut ((*ctxt).constructor) };
            *fresh426 = xmlSchemaConstructionCtxtCreate(unsafe { (*ctxt).dict });
            if (unsafe { (*ctxt).constructor }).is_null() {
                return 0 as xmlSchemaPtr;
            }
            (unsafe { (*ctxt).ownsConstructor = 1 as i32 });
        }
        let fresh427 = unsafe { &mut ((*(*ctxt).constructor).mainSchema) };
        *fresh427 = mainSchema;
        res = xmlSchemaAddSchemaDoc(
            ctxt,
            0 as i32,
            unsafe { (*ctxt).URL },
            unsafe { (*ctxt).doc },
            unsafe { (*ctxt).buffer },
            unsafe { (*ctxt).size },
            0 as xmlNodePtr,
            0 as *const xmlChar,
            0 as *const xmlChar,
            Some(&mut bucket),
        );
        if !(res == -(1 as i32)) {
            if res != 0 as i32 {
                current_block = 7777198333657744202;
            } else if bucket.is_null() {
                if !(unsafe { (*ctxt).URL }).is_null() {
                    xmlSchemaCustomErr(
                        ctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_FAILED_LOAD,
                        0 as xmlNodePtr,
                        0 as xmlSchemaBasicItemPtr,
                        b"Failed to locate the main schema resource at '%s'\0" as *const u8
                            as *const i8,
                        unsafe { (*ctxt).URL },
                        0 as *const xmlChar,
                    );
                } else {
                    xmlSchemaCustomErr(
                        ctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAP_FAILED_LOAD,
                        0 as xmlNodePtr,
                        0 as xmlSchemaBasicItemPtr,
                        b"Failed to locate the main schema resource\0" as *const u8 as *const i8,
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                }
                current_block = 7777198333657744202;
            } else if xmlSchemaParseNewDocWithContext(ctxt, mainSchema, bucket) == -(1 as i32) {
                current_block = 4244197895050895038;
            } else if (unsafe { (*ctxt).nberrors }) != 0 as i32 {
                current_block = 7777198333657744202;
            } else {
                let fresh428 = unsafe { &mut ((*mainSchema).doc) };
                *fresh428 = unsafe { (*bucket).doc };
                (unsafe { (*mainSchema).preserve = (*ctxt).preserve });
                let fresh429 = unsafe { &mut ((*ctxt).schema) };
                *fresh429 = mainSchema;
                if xmlSchemaFixupComponents(ctxt, unsafe { (*(*ctxt).constructor).mainBucket }) == -(1 as i32)
                {
                    current_block = 4244197895050895038;
                } else {
                    current_block = 7777198333657744202;
                }
            }
            match current_block {
                4244197895050895038 => {},
                _ => {
                    if (unsafe { (*ctxt).nberrors }) != 0 as i32 {
                        if !mainSchema.is_null() {
                            xmlSchemaFree(mainSchema);
                            mainSchema = 0 as xmlSchemaPtr;
                        }
                        if !(unsafe { (*ctxt).constructor }).is_null() {
                            xmlSchemaConstructionCtxtFree(unsafe { (*ctxt).constructor });
                            let fresh430 = unsafe { &mut ((*ctxt).constructor) };
                            *fresh430 = 0 as xmlSchemaConstructionCtxtPtr;
                            (unsafe { (*ctxt).ownsConstructor = 0 as i32 });
                        }
                    }
                    let fresh431 = unsafe { &mut ((*ctxt).schema) };
                    *fresh431 = 0 as xmlSchemaPtr;
                    return mainSchema;
                },
            }
        }
    }
    if !mainSchema.is_null() {
        xmlSchemaFree(mainSchema);
        mainSchema = 0 as xmlSchemaPtr;
    }
    if !(unsafe { (*ctxt).constructor }).is_null() {
        xmlSchemaConstructionCtxtFree(unsafe { (*ctxt).constructor });
        let fresh432 = unsafe { &mut ((*ctxt).constructor) };
        *fresh432 = 0 as xmlSchemaConstructionCtxtPtr;
        (unsafe { (*ctxt).ownsConstructor = 0 as i32 });
    }
    xmlSchemaInternalErr(
        ctxt as xmlSchemaAbstractCtxtPtr,
        b"xmlSchemaParse\0" as *const u8 as *const i8,
        b"An internal error occurred\0" as *const u8 as *const i8,
    );
    let fresh433 = unsafe { &mut ((*ctxt).schema) };
    *fresh433 = 0 as xmlSchemaPtr;
    return 0 as xmlSchemaPtr;
}
#[no_mangle]
pub extern "C" fn xmlSchemaSetParserErrors<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut err: Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>,
    mut warn: Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>,
    mut ctx: *mut core::ffi::c_void,
) {
    if ctxt.is_null() {
        return;
    }
    let fresh434 = unsafe { &mut ((*ctxt).error) };
    *fresh434 = err;
    let fresh435 = unsafe { &mut ((*ctxt).warning) };
    *fresh435 = warn;
    let fresh436 = unsafe { &mut ((*ctxt).errCtxt) };
    *fresh436 = ctx;
    if !(unsafe { (*ctxt).vctxt }).is_null() {
        xmlSchemaSetValidErrors(unsafe { (*ctxt).vctxt }, err, warn, ctx);
    }
}
#[no_mangle]
pub extern "C" fn xmlSchemaSetParserStructuredErrors<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a1>,
    mut serror: Option<
        unsafe extern "C" fn(
            _: *mut core::ffi::c_void,
            _: *mut crate::src::threads::_xmlError,
        ) -> (),
    >,
    mut ctx: *mut core::ffi::c_void,
) {
    if ctxt.is_null() {
        return;
    }
    let fresh437 = unsafe { &mut ((*ctxt).serror) };
    *fresh437 = serror;
    let fresh438 = unsafe { &mut ((*ctxt).errCtxt) };
    *fresh438 = ctx;
    if !(unsafe { (*ctxt).vctxt }).is_null() {
        xmlSchemaSetValidStructuredErrors(unsafe { (*ctxt).vctxt }, serror, ctx);
    }
}
#[no_mangle]
pub extern "C" fn xmlSchemaGetParserErrors<'a1, 'a2, 'a3, 'a4, 'a5>(
    mut ctxt: Option<&'a1 mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'a2>>,
    mut err: Option<
        &'a3 mut Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>,
    >,
    mut warn: Option<
        &'a4 mut Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>,
    >,
    mut ctx: Option<&'a5 mut *mut core::ffi::c_void>,
) -> i32 {
    if borrow(&ctxt).is_none() {
        return -(1 as i32);
    }
    if !borrow(&err).is_none() {
        *(borrow_mut(&mut err)).unwrap() = (*(borrow_mut(&mut ctxt)).unwrap()).error;
    }
    if !borrow(&warn).is_none() {
        *(borrow_mut(&mut warn)).unwrap() = (*(borrow_mut(&mut ctxt)).unwrap()).warning;
    }
    if !borrow(&ctx).is_none() {
        *(borrow_mut(&mut ctx)).unwrap() = (*(borrow_mut(&mut ctxt)).unwrap()).errCtxt;
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaFacetTypeToString(mut type_0: u32) -> *const u8 {
    match type_0 as u32 {
        1006 => return b"pattern\0" as *const u8 as *const i8 as *mut xmlChar,
        1003 => {
            return b"maxExclusive\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        1002 => {
            return b"maxInclusive\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        1001 => {
            return b"minExclusive\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        1000 => {
            return b"minInclusive\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        1008 => {
            return b"whiteSpace\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        1007 => {
            return b"enumeration\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        1009 => return b"length\0" as *const u8 as *const i8 as *mut xmlChar,
        1010 => return b"maxLength\0" as *const u8 as *const i8 as *mut xmlChar,
        1011 => return b"minLength\0" as *const u8 as *const i8 as *mut xmlChar,
        1004 => {
            return b"totalDigits\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        1005 => {
            return b"fractionDigits\0" as *const u8 as *const i8 as *mut xmlChar;
        },
        _ => {},
    }
    return b"Internal Error\0" as *const u8 as *const i8 as *mut xmlChar;
}
extern "C" fn xmlSchemaGetWhiteSpaceFacetValue<'a1>(
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a1>,
) -> u32 {
    if (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32 {
        if (unsafe { (*type_0).builtInType }) == XML_SCHEMAS_STRING as i32
            || (unsafe { (*type_0).builtInType }) == XML_SCHEMAS_ANYSIMPLETYPE as i32
        {
            return XML_SCHEMA_WHITESPACE_PRESERVE;
        } else if (unsafe { (*type_0).builtInType }) == XML_SCHEMAS_NORMSTRING as i32 {
            return XML_SCHEMA_WHITESPACE_REPLACE;
        } else {
            return XML_SCHEMA_WHITESPACE_COLLAPSE;
        }
    } else {
        if (unsafe { (*type_0).flags }) & (1 as i32) << 6 as i32 != 0 {
            return XML_SCHEMA_WHITESPACE_COLLAPSE;
        } else {
            if (unsafe { (*type_0).flags }) & (1 as i32) << 7 as i32 != 0 {
                return XML_SCHEMA_WHITESPACE_UNKNOWN;
            } else {
                if (unsafe { (*type_0).flags }) & (1 as i32) << 8 as i32 != 0 {
                    if (unsafe { (*type_0).flags }) & (1 as i32) << 24 as i32 != 0 {
                        return XML_SCHEMA_WHITESPACE_PRESERVE;
                    } else if (unsafe { (*type_0).flags }) & (1 as i32) << 25 as i32 != 0 {
                        return XML_SCHEMA_WHITESPACE_REPLACE;
                    } else {
                        return XML_SCHEMA_WHITESPACE_COLLAPSE;
                    }
                }
            }
        }
    }
    return 4294967295 as xmlSchemaWhitespaceValueType;
}
extern "C" fn xmlSchemaAssembleByLocation<'a1, 'a2>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut nsName: *const u8,
    mut location: *const u8,
) -> i32
where
    'a2: 'a1,
    'a1: 'a2,
    'a1: 'static,
{
    let mut ret: i32 = 0 as i32;
    let mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'_> =
        0 as *mut xmlSchemaParserCtxt;
    let mut bucket: *mut crate::src::xmlschemas::_xmlSchemaBucket = 0 as xmlSchemaBucketPtr;
    if vctxt.is_null() || schema.is_null() {
        return -(1 as i32);
    }
    if (unsafe { (*vctxt).pctxt }).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaAssembleByLocation\0" as *const u8 as *const i8,
            b"no parser context available\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    pctxt = unsafe { (*vctxt).pctxt };
    if (unsafe { (*pctxt).constructor }).is_null() {
        xmlSchemaInternalErr(
            pctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaAssembleByLocation\0" as *const u8 as *const i8,
            b"no constructor\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    location = xmlSchemaBuildAbsoluteURI(unsafe { (*pctxt).dict }, location, node);
    ret = xmlSchemaAddSchemaDoc(
        pctxt,
        1 as i32,
        location,
        0 as xmlDocPtr,
        0 as *const i8,
        0 as i32,
        node,
        0 as *const xmlChar,
        nsName,
        Some(&mut bucket),
    );
    if ret != 0 as i32 {
        return ret;
    }
    if bucket.is_null() {
        xmlSchemaCustomWarning(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_MISC,
            node,
            Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaType<'_>>::None,
            b"The document at location '%s' could not be acquired\0" as *const u8 as *const i8,
            location,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return ret;
    }
    if !bucket.is_null() && (unsafe { (*(*pctxt).constructor).bucket }).is_null() {
        let fresh439 = unsafe { &mut ((*(*pctxt).constructor).bucket) };
        *fresh439 = bucket;
    }
    if bucket.is_null() || !(!(unsafe { (*bucket).doc }).is_null() && (unsafe { (*bucket).parsed }) == 0 as i32) {
        return 0 as i32;
    }
    (unsafe { (*pctxt).nberrors = 0 as i32 });
    (unsafe { (*pctxt).err = 0 as i32 });
    let fresh440 = unsafe { &mut ((*pctxt).doc) };
    *fresh440 = unsafe { (*bucket).doc };
    ret = xmlSchemaParseNewDocWithContext(pctxt, schema, bucket);
    if ret == -(1 as i32) {
        let fresh441 = unsafe { &mut ((*pctxt).doc) };
        *fresh441 = 0 as xmlDocPtr;
        let fresh443 = unsafe { &mut ((*pctxt).doc) };
        *fresh443 = 0 as xmlDocPtr;
        return -(1 as i32);
    } else {
        if ret == 0 as i32 && (unsafe { (*pctxt).nberrors }) != 0 as i32 {
            ret = unsafe { (*pctxt).err };
        }
        if (unsafe { (*pctxt).nberrors }) == 0 as i32 {
            xmlSchemaFixupComponents(pctxt, bucket);
            ret = unsafe { (*pctxt).err };
            if ret != 0 as i32 && (unsafe { (*vctxt).err }) == 0 as i32 {
                (unsafe { (*vctxt).err = ret });
            }
            (unsafe { (*vctxt).nberrors += (*pctxt).nberrors });
        } else {
            (unsafe { (*vctxt).nberrors += (*pctxt).nberrors });
        }
        let fresh442 = unsafe { &mut ((*pctxt).doc) };
        *fresh442 = 0 as xmlDocPtr;
        return ret;
    };
}
extern "C" fn xmlSchemaGetMetaAttrInfo<'a1, 'a2>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut metaType: i32,
) -> *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'a2>
where
    'a2: 'a1,
    'a1: 'a2,
{
    if (unsafe { (*vctxt).nbAttrInfos }) == 0 as i32 {
        return 0 as xmlSchemaAttrInfoPtr;
    }
    let mut i: i32 = 0;
    let mut iattr: *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'_> =
        0 as *mut xmlSchemaAttrInfo;
    i = 0 as i32;
    while i < (unsafe { (*vctxt).nbAttrInfos }) {
        iattr = unsafe { *((*vctxt).attrInfos).offset(i as isize) };
        if (unsafe { (*iattr).metaType }) == metaType {
            return iattr;
        }
        i += 1;
    }
    return 0 as xmlSchemaAttrInfoPtr;
}
extern "C" fn xmlSchemaAssembleByXSI<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> i32
where
    'a1: 'static,
{
    let mut cur: *const u8 = 0 as *const xmlChar;
    let mut end: *const u8 = 0 as *const xmlChar;
    let mut nsname: *const u8 = 0 as *const xmlChar;
    let mut location: *const u8 = 0 as *const xmlChar;
    let mut count: i32 = 0 as i32;
    let mut ret: i32 = 0 as i32;
    let mut iattr: *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'_> =
        0 as *mut xmlSchemaAttrInfo;
    iattr = xmlSchemaGetMetaAttrInfo(vctxt, 3 as i32);
    if iattr.is_null() {
        iattr = xmlSchemaGetMetaAttrInfo(vctxt, 4 as i32);
    }
    if iattr.is_null() {
        return 0 as i32;
    }
    cur = unsafe { (*iattr).value };
    loop {
        if (unsafe { (*iattr).metaType }) == 3 as i32 {
            while (unsafe { *cur }) as i32 == 0x20 as i32
                || 0x9 as i32 <= (unsafe { *cur }) as i32 && (unsafe { *cur }) as i32 <= 0xa as i32
                || (unsafe { *cur }) as i32 == 0xd as i32
            {
                cur = unsafe { cur.offset(1) };
            }
            end = cur;
            while (unsafe { *end }) as i32 != 0 as i32
                && !((unsafe { *end }) as i32 == 0x20 as i32
                    || 0x9 as i32 <= (unsafe { *end }) as i32 && (unsafe { *end }) as i32 <= 0xa as i32
                    || (unsafe { *end }) as i32 == 0xd as i32)
            {
                end = unsafe { end.offset(1) };
            }
            if end == cur {
                break;
            }
            count += 1;
            nsname = unsafe { xmlDictLookup(
                (*(*vctxt).schema).dict,
                cur,
                end.offset_from(cur) as i64 as i32,
            ) };
            cur = end;
        }
        while (unsafe { *cur }) as i32 == 0x20 as i32
            || 0x9 as i32 <= (unsafe { *cur }) as i32 && (unsafe { *cur }) as i32 <= 0xa as i32
            || (unsafe { *cur }) as i32 == 0xd as i32
        {
            cur = unsafe { cur.offset(1) };
        }
        end = cur;
        while (unsafe { *end }) as i32 != 0 as i32
            && !((unsafe { *end }) as i32 == 0x20 as i32
                || 0x9 as i32 <= (unsafe { *end }) as i32 && (unsafe { *end }) as i32 <= 0xa as i32
                || (unsafe { *end }) as i32 == 0xd as i32)
        {
            end = unsafe { end.offset(1) };
        }
        if end == cur {
            if (unsafe { (*iattr).metaType }) == 3 as i32 {
                xmlSchemaCustomWarning (vctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAV_MISC , unsafe { (* iattr) . node } , Option :: < & '_ mut crate :: src :: xmlschemas :: _xmlSchemaType < '_ > > :: None , b"The value must consist of tuples: the target namespace name and the document's URI\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
            }
            break;
        } else {
            count += 1;
            location = unsafe { xmlDictLookup(
                (*(*vctxt).schema).dict,
                cur,
                end.offset_from(cur) as i64 as i32,
            ) };
            cur = end;
            ret = xmlSchemaAssembleByLocation(
                vctxt,
                unsafe { (*vctxt).schema },
                unsafe { (*iattr).node },
                nsname,
                location,
            );
            if ret == -(1 as i32) {
                xmlSchemaInternalErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaAssembleByXSI\0" as *const u8 as *const i8,
                    b"assembling schemata\0" as *const u8 as *const i8,
                );
                return -(1 as i32);
            }
            if !((unsafe { *cur }) as i32 != 0 as i32) {
                break;
            }
        }
    }
    return ret;
}
extern "C" fn xmlSchemaLookupNamespace<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut prefix: *const u8,
) -> *const u8 {
    if !(unsafe { (*vctxt).sax }).is_null() {
        let mut i: i32 = 0;
        let mut j: i32 = 0;
        let mut inode: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'_> =
            0 as *mut xmlSchemaNodeInfo;
        i = unsafe { (*vctxt).depth };
        while i >= 0 as i32 {
            if (unsafe { (**((*vctxt).elemInfos).offset(i as isize)).nbNsBindings }) != 0 as i32 {
                inode = unsafe { *((*vctxt).elemInfos).offset(i as isize) };
                j = 0 as i32;
                while j < (unsafe { (*inode).nbNsBindings }) * 2 as i32 {
                    if prefix.is_null() && (unsafe { *((*inode).nsBindings).offset(j as isize) }).is_null()
                        || !prefix.is_null()
                            && xmlStrEqual(prefix, unsafe { *((*inode).nsBindings).offset(j as isize) }) != 0
                    {
                        return unsafe { *((*inode).nsBindings).offset((j + 1 as i32) as isize) };
                    }
                    j += 2 as i32;
                }
            }
            i -= 1;
        }
        return 0 as *const xmlChar;
    } else if !borrow(unsafe { &((*vctxt).reader) }).is_none() {
        let mut nsName: *mut u8 = 0 as *mut xmlChar;
        nsName = xmlTextReaderLookupNamespace(borrow_mut(unsafe { &mut (*vctxt).reader }), prefix);
        if !nsName.is_null() {
            let mut ret: *const u8 = 0 as *const xmlChar;
            ret = unsafe { xmlDictLookup((*vctxt).dict, nsName, -(1 as i32)) };
            (unsafe { xmlFree.expect("non-null function pointer")(nsName as *mut libc::c_void) });
            return ret;
        } else {
            return 0 as *const xmlChar;
        }
    } else {
        let mut ns: *mut crate::src::threads::_xmlNs = 0 as *mut xmlNs;
        if (unsafe { (*(*vctxt).inode).node }).is_null() || (unsafe { (*(*(*vctxt).inode).node).doc }).is_null() {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaLookupNamespace\0" as *const u8 as *const i8,
                b"no node or node's doc available\0" as *const u8 as *const i8,
            );
            return 0 as *const xmlChar;
        }
        ns = xmlSearchNs(
            unsafe { (*(*(*vctxt).inode).node).doc },
            unsafe { (*(*vctxt).inode).node },
            prefix,
        );
        if !ns.is_null() {
            return unsafe { (*ns).href };
        }
        return 0 as *const xmlChar;
    };
}
extern "C" fn xmlSchemaValidateNotation<'a1, 'a2, 'a3>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a2>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut value: *const u8,
    mut val: Option<&'a3 mut *mut crate::src::xmlschemastypes::_xmlSchemaVal>,
    mut valNeeded: i32,
) -> i32 {
    let mut ret: i32 = 0;
    if !vctxt.is_null() && (unsafe { (*vctxt).schema }).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaValidateNotation\0" as *const u8 as *const i8,
            b"a schema is needed on the validation context\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    ret = xmlValidateQName(value, 1 as i32);
    if ret != 0 as i32 {
        return ret;
    }
    let mut localName: *mut u8 = 0 as *mut xmlChar;
    let mut prefix: *mut u8 = 0 as *mut xmlChar;
    localName = xmlSplitQName2(value, Some(&mut prefix));
    if !prefix.is_null() {
        let mut nsName: *const u8 = 0 as *const xmlChar;
        if !vctxt.is_null() {
            nsName = xmlSchemaLookupNamespace(vctxt, prefix);
        } else if !node.is_null() {
            let mut ns: *mut crate::src::threads::_xmlNs = xmlSearchNs(unsafe { (*node).doc }, node, prefix);
            if !ns.is_null() {
                nsName = unsafe { (*ns).href };
            }
        } else {
            (unsafe { xmlFree.expect("non-null function pointer")(prefix as *mut libc::c_void) });
            (unsafe { xmlFree.expect("non-null function pointer")(localName as *mut libc::c_void) });
            return 1 as i32;
        }
        if nsName.is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(prefix as *mut libc::c_void) });
            (unsafe { xmlFree.expect("non-null function pointer")(localName as *mut libc::c_void) });
            return 1 as i32;
        }
        if !(xmlSchemaGetNotation(schema, localName, nsName)).is_null() {
            if valNeeded != 0 && !borrow(&val).is_none() {
                *(borrow_mut(&mut val)).unwrap() =
                    xmlSchemaNewNOTATIONValue(xmlStrdup(localName), xmlStrdup(nsName));
                if (*(borrow(&val)).unwrap()).is_null() {
                    ret = -(1 as i32);
                }
            }
        } else {
            ret = 1 as i32;
        }
        (unsafe { xmlFree.expect("non-null function pointer")(prefix as *mut libc::c_void) });
        (unsafe { xmlFree.expect("non-null function pointer")(localName as *mut libc::c_void) });
    } else if !(xmlSchemaGetNotation(schema, value, 0 as *const xmlChar)).is_null() {
        if valNeeded != 0 && !borrow(&val).is_none() {
            *(borrow_mut(&mut val)).unwrap() =
                xmlSchemaNewNOTATIONValue(xmlStrdup(value), 0 as *const xmlChar);
            if (*(borrow(&val)).unwrap()).is_null() {
                ret = -(1 as i32);
            }
        }
    } else {
        return 1 as i32;
    }
    return ret;
}
extern "C" fn xmlSchemaVAddNodeQName<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut lname: *const u8,
    mut nsname: *const u8,
) -> i32 {
    let mut i: i32 = 0;
    lname = unsafe { xmlDictLookup((*vctxt).dict, lname, -(1 as i32)) };
    if lname.is_null() {
        return -(1 as i32);
    }
    if !nsname.is_null() {
        nsname = unsafe { xmlDictLookup((*vctxt).dict, nsname, -(1 as i32)) };
        if nsname.is_null() {
            return -(1 as i32);
        }
    }
    i = 0 as i32;
    while i < (unsafe { (*(*vctxt).nodeQNames).nbItems }) {
        if (unsafe { *((*(*vctxt).nodeQNames).items).offset(i as isize) }) == lname as *mut libc::c_void
            && (unsafe { *((*(*vctxt).nodeQNames).items).offset((i + 1 as i32) as isize) })
                == nsname as *mut libc::c_void
        {
            return i;
        }
        i += 2 as i32;
    }
    i = unsafe { (*(*vctxt).nodeQNames).nbItems };
    xmlSchemaItemListAdd(unsafe { (*vctxt).nodeQNames }, lname as *mut libc::c_void);
    xmlSchemaItemListAdd(unsafe { (*vctxt).nodeQNames }, nsname as *mut libc::c_void);
    return i;
}
extern "C" fn xmlSchemaAugmentIDC(
    mut payload: *mut core::ffi::c_void,
    mut data: *mut core::ffi::c_void,
    mut _name: *const u8,
) {
    let mut idcDef: *mut crate::src::xmlschemas::_xmlSchemaIDC<'_> = payload as xmlSchemaIDCPtr;
    let mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'_> =
        data as xmlSchemaValidCtxtPtr;
    let mut aidc: *mut crate::src::xmlschemas::_xmlSchemaIDCAug<'_> = 0 as *mut xmlSchemaIDCAug;
    aidc = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaIDCAug>() as u64
    ) }) as xmlSchemaIDCAugPtr;
    if aidc.is_null() {
        xmlSchemaVErrMemory(
            vctxt,
            b"xmlSchemaAugmentIDC: allocating an augmented IDC definition\0" as *const u8
                as *const i8,
            0 as xmlNodePtr,
        );
        return;
    }
    (unsafe { (*aidc).keyrefDepth = -(1 as i32) });
    let fresh444 = unsafe { &mut ((*aidc).def) };
    *fresh444 = idcDef;
    let fresh445 = unsafe { &mut ((*aidc).next) };
    *fresh445 = 0 as xmlSchemaIDCAugPtr;
    if (unsafe { (*vctxt).aidcs }).is_null() {
        let fresh446 = unsafe { &mut ((*vctxt).aidcs) };
        *fresh446 = aidc;
    } else {
        let fresh447 = unsafe { &mut ((*aidc).next) };
        *fresh447 = unsafe { (*vctxt).aidcs };
        let fresh448 = unsafe { &mut ((*vctxt).aidcs) };
        *fresh448 = aidc;
    }
    if (unsafe { (*vctxt).hasKeyrefs }) == 0 as i32
        && (unsafe { (*idcDef).type_0 }) as u32 == XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
    {
        (unsafe { (*vctxt).hasKeyrefs = 1 as i32 });
    }
}
extern "C" fn xmlSchemaAugmentImportedIDC(
    mut payload: *mut core::ffi::c_void,
    mut data: *mut core::ffi::c_void,
    mut _name: *const u8,
) {
    let mut imported: *mut crate::src::xmlschemas::_xmlSchemaImport<'_> =
        payload as xmlSchemaImportPtr;
    let mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'_> =
        data as xmlSchemaValidCtxtPtr;
    if !(unsafe { (*(*imported).schema).idcDef }).is_null() {
        (unsafe { xmlHashScan(
            (*(*imported).schema).idcDef,
            Some(xmlSchemaAugmentIDC),
            vctxt as *mut libc::c_void,
        ) });
    }
}
extern "C" fn xmlSchemaIDCNewBinding<'a1, 'a2>(
    mut idcDef: *mut crate::src::xmlschemas::_xmlSchemaIDC<'a1>,
) -> *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'a2>
where
    'a2: 'a1,
    'a1: 'a2,
{
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'_> =
        0 as *mut xmlSchemaPSVIIDCBinding;
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaPSVIIDCBinding>() as u64,
    ) }) as xmlSchemaPSVIIDCBindingPtr;
    if ret.is_null() {
        xmlSchemaVErrMemory(
            0 as xmlSchemaValidCtxtPtr,
            b"allocating a PSVI IDC binding item\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaPSVIIDCBindingPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaPSVIIDCBinding>() as u64,
    ) });
    let fresh449 = unsafe { &mut ((*ret).definition) };
    *fresh449 = idcDef;
    return ret;
}
extern "C" fn xmlSchemaIDCStoreNodeTableItem<'a1, 'a2>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut item: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'a2>,
) -> i32
where
    'a1: 'a2,
    'a2: 'a1,
{
    if (unsafe { (*vctxt).idcNodes }).is_null() {
        let fresh450 = unsafe { &mut ((*vctxt).idcNodes) };
        *fresh450 = (unsafe { xmlMalloc.expect("non-null function pointer")(
            (20 as i32 as u64)
                .wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>() as u64),
        ) }) as *mut xmlSchemaPSVIIDCNodePtr;
        if (unsafe { (*vctxt).idcNodes }).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"allocating the IDC node table item list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
        (unsafe { (*vctxt).sizeIdcNodes = 20 as i32 });
    } else if (unsafe { (*vctxt).sizeIdcNodes }) <= (unsafe { (*vctxt).nbIdcNodes }) {
        (unsafe { (*vctxt).sizeIdcNodes *= 2 as i32 });
        let fresh451 = unsafe { &mut ((*vctxt).idcNodes) };
        *fresh451 = (unsafe { xmlRealloc.expect("non-null function pointer")(
            (*vctxt).idcNodes as *mut libc::c_void,
            ((*vctxt).sizeIdcNodes as u64)
                .wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>() as u64),
        ) }) as *mut xmlSchemaPSVIIDCNodePtr;
        if (unsafe { (*vctxt).idcNodes }).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"re-allocating the IDC node table item list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
    }
    let fresh452 = unsafe { &mut ((*vctxt).nbIdcNodes) };
    let mut fresh453 = *fresh452;
    *fresh452 = *fresh452 + 1;
    let fresh454 = unsafe { &mut (*((*vctxt).idcNodes).offset(fresh453 as isize)) };
    *fresh454 = item;
    return 0 as i32;
}
extern "C" fn xmlSchemaIDCStoreKey<'a1, 'a2>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut key: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'a2>,
) -> i32
where
    'a1: 'a2,
    'a2: 'a1,
{
    if (unsafe { (*vctxt).idcKeys }).is_null() {
        let fresh455 = unsafe { &mut ((*vctxt).idcKeys) };
        *fresh455 = (unsafe { xmlMalloc.expect("non-null function pointer")(
            (40 as i32 as u64).wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCKeyPtr>() as u64),
        ) }) as *mut xmlSchemaPSVIIDCKeyPtr;
        if (unsafe { (*vctxt).idcKeys }).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"allocating the IDC key storage list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
        (unsafe { (*vctxt).sizeIdcKeys = 40 as i32 });
    } else if (unsafe { (*vctxt).sizeIdcKeys }) <= (unsafe { (*vctxt).nbIdcKeys }) {
        (unsafe { (*vctxt).sizeIdcKeys *= 2 as i32 });
        let fresh456 = unsafe { &mut ((*vctxt).idcKeys) };
        *fresh456 = (unsafe { xmlRealloc.expect("non-null function pointer")(
            (*vctxt).idcKeys as *mut libc::c_void,
            ((*vctxt).sizeIdcKeys as u64)
                .wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCKeyPtr>() as u64),
        ) }) as *mut xmlSchemaPSVIIDCKeyPtr;
        if (unsafe { (*vctxt).idcKeys }).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"re-allocating the IDC key storage list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
    }
    let fresh457 = unsafe { &mut ((*vctxt).nbIdcKeys) };
    let mut fresh458 = *fresh457;
    *fresh457 = *fresh457 + 1;
    let fresh459 = unsafe { &mut (*((*vctxt).idcKeys).offset(fresh458 as isize)) };
    *fresh459 = key;
    return 0 as i32;
}
extern "C" fn xmlSchemaIDCAppendNodeTableItem<'a1, 'a2>(
    mut bind: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'a1>,
    mut ntItem: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'a2>,
) -> i32
where
    'a2: 'a1,
    'a1: 'a2,
{
    if (unsafe { (*bind).nodeTable }).is_null() {
        (unsafe { (*bind).sizeNodes = 10 as i32 });
        let fresh460 = unsafe { &mut ((*bind).nodeTable) };
        *fresh460 = (unsafe { xmlMalloc.expect("non-null function pointer")(
            (10 as i32 as u64)
                .wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>() as u64),
        ) }) as *mut xmlSchemaPSVIIDCNodePtr;
        if (unsafe { (*bind).nodeTable }).is_null() {
            xmlSchemaVErrMemory(
                0 as xmlSchemaValidCtxtPtr,
                b"allocating an array of IDC node-table items\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
    } else if (unsafe { (*bind).sizeNodes }) <= (unsafe { (*bind).nbNodes }) {
        (unsafe { (*bind).sizeNodes *= 2 as i32 });
        let fresh461 = unsafe { &mut ((*bind).nodeTable) };
        *fresh461 = (unsafe { xmlRealloc.expect("non-null function pointer")(
            (*bind).nodeTable as *mut libc::c_void,
            ((*bind).sizeNodes as u64)
                .wrapping_mul(::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>() as u64),
        ) }) as *mut xmlSchemaPSVIIDCNodePtr;
        if (unsafe { (*bind).nodeTable }).is_null() {
            xmlSchemaVErrMemory(
                0 as xmlSchemaValidCtxtPtr,
                b"re-allocating an array of IDC node-table items\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
    }
    let fresh462 = unsafe { &mut ((*bind).nbNodes) };
    let mut fresh463 = *fresh462;
    *fresh462 = *fresh462 + 1;
    let fresh464 = unsafe { &mut (*((*bind).nodeTable).offset(fresh463 as isize)) };
    *fresh464 = ntItem;
    return 0 as i32;
}
extern "C" fn xmlSchemaIDCAcquireBinding<'a1, 'a2, 'a3>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut matcher: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'a2>,
) -> *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'a3>
where
    'a1: 'a3,
    'a3: 'a2,
    'a3: 'a1,
    'a2: 'a3,
{
    let mut ielem: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'_> =
        0 as *mut xmlSchemaNodeInfo;
    ielem = unsafe { *((*vctxt).elemInfos).offset((*matcher).depth as isize) };
    if (unsafe { (*ielem).idcTable }).is_null() {
        let fresh465 = unsafe { &mut ((*ielem).idcTable) };
        *fresh465 = xmlSchemaIDCNewBinding(unsafe { (*(*matcher).aidc).def });
        if (unsafe { (*ielem).idcTable }).is_null() {
            return 0 as xmlSchemaPSVIIDCBindingPtr;
        }
        return unsafe { (*ielem).idcTable };
    } else {
        let mut bind: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'_> =
            0 as xmlSchemaPSVIIDCBindingPtr;
        bind = unsafe { (*ielem).idcTable };
        loop {
            if (unsafe { (*bind).definition }) == (unsafe { (*(*matcher).aidc).def }) {
                return bind;
            }
            if (unsafe { (*bind).next }).is_null() {
                let fresh466 = unsafe { &mut ((*bind).next) };
                *fresh466 = xmlSchemaIDCNewBinding(unsafe { (*(*matcher).aidc).def });
                if (unsafe { (*bind).next }).is_null() {
                    return 0 as xmlSchemaPSVIIDCBindingPtr;
                }
                return unsafe { (*bind).next };
            }
            bind = unsafe { (*bind).next };
            if bind.is_null() {
                break;
            }
        }
    }
    return 0 as xmlSchemaPSVIIDCBindingPtr;
}
extern "C" fn xmlSchemaIDCAcquireTargetList<'a1, 'a2>(
    mut _vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut matcher: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'a2>,
) -> *mut crate::src::xmlschemas::_xmlSchemaItemList {
    if (unsafe { (*matcher).targets }).is_null() {
        let fresh467 = unsafe { &mut ((*matcher).targets) };
        *fresh467 = xmlSchemaItemListCreate();
    }
    return unsafe { (*matcher).targets };
}
extern "C" fn xmlSchemaIDCFreeKey<'a1>(
    mut key: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'a1>,
) {
    if !(unsafe { (*key).val }).is_null() {
        xmlSchemaFreeValue(unsafe { (*key).val });
    }
    (unsafe { xmlFree.expect("non-null function pointer")(key as *mut libc::c_void) });
}
extern "C" fn xmlSchemaIDCFreeBinding<'a1>(
    mut bind: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'a1>,
) {
    if !(unsafe { (*bind).nodeTable }).is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")((*bind).nodeTable as *mut libc::c_void) });
    }
    if !(unsafe { (*bind).dupls }).is_null() {
        xmlSchemaItemListFree(unsafe { (*bind).dupls });
    }
    (unsafe { xmlFree.expect("non-null function pointer")(bind as *mut libc::c_void) });
}
extern "C" fn xmlSchemaIDCFreeIDCTable<'a1>(
    mut bind: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'a1>,
) {
    let mut prev: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'_> =
        0 as *mut xmlSchemaPSVIIDCBinding;
    while !bind.is_null() {
        prev = bind;
        bind = unsafe { (*bind).next };
        xmlSchemaIDCFreeBinding(prev);
    }
}
extern "C" fn xmlFreeIDCHashEntry(mut payload: *mut core::ffi::c_void, mut _name: *const u8) {
    let mut e: *mut crate::src::xmlschemas::_xmlIDCHashEntry = payload as xmlIDCHashEntryPtr;
    let mut n: *mut crate::src::xmlschemas::_xmlIDCHashEntry = 0 as *mut xmlIDCHashEntry;
    while !e.is_null() {
        n = unsafe { (*e).next };
        (unsafe { xmlFree.expect("non-null function pointer")(e as *mut libc::c_void) });
        e = n;
    }
}
extern "C" fn xmlSchemaIDCFreeMatcherList<'a1>(
    mut matcher: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'a1>,
) {
    let mut next: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'_> =
        0 as *mut xmlSchemaIDCMatcher;
    while !matcher.is_null() {
        next = unsafe { (*matcher).next };
        if !(unsafe { (*matcher).keySeqs }).is_null() {
            let mut i: i32 = 0;
            i = 0 as i32;
            while i < (unsafe { (*matcher).sizeKeySeqs }) {
                if !(unsafe { *((*matcher).keySeqs).offset(i as isize) }).is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(
                        *((*matcher).keySeqs).offset(i as isize) as *mut libc::c_void,
                    ) });
                }
                i += 1;
            }
            (unsafe { xmlFree.expect("non-null function pointer")((*matcher).keySeqs as *mut libc::c_void) });
        }
        if !(unsafe { (*matcher).targets }).is_null() {
            if (unsafe { (*matcher).idcType }) == XML_SCHEMA_TYPE_IDC_KEYREF as i32 {
                let mut i_0: i32 = 0;
                let mut idcNode: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'_> =
                    0 as *mut xmlSchemaPSVIIDCNode;
                i_0 = 0 as i32;
                while i_0 < (unsafe { (*(*matcher).targets).nbItems }) {
                    idcNode = (unsafe { *((*(*matcher).targets).items).offset(i_0 as isize) })
                        as xmlSchemaPSVIIDCNodePtr;
                    (unsafe { xmlFree.expect("non-null function pointer")(
                        (*idcNode).keys as *mut libc::c_void,
                    ) });
                    (unsafe { xmlFree.expect("non-null function pointer")(idcNode as *mut libc::c_void) });
                    i_0 += 1;
                }
            }
            xmlSchemaItemListFree(unsafe { (*matcher).targets });
        }
        if !(unsafe { (*matcher).htab }).is_null() {
            (unsafe { xmlHashFree((*matcher).htab, Some(xmlFreeIDCHashEntry)) });
        }
        (unsafe { xmlFree.expect("non-null function pointer")(matcher as *mut libc::c_void) });
        matcher = next;
    }
}
extern "C" fn xmlSchemaIDCReleaseMatcherList<'a1, 'a2>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut matcher: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'a2>,
) where
    'a2: 'a1,
    'a1: 'a2,
{
    let mut next: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'_> =
        0 as *mut xmlSchemaIDCMatcher;
    while !matcher.is_null() {
        next = unsafe { (*matcher).next };
        if !(unsafe { (*matcher).keySeqs }).is_null() {
            let mut i: i32 = 0;
            i = 0 as i32;
            while i < (unsafe { (*matcher).sizeKeySeqs }) {
                if !(unsafe { *((*matcher).keySeqs).offset(i as isize) }).is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(
                        *((*matcher).keySeqs).offset(i as isize) as *mut libc::c_void,
                    ) });
                    let fresh468 = unsafe { &mut (*((*matcher).keySeqs).offset(i as isize)) };
                    *fresh468 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                }
                i += 1;
            }
        }
        if !(unsafe { (*matcher).targets }).is_null() {
            if (unsafe { (*matcher).idcType }) == XML_SCHEMA_TYPE_IDC_KEYREF as i32 {
                let mut i_0: i32 = 0;
                let mut idcNode: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'_> =
                    0 as *mut xmlSchemaPSVIIDCNode;
                i_0 = 0 as i32;
                while i_0 < (unsafe { (*(*matcher).targets).nbItems }) {
                    idcNode = (unsafe { *((*(*matcher).targets).items).offset(i_0 as isize) })
                        as xmlSchemaPSVIIDCNodePtr;
                    (unsafe { xmlFree.expect("non-null function pointer")(
                        (*idcNode).keys as *mut libc::c_void,
                    ) });
                    (unsafe { xmlFree.expect("non-null function pointer")(idcNode as *mut libc::c_void) });
                    i_0 += 1;
                }
            }
            xmlSchemaItemListFree(unsafe { (*matcher).targets });
            let fresh469 = unsafe { &mut ((*matcher).targets) };
            *fresh469 = 0 as xmlSchemaItemListPtr;
        }
        if !(unsafe { (*matcher).htab }).is_null() {
            (unsafe { xmlHashFree((*matcher).htab, Some(xmlFreeIDCHashEntry)) });
            let fresh470 = unsafe { &mut ((*matcher).htab) };
            *fresh470 = 0 as xmlHashTablePtr;
        }
        let fresh471 = unsafe { &mut ((*matcher).next) };
        *fresh471 = 0 as xmlSchemaIDCMatcherPtr;
        if !(unsafe { (*vctxt).idcMatcherCache }).is_null() {
            let fresh472 = unsafe { &mut ((*matcher).nextCached) };
            *fresh472 = unsafe { (*vctxt).idcMatcherCache };
        }
        let fresh473 = unsafe { &mut ((*vctxt).idcMatcherCache) };
        *fresh473 = matcher;
        matcher = next;
    }
}
extern "C" fn xmlSchemaIDCAddStateObject<'a1, 'a2, 'a3>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut matcher: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'a2>,
    mut sel: *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'a3>,
    mut type_0: i32,
) -> i32
where
    'a3: 'a2,
    'a3: 'a1,
    'a1: 'a3,
    'a2: 'a3,
{
    let mut sto: *mut crate::src::xmlschemas::_xmlSchemaIDCStateObj<'_> =
        0 as *mut xmlSchemaIDCStateObj;
    if !(unsafe { (*vctxt).xpathStatePool }).is_null() {
        sto = unsafe { (*vctxt).xpathStatePool };
        let fresh474 = unsafe { &mut ((*vctxt).xpathStatePool) };
        *fresh474 = unsafe { (*sto).next };
        let fresh475 = unsafe { &mut ((*sto).next) };
        *fresh475 = 0 as xmlSchemaIDCStateObjPtr;
    } else {
        sto = (unsafe { xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<
            xmlSchemaIDCStateObj,
        >() as u64) }) as xmlSchemaIDCStateObjPtr;
        if sto.is_null() {
            xmlSchemaVErrMemory(
                0 as xmlSchemaValidCtxtPtr,
                b"allocating an IDC state object\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return -(1 as i32);
        }
        (unsafe { memset(
            sto as *mut libc::c_void,
            0 as i32,
            ::std::mem::size_of::<xmlSchemaIDCStateObj>() as u64,
        ) });
    }
    if !(unsafe { (*vctxt).xpathStates }).is_null() {
        let fresh476 = unsafe { &mut ((*sto).next) };
        *fresh476 = unsafe { (*vctxt).xpathStates };
    }
    let fresh477 = unsafe { &mut ((*vctxt).xpathStates) };
    *fresh477 = sto;
    if !(unsafe { (*sto).xpathCtxt }).is_null() {
        (unsafe { xmlFreeStreamCtxt((*sto).xpathCtxt as xmlStreamCtxtPtr) });
    }
    let fresh478 = unsafe { &mut ((*sto).xpathCtxt) };
    *fresh478 = (unsafe { xmlPatternGetStreamCtxt((*sel).xpathComp as xmlPatternPtr) }) as *mut libc::c_void;
    if (unsafe { (*sto).xpathCtxt }).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaIDCAddStateObject\0" as *const u8 as *const i8,
            b"failed to create an XPath validation context\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    (unsafe { (*sto).type_0 = type_0 });
    (unsafe { (*sto).depth = (*vctxt).depth });
    let fresh479 = unsafe { &mut ((*sto).matcher) };
    *fresh479 = matcher;
    let fresh480 = unsafe { &mut ((*sto).sel) };
    *fresh480 = sel;
    (unsafe { (*sto).nbHistory = 0 as i32 });
    return 0 as i32;
}
extern "C" fn xmlSchemaXPathEvaluate<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut nodeType: u32,
) -> i32 {
    let mut sto: *mut crate::src::xmlschemas::_xmlSchemaIDCStateObj<'_> =
        0 as *mut xmlSchemaIDCStateObj;
    let mut head: *mut crate::src::xmlschemas::_xmlSchemaIDCStateObj<'_> =
        0 as xmlSchemaIDCStateObjPtr;
    let mut first: *mut crate::src::xmlschemas::_xmlSchemaIDCStateObj<'_> =
        0 as *mut xmlSchemaIDCStateObj;
    let mut res: i32 = 0;
    let mut resolved: i32 = 0 as i32;
    let mut depth: i32 = unsafe { (*vctxt).depth };
    if (unsafe { (*vctxt).xpathStates }).is_null() {
        return 0 as i32;
    }
    if nodeType as u32 == XML_ATTRIBUTE_NODE as i32 as u32 {
        depth += 1;
    }
    first = unsafe { (*vctxt).xpathStates };
    sto = first;
    while sto != head {
        if nodeType as u32 == XML_ELEMENT_NODE as i32 as u32 {
            res = unsafe { xmlStreamPush(
                (*sto).xpathCtxt as xmlStreamCtxtPtr,
                (*(*vctxt).inode).localName,
                (*(*vctxt).inode).nsName,
            ) };
        } else {
            res = unsafe { xmlStreamPushAttr(
                (*sto).xpathCtxt as xmlStreamCtxtPtr,
                (*(*vctxt).inode).localName,
                (*(*vctxt).inode).nsName,
            ) };
        }
        if res == -(1 as i32) {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaXPathEvaluate\0" as *const u8 as *const i8,
                b"calling xmlStreamPush()\0" as *const u8 as *const i8,
            );
            return -(1 as i32);
        }
        if !(res == 0 as i32) {
            if (unsafe { (*sto).history }).is_null() {
                let fresh481 = unsafe { &mut ((*sto).history) };
                *fresh481 = (unsafe { xmlMalloc.expect("non-null function pointer")(
                    (5 as i32 as u64).wrapping_mul(::std::mem::size_of::<i32>() as u64),
                ) }) as *mut i32;
                if (unsafe { (*sto).history }).is_null() {
                    xmlSchemaVErrMemory(
                        0 as xmlSchemaValidCtxtPtr,
                        b"allocating the state object history\0" as *const u8 as *const i8,
                        0 as xmlNodePtr,
                    );
                    return -(1 as i32);
                }
                (unsafe { (*sto).sizeHistory = 5 as i32 });
            } else if (unsafe { (*sto).sizeHistory }) <= (unsafe { (*sto).nbHistory }) {
                (unsafe { (*sto).sizeHistory *= 2 as i32 });
                let fresh482 = unsafe { &mut ((*sto).history) };
                *fresh482 = (unsafe { xmlRealloc.expect("non-null function pointer")(
                    (*sto).history as *mut libc::c_void,
                    ((*sto).sizeHistory as u64).wrapping_mul(::std::mem::size_of::<i32>() as u64),
                ) }) as *mut i32;
                if (unsafe { (*sto).history }).is_null() {
                    xmlSchemaVErrMemory(
                        0 as xmlSchemaValidCtxtPtr,
                        b"re-allocating the state object history\0" as *const u8 as *const i8,
                        0 as xmlNodePtr,
                    );
                    return -(1 as i32);
                }
            }
            let fresh483 = unsafe { &mut ((*sto).nbHistory) };
            let mut fresh484 = *fresh483;
            *fresh483 = *fresh483 + 1;
            (unsafe { *((*sto).history).offset(fresh484 as isize) = depth });
            if (unsafe { (*sto).type_0 }) == 1 as i32 {
                let mut sel: *mut crate::src::xmlschemas::_xmlSchemaIDCSelect<'_> =
                    0 as *mut xmlSchemaIDCSelect;
                sel = unsafe { (*(*(*(*sto).matcher).aidc).def).fields };
                while !sel.is_null() {
                    if xmlSchemaIDCAddStateObject(vctxt, unsafe { (*sto).matcher }, sel, 2 as i32)
                        == -(1 as i32)
                    {
                        return -(1 as i32);
                    }
                    sel = unsafe { (*sel).next };
                }
            } else if (unsafe { (*sto).type_0 }) == 2 as i32 {
                if resolved == 0 as i32 {
                    if (unsafe { (*(*vctxt).inode).flags }) & (1 as i32) << 4 as i32 == 0 as i32 {
                        (unsafe { (*(*vctxt).inode).flags |= (1 as i32) << 4 as i32 });
                    }
                }
                resolved += 1;
            }
        }
        if (unsafe { (*sto).next }).is_null() {
            head = first;
            sto = unsafe { (*vctxt).xpathStates };
        } else {
            sto = unsafe { (*sto).next };
        }
    }
    return resolved;
}
extern "C" fn xmlSchemaFormatIDCKeySequence_1<'a1, 'a2, 'a3>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut buf: Option<&'a2 mut *mut u8>,
    mut seq: *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'a3>,
    mut count: i32,
    mut for_hash: i32,
) -> *const u8 {
    let mut i: i32 = 0;
    let mut res: i32 = 0;
    let mut value: *mut u8 = 0 as *mut xmlChar;
    *(borrow_mut(&mut buf)).unwrap() = xmlStrdup(b"[\0" as *const u8 as *const i8 as *mut xmlChar);
    i = 0 as i32;
    while i < count {
        *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
            *(borrow_mut(&mut buf)).unwrap(),
            b"'\0" as *const u8 as *const i8 as *mut xmlChar,
        );
        if for_hash == 0 {
            res = xmlSchemaGetCanonValueWhtspExt(
                unsafe { (**seq.offset(i as isize)).val },
                xmlSchemaGetWhiteSpaceFacetValue(unsafe { (**seq.offset(i as isize)).type_0 }),
                Some(&mut value),
            );
        } else {
            res = xmlSchemaGetCanonValueHash(unsafe { (**seq.offset(i as isize)).val }, Some(&mut value));
        }
        if res == 0 as i32 {
            *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(*(borrow_mut(&mut buf)).unwrap(), value);
        } else {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaFormatIDCKeySequence\0" as *const u8 as *const i8,
                b"failed to compute a canonical value\0" as *const u8 as *const i8,
            );
            *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                *(borrow_mut(&mut buf)).unwrap(),
                b"???\0" as *const u8 as *const i8 as *mut xmlChar,
            );
        }
        if i < count - 1 as i32 {
            *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                *(borrow_mut(&mut buf)).unwrap(),
                b"', \0" as *const u8 as *const i8 as *mut xmlChar,
            );
        } else {
            *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
                *(borrow_mut(&mut buf)).unwrap(),
                b"'\0" as *const u8 as *const i8 as *mut xmlChar,
            );
        }
        if !value.is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(value as *mut libc::c_void) });
            value = 0 as *mut xmlChar;
        }
        i += 1;
    }
    *(borrow_mut(&mut buf)).unwrap() = xmlStrcat(
        *(borrow_mut(&mut buf)).unwrap(),
        b"]\0" as *const u8 as *const i8 as *mut xmlChar,
    );
    return *(borrow(&buf)).unwrap();
}
extern "C" fn xmlSchemaFormatIDCKeySequence<'a1, 'a2, 'a3>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut buf: Option<&'a2 mut *mut u8>,
    mut seq: *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'a3>,
    mut count: i32,
) -> *const u8 {
    return xmlSchemaFormatIDCKeySequence_1(vctxt, borrow_mut(&mut buf), seq, count, 0 as i32);
}
extern "C" fn xmlSchemaHashKeySequence<'a1, 'a2, 'a3>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut buf: Option<&'a2 mut *mut u8>,
    mut seq: *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'a3>,
    mut count: i32,
) -> *const u8 {
    return xmlSchemaFormatIDCKeySequence_1(vctxt, borrow_mut(&mut buf), seq, count, 1 as i32);
}
extern "C" fn xmlSchemaXPathPop<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> i32 {
    let mut sto: *mut crate::src::xmlschemas::_xmlSchemaIDCStateObj<'_> =
        0 as *mut xmlSchemaIDCStateObj;
    let mut res: i32 = 0;
    if (unsafe { (*vctxt).xpathStates }).is_null() {
        return 0 as i32;
    }
    sto = unsafe { (*vctxt).xpathStates };
    loop {
        res = unsafe { xmlStreamPop((*sto).xpathCtxt as xmlStreamCtxtPtr) };
        if res == -(1 as i32) {
            return -(1 as i32);
        }
        sto = unsafe { (*sto).next };
        if sto.is_null() {
            break;
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaXPathProcessHistory<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut depth: i32,
) -> i32 {
    let mut current_block: u64;
    let mut sto: *mut crate::src::xmlschemas::_xmlSchemaIDCStateObj<'_> =
        0 as *mut xmlSchemaIDCStateObj;
    let mut nextsto: *mut crate::src::xmlschemas::_xmlSchemaIDCStateObj<'_> =
        0 as *mut xmlSchemaIDCStateObj;
    let mut res: i32 = 0;
    let mut matchDepth: i32 = 0;
    let mut key: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'_> =
        0 as xmlSchemaPSVIIDCKeyPtr;
    let mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = unsafe { (*(*vctxt).inode).typeDef };
    let mut simpleType: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as xmlSchemaTypePtr;
    if (unsafe { (*vctxt).xpathStates }).is_null() {
        return 0 as i32;
    }
    sto = unsafe { (*vctxt).xpathStates };
    while !sto.is_null() {
        res = unsafe { xmlStreamPop((*sto).xpathCtxt as xmlStreamCtxtPtr) };
        if res == -(1 as i32) {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaXPathProcessHistory\0" as *const u8 as *const i8,
                b"calling xmlStreamPop()\0" as *const u8 as *const i8,
            );
            return -(1 as i32);
        }
        if !((unsafe { (*sto).nbHistory }) == 0 as i32) {
            matchDepth = unsafe { *((*sto).history).offset(((*sto).nbHistory - 1 as i32) as isize) };
            if matchDepth != depth {
                sto = unsafe { (*sto).next };
                continue;
            } else {
                if (unsafe { (*sto).type_0 }) == 2 as i32 {
                    if (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                        || (unsafe { (*type_0).builtInType }) == XML_SCHEMAS_ANYTYPE as i32
                    {
                        if (unsafe { (*type_0).contentType }) as u32 == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
                            || (unsafe { (*type_0).contentType }) as u32
                                == XML_SCHEMA_CONTENT_BASIC as i32 as u32
                        {
                            simpleType = unsafe { (*type_0).contentTypeDef };
                            if simpleType.is_null() {
                                xmlSchemaInternalErr (vctxt as xmlSchemaAbstractCtxtPtr , b"xmlSchemaXPathProcessHistory\0" as * const u8 as * const i8 , b"field resolves to a CT with simple content but the CT is missing the ST definition\0" as * const u8 as * const i8 ,) ;
                                return -(1 as i32);
                            }
                        } else {
                            simpleType = 0 as xmlSchemaTypePtr;
                        }
                    } else {
                        simpleType = type_0;
                    }
                    if simpleType.is_null() {
                        let mut str: *mut u8 = 0 as *mut xmlChar;
                        xmlSchemaCustomErr (vctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAV_CVC_IDC , 0 as xmlNodePtr , (unsafe { (* (* (* sto) . matcher) . aidc) . def }) as xmlSchemaBasicItemPtr , b"The XPath '%s' of a field of %s does evaluate to a node of non-simple type\0" as * const u8 as * const i8 , unsafe { (* (* sto) . sel) . xpath } , xmlSchemaGetIDCDesignation (Some (& mut str) , unsafe { (* (* (* sto) . matcher) . aidc) . def } ,) ,) ;
                        if !str.is_null() {
                            (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                            str = 0 as *mut xmlChar;
                        }
                        let fresh485 = unsafe { &mut ((*sto).nbHistory) };
                        *fresh485 -= 1;
                        current_block = 10234920862480524530;
                    } else if key.is_null() && (unsafe { (*(*vctxt).inode).val }).is_null() {
                        xmlSchemaCustomErr (vctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAV_CVC_IDC , 0 as xmlNodePtr , (unsafe { (* (* (* sto) . matcher) . aidc) . def }) as xmlSchemaBasicItemPtr , b"Warning: No precomputed value available, the value was either invalid or something strange happened\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
                        let fresh486 = unsafe { &mut ((*sto).nbHistory) };
                        *fresh486 -= 1;
                        current_block = 10234920862480524530;
                    } else {
                        let mut matcher: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'_> =
                            unsafe { (*sto).matcher };
                        let mut keySeq: *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'_> =
                            0 as *mut xmlSchemaPSVIIDCKeyPtr;
                        let mut pos: i32 = 0;
                        let mut idx: i32 = 0;
                        pos = (unsafe { (*sto).depth }) - (unsafe { (*matcher).depth });
                        idx = unsafe { (*(*sto).sel).index };
                        if (unsafe { (*matcher).keySeqs }).is_null() {
                            if pos > 9 as i32 {
                                (unsafe { (*matcher).sizeKeySeqs = pos * 2 as i32 });
                            } else {
                                (unsafe { (*matcher).sizeKeySeqs = 10 as i32 });
                            }
                            let fresh487 = unsafe { &mut ((*matcher).keySeqs) };
                            *fresh487 = (unsafe { xmlMalloc.expect("non-null function pointer")(
                                ((*matcher).sizeKeySeqs as u64).wrapping_mul(
                                    ::std::mem::size_of::<*mut xmlSchemaPSVIIDCKeyPtr>() as u64,
                                ),
                            ) })
                                as *mut *mut xmlSchemaPSVIIDCKeyPtr;
                            if (unsafe { (*matcher).keySeqs }).is_null() {
                                xmlSchemaVErrMemory(
                                    0 as xmlSchemaValidCtxtPtr,
                                    b"allocating an array of key-sequences\0" as *const u8
                                        as *const i8,
                                    0 as xmlNodePtr,
                                );
                                return -(1 as i32);
                            }
                            (unsafe { memset(
                                (*matcher).keySeqs as *mut libc::c_void,
                                0 as i32,
                                ((*matcher).sizeKeySeqs as u64).wrapping_mul(
                                    ::std::mem::size_of::<*mut xmlSchemaPSVIIDCKeyPtr>() as u64,
                                ),
                            ) });
                        } else if pos >= (unsafe { (*matcher).sizeKeySeqs }) {
                            let mut i: i32 = unsafe { (*matcher).sizeKeySeqs };
                            (unsafe { (*matcher).sizeKeySeqs *= 2 as i32 });
                            let fresh488 = unsafe { &mut ((*matcher).keySeqs) };
                            *fresh488 = (unsafe { xmlRealloc.expect("non-null function pointer")(
                                (*matcher).keySeqs as *mut libc::c_void,
                                ((*matcher).sizeKeySeqs as u64).wrapping_mul(
                                    ::std::mem::size_of::<*mut xmlSchemaPSVIIDCKeyPtr>() as u64,
                                ),
                            ) })
                                as *mut *mut xmlSchemaPSVIIDCKeyPtr;
                            if (unsafe { (*matcher).keySeqs }).is_null() {
                                xmlSchemaVErrMemory(
                                    0 as xmlSchemaValidCtxtPtr,
                                    b"reallocating an array of key-sequences\0" as *const u8
                                        as *const i8,
                                    0 as xmlNodePtr,
                                );
                                return -(1 as i32);
                            }
                            while i < (unsafe { (*matcher).sizeKeySeqs }) {
                                let fresh489 = unsafe { &mut (*((*matcher).keySeqs).offset(i as isize)) };
                                *fresh489 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                i += 1;
                            }
                        }
                        keySeq = unsafe { *((*matcher).keySeqs).offset(pos as isize) };
                        if keySeq.is_null() {
                            keySeq = (unsafe { xmlMalloc.expect("non-null function pointer")(
                                ((*(*(*matcher).aidc).def).nbFields as u64).wrapping_mul(
                                    ::std::mem::size_of::<xmlSchemaPSVIIDCKeyPtr>() as u64,
                                ),
                            ) }) as *mut xmlSchemaPSVIIDCKeyPtr;
                            if keySeq.is_null() {
                                xmlSchemaVErrMemory(
                                    0 as xmlSchemaValidCtxtPtr,
                                    b"allocating an IDC key-sequence\0" as *const u8 as *const i8,
                                    0 as xmlNodePtr,
                                );
                                return -(1 as i32);
                            }
                            (unsafe { memset(
                                keySeq as *mut libc::c_void,
                                0 as i32,
                                ((*(*(*matcher).aidc).def).nbFields as u64).wrapping_mul(
                                    ::std::mem::size_of::<xmlSchemaPSVIIDCKeyPtr>() as u64,
                                ),
                            ) });
                            let fresh491 = unsafe { &mut (*((*matcher).keySeqs).offset(pos as isize)) };
                            *fresh491 = keySeq;
                            current_block = 2291247057274820162;
                        } else if !(unsafe { *keySeq.offset(idx as isize) }).is_null() {
                            let mut str_0: *mut u8 = 0 as *mut xmlChar;
                            xmlSchemaCustomErr (vctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAV_CVC_IDC , 0 as xmlNodePtr , (unsafe { (* (* matcher) . aidc) . def }) as xmlSchemaBasicItemPtr , b"The XPath '%s' of a field of %s evaluates to a node-set with more than one member\0" as * const u8 as * const i8 , unsafe { (* (* sto) . sel) . xpath } , xmlSchemaGetIDCDesignation (Some (& mut str_0) , unsafe { (* (* matcher) . aidc) . def } ,) ,) ;
                            if !str_0.is_null() {
                                (unsafe { xmlFree.expect("non-null function pointer")(
                                    str_0 as *mut libc::c_void,
                                ) });
                                str_0 = 0 as *mut xmlChar;
                            }
                            let fresh490 = unsafe { &mut ((*sto).nbHistory) };
                            *fresh490 -= 1;
                            current_block = 10234920862480524530;
                        } else {
                            current_block = 2291247057274820162;
                        }
                        match current_block {
                            10234920862480524530 => {},
                            _ => {
                                if key.is_null() {
                                    key = (unsafe { xmlMalloc.expect("non-null function pointer")(
                                        ::std::mem::size_of::<xmlSchemaPSVIIDCKey>() as u64,
                                    ) })
                                        as xmlSchemaPSVIIDCKeyPtr;
                                    if key.is_null() {
                                        xmlSchemaVErrMemory(
                                            0 as xmlSchemaValidCtxtPtr,
                                            b"allocating a IDC key\0" as *const u8 as *const i8,
                                            0 as xmlNodePtr,
                                        );
                                        (unsafe { xmlFree.expect("non-null function pointer")(
                                            keySeq as *mut libc::c_void,
                                        ) });
                                        let fresh492 =
                                            unsafe { &mut (*((*matcher).keySeqs).offset(pos as isize)) };
                                        *fresh492 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                        return -(1 as i32);
                                    }
                                    let fresh493 = unsafe { &mut ((*key).type_0) };
                                    *fresh493 = simpleType;
                                    let fresh494 = unsafe { &mut ((*key).val) };
                                    *fresh494 = unsafe { (*(*vctxt).inode).val };
                                    let fresh495 = unsafe { &mut ((*(*vctxt).inode).val) };
                                    *fresh495 = 0 as xmlSchemaValPtr;
                                    if xmlSchemaIDCStoreKey(vctxt, key) == -(1 as i32) {
                                        xmlSchemaIDCFreeKey(key);
                                        return -(1 as i32);
                                    }
                                }
                                let fresh496 = unsafe { &mut (*keySeq.offset(idx as isize)) };
                                *fresh496 = key;
                                current_block = 8288085890650723895;
                            },
                        }
                    }
                } else if (unsafe { (*sto).type_0 }) == 1 as i32 {
                    let mut keySeq_0 : Option < & '_ mut * mut * mut crate :: src :: xmlschemas :: _xmlSchemaPSVIIDCKey < '_ > > = Option :: < & '_ mut * mut * mut crate :: src :: xmlschemas :: _xmlSchemaPSVIIDCKey < '_ > > :: None ;
                    let mut ntItem: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'_> =
                        0 as *mut xmlSchemaPSVIIDCNode;
                    let mut matcher_0: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'_> =
                        0 as *mut xmlSchemaIDCMatcher;
                    let mut idc: *mut crate::src::xmlschemas::_xmlSchemaIDC<'_> =
                        0 as *mut xmlSchemaIDC;
                    let mut targets: *mut crate::src::xmlschemas::_xmlSchemaItemList =
                        0 as *mut xmlSchemaItemList;
                    let mut pos_0: i32 = 0;
                    let mut i_0: i32 = 0;
                    let mut j: i32 = 0;
                    let mut nbKeys: i32 = 0;
                    matcher_0 = unsafe { (*sto).matcher };
                    idc = unsafe { (*(*matcher_0).aidc).def };
                    nbKeys = unsafe { (*idc).nbFields };
                    pos_0 = depth - (unsafe { (*matcher_0).depth });
                    if (unsafe { (*matcher_0).keySeqs }).is_null() || (unsafe { (*matcher_0).sizeKeySeqs }) <= pos_0 {
                        if (unsafe { (*idc).type_0 }) as u32 == XML_SCHEMA_TYPE_IDC_KEY as i32 as u32 {
                            current_block = 13895810181616587163;
                        } else {
                            current_block = 17168440009377621674;
                        }
                    } else {
                        keySeq_0 = Some(unsafe { &mut *((*matcher_0).keySeqs).offset(pos_0 as isize) });
                        if (*(borrow(&keySeq_0)).unwrap()).is_null() {
                            if (unsafe { (*idc).type_0 }) as u32 == XML_SCHEMA_TYPE_IDC_KEY as i32 as u32 {
                                current_block = 13895810181616587163;
                            } else {
                                current_block = 17168440009377621674;
                            }
                        } else {
                            i_0 = 0 as i32;
                            loop {
                                if !(i_0 < nbKeys) {
                                    current_block = 14612007084265645573;
                                    break;
                                }
                                if (unsafe { *(*(borrow(&keySeq_0)).unwrap()).offset(i_0 as isize) }).is_null()
                                {
                                    if (unsafe { (*idc).type_0 }) as u32 == XML_SCHEMA_TYPE_IDC_KEY as i32 as u32
                                    {
                                        current_block = 13895810181616587163;
                                        break;
                                    } else {
                                        current_block = 17168440009377621674;
                                        break;
                                    }
                                } else {
                                    i_0 += 1;
                                }
                            }
                            match current_block {
                                13895810181616587163 => {},
                                17168440009377621674 => {},
                                _ => {
                                    targets = xmlSchemaIDCAcquireTargetList(vctxt, matcher_0);
                                    if (unsafe { (*idc).type_0 }) as u32
                                        != XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
                                        && (unsafe { (*targets).nbItems }) != 0 as i32
                                    {
                                        let mut ckey : * mut crate :: src :: xmlschemas :: _xmlSchemaPSVIIDCKey < '_ > = 0 as * mut xmlSchemaPSVIIDCKey ;
                                        let mut bkey : * mut crate :: src :: xmlschemas :: _xmlSchemaPSVIIDCKey < '_ > = 0 as * mut xmlSchemaPSVIIDCKey ;
                                        let mut bkeySeq : * mut * mut crate :: src :: xmlschemas :: _xmlSchemaPSVIIDCKey < '_ > = 0 as * mut xmlSchemaPSVIIDCKeyPtr ;
                                        let mut e: *mut crate::src::xmlschemas::_xmlIDCHashEntry =
                                            0 as *mut xmlIDCHashEntry;
                                        res = 0 as i32;
                                        if (unsafe { (*matcher_0).htab }).is_null() {
                                            e = 0 as xmlIDCHashEntryPtr;
                                        } else {
                                            let mut value: *mut u8 = 0 as *mut xmlChar;
                                            xmlSchemaHashKeySequence(
                                                vctxt,
                                                Some(&mut value),
                                                *(borrow_mut(&mut keySeq_0)).unwrap(),
                                                nbKeys,
                                            );
                                            e = (unsafe { xmlHashLookup((*matcher_0).htab, value) })
                                                as xmlIDCHashEntryPtr;
                                            if !value.is_null() {
                                                (unsafe { xmlFree.expect("non-null function pointer")(
                                                    value as *mut libc::c_void,
                                                ) });
                                                value = 0 as *mut xmlChar;
                                            }
                                        }
                                        while !e.is_null() {
                                            bkeySeq = unsafe { (*(*((*targets).items)
                                                .offset((*e).index as isize)
                                                as xmlSchemaPSVIIDCNodePtr))
                                                .keys };
                                            j = 0 as i32;
                                            while j < nbKeys {
                                                ckey = unsafe { *(*(borrow(&keySeq_0)).unwrap())
                                                    .offset(j as isize) };
                                                bkey = unsafe { *bkeySeq.offset(j as isize) };
                                                res = xmlSchemaAreValuesEqual(
                                                    unsafe { (*ckey).val },
                                                    unsafe { (*bkey).val },
                                                );
                                                if res == -(1 as i32) {
                                                    return -(1 as i32);
                                                } else {
                                                    if res == 0 as i32 {
                                                        break;
                                                    }
                                                    j += 1;
                                                }
                                            }
                                            if res == 1 as i32 {
                                                break;
                                            }
                                            e = unsafe { (*e).next };
                                        }
                                        if !e.is_null() {
                                            let mut str_1: *mut u8 = 0 as *mut xmlChar;
                                            let mut strB: *mut u8 = 0 as *mut xmlChar;
                                            xmlSchemaCustomErr(
                                                vctxt as xmlSchemaAbstractCtxtPtr,
                                                XML_SCHEMAV_CVC_IDC,
                                                0 as xmlNodePtr,
                                                idc as xmlSchemaBasicItemPtr,
                                                b"Duplicate key-sequence %s in %s\0" as *const u8
                                                    as *const i8,
                                                xmlSchemaFormatIDCKeySequence(
                                                    vctxt,
                                                    Some(&mut str_1),
                                                    *(borrow_mut(&mut keySeq_0)).unwrap(),
                                                    nbKeys,
                                                ),
                                                xmlSchemaGetIDCDesignation(Some(&mut strB), idc),
                                            );
                                            if !str_1.is_null() {
                                                (unsafe { xmlFree.expect("non-null function pointer")(
                                                    str_1 as *mut libc::c_void,
                                                ) });
                                                str_1 = 0 as *mut xmlChar;
                                            }
                                            if !strB.is_null() {
                                                (unsafe { xmlFree.expect("non-null function pointer")(
                                                    strB as *mut libc::c_void,
                                                ) });
                                                strB = 0 as *mut xmlChar;
                                            }
                                            current_block = 17168440009377621674;
                                        } else {
                                            current_block = 2704538829018177290;
                                        }
                                    } else {
                                        current_block = 2704538829018177290;
                                    }
                                    match current_block {
                                        17168440009377621674 => {},
                                        _ => {
                                            ntItem = (unsafe { xmlMalloc.expect("non-null function pointer")(
                                                ::std::mem::size_of::<xmlSchemaPSVIIDCNode>()
                                                    as u64,
                                            ) })
                                                as xmlSchemaPSVIIDCNodePtr;
                                            if ntItem.is_null() {
                                                xmlSchemaVErrMemory(
                                                    0 as xmlSchemaValidCtxtPtr,
                                                    b"allocating an IDC node-table item\0"
                                                        as *const u8
                                                        as *const i8,
                                                    0 as xmlNodePtr,
                                                );
                                                (unsafe { xmlFree.expect("non-null function pointer")(
                                                    *(borrow_mut(&mut keySeq_0)).unwrap()
                                                        as *mut libc::c_void,
                                                ) });
                                                *(borrow_mut(&mut keySeq_0)).unwrap() =
                                                    0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                                return -(1 as i32);
                                            }
                                            (unsafe { memset(
                                                ntItem as *mut libc::c_void,
                                                0 as i32,
                                                ::std::mem::size_of::<xmlSchemaPSVIIDCNode>()
                                                    as u64,
                                            ) });
                                            if (unsafe { (*idc).type_0 }) as u32
                                                != XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
                                            {
                                                if xmlSchemaIDCStoreNodeTableItem(vctxt, ntItem)
                                                    == -(1 as i32)
                                                {
                                                    (unsafe { xmlFree.expect("non-null function pointer")(
                                                        ntItem as *mut libc::c_void,
                                                    ) });
                                                    (unsafe { xmlFree.expect("non-null function pointer")(
                                                        *(borrow_mut(&mut keySeq_0)).unwrap()
                                                            as *mut libc::c_void,
                                                    ) });
                                                    *(borrow_mut(&mut keySeq_0)).unwrap() =
                                                        0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                                    return -(1 as i32);
                                                }
                                                (unsafe { (*ntItem).nodeQNameID = -(1 as i32) });
                                            } else {
                                                (unsafe { (*ntItem).nodeQNameID = xmlSchemaVAddNodeQName(
                                                    vctxt,
                                                    (*(*vctxt).inode).localName,
                                                    (*(*vctxt).inode).nsName,
                                                ) });
                                                if (unsafe { (*ntItem).nodeQNameID }) == -(1 as i32) {
                                                    (unsafe { xmlFree.expect("non-null function pointer")(
                                                        ntItem as *mut libc::c_void,
                                                    ) });
                                                    (unsafe { xmlFree.expect("non-null function pointer")(
                                                        *(borrow_mut(&mut keySeq_0)).unwrap()
                                                            as *mut libc::c_void,
                                                    ) });
                                                    *(borrow_mut(&mut keySeq_0)).unwrap() =
                                                        0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                                    return -(1 as i32);
                                                }
                                            }
                                            let fresh497 = unsafe { &mut ((*ntItem).node) };
                                            *fresh497 = unsafe { (*vctxt).node };
                                            (unsafe { (*ntItem).nodeLine = (*(*vctxt).inode).nodeLine });
                                            let fresh498 = unsafe { &mut ((*ntItem).keys) };
                                            *fresh498 = *(borrow_mut(&mut keySeq_0)).unwrap();
                                            *(borrow_mut(&mut keySeq_0)).unwrap() =
                                                0 as *mut xmlSchemaPSVIIDCKeyPtr;
                                            if xmlSchemaItemListAdd(
                                                targets,
                                                ntItem as *mut libc::c_void,
                                            ) == -(1 as i32)
                                            {
                                                if (unsafe { (*idc).type_0 }) as u32
                                                    == XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
                                                {
                                                    (unsafe { xmlFree.expect("non-null function pointer")(
                                                        (*ntItem).keys as *mut libc::c_void,
                                                    ) });
                                                    (unsafe { xmlFree.expect("non-null function pointer")(
                                                        ntItem as *mut libc::c_void,
                                                    ) });
                                                }
                                                return -(1 as i32);
                                            }
                                            if (unsafe { (*idc).type_0 }) as u32
                                                != XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
                                            {
                                                let mut value_0: *mut u8 = 0 as *mut xmlChar;
                                                let mut r : * mut crate :: src :: xmlschemas :: _xmlIDCHashEntry = 0 as * mut crate :: src :: xmlschemas :: _xmlIDCHashEntry ;
                                                let mut e_0 : * mut crate :: src :: xmlschemas :: _xmlIDCHashEntry = 0 as * mut xmlIDCHashEntry ;
                                                if (unsafe { (*matcher_0).htab }).is_null() {
                                                    let fresh499 = unsafe { &mut ((*matcher_0).htab) };
                                                    *fresh499 = unsafe { xmlHashCreate(4 as i32) };
                                                }
                                                xmlSchemaHashKeySequence(
                                                    vctxt,
                                                    Some(&mut value_0),
                                                    unsafe { (*ntItem).keys },
                                                    nbKeys,
                                                );
                                                e_0 = (unsafe { xmlMalloc.expect("non-null function pointer")(
                                                    ::std::mem::size_of::<xmlIDCHashEntry>() as u64,
                                                ) })
                                                    as xmlIDCHashEntryPtr;
                                                (unsafe { (*e_0).index = (*targets).nbItems - 1 as i32 });
                                                r = (unsafe { xmlHashLookup((*matcher_0).htab, value_0) })
                                                    as xmlIDCHashEntryPtr;
                                                if !r.is_null() {
                                                    let fresh500 = unsafe { &mut ((*e_0).next) };
                                                    *fresh500 = unsafe { (*r).next };
                                                    let fresh501 = unsafe { &mut ((*r).next) };
                                                    *fresh501 = e_0;
                                                } else {
                                                    let fresh502 = unsafe { &mut ((*e_0).next) };
                                                    *fresh502 = 0 as xmlIDCHashEntryPtr;
                                                    (unsafe { xmlHashAddEntry(
                                                        (*matcher_0).htab,
                                                        value_0,
                                                        e_0 as *mut libc::c_void,
                                                    ) });
                                                }
                                                if !value_0.is_null() {
                                                    (unsafe { xmlFree.expect("non-null function pointer")(
                                                        value_0 as *mut libc::c_void,
                                                    ) });
                                                    value_0 = 0 as *mut xmlChar;
                                                }
                                            }
                                            current_block = 17168440009377621674;
                                        },
                                    }
                                },
                            }
                        }
                    }
                    match current_block {
                        13895810181616587163 => {
                            let mut str_2: *mut u8 = 0 as *mut xmlChar;
                            xmlSchemaCustomErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAV_CVC_IDC,
                                0 as xmlNodePtr,
                                idc as xmlSchemaBasicItemPtr,
                                b"Not all fields of %s evaluate to a node\0" as *const u8
                                    as *const i8,
                                xmlSchemaGetIDCDesignation(Some(&mut str_2), idc),
                                0 as *const xmlChar,
                            );
                            if !str_2.is_null() {
                                (unsafe { xmlFree.expect("non-null function pointer")(
                                    str_2 as *mut libc::c_void,
                                ) });
                                str_2 = 0 as *mut xmlChar;
                            }
                        },
                        _ => {},
                    }
                    if !borrow(&keySeq_0).is_none()
                        && !(*(borrow_mut(&mut keySeq_0)).unwrap()).is_null()
                    {
                        (unsafe { xmlFree.expect("non-null function pointer")(
                            *(borrow_mut(&mut keySeq_0)).unwrap() as *mut libc::c_void,
                        ) });
                        *(borrow_mut(&mut keySeq_0)).unwrap() = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
                    }
                    current_block = 8288085890650723895;
                } else {
                    current_block = 8288085890650723895;
                }
                match current_block {
                    10234920862480524530 => {},
                    _ => {
                        let fresh503 = unsafe { &mut ((*sto).nbHistory) };
                        *fresh503 -= 1;
                    },
                }
            }
        }
        if (unsafe { (*sto).nbHistory }) == 0 as i32 && (unsafe { (*sto).depth }) == depth {
            if (unsafe { (*vctxt).xpathStates }) != sto {
                xmlSchemaInternalErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaXPathProcessHistory\0" as *const u8 as *const i8,
                    b"The state object to be removed is not the first in the list\0" as *const u8
                        as *const i8,
                );
            }
            nextsto = unsafe { (*sto).next };
            let fresh504 = unsafe { &mut ((*vctxt).xpathStates) };
            *fresh504 = unsafe { (*sto).next };
            let fresh505 = unsafe { &mut ((*sto).next) };
            *fresh505 = unsafe { (*vctxt).xpathStatePool };
            let fresh506 = unsafe { &mut ((*vctxt).xpathStatePool) };
            *fresh506 = sto;
            sto = nextsto;
        } else {
            sto = unsafe { (*sto).next };
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaIDCRegisterMatchers<'a1, 'a2>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut elemDecl: *mut crate::src::xmlschemas::_xmlSchemaElement<'a2>,
) -> i32 {
    let mut matcher: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'_> =
        0 as *mut xmlSchemaIDCMatcher;
    let mut last: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'_> =
        0 as xmlSchemaIDCMatcherPtr;
    let mut idc: *mut crate::src::xmlschemas::_xmlSchemaIDC<'_> = 0 as *mut xmlSchemaIDC;
    let mut refIdc: *mut crate::src::xmlschemas::_xmlSchemaIDC<'_> = 0 as *mut xmlSchemaIDC;
    let mut aidc: *mut crate::src::xmlschemas::_xmlSchemaIDCAug<'_> = 0 as *mut xmlSchemaIDCAug;
    idc = (unsafe { (*elemDecl).idcs }) as xmlSchemaIDCPtr;
    if idc.is_null() {
        return 0 as i32;
    }
    if !(unsafe { (*(*vctxt).inode).idcMatchers }).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaIDCRegisterMatchers\0" as *const u8 as *const i8,
            b"The chain of IDC matchers is expected to be empty\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    loop {
        if (unsafe { (*idc).type_0 }) as u32 == XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32 {
            refIdc = (unsafe { (*(*idc).ref_0).item }) as xmlSchemaIDCPtr;
            if !refIdc.is_null() {
                (unsafe { (*(*vctxt).inode).hasKeyrefs = 1 as i32 });
                aidc = unsafe { (*vctxt).aidcs };
                while !aidc.is_null() {
                    if (unsafe { (*aidc).def }) == refIdc {
                        break;
                    }
                    aidc = unsafe { (*aidc).next };
                }
                if aidc.is_null() {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaIDCRegisterMatchers\0" as *const u8 as *const i8,
                        b"Could not find an augmented IDC item for an IDC definition\0" as *const u8
                            as *const i8,
                    );
                    return -(1 as i32);
                }
                if (unsafe { (*aidc).keyrefDepth }) == -(1 as i32) || (unsafe { (*vctxt).depth }) < (unsafe { (*aidc).keyrefDepth }) {
                    (unsafe { (*aidc).keyrefDepth = (*vctxt).depth });
                }
            }
        }
        aidc = unsafe { (*vctxt).aidcs };
        while !aidc.is_null() {
            if (unsafe { (*aidc).def }) == idc {
                break;
            }
            aidc = unsafe { (*aidc).next };
        }
        if aidc.is_null() {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaIDCRegisterMatchers\0" as *const u8 as *const i8,
                b"Could not find an augmented IDC item for an IDC definition\0" as *const u8
                    as *const i8,
            );
            return -(1 as i32);
        }
        if !(unsafe { (*vctxt).idcMatcherCache }).is_null() {
            matcher = unsafe { (*vctxt).idcMatcherCache };
            let fresh507 = unsafe { &mut ((*vctxt).idcMatcherCache) };
            *fresh507 = unsafe { (*matcher).nextCached };
            let fresh508 = unsafe { &mut ((*matcher).nextCached) };
            *fresh508 = 0 as xmlSchemaIDCMatcherPtr;
        } else {
            matcher = (unsafe { xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<
                xmlSchemaIDCMatcher,
            >() as u64) }) as xmlSchemaIDCMatcherPtr;
            if matcher.is_null() {
                xmlSchemaVErrMemory(
                    vctxt,
                    b"allocating an IDC matcher\0" as *const u8 as *const i8,
                    0 as xmlNodePtr,
                );
                return -(1 as i32);
            }
            (unsafe { memset(
                matcher as *mut libc::c_void,
                0 as i32,
                ::std::mem::size_of::<xmlSchemaIDCMatcher>() as u64,
            ) });
        }
        if last.is_null() {
            let fresh509 = unsafe { &mut ((*(*vctxt).inode).idcMatchers) };
            *fresh509 = matcher;
        } else {
            let fresh510 = unsafe { &mut ((*last).next) };
            *fresh510 = matcher;
        }
        last = matcher;
        (unsafe { (*matcher).type_0 = 0 as i32 });
        (unsafe { (*matcher).depth = (*vctxt).depth });
        let fresh511 = unsafe { &mut ((*matcher).aidc) };
        *fresh511 = aidc;
        (unsafe { (*matcher).idcType = (*(*aidc).def).type_0 as i32 });
        if xmlSchemaIDCAddStateObject(vctxt, matcher, unsafe { (*idc).selector }, 1 as i32) == -(1 as i32) {
            return -(1 as i32);
        }
        idc = unsafe { (*idc).next };
        if idc.is_null() {
            break;
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaIDCFillNodeTables<'a1, 'a2>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut ielem: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'a2>,
) -> i32
where
    'a2: 'a1,
    'a1: 'a2,
{
    let mut current_block: u64;
    let mut bind: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'_> =
        0 as *mut xmlSchemaPSVIIDCBinding;
    let mut res: i32 = 0;
    let mut i: i32 = 0;
    let mut j: i32 = 0;
    let mut k: i32 = 0;
    let mut nbTargets: i32 = 0;
    let mut nbFields: i32 = 0;
    let mut nbDupls: i32 = 0;
    let mut nbNodeTable: i32 = 0;
    let mut keys: *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'_> =
        0 as *mut xmlSchemaPSVIIDCKeyPtr;
    let mut ntkeys: *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'_> =
        0 as *mut xmlSchemaPSVIIDCKeyPtr;
    let mut targets: *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'_> =
        0 as *mut xmlSchemaPSVIIDCNodePtr;
    let mut dupls: *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'_> =
        0 as *mut xmlSchemaPSVIIDCNodePtr;
    let mut matcher: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'_> = unsafe { (*ielem).idcMatchers };
    's_17: loop {
        if matcher.is_null() {
            current_block = 14541395414537699361;
            break;
        }
        if (unsafe { (*(*(*matcher).aidc).def).type_0 }) as u32 == XML_SCHEMA_TYPE_IDC_KEYREF as i32 as u32
            || ((unsafe { (*matcher).targets }).is_null() || (unsafe { (*(*matcher).targets).nbItems }) == 0 as i32)
        {
            matcher = unsafe { (*matcher).next };
        } else if (unsafe { (*vctxt).createIDCNodeTables }) == 0
            && ((unsafe { (*(*matcher).aidc).keyrefDepth }) == -(1 as i32)
                || (unsafe { (*(*matcher).aidc).keyrefDepth }) > (unsafe { (*vctxt).depth }))
        {
            matcher = unsafe { (*matcher).next };
        } else {
            bind = xmlSchemaIDCAcquireBinding(vctxt, matcher);
            if bind.is_null() {
                current_block = 17119793500333090447;
                break;
            }
            if !((unsafe { (*bind).dupls }).is_null() || (unsafe { (*(*bind).dupls).nbItems }) == 0 as i32) {
                dupls = (unsafe { (*(*bind).dupls).items }) as *mut xmlSchemaPSVIIDCNodePtr;
                nbDupls = unsafe { (*(*bind).dupls).nbItems };
            } else {
                dupls = 0 as *mut xmlSchemaPSVIIDCNodePtr;
                nbDupls = 0 as i32;
            }
            if !(unsafe { (*bind).nodeTable }).is_null() {
                nbNodeTable = unsafe { (*bind).nbNodes };
            } else {
                nbNodeTable = 0 as i32;
            }
            if nbNodeTable == 0 as i32 && nbDupls == 0 as i32 {
                let fresh512 = unsafe { &mut ((*bind).nodeTable) };
                *fresh512 = (unsafe { (*(*matcher).targets).items }) as *mut xmlSchemaPSVIIDCNodePtr;
                (unsafe { (*bind).sizeNodes = (*(*matcher).targets).sizeItems });
                (unsafe { (*bind).nbNodes = (*(*matcher).targets).nbItems });
                let fresh513 = unsafe { &mut ((*(*matcher).targets).items) };
                *fresh513 = 0 as *mut *mut libc::c_void;
                (unsafe { (*(*matcher).targets).sizeItems = 0 as i32 });
                (unsafe { (*(*matcher).targets).nbItems = 0 as i32 });
                if !(unsafe { (*matcher).htab }).is_null() {
                    (unsafe { xmlHashFree((*matcher).htab, Some(xmlFreeIDCHashEntry)) });
                    let fresh514 = unsafe { &mut ((*matcher).htab) };
                    *fresh514 = 0 as xmlHashTablePtr;
                }
            } else {
                nbTargets = unsafe { (*(*matcher).targets).nbItems };
                targets = (unsafe { (*(*matcher).targets).items }) as *mut xmlSchemaPSVIIDCNodePtr;
                nbFields = unsafe { (*(*(*matcher).aidc).def).nbFields };
                i = 0 as i32;
                loop {
                    keys = unsafe { (**targets.offset(i as isize)).keys };
                    if nbDupls != 0 {
                        j = 0 as i32;
                        loop {
                            if nbFields == 1 as i32 {
                                res = xmlSchemaAreValuesEqual(
                                    unsafe { (**keys.offset(0 as i32 as isize)).val },
                                    unsafe { (**((**dupls.offset(j as isize)).keys)
                                        .offset(0 as i32 as isize))
                                    .val },
                                );
                                if res == -(1 as i32) {
                                    current_block = 17119793500333090447;
                                    break 's_17;
                                }
                                if res == 1 as i32 {
                                    current_block = 7654530974828906095;
                                    break;
                                }
                            } else {
                                res = 0 as i32;
                                ntkeys = unsafe { (**dupls.offset(j as isize)).keys };
                                k = 0 as i32;
                                while k < nbFields {
                                    res = xmlSchemaAreValuesEqual(
                                        unsafe { (**keys.offset(k as isize)).val },
                                        unsafe { (**ntkeys.offset(k as isize)).val },
                                    );
                                    if res == -(1 as i32) {
                                        current_block = 17119793500333090447;
                                        break 's_17;
                                    }
                                    if res == 0 as i32 {
                                        break;
                                    }
                                    k += 1;
                                }
                                if res == 1 as i32 {
                                    current_block = 7654530974828906095;
                                    break;
                                }
                            }
                            j += 1;
                            if !(j < nbDupls) {
                                current_block = 9241535491006583629;
                                break;
                            }
                        }
                    } else {
                        current_block = 9241535491006583629;
                    }
                    match current_block {
                        9241535491006583629 => {
                            if nbNodeTable != 0 {
                                j = 0 as i32;
                                loop {
                                    if nbFields == 1 as i32 {
                                        res = xmlSchemaAreValuesEqual(
                                            unsafe { (**keys.offset(0 as i32 as isize)).val },
                                            unsafe { (**((**((*bind).nodeTable).offset(j as isize)).keys)
                                                .offset(0 as i32 as isize))
                                            .val },
                                        );
                                        if res == -(1 as i32) {
                                            current_block = 17119793500333090447;
                                            break 's_17;
                                        }
                                        if res == 0 as i32 {
                                            current_block = 6985438050701255290;
                                        } else {
                                            current_block = 2168227384378665163;
                                        }
                                    } else {
                                        res = 0 as i32;
                                        ntkeys = unsafe { (**((*bind).nodeTable).offset(j as isize)).keys };
                                        k = 0 as i32;
                                        loop {
                                            if !(k < nbFields) {
                                                current_block = 2168227384378665163;
                                                break;
                                            }
                                            res = xmlSchemaAreValuesEqual(
                                                unsafe { (**keys.offset(k as isize)).val },
                                                unsafe { (**ntkeys.offset(k as isize)).val },
                                            );
                                            if res == -(1 as i32) {
                                                current_block = 17119793500333090447;
                                                break 's_17;
                                            }
                                            if res == 0 as i32 {
                                                current_block = 6985438050701255290;
                                                break;
                                            }
                                            k += 1;
                                        }
                                    }
                                    match current_block {
                                        6985438050701255290 => {
                                            j += 1;
                                            if !(j < nbNodeTable) {
                                                current_block = 15855550149339537395;
                                                break;
                                            }
                                        },
                                        _ => {
                                            if (unsafe { (*bind).dupls }).is_null() {
                                                let fresh515 = unsafe { &mut ((*bind).dupls) };
                                                *fresh515 = xmlSchemaItemListCreate();
                                                if (unsafe { (*bind).dupls }).is_null() {
                                                    current_block = 17119793500333090447;
                                                    break 's_17;
                                                }
                                            }
                                            if xmlSchemaItemListAdd(
                                                unsafe { (*bind).dupls },
                                                (unsafe { *((*bind).nodeTable).offset(j as isize) })
                                                    as *mut libc::c_void,
                                            ) == -(1 as i32)
                                            {
                                                current_block = 17119793500333090447;
                                                break 's_17;
                                            }
                                            let fresh516 =
                                                unsafe { &mut (*((*bind).nodeTable).offset(j as isize)) };
                                            *fresh516 = unsafe { *((*bind).nodeTable)
                                                .offset(((*bind).nbNodes - 1 as i32) as isize) };
                                            let fresh517 = unsafe { &mut ((*bind).nbNodes) };
                                            *fresh517 -= 1;
                                            current_block = 7654530974828906095;
                                            break;
                                        },
                                    }
                                }
                            } else {
                                current_block = 15855550149339537395;
                            }
                            match current_block {
                                7654530974828906095 => {},
                                _ => {
                                    if xmlSchemaIDCAppendNodeTableItem(
                                        bind,
                                        unsafe { *targets.offset(i as isize) },
                                    ) == -(1 as i32)
                                    {
                                        current_block = 17119793500333090447;
                                        break 's_17;
                                    }
                                },
                            }
                        },
                        _ => {},
                    }
                    i += 1;
                    if !(i < nbTargets) {
                        break;
                    }
                }
            }
            matcher = unsafe { (*matcher).next };
        }
    }
    match current_block {
        17119793500333090447 => return -(1 as i32),
        _ => return 0 as i32,
    };
}
extern "C" fn xmlSchemaBubbleIDCNodeTables<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> i32 {
    let mut current_block: u64;
    let mut bind: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'_> =
        0 as *mut xmlSchemaPSVIIDCBinding;
    let mut parTable: Option<&'_ mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'_>> =
        Option::<&'_ mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'_>>::None;
    let mut parBind: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'_> =
        0 as xmlSchemaPSVIIDCBindingPtr;
    let mut node: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'_> =
        0 as *mut xmlSchemaPSVIIDCNode;
    let mut parNode: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'_> =
        0 as xmlSchemaPSVIIDCNodePtr;
    let mut dupls: *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'_> =
        0 as *mut xmlSchemaPSVIIDCNodePtr;
    let mut parNodes: *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'_> =
        0 as *mut xmlSchemaPSVIIDCNodePtr;
    let mut aidc: *mut crate::src::xmlschemas::_xmlSchemaIDCAug<'_> = 0 as *mut xmlSchemaIDCAug;
    let mut i: i32 = 0;
    let mut j: i32 = 0;
    let mut k: i32 = 0;
    let mut ret: i32 = 0 as i32;
    let mut nbFields: i32 = 0;
    let mut oldNum: i32 = 0;
    let mut oldDupls: i32 = 0;
    bind = unsafe { (*(*vctxt).inode).idcTable };
    if bind.is_null() {
        return 0 as i32;
    }
    parTable =
        Some(unsafe { &mut (**((*vctxt).elemInfos).offset(((*vctxt).depth - 1 as i32) as isize)).idcTable });
    's_37: loop {
        if bind.is_null() {
            current_block = 7157669805658135323;
            break;
        }
        if !((unsafe { (*bind).nbNodes }) == 0 as i32
            && ((unsafe { (*bind).dupls }).is_null() || (unsafe { (*(*bind).dupls).nbItems }) == 0 as i32))
        {
            if (unsafe { (*vctxt).createIDCNodeTables }) == 0 {
                aidc = unsafe { (*vctxt).aidcs };
                loop {
                    if (unsafe { (*aidc).def }) == (unsafe { (*bind).definition }) {
                        if (unsafe { (*aidc).keyrefDepth }) == -(1 as i32)
                            || (unsafe { (*aidc).keyrefDepth }) >= (unsafe { (*vctxt).depth })
                        {
                            current_block = 1182060686398305565;
                            break;
                        } else {
                            current_block = 17833034027772472439;
                            break;
                        }
                    } else {
                        aidc = unsafe { (*aidc).next };
                        if aidc.is_null() {
                            current_block = 17833034027772472439;
                            break;
                        }
                    }
                }
            } else {
                current_block = 17833034027772472439;
            }
            match current_block {
                1182060686398305565 => {},
                _ => {
                    if !borrow(&parTable).is_none() {
                        parBind = *(borrow_mut(&mut parTable)).unwrap();
                    }
                    while !parBind.is_null() {
                        if (unsafe { (*parBind).definition }) == (unsafe { (*bind).definition }) {
                            break;
                        }
                        parBind = unsafe { (*parBind).next };
                    }
                    if !parBind.is_null() {
                        oldNum = unsafe { (*parBind).nbNodes };
                        if !((unsafe { (*parBind).dupls }).is_null()
                            || (unsafe { (*(*parBind).dupls).nbItems }) == 0 as i32)
                        {
                            oldDupls = unsafe { (*(*parBind).dupls).nbItems };
                            dupls = (unsafe { (*(*parBind).dupls).items }) as *mut xmlSchemaPSVIIDCNodePtr;
                        } else {
                            dupls = 0 as *mut xmlSchemaPSVIIDCNodePtr;
                            oldDupls = 0 as i32;
                        }
                        parNodes = unsafe { (*parBind).nodeTable };
                        nbFields = unsafe { (*(*bind).definition).nbFields };
                        i = 0 as i32;
                        while i < (unsafe { (*bind).nbNodes }) {
                            node = unsafe { *((*bind).nodeTable).offset(i as isize) };
                            if !node.is_null() {
                                if oldDupls != 0 {
                                    j = 0 as i32;
                                    while j < oldDupls {
                                        if nbFields == 1 as i32 {
                                            ret = xmlSchemaAreValuesEqual(
                                                unsafe { (**((*node).keys).offset(0 as i32 as isize)).val },
                                                unsafe { (**((**dupls.offset(j as isize)).keys)
                                                    .offset(0 as i32 as isize))
                                                .val },
                                            );
                                            if ret == -(1 as i32) {
                                                current_block = 8730031095742260322;
                                                break 's_37;
                                            }
                                            if ret == 0 as i32 {
                                                j += 1;
                                                continue;
                                            }
                                        } else {
                                            parNode = unsafe { *dupls.offset(j as isize) };
                                            k = 0 as i32;
                                            while k < nbFields {
                                                ret = xmlSchemaAreValuesEqual(
                                                    unsafe { (**((*node).keys).offset(k as isize)).val },
                                                    unsafe { (**((*parNode).keys).offset(k as isize)).val },
                                                );
                                                if ret == -(1 as i32) {
                                                    current_block = 8730031095742260322;
                                                    break 's_37;
                                                }
                                                if ret == 0 as i32 {
                                                    break;
                                                }
                                                k += 1;
                                            }
                                        }
                                        if ret == 1 as i32 {
                                            break;
                                        }
                                        j += 1;
                                    }
                                    if j != oldDupls {
                                        current_block = 14434620278749266018;
                                    } else {
                                        current_block = 6721012065216013753;
                                    }
                                } else {
                                    current_block = 6721012065216013753;
                                }
                                match current_block {
                                    14434620278749266018 => {},
                                    _ => {
                                        if oldNum != 0 {
                                            j = 0 as i32;
                                            while j < oldNum {
                                                parNode = unsafe { *parNodes.offset(j as isize) };
                                                if nbFields == 1 as i32 {
                                                    ret = xmlSchemaAreValuesEqual(
                                                        unsafe { (**((*node).keys)
                                                            .offset(0 as i32 as isize))
                                                        .val },
                                                        unsafe { (**((*parNode).keys)
                                                            .offset(0 as i32 as isize))
                                                        .val },
                                                    );
                                                    if ret == -(1 as i32) {
                                                        current_block = 8730031095742260322;
                                                        break 's_37;
                                                    }
                                                    if ret == 0 as i32 {
                                                        j += 1;
                                                        continue;
                                                    }
                                                } else {
                                                    k = 0 as i32;
                                                    while k < nbFields {
                                                        ret = xmlSchemaAreValuesEqual(
                                                            unsafe { (**((*node).keys).offset(k as isize))
                                                                .val },
                                                            unsafe { (**((*parNode).keys)
                                                                .offset(k as isize))
                                                            .val },
                                                        );
                                                        if ret == -(1 as i32) {
                                                            current_block = 8730031095742260322;
                                                            break 's_37;
                                                        }
                                                        if ret == 0 as i32 {
                                                            break;
                                                        }
                                                        k += 1;
                                                    }
                                                }
                                                if ret == 1 as i32 {
                                                    break;
                                                }
                                                j += 1;
                                            }
                                            if j != oldNum {
                                                oldNum -= 1;
                                                let fresh518 = unsafe { &mut ((*parBind).nbNodes) };
                                                *fresh518 -= 1;
                                                let fresh519 = unsafe { &mut (*parNodes.offset(j as isize)) };
                                                *fresh519 = unsafe { *parNodes.offset(oldNum as isize) };
                                                if (unsafe { (*parBind).nbNodes }) != oldNum {
                                                    let fresh520 =
                                                        unsafe { &mut (*parNodes.offset(oldNum as isize)) };
                                                    *fresh520 = unsafe { *parNodes
                                                        .offset((*parBind).nbNodes as isize) };
                                                }
                                                if (unsafe { (*parBind).dupls }).is_null() {
                                                    let fresh521 = unsafe { &mut ((*parBind).dupls) };
                                                    *fresh521 = xmlSchemaItemListCreate();
                                                    if (unsafe { (*parBind).dupls }).is_null() {
                                                        current_block = 8730031095742260322;
                                                        break 's_37;
                                                    }
                                                }
                                                xmlSchemaItemListAdd(
                                                    unsafe { (*parBind).dupls },
                                                    parNode as *mut libc::c_void,
                                                );
                                            } else {
                                                if (unsafe { (*parBind).nodeTable }).is_null() {
                                                    let fresh522 = unsafe { &mut ((*parBind).nodeTable) };
                                                    *fresh522 = (unsafe { xmlMalloc
                                                        .expect("non-null function pointer")(
                                                        (10 as i32 as u64).wrapping_mul(
                                                            ::std::mem::size_of::<
                                                                xmlSchemaPSVIIDCNodePtr,
                                                            >(
                                                            )
                                                                as u64,
                                                        ),
                                                    ) })
                                                        as *mut xmlSchemaPSVIIDCNodePtr;
                                                    if (unsafe { (*parBind).nodeTable }).is_null() {
                                                        xmlSchemaVErrMemory (0 as xmlSchemaValidCtxtPtr , b"allocating IDC list of node-table items\0" as * const u8 as * const i8 , 0 as xmlNodePtr ,) ;
                                                        current_block = 8730031095742260322;
                                                        break 's_37;
                                                    } else {
                                                        (unsafe { (*parBind).sizeNodes = 1 as i32 });
                                                    }
                                                } else if (unsafe { (*parBind).nbNodes }) >= (unsafe { (*parBind).sizeNodes })
                                                {
                                                    (unsafe { (*parBind).sizeNodes *= 2 as i32 });
                                                    let fresh523 = unsafe { &mut ((*parBind).nodeTable) };
                                                    *fresh523 = (unsafe { xmlRealloc
                                                        .expect("non-null function pointer")(
                                                        (*parBind).nodeTable as *mut libc::c_void,
                                                        ((*parBind).sizeNodes as u64).wrapping_mul(
                                                            ::std::mem::size_of::<
                                                                xmlSchemaPSVIIDCNodePtr,
                                                            >(
                                                            )
                                                                as u64,
                                                        ),
                                                    ) })
                                                        as *mut xmlSchemaPSVIIDCNodePtr;
                                                    if (unsafe { (*parBind).nodeTable }).is_null() {
                                                        xmlSchemaVErrMemory (0 as xmlSchemaValidCtxtPtr , b"re-allocating IDC list of node-table items\0" as * const u8 as * const i8 , 0 as xmlNodePtr ,) ;
                                                        current_block = 8730031095742260322;
                                                        break 's_37;
                                                    }
                                                }
                                                parNodes = unsafe { (*parBind).nodeTable };
                                                let fresh524 = unsafe { &mut ((*parBind).nbNodes) };
                                                let mut fresh525 = *fresh524;
                                                *fresh524 = *fresh524 + 1;
                                                let fresh526 =
                                                    unsafe { &mut (*parNodes.offset(fresh525 as isize)) };
                                                *fresh526 = node;
                                            }
                                        }
                                    },
                                }
                            }
                            i += 1;
                        }
                    } else {
                        parBind = xmlSchemaIDCNewBinding(unsafe { (*bind).definition });
                        if parBind.is_null() {
                            current_block = 8730031095742260322;
                            break;
                        }
                        if (unsafe { (*bind).nbNodes }) != 0 as i32 {
                            if (unsafe { (*vctxt).psviExposeIDCNodeTables }) == 0 {
                                let fresh527 = unsafe { &mut ((*parBind).nodeTable) };
                                *fresh527 = unsafe { (*bind).nodeTable };
                                let fresh528 = unsafe { &mut ((*bind).nodeTable) };
                                *fresh528 = 0 as *mut xmlSchemaPSVIIDCNodePtr;
                                (unsafe { (*parBind).sizeNodes = (*bind).sizeNodes });
                                (unsafe { (*bind).sizeNodes = 0 as i32 });
                                (unsafe { (*parBind).nbNodes = (*bind).nbNodes });
                                (unsafe { (*bind).nbNodes = 0 as i32 });
                            } else {
                                let fresh529 = unsafe { &mut ((*parBind).nodeTable) };
                                *fresh529 =
                                    (unsafe { xmlMalloc.expect("non-null function pointer")(
                                        ((*bind).nbNodes as u64).wrapping_mul(
                                            ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>() as u64,
                                        ),
                                    ) })
                                        as *mut xmlSchemaPSVIIDCNodePtr;
                                if (unsafe { (*parBind).nodeTable }).is_null() {
                                    xmlSchemaVErrMemory(
                                        0 as xmlSchemaValidCtxtPtr,
                                        b"allocating an array of IDC node-table items\0"
                                            as *const u8
                                            as *const i8,
                                        0 as xmlNodePtr,
                                    );
                                    xmlSchemaIDCFreeBinding(parBind);
                                    current_block = 8730031095742260322;
                                    break;
                                } else {
                                    (unsafe { (*parBind).sizeNodes = (*bind).nbNodes });
                                    (unsafe { (*parBind).nbNodes = (*bind).nbNodes });
                                    (unsafe { memcpy(
                                        (*parBind).nodeTable as *mut libc::c_void,
                                        (*bind).nodeTable as *const libc::c_void,
                                        ((*bind).nbNodes as u64).wrapping_mul(
                                            ::std::mem::size_of::<xmlSchemaPSVIIDCNodePtr>() as u64,
                                        ),
                                    ) });
                                }
                            }
                        }
                        if !(unsafe { (*bind).dupls }).is_null() {
                            if !(unsafe { (*parBind).dupls }).is_null() {
                                xmlSchemaItemListFree(unsafe { (*parBind).dupls });
                            }
                            let fresh530 = unsafe { &mut ((*parBind).dupls) };
                            *fresh530 = unsafe { (*bind).dupls };
                            let fresh531 = unsafe { &mut ((*bind).dupls) };
                            *fresh531 = 0 as xmlSchemaItemListPtr;
                        }
                        if !borrow(&parTable).is_none() {
                            if (*(borrow(&parTable)).unwrap()).is_null() {
                                *(borrow_mut(&mut parTable)).unwrap() = parBind;
                            } else {
                                let fresh532 = unsafe { &mut ((*parBind).next) };
                                *fresh532 = *(borrow_mut(&mut parTable)).unwrap();
                                *(borrow_mut(&mut parTable)).unwrap() = parBind;
                            }
                        }
                    }
                },
            }
        }
        bind = unsafe { (*bind).next };
    }
    match current_block {
        8730031095742260322 => return -(1 as i32),
        _ => return 0 as i32,
    };
}
extern "C" fn xmlSchemaCheckCVCIDCKeyRef<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> i32 {
    let mut matcher: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'_> =
        0 as *mut xmlSchemaIDCMatcher;
    let mut bind: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCBinding<'_> =
        0 as *mut xmlSchemaPSVIIDCBinding;
    matcher = unsafe { (*(*vctxt).inode).idcMatchers };
    while !matcher.is_null() {
        if (unsafe { (*matcher).idcType }) == XML_SCHEMA_TYPE_IDC_KEYREF as i32
            && !(unsafe { (*matcher).targets }).is_null()
            && (unsafe { (*(*matcher).targets).nbItems }) != 0
        {
            let mut i: i32 = 0;
            let mut j: i32 = 0;
            let mut k: i32 = 0;
            let mut res: i32 = 0;
            let mut nbFields: i32 = 0;
            let mut hasDupls: i32 = 0;
            let mut refKeys: *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'_> =
                0 as *mut xmlSchemaPSVIIDCKeyPtr;
            let mut keys: *mut *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCKey<'_> =
                0 as *mut xmlSchemaPSVIIDCKeyPtr;
            let mut refNode: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'_> =
                0 as *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'_>;
            let mut table: *mut crate::src::xmlsave::_xmlHashTable = 0 as xmlHashTablePtr;
            nbFields = unsafe { (*(*(*matcher).aidc).def).nbFields };
            bind = unsafe { (*(*vctxt).inode).idcTable };
            while !bind.is_null() {
                if (unsafe { (*(*(*(*matcher).aidc).def).ref_0).item }) as xmlSchemaIDCPtr == (unsafe { (*bind).definition })
                {
                    break;
                }
                bind = unsafe { (*bind).next };
            }
            hasDupls =
                if !bind.is_null() && !(unsafe { (*bind).dupls }).is_null() && (unsafe { (*(*bind).dupls).nbItems }) != 0 {
                    1 as i32
                } else {
                    0 as i32
                };
            if !bind.is_null() {
                table = unsafe { xmlHashCreate((*bind).nbNodes * 2 as i32) };
                j = 0 as i32;
                while j < (unsafe { (*bind).nbNodes }) {
                    let mut value: *mut u8 = 0 as *mut xmlChar;
                    let mut r: *mut crate::src::xmlschemas::_xmlIDCHashEntry =
                        0 as *mut crate::src::xmlschemas::_xmlIDCHashEntry;
                    let mut e: *mut crate::src::xmlschemas::_xmlIDCHashEntry =
                        0 as *mut xmlIDCHashEntry;
                    keys = unsafe { (**((*bind).nodeTable).offset(j as isize)).keys };
                    xmlSchemaHashKeySequence(vctxt, Some(&mut value), keys, nbFields);
                    e = (unsafe { xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<
                        xmlIDCHashEntry,
                    >()
                        as u64) }) as xmlIDCHashEntryPtr;
                    (unsafe { (*e).index = j });
                    r = (unsafe { xmlHashLookup(table, value) }) as xmlIDCHashEntryPtr;
                    if !r.is_null() {
                        let fresh533 = unsafe { &mut ((*e).next) };
                        *fresh533 = unsafe { (*r).next };
                        let fresh534 = unsafe { &mut ((*r).next) };
                        *fresh534 = e;
                    } else {
                        let fresh535 = unsafe { &mut ((*e).next) };
                        *fresh535 = 0 as xmlIDCHashEntryPtr;
                        (unsafe { xmlHashAddEntry(table, value, e as *mut libc::c_void) });
                    }
                    if !value.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(value as *mut libc::c_void) });
                        value = 0 as *mut xmlChar;
                    }
                    j += 1;
                }
            }
            i = 0 as i32;
            while i < (unsafe { (*(*matcher).targets).nbItems }) {
                res = 0 as i32;
                refNode =
                    (unsafe { *((*(*matcher).targets).items).offset(i as isize) }) as xmlSchemaPSVIIDCNodePtr;
                if !bind.is_null() {
                    let mut value_0: *mut u8 = 0 as *mut xmlChar;
                    let mut e_0: *mut crate::src::xmlschemas::_xmlIDCHashEntry =
                        0 as *mut xmlIDCHashEntry;
                    refKeys = unsafe { (*refNode).keys };
                    xmlSchemaHashKeySequence(vctxt, Some(&mut value_0), refKeys, nbFields);
                    e_0 = (unsafe { xmlHashLookup(table, value_0) }) as xmlIDCHashEntryPtr;
                    if !value_0.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(value_0 as *mut libc::c_void) });
                        value_0 = 0 as *mut xmlChar;
                    }
                    res = 0 as i32;
                    while !e_0.is_null() {
                        keys = unsafe { (**((*bind).nodeTable).offset((*e_0).index as isize)).keys };
                        k = 0 as i32;
                        while k < nbFields {
                            res = xmlSchemaAreValuesEqual(
                                unsafe { (**keys.offset(k as isize)).val },
                                unsafe { (**refKeys.offset(k as isize)).val },
                            );
                            if res == 0 as i32 {
                                break;
                            }
                            if res == -(1 as i32) {
                                return -(1 as i32);
                            }
                            k += 1;
                        }
                        if res == 1 as i32 {
                            break;
                        }
                        e_0 = unsafe { (*e_0).next };
                    }
                    if res == 0 as i32 && hasDupls != 0 {
                        j = 0 as i32;
                        while j < (unsafe { (*(*bind).dupls).nbItems }) {
                            keys = unsafe { (*(*((*(*bind).dupls).items).offset(j as isize)
                                as xmlSchemaPSVIIDCNodePtr))
                                .keys };
                            k = 0 as i32;
                            while k < nbFields {
                                res = xmlSchemaAreValuesEqual(
                                    unsafe { (**keys.offset(k as isize)).val },
                                    unsafe { (**refKeys.offset(k as isize)).val },
                                );
                                if res == 0 as i32 {
                                    break;
                                }
                                if res == -(1 as i32) {
                                    return -(1 as i32);
                                }
                                k += 1;
                            }
                            if res == 1 as i32 {
                                let mut str: *mut u8 = 0 as *mut xmlChar;
                                let mut strB: *mut u8 = 0 as *mut xmlChar;
                                xmlSchemaKeyrefErr (vctxt , XML_SCHEMAV_CVC_IDC , refNode , (unsafe { (* (* matcher) . aidc) . def }) as xmlSchemaTypePtr , b"More than one match found for key-sequence %s of keyref '%s'\0" as * const u8 as * const i8 , xmlSchemaFormatIDCKeySequence (vctxt , Some (& mut str) , unsafe { (* refNode) . keys } , nbFields ,) , xmlSchemaGetComponentQName (Some (& mut strB) , (unsafe { (* (* matcher) . aidc) . def }) as * mut libc :: c_void ,) ,) ;
                                if !str.is_null() {
                                    (unsafe { xmlFree.expect("non-null function pointer")(
                                        str as *mut libc::c_void,
                                    ) });
                                    str = 0 as *mut xmlChar;
                                }
                                if !strB.is_null() {
                                    (unsafe { xmlFree.expect("non-null function pointer")(
                                        strB as *mut libc::c_void,
                                    ) });
                                    strB = 0 as *mut xmlChar;
                                }
                                break;
                            } else {
                                j += 1;
                            }
                        }
                    }
                }
                if res == 0 as i32 {
                    let mut str_0: *mut u8 = 0 as *mut xmlChar;
                    let mut strB_0: *mut u8 = 0 as *mut xmlChar;
                    xmlSchemaKeyrefErr(
                        vctxt,
                        XML_SCHEMAV_CVC_IDC,
                        refNode,
                        (unsafe { (*(*matcher).aidc).def }) as xmlSchemaTypePtr,
                        b"No match found for key-sequence %s of keyref '%s'\0" as *const u8
                            as *const i8,
                        xmlSchemaFormatIDCKeySequence(
                            vctxt,
                            Some(&mut str_0),
                            unsafe { (*refNode).keys },
                            nbFields,
                        ),
                        xmlSchemaGetComponentQName(
                            Some(&mut strB_0),
                            (unsafe { (*(*matcher).aidc).def }) as *mut libc::c_void,
                        ),
                    );
                    if !str_0.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(str_0 as *mut libc::c_void) });
                        str_0 = 0 as *mut xmlChar;
                    }
                    if !strB_0.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(strB_0 as *mut libc::c_void) });
                        strB_0 = 0 as *mut xmlChar;
                    }
                }
                i += 1;
            }
            if !table.is_null() {
                (unsafe { xmlHashFree(table, Some(xmlFreeIDCHashEntry)) });
            }
        }
        matcher = unsafe { (*matcher).next };
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaGetFreshAttrInfo<'a1, 'a2>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'a2>
where
    'a1: 'a2,
    'a2: 'a1,
{
    let mut iattr: *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'_> =
        0 as *mut xmlSchemaAttrInfo;
    if (unsafe { (*vctxt).attrInfos }).is_null() {
        let fresh536 = unsafe { &mut ((*vctxt).attrInfos) };
        *fresh536 = (unsafe { xmlMalloc.expect("non-null function pointer")(::std::mem::size_of::<
            xmlSchemaAttrInfoPtr,
        >() as u64) }) as *mut xmlSchemaAttrInfoPtr;
        (unsafe { (*vctxt).sizeAttrInfos = 1 as i32 });
        if (unsafe { (*vctxt).attrInfos }).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"allocating attribute info list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return 0 as xmlSchemaAttrInfoPtr;
        }
    } else if (unsafe { (*vctxt).sizeAttrInfos }) <= (unsafe { (*vctxt).nbAttrInfos }) {
        let fresh537 = unsafe { &mut ((*vctxt).sizeAttrInfos) };
        *fresh537 += 1;
        let fresh538 = unsafe { &mut ((*vctxt).attrInfos) };
        *fresh538 = (unsafe { xmlRealloc.expect("non-null function pointer")(
            (*vctxt).attrInfos as *mut libc::c_void,
            ((*vctxt).sizeAttrInfos as u64)
                .wrapping_mul(::std::mem::size_of::<xmlSchemaAttrInfoPtr>() as u64),
        ) }) as *mut xmlSchemaAttrInfoPtr;
        if (unsafe { (*vctxt).attrInfos }).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"re-allocating attribute info list\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return 0 as xmlSchemaAttrInfoPtr;
        }
    } else {
        let fresh539 = unsafe { &mut ((*vctxt).nbAttrInfos) };
        let mut fresh540 = *fresh539;
        *fresh539 = *fresh539 + 1;
        iattr = unsafe { *((*vctxt).attrInfos).offset(fresh540 as isize) };
        if !(unsafe { (*iattr).localName }).is_null() {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaGetFreshAttrInfo\0" as *const u8 as *const i8,
                b"attr info not cleared\0" as *const u8 as *const i8,
            );
            return 0 as xmlSchemaAttrInfoPtr;
        }
        (unsafe { (*iattr).nodeType = XML_ATTRIBUTE_NODE as i32 });
        return iattr;
    }
    iattr = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaAttrInfo>() as u64,
    ) }) as xmlSchemaAttrInfoPtr;
    if iattr.is_null() {
        xmlSchemaVErrMemory(
            vctxt,
            b"creating new attribute info\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaAttrInfoPtr;
    }
    (unsafe { memset(
        iattr as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaAttrInfo>() as u64,
    ) });
    (unsafe { (*iattr).nodeType = XML_ATTRIBUTE_NODE as i32 });
    let fresh541 = unsafe { &mut ((*vctxt).nbAttrInfos) };
    let mut fresh542 = *fresh541;
    *fresh541 = *fresh541 + 1;
    let fresh543 = unsafe { &mut (*((*vctxt).attrInfos).offset(fresh542 as isize)) };
    *fresh543 = iattr;
    return iattr;
}
extern "C" fn xmlSchemaValidatorPushAttribute<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut attrNode: *mut crate::src::threads::_xmlNode,
    mut nodeLine: i32,
    mut localName: *const u8,
    mut nsName: *const u8,
    mut ownedNames: i32,
    mut value: *mut u8,
    mut ownedValue: i32,
) -> i32 {
    let mut attr: *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'_> = 0 as *mut xmlSchemaAttrInfo;
    attr = xmlSchemaGetFreshAttrInfo(vctxt);
    if attr.is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaPushAttribute\0" as *const u8 as *const i8,
            b"calling xmlSchemaGetFreshAttrInfo()\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    let fresh544 = unsafe { &mut ((*attr).node) };
    *fresh544 = attrNode;
    (unsafe { (*attr).nodeLine = nodeLine });
    (unsafe { (*attr).state = 1 as i32 });
    let fresh545 = unsafe { &mut ((*attr).localName) };
    *fresh545 = localName;
    let fresh546 = unsafe { &mut ((*attr).nsName) };
    *fresh546 = nsName;
    if ownedNames != 0 {
        (unsafe { (*attr).flags |= (1 as i32) << 0 as i32 });
    }
    if !nsName.is_null() {
        if xmlStrEqual(
            localName,
            b"nil\0" as *const u8 as *const i8 as *mut xmlChar,
        ) != 0
        {
            if xmlStrEqual(unsafe { (*attr).nsName }, unsafe { xmlSchemaInstanceNs }) != 0 {
                (unsafe { (*attr).metaType = 2 as i32 });
            }
        } else if xmlStrEqual(
            localName,
            b"type\0" as *const u8 as *const i8 as *mut xmlChar,
        ) != 0
        {
            if xmlStrEqual(unsafe { (*attr).nsName }, unsafe { xmlSchemaInstanceNs }) != 0 {
                (unsafe { (*attr).metaType = 1 as i32 });
            }
        } else if xmlStrEqual(
            localName,
            b"schemaLocation\0" as *const u8 as *const i8 as *mut xmlChar,
        ) != 0
        {
            if xmlStrEqual(unsafe { (*attr).nsName }, unsafe { xmlSchemaInstanceNs }) != 0 {
                (unsafe { (*attr).metaType = 3 as i32 });
            }
        } else if xmlStrEqual(
            localName,
            b"noNamespaceSchemaLocation\0" as *const u8 as *const i8 as *mut xmlChar,
        ) != 0
        {
            if xmlStrEqual(unsafe { (*attr).nsName }, unsafe { xmlSchemaInstanceNs }) != 0 {
                (unsafe { (*attr).metaType = 4 as i32 });
            }
        } else if xmlStrEqual(unsafe { (*attr).nsName }, unsafe { xmlNamespaceNs }) != 0 {
            (unsafe { (*attr).metaType = 5 as i32 });
        }
    }
    let fresh547 = unsafe { &mut ((*attr).value) };
    *fresh547 = value;
    if ownedValue != 0 {
        (unsafe { (*attr).flags |= (1 as i32) << 1 as i32 });
    }
    if (unsafe { (*attr).metaType }) != 0 as i32 {
        (unsafe { (*attr).state = 17 as i32 });
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaClearElemInfo<'a1, 'a2>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut ielem: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'a2>,
) where
    'a1: 'a2,
    'a2: 'a1,
{
    (unsafe { (*ielem).hasKeyrefs = 0 as i32 });
    (unsafe { (*ielem).appliedXPath = 0 as i32 });
    if (unsafe { (*ielem).flags }) & (1 as i32) << 0 as i32 != 0 {
        if !(unsafe { (*ielem).localName }).is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(
                (*ielem).localName as *mut xmlChar as *mut libc::c_void,
            ) });
            let fresh548 = unsafe { &mut ((*ielem).localName) };
            *fresh548 = 0 as *const xmlChar;
        }
        if !(unsafe { (*ielem).nsName }).is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(
                (*ielem).nsName as *mut xmlChar as *mut libc::c_void,
            ) });
            let fresh549 = unsafe { &mut ((*ielem).nsName) };
            *fresh549 = 0 as *const xmlChar;
        }
    } else {
        let fresh550 = unsafe { &mut ((*ielem).localName) };
        *fresh550 = 0 as *const xmlChar;
        let fresh551 = unsafe { &mut ((*ielem).nsName) };
        *fresh551 = 0 as *const xmlChar;
    }
    if (unsafe { (*ielem).flags }) & (1 as i32) << 1 as i32 != 0 {
        if !(unsafe { (*ielem).value }).is_null() {
            (unsafe { xmlFree.expect("non-null function pointer")(
                (*ielem).value as *mut xmlChar as *mut libc::c_void,
            ) });
            let fresh552 = unsafe { &mut ((*ielem).value) };
            *fresh552 = 0 as *const xmlChar;
        }
    } else {
        let fresh553 = unsafe { &mut ((*ielem).value) };
        *fresh553 = 0 as *const xmlChar;
    }
    if !(unsafe { (*ielem).val }).is_null() {
        xmlSchemaFreeValue(unsafe { (*ielem).val });
        let fresh554 = unsafe { &mut ((*ielem).val) };
        *fresh554 = 0 as xmlSchemaValPtr;
    }
    if !(unsafe { (*ielem).idcMatchers }).is_null() {
        xmlSchemaIDCReleaseMatcherList(vctxt, unsafe { (*ielem).idcMatchers });
        let fresh555 = unsafe { &mut ((*ielem).idcMatchers) };
        *fresh555 = 0 as xmlSchemaIDCMatcherPtr;
    }
    if !(unsafe { (*ielem).idcTable }).is_null() {
        xmlSchemaIDCFreeIDCTable(unsafe { (*ielem).idcTable });
        let fresh556 = unsafe { &mut ((*ielem).idcTable) };
        *fresh556 = 0 as xmlSchemaPSVIIDCBindingPtr;
    }
    if !(unsafe { (*ielem).regexCtxt }).is_null() {
        xmlRegFreeExecCtxt(unsafe { (*ielem).regexCtxt });
        let fresh557 = unsafe { &mut ((*ielem).regexCtxt) };
        *fresh557 = 0 as xmlRegExecCtxtPtr;
    }
    if !(unsafe { (*ielem).nsBindings }).is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(
            (*ielem).nsBindings as *mut *mut xmlChar as *mut libc::c_void,
        ) });
        let fresh558 = unsafe { &mut ((*ielem).nsBindings) };
        *fresh558 = 0 as *mut *const xmlChar;
        (unsafe { (*ielem).nbNsBindings = 0 as i32 });
        (unsafe { (*ielem).sizeNsBindings = 0 as i32 });
    }
}
extern "C" fn xmlSchemaGetFreshElemInfo<'a1, 'a2>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'a2>
where
    'a1: 'a2,
    'a2: 'a1,
{
    let mut info: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'_> = 0 as xmlSchemaNodeInfoPtr;
    if (unsafe { (*vctxt).depth }) > (unsafe { (*vctxt).sizeElemInfos }) {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaGetFreshElemInfo\0" as *const u8 as *const i8,
            b"inconsistent depth encountered\0" as *const u8 as *const i8,
        );
        return 0 as xmlSchemaNodeInfoPtr;
    }
    if (unsafe { (*vctxt).elemInfos }).is_null() {
        let fresh559 = unsafe { &mut ((*vctxt).elemInfos) };
        *fresh559 = (unsafe { xmlMalloc.expect("non-null function pointer")(
            (10 as i32 as u64).wrapping_mul(::std::mem::size_of::<xmlSchemaNodeInfoPtr>() as u64),
        ) }) as *mut xmlSchemaNodeInfoPtr;
        if (unsafe { (*vctxt).elemInfos }).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"allocating the element info array\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return 0 as xmlSchemaNodeInfoPtr;
        }
        (unsafe { memset(
            (*vctxt).elemInfos as *mut libc::c_void,
            0 as i32,
            (10 as i32 as u64).wrapping_mul(::std::mem::size_of::<xmlSchemaNodeInfoPtr>() as u64),
        ) });
        (unsafe { (*vctxt).sizeElemInfos = 10 as i32 });
    } else if (unsafe { (*vctxt).sizeElemInfos }) <= (unsafe { (*vctxt).depth }) {
        let mut i: i32 = unsafe { (*vctxt).sizeElemInfos };
        (unsafe { (*vctxt).sizeElemInfos *= 2 as i32 });
        let fresh560 = unsafe { &mut ((*vctxt).elemInfos) };
        *fresh560 = (unsafe { xmlRealloc.expect("non-null function pointer")(
            (*vctxt).elemInfos as *mut libc::c_void,
            ((*vctxt).sizeElemInfos as u64)
                .wrapping_mul(::std::mem::size_of::<xmlSchemaNodeInfoPtr>() as u64),
        ) }) as *mut xmlSchemaNodeInfoPtr;
        if (unsafe { (*vctxt).elemInfos }).is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"re-allocating the element info array\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return 0 as xmlSchemaNodeInfoPtr;
        }
        while i < (unsafe { (*vctxt).sizeElemInfos }) {
            let fresh561 = unsafe { &mut (*((*vctxt).elemInfos).offset(i as isize)) };
            *fresh561 = 0 as xmlSchemaNodeInfoPtr;
            i += 1;
        }
    } else {
        info = unsafe { *((*vctxt).elemInfos).offset((*vctxt).depth as isize) };
    }
    if info.is_null() {
        info = (unsafe { xmlMalloc.expect("non-null function pointer")(
            ::std::mem::size_of::<xmlSchemaNodeInfo>() as u64,
        ) }) as xmlSchemaNodeInfoPtr;
        if info.is_null() {
            xmlSchemaVErrMemory(
                vctxt,
                b"allocating an element info\0" as *const u8 as *const i8,
                0 as xmlNodePtr,
            );
            return 0 as xmlSchemaNodeInfoPtr;
        }
        let fresh562 = unsafe { &mut (*((*vctxt).elemInfos).offset((*vctxt).depth as isize)) };
        *fresh562 = info;
    } else if !(unsafe { (*info).localName }).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaGetFreshElemInfo\0" as *const u8 as *const i8,
            b"elem info has not been cleared\0" as *const u8 as *const i8,
        );
        return 0 as xmlSchemaNodeInfoPtr;
    }
    (unsafe { memset(
        info as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaNodeInfo>() as u64,
    ) });
    (unsafe { (*info).nodeType = XML_ELEMENT_NODE as i32 });
    (unsafe { (*info).depth = (*vctxt).depth });
    return info;
}
extern "C" fn xmlSchemaValidateFacets<'a1, 'a2>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
    mut valType: u32,
    mut value: *const u8,
    mut val: *mut crate::src::xmlschemastypes::_xmlSchemaVal,
    mut length: u64,
    mut fireErrors: i32,
) -> i32 {
    let mut current_block: u64;
    let mut ret: i32 = 0;
    let mut error: i32 = 0 as i32;
    let mut found: i32 = 0;
    let mut tmpType: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut facetLink: *mut crate::src::xmlschemas::_xmlSchemaFacetLink<'_> =
        0 as *mut xmlSchemaFacetLink;
    let mut facet: *mut crate::src::xmlschemas::_xmlSchemaFacet<'_> = 0 as *mut xmlSchemaFacet;
    let mut len: u64 = 0 as i32 as u64;
    let mut ws: u32 = XML_SCHEMA_WHITESPACE_UNKNOWN;
    if (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32 {
        return 0 as i32;
    }
    if !(unsafe { (*type_0).facetSet }).is_null() {
        if (unsafe { (*type_0).flags }) & (1 as i32) << 8 as i32 == 0 {
            if (unsafe { (*type_0).flags }) & (1 as i32) << 6 as i32 != 0 {
                current_block = 13331728595066369563;
            } else {
                current_block = 1410358537824353994;
            }
        } else {
            tmpType = xmlSchemaGetPrimitiveType(type_0);
            if (unsafe { (*tmpType).builtInType }) == XML_SCHEMAS_STRING as i32
                || (unsafe { (*tmpType).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
                    && (unsafe { (*tmpType).builtInType }) == XML_SCHEMAS_ANYSIMPLETYPE as i32
            {
                ws = xmlSchemaGetWhiteSpaceFacetValue(type_0);
            } else {
                ws = XML_SCHEMA_WHITESPACE_COLLAPSE;
            }
            if !val.is_null() {
                valType = xmlSchemaGetValType(val);
            }
            ret = 0 as i32;
            let mut current_block_25: u64;
            facetLink = unsafe { (*type_0).facetSet };
            while !facetLink.is_null() {
                match (unsafe { (*(*facetLink).facet).type_0 }) as u32 {
                    1008 | 1006 | 1007 => {
                        current_block_25 = 15652330335145281839;
                    },
                    1009 | 1011 | 1010 => {
                        ret = xmlSchemaValidateLengthFacetWhtsp(
                            unsafe { (*facetLink).facet },
                            valType,
                            value,
                            val,
                            Some(&mut len),
                            ws,
                        );
                        current_block_25 = 2719512138335094285;
                    },
                    _ => {
                        ret = xmlSchemaValidateFacetWhtsp(
                            unsafe { (*facetLink).facet },
                            ws,
                            valType,
                            value,
                            val,
                            ws,
                        );
                        current_block_25 = 2719512138335094285;
                    },
                }
                match current_block_25 {
                    2719512138335094285 => {
                        if ret < 0 as i32 {
                            xmlSchemaInternalErr(
                                actxt,
                                b"xmlSchemaValidateFacets\0" as *const u8 as *const i8,
                                b"validating against a atomic type facet\0" as *const u8
                                    as *const i8,
                            );
                            return -(1 as i32);
                        } else {
                            if ret > 0 as i32 {
                                if fireErrors != 0 {
                                    xmlSchemaFacetErr(
                                        actxt,
                                        ret as xmlParserErrors,
                                        node,
                                        value,
                                        len,
                                        type_0,
                                        unsafe { (*facetLink).facet },
                                        0 as *const i8,
                                        0 as *const xmlChar,
                                        0 as *const xmlChar,
                                    );
                                } else {
                                    return ret;
                                }
                                if error == 0 as i32 {
                                    error = ret;
                                }
                            }
                        }
                        ret = 0 as i32;
                    },
                    _ => {},
                }
                facetLink = unsafe { (*facetLink).next };
            }
            current_block = 13331728595066369563;
        }
        match current_block {
            1410358537824353994 => {},
            _ => {
                if !((unsafe { (*type_0).flags }) & (1 as i32) << 6 as i32 == 0) {
                    ret = 0 as i32;
                    facetLink = unsafe { (*type_0).facetSet };
                    while !facetLink.is_null() {
                        match (unsafe { (*(*facetLink).facet).type_0 }) as u32 {
                            1009 | 1011 | 1010 => {
                                ret = xmlSchemaValidateListSimpleTypeFacet(
                                    unsafe { (*facetLink).facet },
                                    value,
                                    length,
                                    Option::<&'_ mut u64>::None,
                                );
                                if ret < 0 as i32 {
                                    xmlSchemaInternalErr(
                                        actxt,
                                        b"xmlSchemaValidateFacets\0" as *const u8 as *const i8,
                                        b"validating against a list type facet\0" as *const u8
                                            as *const i8,
                                    );
                                    return -(1 as i32);
                                } else {
                                    if ret > 0 as i32 {
                                        if fireErrors != 0 {
                                            xmlSchemaFacetErr(
                                                actxt,
                                                ret as xmlParserErrors,
                                                node,
                                                value,
                                                length,
                                                type_0,
                                                unsafe { (*facetLink).facet },
                                                0 as *const i8,
                                                0 as *const xmlChar,
                                                0 as *const xmlChar,
                                            );
                                        } else {
                                            return ret;
                                        }
                                        if error == 0 as i32 {
                                            error = ret;
                                        }
                                    }
                                }
                                ret = 0 as i32;
                            },
                            _ => {},
                        }
                        facetLink = unsafe { (*facetLink).next };
                    }
                }
            },
        }
    }
    found = 0 as i32;
    ret = 0 as i32;
    tmpType = type_0;
    loop {
        facet = unsafe { (*tmpType).facets };
        while !facet.is_null() {
            if !((unsafe { (*facet).type_0 }) as u32 != XML_SCHEMA_FACET_ENUMERATION as i32 as u32) {
                found = 1 as i32;
                ret = xmlSchemaAreValuesEqual(unsafe { (*facet).val }, val);
                if ret == 1 as i32 {
                    break;
                }
                if ret < 0 as i32 {
                    xmlSchemaInternalErr(
                        actxt,
                        b"xmlSchemaValidateFacets\0" as *const u8 as *const i8,
                        b"validating against an enumeration facet\0" as *const u8 as *const i8,
                    );
                    return -(1 as i32);
                }
            }
            facet = unsafe { (*facet).next };
        }
        if ret != 0 as i32 {
            break;
        }
        if found != 0 {
            break;
        }
        tmpType = unsafe { (*tmpType).baseType };
        if !(!tmpType.is_null() && (unsafe { (*tmpType).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32)
        {
            break;
        }
    }
    if found != 0 && ret == 0 as i32 {
        ret = XML_SCHEMAV_CVC_ENUMERATION_VALID as i32;
        if fireErrors != 0 {
            xmlSchemaFacetErr(
                actxt,
                ret as xmlParserErrors,
                node,
                value,
                0 as i32 as u64,
                type_0,
                0 as xmlSchemaFacetPtr,
                0 as *const i8,
                0 as *const xmlChar,
                0 as *const xmlChar,
            );
        } else {
            return ret;
        }
        if error == 0 as i32 {
            error = ret;
        }
    }
    tmpType = type_0;
    facet = 0 as xmlSchemaFacetPtr;
    loop {
        found = 0 as i32;
        facetLink = unsafe { (*tmpType).facetSet };
        while !facetLink.is_null() {
            if !((unsafe { (*(*facetLink).facet).type_0 }) as u32 != XML_SCHEMA_FACET_PATTERN as i32 as u32) {
                found = 1 as i32;
                ret = xmlRegexpExec(unsafe { (*(*facetLink).facet).regexp }, value);
                if ret == 1 as i32 {
                    break;
                }
                if ret < 0 as i32 {
                    xmlSchemaInternalErr(
                        actxt,
                        b"xmlSchemaValidateFacets\0" as *const u8 as *const i8,
                        b"validating against a pattern facet\0" as *const u8 as *const i8,
                    );
                    return -(1 as i32);
                } else {
                    facet = unsafe { (*facetLink).facet };
                }
            }
            facetLink = unsafe { (*facetLink).next };
        }
        if found != 0 && ret != 1 as i32 {
            ret = XML_SCHEMAV_CVC_PATTERN_VALID as i32;
            if fireErrors != 0 {
                xmlSchemaFacetErr(
                    actxt,
                    ret as xmlParserErrors,
                    node,
                    value,
                    0 as i32 as u64,
                    type_0,
                    facet,
                    0 as *const i8,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
            } else {
                return ret;
            }
            if error == 0 as i32 {
                error = ret;
            }
            break;
        } else {
            tmpType = unsafe { (*tmpType).baseType };
            if !(!tmpType.is_null()
                && (unsafe { (*tmpType).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32)
            {
                break;
            }
        }
    }
    return error;
}
extern "C" fn xmlSchemaNormalizeValue<'a1>(
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a1>,
    mut value: *const u8,
) -> *mut u8 {
    match xmlSchemaGetWhiteSpaceFacetValue(type_0) as u32 {
        3 => return xmlSchemaCollapseString(value),
        2 => return xmlSchemaWhiteSpaceReplace(value),
        _ => return 0 as *mut xmlChar,
    };
}
extern "C" fn xmlSchemaValidateQName<'a1, 'a2>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut value: *const u8,
    mut val: Option<&'a2 mut *mut crate::src::xmlschemastypes::_xmlSchemaVal>,
    mut valNeeded: i32,
) -> i32 {
    let mut ret: i32 = 0;
    let mut stripped: *mut u8 = 0 as *mut xmlChar;
    let mut nsName: *const u8 = 0 as *const xmlChar;
    let mut local: *mut u8 = 0 as *mut xmlChar;
    let mut prefix: *mut u8 = 0 as *mut xmlChar;
    ret = xmlValidateQName(value, 1 as i32);
    if ret != 0 as i32 {
        if ret == -(1 as i32) {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaValidateQName\0" as *const u8 as *const i8,
                b"calling xmlValidateQName()\0" as *const u8 as *const i8,
            );
            return -(1 as i32);
        }
        return XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as i32;
    }
    stripped = xmlSchemaCollapseString(value);
    local = xmlSplitQName2(
        if !stripped.is_null() {
            stripped as *const xmlChar
        } else {
            value
        },
        Some(&mut prefix),
    );
    (unsafe { xmlFree.expect("non-null function pointer")(stripped as *mut libc::c_void) });
    if local.is_null() {
        local = xmlStrdup(value);
    }
    nsName = xmlSchemaLookupNamespace(vctxt, prefix);
    if !prefix.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(prefix as *mut libc::c_void) });
        if nsName.is_null() {
            ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as i32;
            xmlSchemaCustomErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                ret as xmlParserErrors,
                0 as xmlNodePtr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME) as xmlSchemaBasicItemPtr,
                b"The QName value '%s' has no corresponding namespace declaration in scope\0"
                    as *const u8 as *const i8,
                value,
                0 as *const xmlChar,
            );
            if !local.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(local as *mut libc::c_void) });
            }
            return ret;
        }
    }
    if valNeeded != 0 && !borrow(&val).is_none() {
        if !nsName.is_null() {
            *(borrow_mut(&mut val)).unwrap() = xmlSchemaNewQNameValue(xmlStrdup(nsName), local);
        } else {
            *(borrow_mut(&mut val)).unwrap() = xmlSchemaNewQNameValue(0 as *const xmlChar, local);
        }
    } else {
        (unsafe { xmlFree.expect("non-null function pointer")(local as *mut libc::c_void) });
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaVCheckCVCSimpleType<'a1, 'a2, 'a3>(
    mut actxt: *mut crate::src::xmlschemas::_xmlSchemaAbstractCtxt<'a1>,
    mut node: *mut crate::src::threads::_xmlNode,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a2>,
    mut value: *const u8,
    mut retVal: Option<&'a3 mut *mut crate::src::xmlschemastypes::_xmlSchemaVal>,
    mut fireErrors: i32,
    mut normalize: i32,
    mut isNormalized: i32,
) -> i32
where
    'a2: 'static,
{
    let mut current_block: u64;
    let mut ret: i32 = 0 as i32;
    let mut valNeeded: i32 = if !borrow(&retVal).is_none() {
        1 as i32
    } else {
        0 as i32
    };
    let mut val: *mut crate::src::xmlschemastypes::_xmlSchemaVal = 0 as xmlSchemaValPtr;
    let mut normValue: *mut u8 = 0 as *mut xmlChar;
    if !borrow(&retVal).is_none() && !(*(borrow_mut(&mut retVal)).unwrap()).is_null() {
        xmlSchemaFreeValue(*(borrow_mut(&mut retVal)).unwrap());
        *(borrow_mut(&mut retVal)).unwrap() = 0 as xmlSchemaValPtr;
    }
    if valNeeded == 0 && (unsafe { (*type_0).flags }) & (1 as i32) << 21 as i32 != 0 {
        valNeeded = 1 as i32;
    }
    if value.is_null() {
        value = b"\0" as *const u8 as *const i8 as *mut xmlChar;
    }
    if (unsafe { (*type_0).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
        && (unsafe { (*type_0).builtInType }) == XML_SCHEMAS_ANYSIMPLETYPE as i32
        || (unsafe { (*type_0).flags }) & (1 as i32) << 8 as i32 != 0
    {
        let mut biType: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
        if isNormalized == 0 && (normalize != 0 || (unsafe { (*type_0).flags }) & (1 as i32) << 28 as i32 != 0) {
            normValue = xmlSchemaNormalizeValue(type_0, value);
            if !normValue.is_null() {
                value = normValue;
            }
            isNormalized = 1 as i32;
        }
        if (unsafe { (*type_0).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32 {
            biType = unsafe { (*type_0).baseType };
            while !biType.is_null()
                && (unsafe { (*biType).type_0 }) as u32 != XML_SCHEMA_TYPE_BASIC as i32 as u32
            {
                biType = unsafe { (*biType).baseType };
            }
            if biType.is_null() {
                xmlSchemaInternalErr(
                    actxt,
                    b"xmlSchemaVCheckCVCSimpleType\0" as *const u8 as *const i8,
                    b"could not get the built-in type\0" as *const u8 as *const i8,
                );
                current_block = 10711413107550680511;
            } else {
                current_block = 9828876828309294594;
            }
        } else {
            biType = type_0;
            current_block = 9828876828309294594;
        }
        match current_block {
            10711413107550680511 => {},
            _ => {
                if (unsafe { (*actxt).type_0 }) == 2 as i32 {
                    match unsafe { (*biType).builtInType } {
                        28 => {
                            ret = xmlSchemaValidateNotation(
                                actxt as xmlSchemaValidCtxtPtr,
                                unsafe { (*(actxt as xmlSchemaValidCtxtPtr)).schema },
                                0 as xmlNodePtr,
                                value,
                                Some(&mut val),
                                valNeeded,
                            );
                        },
                        21 => {
                            ret = xmlSchemaValidateQName(
                                actxt as xmlSchemaValidCtxtPtr,
                                value,
                                Some(&mut val),
                                valNeeded,
                            );
                        },
                        _ => {
                            if valNeeded != 0 {
                                ret = xmlSchemaValPredefTypeNodeNoNorm(
                                    biType,
                                    value,
                                    Some(&mut val),
                                    node,
                                );
                            } else {
                                ret =
                                    xmlSchemaValPredefTypeNodeNoNorm(
                                        biType,
                                        value,
                                        Option::<
                                            &'_ mut *mut crate::src::xmlschemastypes::_xmlSchemaVal,
                                        >::None,
                                        node,
                                    );
                            }
                        },
                    }
                    current_block = 16799951812150840583;
                } else if (unsafe { (*actxt).type_0 }) == 1 as i32 {
                    match unsafe { (*biType).builtInType } {
                        28 => {
                            ret = xmlSchemaValidateNotation(
                                0 as xmlSchemaValidCtxtPtr,
                                unsafe { (*(actxt as xmlSchemaParserCtxtPtr)).schema },
                                node,
                                value,
                                Some(&mut val),
                                valNeeded,
                            );
                        },
                        _ => {
                            if valNeeded != 0 {
                                ret = xmlSchemaValPredefTypeNodeNoNorm(
                                    biType,
                                    value,
                                    Some(&mut val),
                                    node,
                                );
                            } else {
                                ret =
                                    xmlSchemaValPredefTypeNodeNoNorm(
                                        biType,
                                        value,
                                        Option::<
                                            &'_ mut *mut crate::src::xmlschemastypes::_xmlSchemaVal,
                                        >::None,
                                        node,
                                    );
                            }
                        },
                    }
                    current_block = 16799951812150840583;
                } else {
                    (unsafe { (*__xmlGenericError()).expect("non-null function pointer")(
                        *__xmlGenericErrorContext(),
                        b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
                        b"xmlschemas.c\0" as *const u8 as *const i8,
                        24827 as i32,
                    ) });
                    current_block = 10711413107550680511;
                }
                match current_block {
                    10711413107550680511 => {},
                    _ => {
                        if ret != 0 as i32 {
                            if ret < 0 as i32 {
                                xmlSchemaInternalErr(
                                    actxt,
                                    b"xmlSchemaVCheckCVCSimpleType\0" as *const u8 as *const i8,
                                    b"validating against a built-in type\0" as *const u8
                                        as *const i8,
                                );
                                current_block = 10711413107550680511;
                            } else {
                                if (unsafe { (*type_0).flags }) & (1 as i32) << 6 as i32 != 0 {
                                    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as i32;
                                } else {
                                    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as i32;
                                }
                                current_block = 13826291924415791078;
                            }
                        } else {
                            current_block = 13826291924415791078;
                        }
                        match current_block {
                            10711413107550680511 => {},
                            _ => {
                                if ret == 0 as i32 && (unsafe { (*type_0).flags }) & (1 as i32) << 27 as i32 != 0
                                {
                                    ret = xmlSchemaValidateFacets(
                                        actxt,
                                        node,
                                        type_0,
                                        (unsafe { (*biType).builtInType }) as xmlSchemaValType,
                                        value,
                                        val,
                                        0 as i32 as u64,
                                        fireErrors,
                                    );
                                    if ret != 0 as i32 {
                                        if ret < 0 as i32 {
                                            xmlSchemaInternalErr(
                                                actxt,
                                                b"xmlSchemaVCheckCVCSimpleType\0" as *const u8
                                                    as *const i8,
                                                b"validating facets of atomic simple type\0"
                                                    as *const u8
                                                    as *const i8,
                                            );
                                            current_block = 10711413107550680511;
                                        } else {
                                            if (unsafe { (*type_0).flags }) & (1 as i32) << 6 as i32 != 0 {
                                                ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as i32;
                                            } else {
                                                ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 as i32;
                                            }
                                            current_block = 8953117030348968745;
                                        }
                                    } else {
                                        current_block = 8953117030348968745;
                                    }
                                } else {
                                    if fireErrors != 0 && ret > 0 as i32 {
                                        xmlSchemaSimpleTypeErr(
                                            actxt,
                                            ret as xmlParserErrors,
                                            node,
                                            value,
                                            type_0,
                                            1 as i32,
                                        );
                                    }
                                    current_block = 8953117030348968745;
                                }
                            },
                        }
                    },
                }
            },
        }
    } else if (unsafe { (*type_0).flags }) & (1 as i32) << 6 as i32 != 0 {
        let mut itemType: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
        let mut cur: *const u8 = 0 as *const xmlChar;
        let mut end: *const u8 = 0 as *const xmlChar;
        let mut tmpValue: *mut u8 = 0 as *mut xmlChar;
        let mut len: u64 = 0 as i32 as u64;
        let mut prevVal: *mut crate::src::xmlschemastypes::_xmlSchemaVal = 0 as xmlSchemaValPtr;
        let mut curVal: *mut crate::src::xmlschemastypes::_xmlSchemaVal = 0 as xmlSchemaValPtr;
        if isNormalized == 0 && (normalize != 0 || (unsafe { (*type_0).flags }) & (1 as i32) << 28 as i32 != 0) {
            normValue = xmlSchemaNormalizeValue(type_0, value);
            if !normValue.is_null() {
                value = normValue;
            }
            isNormalized = 1 as i32;
        }
        itemType = unsafe { (*type_0).subtypes };
        cur = value;
        loop {
            while (unsafe { *cur }) as i32 == 0x20 as i32
                || 0x9 as i32 <= (unsafe { *cur }) as i32 && (unsafe { *cur }) as i32 <= 0xa as i32
                || (unsafe { *cur }) as i32 == 0xd as i32
            {
                cur = unsafe { cur.offset(1) };
            }
            end = cur;
            while (unsafe { *end }) as i32 != 0 as i32
                && !((unsafe { *end }) as i32 == 0x20 as i32
                    || 0x9 as i32 <= (unsafe { *end }) as i32 && (unsafe { *end }) as i32 <= 0xa as i32
                    || (unsafe { *end }) as i32 == 0xd as i32)
            {
                end = unsafe { end.offset(1) };
            }
            if end == cur {
                current_block = 4804377075063615140;
                break;
            }
            tmpValue = xmlStrndup(cur, (unsafe { end.offset_from(cur) }) as i64 as i32);
            len = len.wrapping_add(1);
            if valNeeded != 0 {
                ret = xmlSchemaVCheckCVCSimpleType(
                    actxt,
                    node,
                    itemType,
                    tmpValue,
                    Some(&mut curVal),
                    fireErrors,
                    0 as i32,
                    1 as i32,
                );
            } else {
                ret = xmlSchemaVCheckCVCSimpleType(
                    actxt,
                    node,
                    itemType,
                    tmpValue,
                    Option::<&'_ mut *mut crate::src::xmlschemastypes::_xmlSchemaVal>::None,
                    fireErrors,
                    0 as i32,
                    1 as i32,
                );
            }
            if !tmpValue.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(tmpValue as *mut libc::c_void) });
                tmpValue = 0 as *mut xmlChar;
            }
            if !curVal.is_null() {
                if val.is_null() {
                    val = curVal;
                } else {
                    xmlSchemaValueAppend(prevVal, curVal);
                }
                prevVal = curVal;
                curVal = 0 as xmlSchemaValPtr;
            }
            if ret != 0 as i32 {
                if ret < 0 as i32 {
                    xmlSchemaInternalErr(
                        actxt,
                        b"xmlSchemaVCheckCVCSimpleType\0" as *const u8 as *const i8,
                        b"validating an item of list simple type\0" as *const u8 as *const i8,
                    );
                    current_block = 10711413107550680511;
                    break;
                } else {
                    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as i32;
                    current_block = 4804377075063615140;
                    break;
                }
            } else {
                cur = end;
                if !((unsafe { *cur }) as i32 != 0 as i32) {
                    current_block = 4804377075063615140;
                    break;
                }
            }
        }
        match current_block {
            10711413107550680511 => {},
            _ => {
                if !tmpValue.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(tmpValue as *mut libc::c_void) });
                    tmpValue = 0 as *mut xmlChar;
                }
                if ret == 0 as i32 && (unsafe { (*type_0).flags }) & (1 as i32) << 27 as i32 != 0 {
                    ret = xmlSchemaValidateFacets(
                        actxt,
                        node,
                        type_0,
                        XML_SCHEMAS_UNKNOWN,
                        value,
                        val,
                        len,
                        fireErrors,
                    );
                    if ret != 0 as i32 {
                        if ret < 0 as i32 {
                            xmlSchemaInternalErr(
                                actxt,
                                b"xmlSchemaVCheckCVCSimpleType\0" as *const u8 as *const i8,
                                b"validating facets of list simple type\0" as *const u8
                                    as *const i8,
                            );
                            current_block = 10711413107550680511;
                        } else {
                            ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 as i32;
                            current_block = 8533724845731836612;
                        }
                    } else {
                        current_block = 8533724845731836612;
                    }
                } else {
                    current_block = 8533724845731836612;
                }
                match current_block {
                    10711413107550680511 => {},
                    _ => {
                        if fireErrors != 0 && ret > 0 as i32 {
                            normalize = 1 as i32;
                            if isNormalized == 0
                                && (normalize != 0
                                    || (unsafe { (*type_0).flags }) & (1 as i32) << 28 as i32 != 0)
                            {
                                normValue = xmlSchemaNormalizeValue(type_0, value);
                                if !normValue.is_null() {
                                    value = normValue;
                                }
                                isNormalized = 1 as i32;
                            }
                            xmlSchemaSimpleTypeErr(
                                actxt,
                                ret as xmlParserErrors,
                                node,
                                value,
                                type_0,
                                1 as i32,
                            );
                        }
                        current_block = 8953117030348968745;
                    },
                }
            },
        }
    } else if (unsafe { (*type_0).flags }) & (1 as i32) << 7 as i32 != 0 {
        let mut memberLink: *mut crate::src::xmlschemas::_xmlSchemaTypeLink<'_> =
            0 as *mut xmlSchemaTypeLink;
        memberLink = xmlSchemaGetUnionSimpleTypeMemberTypes(type_0);
        if memberLink.is_null() {
            xmlSchemaInternalErr(
                actxt,
                b"xmlSchemaVCheckCVCSimpleType\0" as *const u8 as *const i8,
                b"union simple type has no member types\0" as *const u8 as *const i8,
            );
            current_block = 10711413107550680511;
        } else {
            while !memberLink.is_null() {
                if valNeeded != 0 {
                    ret = xmlSchemaVCheckCVCSimpleType(
                        actxt,
                        node,
                        unsafe { (*memberLink).type_0 },
                        value,
                        Some(&mut val),
                        0 as i32,
                        1 as i32,
                        0 as i32,
                    );
                } else {
                    ret = xmlSchemaVCheckCVCSimpleType(
                        actxt,
                        node,
                        unsafe { (*memberLink).type_0 },
                        value,
                        Option::<&'_ mut *mut crate::src::xmlschemastypes::_xmlSchemaVal>::None,
                        0 as i32,
                        1 as i32,
                        0 as i32,
                    );
                }
                if ret <= 0 as i32 {
                    break;
                }
                memberLink = unsafe { (*memberLink).next };
            }
            if ret != 0 as i32 {
                if ret < 0 as i32 {
                    xmlSchemaInternalErr(
                        actxt,
                        b"xmlSchemaVCheckCVCSimpleType\0" as *const u8 as *const i8,
                        b"validating members of union simple type\0" as *const u8 as *const i8,
                    );
                    current_block = 10711413107550680511;
                } else {
                    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3 as i32;
                    current_block = 4871270227279186910;
                }
            } else {
                current_block = 4871270227279186910;
            }
            match current_block {
                10711413107550680511 => {},
                _ => {
                    if ret == 0 as i32 && (unsafe { (*type_0).flags }) & (1 as i32) << 27 as i32 != 0 {
                        if isNormalized == 0
                            && (normalize != 0 || (unsafe { (*type_0).flags }) & (1 as i32) << 28 as i32 != 0)
                        {
                            normValue = xmlSchemaNormalizeValue(unsafe { (*memberLink).type_0 }, value);
                            if !normValue.is_null() {
                                value = normValue;
                            }
                            isNormalized = 1 as i32;
                        }
                        ret = xmlSchemaValidateFacets(
                            actxt,
                            node,
                            type_0,
                            XML_SCHEMAS_UNKNOWN,
                            value,
                            val,
                            0 as i32 as u64,
                            fireErrors,
                        );
                        if ret != 0 as i32 {
                            if ret < 0 as i32 {
                                xmlSchemaInternalErr(
                                    actxt,
                                    b"xmlSchemaVCheckCVCSimpleType\0" as *const u8 as *const i8,
                                    b"validating facets of union simple type\0" as *const u8
                                        as *const i8,
                                );
                                current_block = 10711413107550680511;
                            } else {
                                ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3 as i32;
                                current_block = 7198204517578597543;
                            }
                        } else {
                            current_block = 7198204517578597543;
                        }
                    } else {
                        current_block = 7198204517578597543;
                    }
                    match current_block {
                        10711413107550680511 => {},
                        _ => {
                            if fireErrors != 0 && ret > 0 as i32 {
                                xmlSchemaSimpleTypeErr(
                                    actxt,
                                    ret as xmlParserErrors,
                                    node,
                                    value,
                                    type_0,
                                    1 as i32,
                                );
                            }
                            current_block = 8953117030348968745;
                        },
                    }
                },
            }
        }
    } else {
        current_block = 8953117030348968745;
    }
    match current_block {
        10711413107550680511 => {
            if !normValue.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(normValue as *mut libc::c_void) });
            }
            if !val.is_null() {
                xmlSchemaFreeValue(val);
            }
            return -(1 as i32);
        },
        _ => {
            if !normValue.is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(normValue as *mut libc::c_void) });
            }
            if ret == 0 as i32 {
                if !borrow(&retVal).is_none() {
                    *(borrow_mut(&mut retVal)).unwrap() = val;
                } else if !val.is_null() {
                    xmlSchemaFreeValue(val);
                }
            } else if !val.is_null() {
                xmlSchemaFreeValue(val);
            }
            return ret;
        },
    };
}
extern "C" fn xmlSchemaVExpandQName<'a1, 'a2, 'a3>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut value: *const u8,
    mut nsName: Option<&'a2 mut *const u8>,
    mut localName: Option<&'a3 mut *const u8>,
) -> i32 {
    let mut ret: i32 = 0 as i32;
    if borrow(&nsName).is_none() || borrow(&localName).is_none() {
        return -(1 as i32);
    }
    *(borrow_mut(&mut nsName)).unwrap() = 0 as *const xmlChar;
    *(borrow_mut(&mut localName)).unwrap() = 0 as *const xmlChar;
    ret = xmlValidateQName(value, 1 as i32);
    if ret == -(1 as i32) {
        return -(1 as i32);
    }
    if ret > 0 as i32 {
        xmlSchemaSimpleTypeErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1,
            0 as xmlNodePtr,
            value,
            xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME),
            1 as i32,
        );
        return 1 as i32;
    }
    let mut local: *mut u8 = 0 as *mut xmlChar;
    let mut prefix: *mut u8 = 0 as *mut xmlChar;
    local = xmlSplitQName2(value, Some(&mut prefix));
    if local.is_null() {
        *(borrow_mut(&mut localName)).unwrap() = unsafe { xmlDictLookup((*vctxt).dict, value, -(1 as i32)) };
    } else {
        *(borrow_mut(&mut localName)).unwrap() = unsafe { xmlDictLookup((*vctxt).dict, local, -(1 as i32)) };
        (unsafe { xmlFree.expect("non-null function pointer")(local as *mut libc::c_void) });
    }
    *(borrow_mut(&mut nsName)).unwrap() = xmlSchemaLookupNamespace(vctxt, prefix);
    if !prefix.is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")(prefix as *mut libc::c_void) });
        if (*(borrow_mut(&mut nsName)).unwrap()).is_null() {
            xmlSchemaCustomErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1,
                0 as xmlNodePtr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_QNAME) as xmlSchemaBasicItemPtr,
                b"The QName value '%s' has no corresponding namespace declaration in scope\0"
                    as *const u8 as *const i8,
                value,
                0 as *const xmlChar,
            );
            return 2 as i32;
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaProcessXSIType<'a1, 'a2, 'a3, 'a4>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut iattr: *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'a2>,
    mut localType: *mut *mut crate::src::xmlschemas::_xmlSchemaType<'a3>,
    mut elemDecl: *mut crate::src::xmlschemas::_xmlSchemaElement<'a4>,
) -> i32
where
    'a3: 'static,
    'a3: 'a4,
    'a4: 'a3,
{
    let mut ret: i32 = 0 as i32;
    if localType.is_null() {
        return -(1 as i32);
    }
    (unsafe { *localType = 0 as xmlSchemaTypePtr });
    if iattr.is_null() {
        return 0 as i32;
    } else {
        let mut nsName: *const u8 = 0 as *const xmlChar;
        let mut local: *const u8 = 0 as *const xmlChar;
        let fresh563 = unsafe { &mut ((*vctxt).inode) };
        *fresh563 = iattr as xmlSchemaNodeInfoPtr;
        ret = xmlSchemaVExpandQName(vctxt, unsafe { (*iattr).value }, Some(&mut nsName), Some(&mut local));
        if ret != 0 as i32 {
            if ret < 0 as i32 {
                xmlSchemaInternalErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaValidateElementByDeclaration\0" as *const u8 as *const i8,
                    b"calling xmlSchemaQNameExpand() to validate the attribute 'xsi:type'\0"
                        as *const u8 as *const i8,
                );
                let fresh565 = unsafe { &mut ((*vctxt).inode) };
                *fresh565 = unsafe { *((*vctxt).elemInfos).offset((*vctxt).depth as isize) };
                return -(1 as i32);
            }
        } else {
            (unsafe { *localType = xmlSchemaGetType((*vctxt).schema, local, nsName) });
            if (unsafe { *localType }).is_null() {
                let mut str: *mut u8 = 0 as *mut xmlChar;
                xmlSchemaCustomErr (vctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAV_CVC_ELT_4_2 , 0 as xmlNodePtr , xmlSchemaGetBuiltInType (XML_SCHEMAS_QNAME) as xmlSchemaBasicItemPtr , b"The QName value '%s' of the xsi:type attribute does not resolve to a type definition\0" as * const u8 as * const i8 , xmlSchemaFormatQName (Some (& mut str) , nsName , local) , 0 as * const xmlChar ,) ;
                if !str.is_null() {
                    (unsafe { xmlFree.expect("non-null function pointer")(str as *mut libc::c_void) });
                    str = 0 as *mut xmlChar;
                }
                ret = unsafe { (*vctxt).err };
            } else if !elemDecl.is_null() {
                let mut set: i32 = 0 as i32;
                if (unsafe { (*elemDecl).flags }) & (1 as i32) << 11 as i32 != 0
                    || (unsafe { (*(*elemDecl).subtypes).flags }) & (1 as i32) << 18 as i32 != 0
                {
                    set |= (1 as i32) << 1 as i32;
                }
                if (unsafe { (*elemDecl).flags }) & (1 as i32) << 12 as i32 != 0
                    || (unsafe { (*(*elemDecl).subtypes).flags }) & (1 as i32) << 19 as i32 != 0
                {
                    set |= (1 as i32) << 0 as i32;
                }
                if xmlSchemaCheckCOSDerivedOK(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    unsafe { *localType },
                    unsafe { (*elemDecl).subtypes },
                    set,
                ) != 0 as i32
                {
                    let mut str_0: *mut u8 = 0 as *mut xmlChar;
                    xmlSchemaCustomErr (vctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAV_CVC_ELT_4_3 , 0 as xmlNodePtr , 0 as xmlSchemaBasicItemPtr , b"The type definition '%s', specified by xsi:type, is blocked or not validly derived from the type definition of the element declaration\0" as * const u8 as * const i8 , xmlSchemaFormatQName (Some (& mut str_0) , unsafe { (* * localType) . targetNamespace } , unsafe { (* * localType) . name } ,) , 0 as * const xmlChar ,) ;
                    if !str_0.is_null() {
                        (unsafe { xmlFree.expect("non-null function pointer")(str_0 as *mut libc::c_void) });
                        str_0 = 0 as *mut xmlChar;
                    }
                    ret = unsafe { (*vctxt).err };
                    (unsafe { *localType = 0 as xmlSchemaTypePtr });
                }
            }
        }
        let fresh564 = unsafe { &mut ((*vctxt).inode) };
        *fresh564 = unsafe { *((*vctxt).elemInfos).offset((*vctxt).depth as isize) };
        return ret;
    };
}
extern "C" fn xmlSchemaValidateElemDecl<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> i32
where
    'a1: 'static,
{
    let mut elemDecl: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> = unsafe { (*(*vctxt).inode).decl };
    let mut actualType: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    if elemDecl.is_null() {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_ELT_1,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"No matching declaration available\0" as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return unsafe { (*vctxt).err };
    }
    actualType = unsafe { (*elemDecl).subtypes };
    if (unsafe { (*elemDecl).flags }) & (1 as i32) << 4 as i32 != 0 {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_ELT_2,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"The element declaration is abstract\0" as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return unsafe { (*vctxt).err };
    }
    if actualType.is_null() {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_TYPE_1,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"The type definition is absent\0" as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return XML_SCHEMAV_CVC_TYPE_1 as i32;
    }
    if (unsafe { (*vctxt).nbAttrInfos }) != 0 as i32 {
        let mut ret: i32 = 0;
        let mut iattr: *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'_> =
            0 as *mut xmlSchemaAttrInfo;
        iattr = xmlSchemaGetMetaAttrInfo(vctxt, 2 as i32);
        if !iattr.is_null() {
            let fresh566 = unsafe { &mut ((*vctxt).inode) };
            *fresh566 = iattr as xmlSchemaNodeInfoPtr;
            ret = xmlSchemaVCheckCVCSimpleType(
                vctxt as xmlSchemaAbstractCtxtPtr,
                0 as xmlNodePtr,
                xmlSchemaGetBuiltInType(XML_SCHEMAS_BOOLEAN),
                unsafe { (*iattr).value },
                Some(unsafe { &mut (*iattr).val }),
                1 as i32,
                0 as i32,
                0 as i32,
            );
            let fresh567 = unsafe { &mut ((*vctxt).inode) };
            *fresh567 = unsafe { *((*vctxt).elemInfos).offset((*vctxt).depth as isize) };
            if ret < 0 as i32 {
                xmlSchemaInternalErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaValidateElemDecl\0" as *const u8 as *const i8,
                    b"calling xmlSchemaVCheckCVCSimpleType() to validate the attribute 'xsi:nil'\0"
                        as *const u8 as *const i8,
                );
                return -(1 as i32);
            }
            if ret == 0 as i32 {
                if (unsafe { (*elemDecl).flags }) & (1 as i32) << 0 as i32 == 0 as i32 {
                    xmlSchemaCustomErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAV_CVC_ELT_3_1,
                        0 as xmlNodePtr,
                        0 as xmlSchemaBasicItemPtr,
                        b"The element is not 'nillable'\0" as *const u8 as *const i8,
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                } else if xmlSchemaValueGetAsBoolean(unsafe { (*iattr).val }) != 0 {
                    if (unsafe { (*elemDecl).flags }) & (1 as i32) << 3 as i32 != 0
                        && !(unsafe { (*elemDecl).value }).is_null()
                    {
                        xmlSchemaCustomErr (vctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAV_CVC_ELT_3_2_2 , 0 as xmlNodePtr , 0 as xmlSchemaBasicItemPtr , b"The element cannot be 'nilled' because there is a fixed value constraint defined for it\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
                    } else {
                        (unsafe { (*(*vctxt).inode).flags |= (1 as i32) << 2 as i32 });
                    }
                }
            }
        }
        iattr = xmlSchemaGetMetaAttrInfo(vctxt, 1 as i32);
        if !iattr.is_null() {
            let mut localType: *mut crate::src::xmlschemas::_xmlSchemaType<'_> =
                0 as xmlSchemaTypePtr;
            ret = xmlSchemaProcessXSIType(vctxt, iattr, &mut localType, elemDecl);
            if ret != 0 as i32 {
                if ret == -(1 as i32) {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaValidateElemDecl\0" as *const u8 as *const i8,
                        b"calling xmlSchemaProcessXSIType() to process the attribute 'xsi:type'\0"
                            as *const u8 as *const i8,
                    );
                    return -(1 as i32);
                }
            }
            if !localType.is_null() {
                (unsafe { (*(*vctxt).inode).flags |= (1 as i32) << 3 as i32 });
                actualType = localType;
            }
        }
    }
    if !(unsafe { (*elemDecl).idcs }).is_null() && xmlSchemaIDCRegisterMatchers(vctxt, elemDecl) == -(1 as i32)
    {
        return -(1 as i32);
    }
    if actualType.is_null() {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_TYPE_1,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"The type definition is absent\0" as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return XML_SCHEMAV_CVC_TYPE_1 as i32;
    }
    let fresh568 = unsafe { &mut ((*(*vctxt).inode).typeDef) };
    *fresh568 = actualType;
    return 0 as i32;
}
extern "C" fn xmlSchemaVAttributesSimple<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> i32 {
    let mut iattr: *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'_> =
        0 as *mut xmlSchemaAttrInfo;
    let mut ret: i32 = 0 as i32;
    let mut i: i32 = 0;
    if (unsafe { (*vctxt).nbAttrInfos }) == 0 as i32 {
        return 0 as i32;
    }
    i = 0 as i32;
    while i < (unsafe { (*vctxt).nbAttrInfos }) {
        iattr = unsafe { *((*vctxt).attrInfos).offset(i as isize) };
        if (unsafe { (*iattr).metaType }) == 0 {
            let fresh569 = unsafe { &mut ((*vctxt).inode) };
            *fresh569 = iattr as xmlSchemaNodeInfoPtr;
            xmlSchemaIllegalAttrErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                XML_SCHEMAV_CVC_TYPE_3_1_1,
                iattr,
                0 as xmlNodePtr,
            );
            ret = XML_SCHEMAV_CVC_TYPE_3_1_1 as i32;
        }
        i += 1;
    }
    let fresh570 = unsafe { &mut ((*vctxt).inode) };
    *fresh570 = unsafe { *((*vctxt).elemInfos).offset((*vctxt).depth as isize) };
    return ret;
}
extern "C" fn xmlSchemaClearAttrInfos<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) {
    let mut i: i32 = 0;
    let mut attr: *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'_> = 0 as *mut xmlSchemaAttrInfo;
    if (unsafe { (*vctxt).nbAttrInfos }) == 0 as i32 {
        return;
    }
    i = 0 as i32;
    while i < (unsafe { (*vctxt).nbAttrInfos }) {
        attr = unsafe { *((*vctxt).attrInfos).offset(i as isize) };
        if (unsafe { (*attr).flags }) & (1 as i32) << 0 as i32 != 0 {
            if !(unsafe { (*attr).localName }).is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(
                    (*attr).localName as *mut xmlChar as *mut libc::c_void,
                ) });
            }
            if !(unsafe { (*attr).nsName }).is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(
                    (*attr).nsName as *mut xmlChar as *mut libc::c_void,
                ) });
            }
        }
        if (unsafe { (*attr).flags }) & (1 as i32) << 1 as i32 != 0 {
            if !(unsafe { (*attr).value }).is_null() {
                (unsafe { xmlFree.expect("non-null function pointer")(
                    (*attr).value as *mut xmlChar as *mut libc::c_void,
                ) });
            }
        }
        if !(unsafe { (*attr).val }).is_null() {
            xmlSchemaFreeValue(unsafe { (*attr).val });
            let fresh571 = unsafe { &mut ((*attr).val) };
            *fresh571 = 0 as xmlSchemaValPtr;
        }
        (unsafe { memset(
            attr as *mut libc::c_void,
            0 as i32,
            ::std::mem::size_of::<xmlSchemaAttrInfo>() as u64,
        ) });
        i += 1;
    }
    (unsafe { (*vctxt).nbAttrInfos = 0 as i32 });
}
extern "C" fn xmlSchemaVAttributesComplex<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> i32
where
    'a1: 'static,
{
    let mut current_block: u64;
    let mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = unsafe { (*(*vctxt).inode).typeDef };
    let mut attrUseList: *mut crate::src::xmlschemas::_xmlSchemaItemList =
        0 as *mut crate::src::xmlschemas::_xmlSchemaItemList;
    let mut attrUse: *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_> =
        0 as *mut crate::src::xmlschemas::_xmlSchemaAttributeUse<'_>;
    let mut attrDecl: *mut crate::src::xmlschemas::_xmlSchemaAttribute<'_> =
        0 as xmlSchemaAttributePtr;
    let mut iattr: *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'_> =
        0 as *mut xmlSchemaAttrInfo;
    let mut tmpiattr: *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'_> =
        0 as *mut xmlSchemaAttrInfo;
    let mut i: i32 = 0;
    let mut j: i32 = 0;
    let mut found: i32 = 0;
    let mut nbAttrs: i32 = 0;
    let mut nbUses: i32 = 0;
    let mut xpathRes: i32 = 0 as i32;
    let mut res: i32 = 0;
    let mut wildIDs: i32 = 0 as i32;
    let mut fixed: i32 = 0;
    let mut defAttrOwnerElem: *mut crate::src::threads::_xmlNode = 0 as xmlNodePtr;
    attrUseList = (unsafe { (*type_0).attrUses }) as xmlSchemaItemListPtr;
    nbAttrs = unsafe { (*vctxt).nbAttrInfos };
    if !attrUseList.is_null() {
        nbUses = unsafe { (*attrUseList).nbItems };
    } else {
        nbUses = 0 as i32;
    }
    i = 0 as i32;
    while i < nbUses {
        found = 0 as i32;
        attrUse = (unsafe { *((*attrUseList).items).offset(i as isize) }) as xmlSchemaAttributeUsePtr;
        attrDecl = unsafe { (*attrUse).attrDecl };
        j = 0 as i32;
        while j < nbAttrs {
            iattr = unsafe { *((*vctxt).attrInfos).offset(j as isize) };
            if !((unsafe { (*iattr).metaType }) != 0) {
                if !((unsafe { *((*iattr).localName).offset(0 as i32 as isize) }) as i32
                    != (unsafe { *((*attrDecl).name).offset(0 as i32 as isize) }) as i32)
                {
                    if !(xmlStrEqual(unsafe { (*iattr).localName }, unsafe { (*attrDecl).name }) == 0) {
                        if !(xmlStrEqual(unsafe { (*iattr).nsName }, unsafe { (*attrDecl).targetNamespace }) == 0) {
                            found = 1 as i32;
                            (unsafe { (*iattr).state = 2 as i32 });
                            let fresh572 = unsafe { &mut ((*iattr).use_0) };
                            *fresh572 = attrUse;
                            let fresh573 = unsafe { &mut ((*iattr).decl) };
                            *fresh573 = attrDecl;
                            let fresh574 = unsafe { &mut ((*iattr).typeDef) };
                            *fresh574 = unsafe { (*attrDecl).subtypes };
                            break;
                        }
                    }
                }
            }
            j += 1;
        }
        if !(found != 0) {
            if (unsafe { (*attrUse).occurs }) == 1 as i32 {
                tmpiattr = xmlSchemaGetFreshAttrInfo(vctxt);
                if tmpiattr.is_null() {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaVAttributesComplex\0" as *const u8 as *const i8,
                        b"calling xmlSchemaGetFreshAttrInfo()\0" as *const u8 as *const i8,
                    );
                    return -(1 as i32);
                }
                (unsafe { (*tmpiattr).state = 4 as i32 });
                let fresh575 = unsafe { &mut ((*tmpiattr).use_0) };
                *fresh575 = attrUse;
                let fresh576 = unsafe { &mut ((*tmpiattr).decl) };
                *fresh576 = attrDecl;
            } else if (unsafe { (*attrUse).occurs }) == 2 as i32
                && (!(unsafe { (*attrUse).defValue }).is_null() || !(unsafe { (*attrDecl).defValue }).is_null())
            {
                tmpiattr = xmlSchemaGetFreshAttrInfo(vctxt);
                if tmpiattr.is_null() {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaVAttributesComplex\0" as *const u8 as *const i8,
                        b"calling xmlSchemaGetFreshAttrInfo()\0" as *const u8 as *const i8,
                    );
                    return -(1 as i32);
                }
                (unsafe { (*tmpiattr).state = 8 as i32 });
                let fresh577 = unsafe { &mut ((*tmpiattr).use_0) };
                *fresh577 = attrUse;
                let fresh578 = unsafe { &mut ((*tmpiattr).decl) };
                *fresh578 = attrDecl;
                let fresh579 = unsafe { &mut ((*tmpiattr).typeDef) };
                *fresh579 = unsafe { (*attrDecl).subtypes };
                let fresh580 = unsafe { &mut ((*tmpiattr).localName) };
                *fresh580 = unsafe { (*attrDecl).name };
                let fresh581 = unsafe { &mut ((*tmpiattr).nsName) };
                *fresh581 = unsafe { (*attrDecl).targetNamespace };
            }
        }
        i += 1;
    }
    if (unsafe { (*vctxt).nbAttrInfos }) == 0 as i32 {
        return 0 as i32;
    }
    if !(unsafe { (*type_0).attributeWildcard }).is_null() {
        i = 0 as i32;
        while i < nbAttrs {
            iattr = unsafe { *((*vctxt).attrInfos).offset(i as isize) };
            if !((unsafe { (*iattr).state }) != 1 as i32) {
                if xmlSchemaCheckCVCWildcardNamespace(unsafe { (*type_0).attributeWildcard }, unsafe { (*iattr).nsName })
                    == 0 as i32
                {
                    if (unsafe { (*(*type_0).attributeWildcard).processContents }) == 1 as i32 {
                        (unsafe { (*iattr).state = 13 as i32 });
                    } else {
                        let fresh582 = unsafe { &mut ((*iattr).decl) };
                        *fresh582 = xmlSchemaGetAttributeDecl(
                            unsafe { (*vctxt).schema },
                            unsafe { (*iattr).localName },
                            unsafe { (*iattr).nsName },
                        );
                        if !(unsafe { (*iattr).decl }).is_null() {
                            (unsafe { (*iattr).state = 2 as i32 });
                            let fresh583 = unsafe { &mut ((*iattr).typeDef) };
                            *fresh583 = unsafe { (*(*iattr).decl).subtypes };
                            if xmlSchemaIsDerivedFromBuiltInType(
                                unsafe { (*iattr).typeDef },
                                XML_SCHEMAS_ID as i32,
                            ) != 0
                            {
                                if wildIDs != 0 as i32 {
                                    (unsafe { (*iattr).state = 15 as i32 });
                                    (unsafe { (*__xmlGenericError()).expect("non-null function pointer")(
                                        *__xmlGenericErrorContext(),
                                        b"Unimplemented block at %s:%d\n\0" as *const u8
                                            as *const i8,
                                        b"xmlschemas.c\0" as *const u8 as *const i8,
                                        25640 as i32,
                                    ) });
                                } else {
                                    wildIDs += 1;
                                    if !attrUseList.is_null() {
                                        j = 0 as i32;
                                        while j < (unsafe { (*attrUseList).nbItems }) {
                                            if xmlSchemaIsDerivedFromBuiltInType(
                                                unsafe { (*(*(*((*attrUseList).items).offset(j as isize)
                                                    as xmlSchemaAttributeUsePtr))
                                                    .attrDecl)
                                                    .subtypes },
                                                XML_SCHEMAS_ID as i32,
                                            ) != 0
                                            {
                                                (unsafe { (*iattr).state = 16 as i32 });
                                                (unsafe { (*__xmlGenericError())
                                                    .expect("non-null function pointer")(
                                                    *__xmlGenericErrorContext(),
                                                    b"Unimplemented block at %s:%d\n\0" as *const u8
                                                        as *const i8,
                                                    b"xmlschemas.c\0" as *const u8 as *const i8,
                                                    25658 as i32,
                                                ) });
                                                break;
                                            } else {
                                                j += 1;
                                            }
                                        }
                                    }
                                }
                            }
                        } else if (unsafe { (*(*type_0).attributeWildcard).processContents }) == 2 as i32 {
                            (unsafe { (*iattr).state = 14 as i32 });
                        } else {
                            (unsafe { (*iattr).state = 10 as i32 });
                        }
                    }
                }
            }
            i += 1;
        }
    }
    if (unsafe { (*vctxt).nbAttrInfos }) == 0 as i32 {
        return 0 as i32;
    }
    if (unsafe { (*vctxt).options }) & XML_SCHEMA_VAL_VC_I_CREATE as i32 != 0 {
        let mut ielem: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'_> =
            unsafe { *((*vctxt).elemInfos).offset((*vctxt).depth as isize) };
        if !ielem.is_null() && !(unsafe { (*ielem).node }).is_null() && !(unsafe { (*(*ielem).node).doc }).is_null() {
            defAttrOwnerElem = unsafe { (*ielem).node };
        }
    }
    i = 0 as i32;
    's_457: loop {
        if !(i < (unsafe { (*vctxt).nbAttrInfos })) {
            current_block = 12463749970033092792;
            break;
        }
        iattr = unsafe { *((*vctxt).attrInfos).offset(i as isize) };
        if !((unsafe { (*iattr).state }) != 2 as i32 && (unsafe { (*iattr).state }) != 8 as i32) {
            if (unsafe { (*iattr).typeDef }).is_null() {
                (unsafe { (*iattr).state = 6 as i32 });
            } else {
                let fresh584 = unsafe { &mut ((*vctxt).inode) };
                *fresh584 = iattr as xmlSchemaNodeInfoPtr;
                fixed = 0 as i32;
                xpathRes = 0 as i32;
                if !(unsafe { (*vctxt).xpathStates }).is_null() {
                    xpathRes = xmlSchemaXPathEvaluate(vctxt, XML_ATTRIBUTE_NODE);
                    if xpathRes == -(1 as i32) {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaVAttributesComplex\0" as *const u8 as *const i8,
                            b"calling xmlSchemaXPathEvaluate()\0" as *const u8 as *const i8,
                        );
                        current_block = 16059426333721732591;
                        break;
                    }
                }
                if (unsafe { (*iattr).state }) == 8 as i32 {
                    if xpathRes != 0 || !defAttrOwnerElem.is_null() {
                        if !(unsafe { (*(*iattr).use_0).defValue }).is_null() {
                            let fresh585 = unsafe { &mut ((*iattr).value) };
                            *fresh585 = (unsafe { (*(*iattr).use_0).defValue }) as *mut xmlChar;
                            let fresh586 = unsafe { &mut ((*iattr).val) };
                            *fresh586 = unsafe { (*(*iattr).use_0).defVal };
                        } else {
                            let fresh587 = unsafe { &mut ((*iattr).value) };
                            *fresh587 = (unsafe { (*(*iattr).decl).defValue }) as *mut xmlChar;
                            let fresh588 = unsafe { &mut ((*iattr).val) };
                            *fresh588 = unsafe { (*(*iattr).decl).defVal };
                        }
                        if (unsafe { (*iattr).val }).is_null() {
                            xmlSchemaInternalErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                b"xmlSchemaVAttributesComplex\0" as *const u8 as *const i8,
                                b"default/fixed value on an attribute use was not precomputed\0"
                                    as *const u8 as *const i8,
                            );
                            current_block = 16059426333721732591;
                            break;
                        } else {
                            let fresh589 = unsafe { &mut ((*iattr).val) };
                            *fresh589 = xmlSchemaCopyValue(unsafe { (*iattr).val });
                            if (unsafe { (*iattr).val }).is_null() {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaVAttributesComplex\0" as *const u8 as *const i8,
                                    b"calling xmlSchemaCopyValue()\0" as *const u8 as *const i8,
                                );
                                current_block = 16059426333721732591;
                                break;
                            }
                        }
                    }
                    if !defAttrOwnerElem.is_null() {
                        let mut normValue: *mut u8 = 0 as *mut xmlChar;
                        let mut value: *const u8 = 0 as *const xmlChar;
                        value = unsafe { (*iattr).value };
                        normValue = xmlSchemaNormalizeValue(unsafe { (*iattr).typeDef }, unsafe { (*iattr).value });
                        if !normValue.is_null() {
                            value = normValue;
                        }
                        if (unsafe { (*iattr).nsName }).is_null() {
                            if (xmlNewProp(defAttrOwnerElem, unsafe { (*iattr).localName }, value)).is_null() {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaVAttributesComplex\0" as *const u8 as *const i8,
                                    b"calling xmlNewProp()\0" as *const u8 as *const i8,
                                );
                                if !normValue.is_null() {
                                    (unsafe { xmlFree.expect("non-null function pointer")(
                                        normValue as *mut libc::c_void,
                                    ) });
                                }
                                current_block = 16059426333721732591;
                                break;
                            }
                        } else {
                            let mut ns: *mut crate::src::threads::_xmlNs = 0 as *mut xmlNs;
                            ns = xmlSearchNsByHref(
                                unsafe { (*defAttrOwnerElem).doc },
                                defAttrOwnerElem,
                                unsafe { (*iattr).nsName },
                            );
                            if ns.is_null() {
                                let mut prefix: [u8; 12] = [0; 12];
                                let mut counter: i32 = 0 as i32;
                                loop {
                                    let mut fresh590 = counter;
                                    counter = counter + 1;
                                    (unsafe { snprintf(
                                        prefix.as_mut_ptr() as *mut i8,
                                        12 as i32 as u64,
                                        b"p%d\0" as *const u8 as *const i8,
                                        fresh590,
                                    ) });
                                    ns = xmlSearchNs(
                                        unsafe { (*defAttrOwnerElem).doc },
                                        defAttrOwnerElem,
                                        prefix.as_mut_ptr(),
                                    );
                                    if counter > 1000 as i32 {
                                        xmlSchemaInternalErr (vctxt as xmlSchemaAbstractCtxtPtr , b"xmlSchemaVAttributesComplex\0" as * const u8 as * const i8 , b"could not compute a ns prefix for a default/fixed attribute\0" as * const u8 as * const i8 ,) ;
                                        if !normValue.is_null() {
                                            (unsafe { xmlFree.expect("non-null function pointer")(
                                                normValue as *mut libc::c_void,
                                            ) });
                                        }
                                        current_block = 16059426333721732591;
                                        break 's_457;
                                    } else if ns.is_null() {
                                        break;
                                    }
                                }
                                ns = xmlNewNs(
                                    unsafe { (*vctxt).validationRoot },
                                    unsafe { (*iattr).nsName },
                                    prefix.as_mut_ptr(),
                                );
                            }
                            xmlNewNsProp(defAttrOwnerElem, ns, unsafe { (*iattr).localName }, value);
                        }
                        if !normValue.is_null() {
                            (unsafe { xmlFree.expect("non-null function pointer")(
                                normValue as *mut libc::c_void,
                            ) });
                        }
                    }
                } else {
                    if !(unsafe { (*vctxt).value }).is_null() {
                        xmlSchemaFreeValue(unsafe { (*vctxt).value });
                        let fresh591 = unsafe { &mut ((*vctxt).value) };
                        *fresh591 = 0 as xmlSchemaValPtr;
                    }
                    if (unsafe { (*(*iattr).decl).flags }) & (1 as i32) << 9 as i32 != 0
                        || !(unsafe { (*iattr).use_0 }).is_null()
                            && (unsafe { (*(*iattr).use_0).flags }) & (1 as i32) << 9 as i32 != 0
                    {
                        fixed = 1 as i32;
                    } else {
                        fixed = 0 as i32;
                    }
                    if xpathRes != 0 || fixed != 0 {
                        (unsafe { (*iattr).flags |= (1 as i32) << 4 as i32 });
                        res = xmlSchemaVCheckCVCSimpleType(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            unsafe { (*iattr).node },
                            unsafe { (*iattr).typeDef },
                            unsafe { (*iattr).value },
                            Some(unsafe { &mut (*iattr).val }),
                            1 as i32,
                            1 as i32,
                            0 as i32,
                        );
                    } else {
                        res = xmlSchemaVCheckCVCSimpleType(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            unsafe { (*iattr).node },
                            unsafe { (*iattr).typeDef },
                            unsafe { (*iattr).value },
                            Option::<&'_ mut *mut crate::src::xmlschemastypes::_xmlSchemaVal>::None,
                            1 as i32,
                            0 as i32,
                            0 as i32,
                        );
                    }
                    if res != 0 as i32 {
                        if res == -(1 as i32) {
                            xmlSchemaInternalErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                b"xmlSchemaVAttributesComplex\0" as *const u8 as *const i8,
                                b"calling xmlSchemaStreamValidateSimpleTypeValue()\0" as *const u8
                                    as *const i8,
                            );
                            current_block = 16059426333721732591;
                            break;
                        } else {
                            (unsafe { (*iattr).state = 5 as i32 });
                        }
                    } else if fixed != 0 {
                        if (unsafe { (*iattr).val }).is_null() {
                            (unsafe { (*__xmlGenericError()).expect("non-null function pointer")(
                                *__xmlGenericErrorContext(),
                                b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
                                b"xmlschemas.c\0" as *const u8 as *const i8,
                                25912 as i32,
                            ) });
                        } else if !(unsafe { (*iattr).use_0 }).is_null()
                            && !(unsafe { (*(*iattr).use_0).defValue }).is_null()
                        {
                            if (unsafe { (*(*iattr).use_0).defVal }).is_null() {
                                (unsafe { (*__xmlGenericError()).expect("non-null function pointer")(
                                    *__xmlGenericErrorContext(),
                                    b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
                                    b"xmlschemas.c\0" as *const u8 as *const i8,
                                    25919 as i32,
                                ) });
                            } else {
                                let fresh592 = unsafe { &mut ((*iattr).vcValue) };
                                *fresh592 = unsafe { (*(*iattr).use_0).defValue };
                                if xmlSchemaAreValuesEqual(unsafe { (*iattr).val }, unsafe { (*(*iattr).use_0).defVal })
                                    == 0
                                {
                                    (unsafe { (*iattr).state = 7 as i32 });
                                }
                            }
                        } else if (unsafe { (*(*iattr).decl).defVal }).is_null() {
                            (unsafe { (*__xmlGenericError()).expect("non-null function pointer")(
                                *__xmlGenericErrorContext(),
                                b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
                                b"xmlschemas.c\0" as *const u8 as *const i8,
                                25934 as i32,
                            ) });
                        } else {
                            let fresh593 = unsafe { &mut ((*iattr).vcValue) };
                            *fresh593 = unsafe { (*(*iattr).decl).defValue };
                            if xmlSchemaAreValuesEqual(unsafe { (*iattr).val }, unsafe { (*(*iattr).decl).defVal }) == 0 {
                                (unsafe { (*iattr).state = 7 as i32 });
                            }
                        }
                    }
                }
                if xpathRes != 0 {
                    if xmlSchemaXPathProcessHistory(vctxt, (unsafe { (*vctxt).depth }) + 1 as i32) == -(1 as i32)
                    {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaVAttributesComplex\0" as *const u8 as *const i8,
                            b"calling xmlSchemaXPathEvaluate()\0" as *const u8 as *const i8,
                        );
                        current_block = 16059426333721732591;
                        break;
                    }
                } else if !(unsafe { (*vctxt).xpathStates }).is_null() {
                    xmlSchemaXPathPop(vctxt);
                }
            }
        }
        i += 1;
    }
    match current_block {
        16059426333721732591 => {
            let fresh597 = unsafe { &mut ((*vctxt).inode) };
            *fresh597 = unsafe { *((*vctxt).elemInfos).offset((*vctxt).depth as isize) };
            return -(1 as i32);
        },
        _ => {
            i = 0 as i32;
            while i < (unsafe { (*vctxt).nbAttrInfos }) {
                iattr = unsafe { *((*vctxt).attrInfos).offset(i as isize) };
                if !((unsafe { (*iattr).state }) == 17 as i32
                    || (unsafe { (*iattr).state }) == 2 as i32
                    || (unsafe { (*iattr).state }) == 13 as i32
                    || (unsafe { (*iattr).state }) == 14 as i32)
                {
                    let fresh594 = unsafe { &mut ((*vctxt).inode) };
                    *fresh594 = iattr as xmlSchemaNodeInfoPtr;
                    match unsafe { (*iattr).state } {
                        4 => {
                            let mut str: *mut u8 = 0 as *mut xmlChar;
                            let fresh595 = unsafe { &mut ((*vctxt).inode) };
                            *fresh595 = unsafe { *((*vctxt).elemInfos).offset((*vctxt).depth as isize) };
                            xmlSchemaCustomErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAV_CVC_COMPLEX_TYPE_4,
                                0 as xmlNodePtr,
                                0 as xmlSchemaBasicItemPtr,
                                b"The attribute '%s' is required but missing\0" as *const u8
                                    as *const i8,
                                xmlSchemaFormatQName(
                                    Some(&mut str),
                                    unsafe { (*(*iattr).decl).targetNamespace },
                                    unsafe { (*(*iattr).decl).name },
                                ),
                                0 as *const xmlChar,
                            );
                            if !str.is_null() {
                                (unsafe { xmlFree.expect("non-null function pointer")(
                                    str as *mut libc::c_void,
                                ) });
                                str = 0 as *mut xmlChar;
                            }
                        },
                        6 => {
                            xmlSchemaCustomErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAV_CVC_ATTRIBUTE_2,
                                0 as xmlNodePtr,
                                0 as xmlSchemaBasicItemPtr,
                                b"The type definition is absent\0" as *const u8 as *const i8,
                                0 as *const xmlChar,
                                0 as *const xmlChar,
                            );
                        },
                        7 => {
                            xmlSchemaCustomErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                XML_SCHEMAV_CVC_AU,
                                0 as xmlNodePtr,
                                0 as xmlSchemaBasicItemPtr,
                                b"The value '%s' does not match the fixed value constraint '%s'\0"
                                    as *const u8 as *const i8,
                                unsafe { (*iattr).value },
                                unsafe { (*iattr).vcValue },
                            );
                        },
                        10 => {
                            xmlSchemaCustomErr (vctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAV_CVC_WILDCARD , 0 as xmlNodePtr , 0 as xmlSchemaBasicItemPtr , b"No matching global attribute declaration available, but demanded by the strict wildcard\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
                        },
                        1 => {
                            if !((unsafe { (*iattr).metaType }) != 0) {
                                if (unsafe { (*type_0).attributeWildcard }).is_null() {
                                    xmlSchemaIllegalAttrErr(
                                        vctxt as xmlSchemaAbstractCtxtPtr,
                                        XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1,
                                        iattr,
                                        0 as xmlNodePtr,
                                    );
                                } else {
                                    xmlSchemaIllegalAttrErr(
                                        vctxt as xmlSchemaAbstractCtxtPtr,
                                        XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2,
                                        iattr,
                                        0 as xmlNodePtr,
                                    );
                                }
                            }
                        },
                        _ => {},
                    }
                }
                i += 1;
            }
            let fresh596 = unsafe { &mut ((*vctxt).inode) };
            *fresh596 = unsafe { *((*vctxt).elemInfos).offset((*vctxt).depth as isize) };
            return 0 as i32;
        },
    };
}
extern "C" fn xmlSchemaValidateElemWildcard<'a1, 'a2>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut skip: Option<&'a2 mut i32>,
) -> i32
where
    'a1: 'static,
{
    let mut wild: *mut crate::src::xmlschemas::_xmlSchemaWildcard<'_> =
        (unsafe { (*(*vctxt).inode).decl }) as xmlSchemaWildcardPtr;
    if borrow(&skip).is_none()
        || wild.is_null()
        || (unsafe { (*wild).type_0 }) as u32 != XML_SCHEMA_TYPE_ANY as i32 as u32
    {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaValidateElemWildcard\0" as *const u8 as *const i8,
            b"bad arguments\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    *(borrow_mut(&mut skip)).unwrap() = 0 as i32;
    if (unsafe { (*wild).processContents }) == 1 as i32 {
        *(borrow_mut(&mut skip)).unwrap() = 1 as i32;
        return 0 as i32;
    }
    let mut decl: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> = 0 as xmlSchemaElementPtr;
    decl = xmlSchemaGetElem(
        unsafe { (*vctxt).schema },
        unsafe { (*(*vctxt).inode).localName },
        unsafe { (*(*vctxt).inode).nsName },
    );
    if !decl.is_null() {
        let fresh598 = unsafe { &mut ((*(*vctxt).inode).decl) };
        *fresh598 = decl;
        return 0 as i32;
    }
    if (unsafe { (*wild).processContents }) == 3 as i32 {
        xmlSchemaCustomErr (vctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAV_CVC_ELT_1 , 0 as xmlNodePtr , 0 as xmlSchemaBasicItemPtr , b"No matching global element declaration available, but demanded by the strict wildcard\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
        return unsafe { (*vctxt).err };
    }
    if (unsafe { (*vctxt).nbAttrInfos }) != 0 as i32 {
        let mut iattr: *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'_> =
            0 as *mut xmlSchemaAttrInfo;
        iattr = xmlSchemaGetMetaAttrInfo(vctxt, 1 as i32);
        if !iattr.is_null() {
            if xmlSchemaProcessXSIType(
                vctxt,
                iattr,
                unsafe { &mut (*(*vctxt).inode).typeDef },
                0 as xmlSchemaElementPtr,
            ) == -(1 as i32)
            {
                xmlSchemaInternalErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    b"xmlSchemaValidateElemWildcard\0" as *const u8 as *const i8,
                    b"calling xmlSchemaProcessXSIType() to process the attribute 'xsi:nil'\0"
                        as *const u8 as *const i8,
                );
                return -(1 as i32);
            }
            return 0 as i32;
        }
    }
    let fresh599 = unsafe { &mut ((*(*vctxt).inode).typeDef) };
    *fresh599 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
    return 0 as i32;
}
extern "C" fn xmlSchemaCheckCOSValidDefault<'a1, 'a2>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut value: *const u8,
    mut val: Option<&'a2 mut *mut crate::src::xmlschemastypes::_xmlSchemaVal>,
) -> i32
where
    'a1: 'static,
{
    let mut ret: i32 = 0 as i32;
    let mut inode: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'_> = unsafe { (*vctxt).inode };
    if (unsafe { (*(*inode).typeDef).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
        || (unsafe { (*(*inode).typeDef).builtInType }) == XML_SCHEMAS_ANYTYPE as i32
    {
        if !((unsafe { (*(*inode).typeDef).contentType }) as u32 == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
            || (unsafe { (*(*inode).typeDef).contentType }) as u32 == XML_SCHEMA_CONTENT_BASIC as i32 as u32)
            && (!((unsafe { (*(*inode).typeDef).contentType }) as u32 == XML_SCHEMA_CONTENT_MIXED as i32 as u32)
                || xmlSchemaIsParticleEmptiable(
                    (unsafe { (*(*inode).typeDef).subtypes }) as xmlSchemaParticlePtr,
                ) == 0)
        {
            ret = XML_SCHEMAP_COS_VALID_DEFAULT_2_1 as i32;
            xmlSchemaCustomErr (vctxt as xmlSchemaAbstractCtxtPtr , ret as xmlParserErrors , 0 as xmlNodePtr , 0 as xmlSchemaBasicItemPtr , b"For a string to be a valid default, the type definition must be a simple type or a complex type with simple content or mixed content and a particle emptiable\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
            return ret;
        }
    }
    if (unsafe { (*(*inode).typeDef).type_0 }) as u32 == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
        || (unsafe { (*(*inode).typeDef).type_0 }) as u32 == XML_SCHEMA_TYPE_BASIC as i32 as u32
            && (unsafe { (*(*inode).typeDef).builtInType }) != XML_SCHEMAS_ANYTYPE as i32
    {
        ret = xmlSchemaVCheckCVCSimpleType(
            vctxt as xmlSchemaAbstractCtxtPtr,
            0 as xmlNodePtr,
            unsafe { (*inode).typeDef },
            value,
            borrow_mut(&mut val),
            1 as i32,
            1 as i32,
            0 as i32,
        );
    } else if (unsafe { (*(*inode).typeDef).contentType }) as u32 == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
        || (unsafe { (*(*inode).typeDef).contentType }) as u32 == XML_SCHEMA_CONTENT_BASIC as i32 as u32
    {
        ret = xmlSchemaVCheckCVCSimpleType(
            vctxt as xmlSchemaAbstractCtxtPtr,
            0 as xmlNodePtr,
            unsafe { (*(*inode).typeDef).contentTypeDef },
            value,
            borrow_mut(&mut val),
            1 as i32,
            1 as i32,
            0 as i32,
        );
    }
    if ret < 0 as i32 {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaCheckCOSValidDefault\0" as *const u8 as *const i8,
            b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8 as *const i8,
        );
    }
    return ret;
}
extern "C" fn xmlSchemaVContentModelCallback(
    mut _exec: *mut crate::src::xmlregexp::_xmlRegExecCtxt,
    mut _name: *const u8,
    mut transdata: *mut core::ffi::c_void,
    mut inputdata: *mut core::ffi::c_void,
) {
    let mut item: *mut crate::src::xmlschemas::_xmlSchemaElement<'_> =
        transdata as xmlSchemaElementPtr;
    let mut inode: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'_> =
        inputdata as xmlSchemaNodeInfoPtr;
    let fresh600 = unsafe { &mut ((*inode).decl) };
    *fresh600 = item;
}
extern "C" fn xmlSchemaValidatorPushElem<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> i32 {
    let fresh601 = unsafe { &mut ((*vctxt).inode) };
    *fresh601 = xmlSchemaGetFreshElemInfo(vctxt);
    if (unsafe { (*vctxt).inode }).is_null() {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaValidatorPushElem\0" as *const u8 as *const i8,
            b"calling xmlSchemaGetFreshElemInfo()\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    (unsafe { (*vctxt).nbAttrInfos = 0 as i32 });
    return 0 as i32;
}
extern "C" fn xmlSchemaVCheckINodeDataType<'a1, 'a2, 'a3>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut inode: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'a2>,
    mut type_0: *mut crate::src::xmlschemas::_xmlSchemaType<'a3>,
    mut value: *const u8,
) -> i32
where
    'a3: 'static,
{
    if (unsafe { (*inode).flags }) & (1 as i32) << 4 as i32 != 0 {
        return xmlSchemaVCheckCVCSimpleType(
            vctxt as xmlSchemaAbstractCtxtPtr,
            0 as xmlNodePtr,
            type_0,
            value,
            Some(unsafe { &mut (*inode).val }),
            1 as i32,
            1 as i32,
            0 as i32,
        );
    } else {
        return xmlSchemaVCheckCVCSimpleType(
            vctxt as xmlSchemaAbstractCtxtPtr,
            0 as xmlNodePtr,
            type_0,
            value,
            Option::<&'_ mut *mut crate::src::xmlschemastypes::_xmlSchemaVal>::None,
            1 as i32,
            0 as i32,
            0 as i32,
        );
    };
}
extern "C" fn xmlSchemaValidatorPopElem<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> i32
where
    'a1: 'static,
{
    let mut current_block: u64;
    let mut ret: i32 = 0 as i32;
    let mut inode: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'_> = unsafe { (*vctxt).inode };
    if (unsafe { (*vctxt).nbAttrInfos }) != 0 as i32 {
        xmlSchemaClearAttrInfos(vctxt);
    }
    if (unsafe { (*inode).flags }) & (1 as i32) << 9 as i32 != 0 {
        (unsafe { (*vctxt).skipDepth = (*vctxt).depth - 1 as i32 });
        current_block = 13159517723375190530;
    } else if (unsafe { (*inode).typeDef }).is_null() || (unsafe { (*inode).flags }) & (1 as i32) << 10 as i32 != 0 {
        current_block = 13159517723375190530;
    } else {
        if (unsafe { (*(*inode).typeDef).contentType }) as u32 == XML_SCHEMA_CONTENT_MIXED as i32 as u32
            || (unsafe { (*(*inode).typeDef).contentType }) as u32 == XML_SCHEMA_CONTENT_ELEMENTS as i32 as u32
        {
            if (unsafe { (*(*inode).typeDef).builtInType }) == XML_SCHEMAS_ANYTYPE as i32 {
                current_block = 8993999215443021867;
            } else if (unsafe { (*inode).flags }) & (1 as i32) << 8 as i32 == 0 as i32 {
                let mut values: [*mut u8; 10] = [0 as *mut xmlChar; 10];
                let mut terminal: i32 = 0;
                let mut nbval: i32 = 10 as i32;
                let mut nbneg: i32 = 0;
                if (unsafe { (*inode).regexCtxt }).is_null() {
                    let fresh602 = unsafe { &mut ((*inode).regexCtxt) };
                    *fresh602 = xmlRegNewExecCtxt(
                        unsafe { (*(*inode).typeDef).contModel },
                        Some(xmlSchemaVContentModelCallback),
                        vctxt as *mut libc::c_void,
                    );
                    if (unsafe { (*inode).regexCtxt }).is_null() {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaValidatorPopElem\0" as *const u8 as *const i8,
                            b"failed to create a regex context\0" as *const u8 as *const i8,
                        );
                        current_block = 3454747893076357924;
                    } else {
                        current_block = 15976848397966268834;
                    }
                } else {
                    current_block = 15976848397966268834;
                }
                match current_block {
                    3454747893076357924 => {},
                    _ => {
                        if (unsafe { (*inode).flags }) & (1 as i32) << 2 as i32 != 0 {
                            ret = 0 as i32;
                        } else {
                            xmlRegExecNextValues(
                                unsafe { (*inode).regexCtxt },
                                Some(&mut nbval),
                                Some(&mut nbneg),
                                unsafe { &mut *values.as_mut_ptr().offset(0 as i32 as isize) },
                                Some(&mut terminal),
                            );
                            ret = xmlRegExecPushString(
                                unsafe { (*inode).regexCtxt },
                                0 as *const xmlChar,
                                0 as *mut libc::c_void,
                            );
                            if ret < 0 as i32
                                || ret == 0 as i32 && (unsafe { (*inode).flags }) & (1 as i32) << 2 as i32 == 0
                            {
                                ret = 1 as i32;
                                (unsafe { (*inode).flags |= (1 as i32) << 8 as i32 });
                                xmlSchemaComplexTypeErr (vctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAV_ELEMENT_CONTENT , 0 as xmlNodePtr , Option :: < & '_ mut crate :: src :: xmlschemas :: _xmlSchemaType < '_ > > :: None , b"Missing child element(s)\0" as * const u8 as * const i8 , nbval , nbneg , values . as_mut_ptr () ,) ;
                            } else {
                                ret = 0 as i32;
                            }
                        }
                        current_block = 10035050265139717661;
                    },
                }
            } else {
                current_block = 10035050265139717661;
            }
        } else {
            current_block = 10035050265139717661;
        }
        match current_block {
            3454747893076357924 => {},
            _ => {
                match current_block {
                    10035050265139717661 => {
                        if (unsafe { (*(*inode).typeDef).contentType }) as u32
                            == XML_SCHEMA_CONTENT_ELEMENTS as i32 as u32
                        {
                            current_block = 13159517723375190530;
                        } else {
                            current_block = 8993999215443021867;
                        }
                    },
                    _ => {},
                }
                match current_block {
                    13159517723375190530 => {},
                    _ => {
                        if !(unsafe { (*vctxt).value }).is_null() {
                            xmlSchemaFreeValue(unsafe { (*vctxt).value });
                            let fresh603 = unsafe { &mut ((*vctxt).value) };
                            *fresh603 = 0 as xmlSchemaValPtr;
                        }
                        if (unsafe { (*inode).decl }).is_null() {
                            if (unsafe { (*(*inode).typeDef).type_0 }) as u32
                                == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                                || (unsafe { (*(*inode).typeDef).type_0 }) as u32
                                    == XML_SCHEMA_TYPE_BASIC as i32 as u32
                                    && (unsafe { (*(*inode).typeDef).builtInType }) != XML_SCHEMAS_ANYTYPE as i32
                            {
                                ret = xmlSchemaVCheckINodeDataType(
                                    vctxt,
                                    inode,
                                    unsafe { (*inode).typeDef },
                                    unsafe { (*inode).value },
                                );
                            } else if (unsafe { (*(*inode).typeDef).contentType }) as u32
                                == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
                                || (unsafe { (*(*inode).typeDef).contentType }) as u32
                                    == XML_SCHEMA_CONTENT_BASIC as i32 as u32
                            {
                                ret = xmlSchemaVCheckINodeDataType(
                                    vctxt,
                                    inode,
                                    unsafe { (*(*inode).typeDef).contentTypeDef },
                                    unsafe { (*inode).value },
                                );
                            }
                            if ret < 0 as i32 {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaValidatorPopElem\0" as *const u8 as *const i8,
                                    b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8
                                        as *const i8,
                                );
                                current_block = 3454747893076357924;
                            } else {
                                current_block = 13159517723375190530;
                            }
                        } else if !(unsafe { (*(*inode).decl).value }).is_null()
                            && (unsafe { (*inode).flags }) & (1 as i32) << 5 as i32 != 0
                            && (unsafe { (*inode).flags }) & (1 as i32) << 2 as i32 == 0
                        {
                            if (unsafe { (*inode).flags }) & (1 as i32) << 3 as i32 != 0 {
                                ret = xmlSchemaCheckCOSValidDefault(
                                    vctxt,
                                    unsafe { (*(*inode).decl).value },
                                    Some(unsafe { &mut (*inode).val }),
                                );
                                if ret != 0 as i32 {
                                    if ret < 0 as i32 {
                                        xmlSchemaInternalErr(
                                            vctxt as xmlSchemaAbstractCtxtPtr,
                                            b"xmlSchemaValidatorPopElem\0" as *const u8
                                                as *const i8,
                                            b"calling xmlSchemaCheckCOSValidDefault()\0"
                                                as *const u8
                                                as *const i8,
                                        );
                                        current_block = 3454747893076357924;
                                    } else {
                                        current_block = 13159517723375190530;
                                    }
                                } else {
                                    current_block = 15766311179120147566;
                                }
                            } else {
                                if (unsafe { (*(*inode).typeDef).type_0 }) as u32
                                    == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                                    || (unsafe { (*(*inode).typeDef).type_0 }) as u32
                                        == XML_SCHEMA_TYPE_BASIC as i32 as u32
                                        && (unsafe { (*(*inode).typeDef).builtInType })
                                            != XML_SCHEMAS_ANYTYPE as i32
                                {
                                    ret = xmlSchemaVCheckINodeDataType(
                                        vctxt,
                                        inode,
                                        unsafe { (*inode).typeDef },
                                        unsafe { (*(*inode).decl).value },
                                    );
                                } else if (unsafe { (*(*inode).typeDef).contentType }) as u32
                                    == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
                                    || (unsafe { (*(*inode).typeDef).contentType }) as u32
                                        == XML_SCHEMA_CONTENT_BASIC as i32 as u32
                                {
                                    ret = xmlSchemaVCheckINodeDataType(
                                        vctxt,
                                        inode,
                                        unsafe { (*(*inode).typeDef).contentTypeDef },
                                        unsafe { (*(*inode).decl).value },
                                    );
                                }
                                if ret != 0 as i32 {
                                    if ret < 0 as i32 {
                                        xmlSchemaInternalErr(
                                            vctxt as xmlSchemaAbstractCtxtPtr,
                                            b"xmlSchemaValidatorPopElem\0" as *const u8
                                                as *const i8,
                                            b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8
                                                as *const i8,
                                        );
                                        current_block = 3454747893076357924;
                                    } else {
                                        current_block = 13159517723375190530;
                                    }
                                } else {
                                    current_block = 15766311179120147566;
                                }
                            }
                            match current_block {
                                13159517723375190530 => {},
                                3454747893076357924 => {},
                                _ => {
                                    if (unsafe { (*vctxt).options }) & XML_SCHEMA_VAL_VC_I_CREATE as i32 != 0
                                        && !(unsafe { (*inode).node }).is_null()
                                    {
                                        let mut textChild: *mut crate::src::threads::_xmlNode =
                                            0 as *mut xmlNode;
                                        let mut normValue: *mut u8 = 0 as *mut xmlChar;
                                        normValue = xmlSchemaNormalizeValue(
                                            unsafe { (*inode).typeDef },
                                            unsafe { (*(*inode).decl).value },
                                        );
                                        if !normValue.is_null() {
                                            textChild =
                                                xmlNewDocText(unsafe { (*(*inode).node).doc }, normValue);
                                            (unsafe { xmlFree.expect("non-null function pointer")(
                                                normValue as *mut libc::c_void,
                                            ) });
                                        } else {
                                            textChild = xmlNewDocText(
                                                unsafe { (*(*inode).node).doc },
                                                unsafe { (*(*inode).decl).value },
                                            );
                                        }
                                        if textChild.is_null() {
                                            xmlSchemaInternalErr(
                                                vctxt as xmlSchemaAbstractCtxtPtr,
                                                b"xmlSchemaValidatorPopElem\0" as *const u8
                                                    as *const i8,
                                                b"calling xmlNewDocText()\0" as *const u8
                                                    as *const i8,
                                            );
                                            current_block = 3454747893076357924;
                                        } else {
                                            xmlAddChild(unsafe { (*inode).node }, textChild);
                                            current_block = 13159517723375190530;
                                        }
                                    } else {
                                        current_block = 13159517723375190530;
                                    }
                                },
                            }
                        } else if (unsafe { (*inode).flags }) & (1 as i32) << 2 as i32 == 0 {
                            if (unsafe { (*(*inode).typeDef).type_0 }) as u32
                                == XML_SCHEMA_TYPE_SIMPLE as i32 as u32
                                || (unsafe { (*(*inode).typeDef).type_0 }) as u32
                                    == XML_SCHEMA_TYPE_BASIC as i32 as u32
                                    && (unsafe { (*(*inode).typeDef).builtInType }) != XML_SCHEMAS_ANYTYPE as i32
                            {
                                ret = xmlSchemaVCheckINodeDataType(
                                    vctxt,
                                    inode,
                                    unsafe { (*inode).typeDef },
                                    unsafe { (*inode).value },
                                );
                            } else if (unsafe { (*(*inode).typeDef).contentType }) as u32
                                == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
                                || (unsafe { (*(*inode).typeDef).contentType }) as u32
                                    == XML_SCHEMA_CONTENT_BASIC as i32 as u32
                            {
                                ret = xmlSchemaVCheckINodeDataType(
                                    vctxt,
                                    inode,
                                    unsafe { (*(*inode).typeDef).contentTypeDef },
                                    unsafe { (*inode).value },
                                );
                            }
                            if ret != 0 as i32 {
                                if ret < 0 as i32 {
                                    xmlSchemaInternalErr(
                                        vctxt as xmlSchemaAbstractCtxtPtr,
                                        b"xmlSchemaValidatorPopElem\0" as *const u8 as *const i8,
                                        b"calling xmlSchemaVCheckCVCSimpleType()\0" as *const u8
                                            as *const i8,
                                    );
                                    current_block = 3454747893076357924;
                                } else {
                                    current_block = 13159517723375190530;
                                }
                            } else if !(unsafe { (*(*inode).decl).value }).is_null()
                                && (unsafe { (*(*inode).decl).flags }) & (1 as i32) << 3 as i32 != 0
                            {
                                if (unsafe { (*inode).flags }) & (1 as i32) << 7 as i32 != 0 {
                                    ret = XML_SCHEMAV_CVC_ELT_5_2_2_1 as i32;
                                    xmlSchemaCustomErr (vctxt as xmlSchemaAbstractCtxtPtr , ret as xmlParserErrors , 0 as xmlNodePtr , 0 as xmlSchemaBasicItemPtr , b"The content must not contain element nodes since there is a fixed value constraint\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
                                } else if (unsafe { (*(*inode).typeDef).contentType }) as u32
                                    == XML_SCHEMA_CONTENT_MIXED as i32 as u32
                                {
                                    if xmlStrEqual(unsafe { (*inode).value }, unsafe { (*(*inode).decl).value }) == 0 {
                                        ret = XML_SCHEMAV_CVC_ELT_5_2_2_2_1 as i32;
                                        xmlSchemaCustomErr (vctxt as xmlSchemaAbstractCtxtPtr , ret as xmlParserErrors , 0 as xmlNodePtr , 0 as xmlSchemaBasicItemPtr , b"The initial value '%s' does not match the fixed value constraint '%s'\0" as * const u8 as * const i8 , unsafe { (* inode) . value } , unsafe { (* (* inode) . decl) . value } ,) ;
                                    }
                                } else if (unsafe { (*(*inode).typeDef).contentType }) as u32
                                    == XML_SCHEMA_CONTENT_SIMPLE as i32 as u32
                                    || (unsafe { (*(*inode).typeDef).contentType }) as u32
                                        == XML_SCHEMA_CONTENT_BASIC as i32 as u32
                                {
                                    if xmlStrEqual(unsafe { (*inode).value }, unsafe { (*(*inode).decl).value }) == 0 {
                                        ret = XML_SCHEMAV_CVC_ELT_5_2_2_2_2 as i32;
                                        xmlSchemaCustomErr (vctxt as xmlSchemaAbstractCtxtPtr , ret as xmlParserErrors , 0 as xmlNodePtr , 0 as xmlSchemaBasicItemPtr , b"The actual value '%s' does not match the fixed value constraint '%s'\0" as * const u8 as * const i8 , unsafe { (* inode) . value } , unsafe { (* (* inode) . decl) . value } ,) ;
                                    }
                                }
                                current_block = 13159517723375190530;
                            } else {
                                current_block = 13159517723375190530;
                            }
                        } else {
                            current_block = 13159517723375190530;
                        }
                    },
                }
            },
        }
    }
    match current_block {
        13159517723375190530 => {
            if (unsafe { (*vctxt).depth }) < 0 as i32 {
                return 0 as i32;
            }
            if (unsafe { (*vctxt).depth }) == (unsafe { (*vctxt).skipDepth }) {
                (unsafe { (*vctxt).skipDepth = -(1 as i32) });
            }
            if !((unsafe { (*inode).appliedXPath }) != 0
                && xmlSchemaXPathProcessHistory(vctxt, unsafe { (*vctxt).depth }) == -(1 as i32))
            {
                if !(unsafe { (*inode).idcMatchers }).is_null()
                    && ((unsafe { (*vctxt).hasKeyrefs }) != 0 || (unsafe { (*vctxt).createIDCNodeTables }) != 0)
                {
                    if xmlSchemaIDCFillNodeTables(vctxt, inode) == -(1 as i32) {
                        current_block = 3454747893076357924;
                    } else {
                        current_block = 6665878751423064961;
                    }
                } else {
                    current_block = 6665878751423064961;
                }
                match current_block {
                    3454747893076357924 => {},
                    _ => {
                        if (unsafe { (*(*vctxt).inode).hasKeyrefs }) != 0 {
                            if xmlSchemaCheckCVCIDCKeyRef(vctxt) == -(1 as i32) {
                                current_block = 3454747893076357924;
                            } else {
                                current_block = 8225018548522317130;
                            }
                        } else {
                            current_block = 8225018548522317130;
                        }
                        match current_block {
                            3454747893076357924 => {},
                            _ => {
                                if !(unsafe { (*inode).idcTable }).is_null() {
                                    if (unsafe { (*vctxt).depth }) > 0 as i32
                                        && ((unsafe { (*vctxt).hasKeyrefs }) != 0
                                            || (unsafe { (*vctxt).createIDCNodeTables }) != 0)
                                    {
                                        if xmlSchemaBubbleIDCNodeTables(vctxt) == -(1 as i32) {
                                            current_block = 3454747893076357924;
                                        } else {
                                            current_block = 5636883459695696059;
                                        }
                                    } else {
                                        current_block = 5636883459695696059;
                                    }
                                } else {
                                    current_block = 5636883459695696059;
                                }
                                match current_block {
                                    3454747893076357924 => {},
                                    _ => {
                                        xmlSchemaClearElemInfo(vctxt, inode);
                                        if (unsafe { (*vctxt).depth }) == 0 as i32 {
                                            let fresh604 = unsafe { &mut ((*vctxt).depth) };
                                            *fresh604 -= 1;
                                            let fresh605 = unsafe { &mut ((*vctxt).inode) };
                                            *fresh605 = 0 as xmlSchemaNodeInfoPtr;
                                            return 0 as i32;
                                        }
                                        if !(unsafe { (*vctxt).aidcs }).is_null() {
                                            let mut aidc : * mut crate :: src :: xmlschemas :: _xmlSchemaIDCAug < '_ > = unsafe { (* vctxt) . aidcs } ;
                                            loop {
                                                if (unsafe { (*aidc).keyrefDepth }) == (unsafe { (*vctxt).depth }) {
                                                    (unsafe { (*aidc).keyrefDepth = -(1 as i32) });
                                                }
                                                aidc = unsafe { (*aidc).next };
                                                if aidc.is_null() {
                                                    break;
                                                }
                                            }
                                        }
                                        let fresh606 = unsafe { &mut ((*vctxt).depth) };
                                        *fresh606 -= 1;
                                        let fresh607 = unsafe { &mut ((*vctxt).inode) };
                                        *fresh607 =
                                            unsafe { *((*vctxt).elemInfos).offset((*vctxt).depth as isize) };
                                        return ret;
                                    },
                                }
                            },
                        }
                    },
                }
            }
        },
        _ => {},
    }
    (unsafe { (*vctxt).err = -(1 as i32) });
    return -(1 as i32);
}
extern "C" fn xmlSchemaValidateChildElem<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> i32
where
    'a1: 'static,
{
    let mut current_block: u64;
    let mut pielem: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'_> =
        0 as *mut xmlSchemaNodeInfo;
    let mut ptype: *mut crate::src::xmlschemas::_xmlSchemaType<'_> = 0 as *mut xmlSchemaType;
    let mut ret: i32 = 0 as i32;
    if (unsafe { (*vctxt).depth }) <= 0 as i32 {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaValidateChildElem\0" as *const u8 as *const i8,
            b"not intended for the validation root\0" as *const u8 as *const i8,
        );
        return -(1 as i32);
    }
    pielem = unsafe { *((*vctxt).elemInfos).offset(((*vctxt).depth - 1 as i32) as isize) };
    if (unsafe { (*pielem).flags }) & (1 as i32) << 5 as i32 != 0 {
        (unsafe { (*pielem).flags ^= (1 as i32) << 5 as i32 });
    }
    if (unsafe { (*pielem).flags }) & (1 as i32) << 2 as i32 != 0 {
        let fresh608 = unsafe { &mut ((*vctxt).inode) };
        *fresh608 = unsafe { *((*vctxt).elemInfos).offset(((*vctxt).depth - 1 as i32) as isize) };
        ret = XML_SCHEMAV_CVC_ELT_3_2_1 as i32;
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            ret as xmlParserErrors,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"Neither character nor element content is allowed, because the element was 'nilled'\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        let fresh609 = unsafe { &mut ((*vctxt).inode) };
        *fresh609 = unsafe { *((*vctxt).elemInfos).offset((*vctxt).depth as isize) };
    } else {
        ptype = unsafe { (*pielem).typeDef };
        if (unsafe { (*ptype).builtInType }) == XML_SCHEMAS_ANYTYPE as i32 {
            let fresh610 = unsafe { &mut ((*(*vctxt).inode).decl) };
            *fresh610 = xmlSchemaGetElem(
                unsafe { (*vctxt).schema },
                unsafe { (*(*vctxt).inode).localName },
                unsafe { (*(*vctxt).inode).nsName },
            );
            if (unsafe { (*(*vctxt).inode).decl }).is_null() {
                let mut iattr: *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'_> =
                    0 as *mut xmlSchemaAttrInfo;
                iattr = xmlSchemaGetMetaAttrInfo(vctxt, 1 as i32);
                if !iattr.is_null() {
                    ret = xmlSchemaProcessXSIType(
                        vctxt,
                        iattr,
                        unsafe { &mut (*(*vctxt).inode).typeDef },
                        0 as xmlSchemaElementPtr,
                    );
                    if ret != 0 as i32 {
                        if ret == -(1 as i32) {
                            xmlSchemaInternalErr (vctxt as xmlSchemaAbstractCtxtPtr , b"xmlSchemaValidateChildElem\0" as * const u8 as * const i8 , b"calling xmlSchemaProcessXSIType() to process the attribute 'xsi:nil'\0" as * const u8 as * const i8 ,) ;
                            return -(1 as i32);
                        }
                        return ret;
                    }
                } else {
                    let fresh611 = unsafe { &mut ((*(*vctxt).inode).typeDef) };
                    *fresh611 = xmlSchemaGetBuiltInType(XML_SCHEMAS_ANYTYPE);
                }
            }
            return 0 as i32;
        }
        match (unsafe { (*ptype).contentType }) as u32 {
            1 => {
                let fresh612 = unsafe { &mut ((*vctxt).inode) };
                *fresh612 = unsafe { *((*vctxt).elemInfos).offset(((*vctxt).depth - 1 as i32) as isize) };
                ret = XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1 as i32;
                xmlSchemaCustomErr(
                    vctxt as xmlSchemaAbstractCtxtPtr,
                    ret as xmlParserErrors,
                    0 as xmlNodePtr,
                    0 as xmlSchemaBasicItemPtr,
                    b"Element content is not allowed, because the content type is empty\0"
                        as *const u8 as *const i8,
                    0 as *const xmlChar,
                    0 as *const xmlChar,
                );
                let fresh613 = unsafe { &mut ((*vctxt).inode) };
                *fresh613 = unsafe { *((*vctxt).elemInfos).offset((*vctxt).depth as isize) };
                current_block = 16160522325362342750;
            },
            3 | 2 => {
                let mut regexCtxt: *mut crate::src::xmlregexp::_xmlRegExecCtxt =
                    0 as *mut xmlRegExecCtxt;
                let mut values: [*mut u8; 10] = [0 as *mut xmlChar; 10];
                let mut terminal: i32 = 0;
                let mut nbval: i32 = 10 as i32;
                let mut nbneg: i32 = 0;
                if (unsafe { (*ptype).contModel }).is_null() {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaValidateChildElem\0" as *const u8 as *const i8,
                        b"type has elem content but no content model\0" as *const u8 as *const i8,
                    );
                    return -(1 as i32);
                }
                if (unsafe { (*pielem).flags }) & (1 as i32) << 8 as i32 != 0 {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaValidateChildElem\0" as *const u8 as *const i8,
                        b"validating elem, but elem content is already invalid\0" as *const u8
                            as *const i8,
                    );
                    return -(1 as i32);
                }
                regexCtxt = unsafe { (*pielem).regexCtxt };
                if regexCtxt.is_null() {
                    regexCtxt = xmlRegNewExecCtxt(
                        unsafe { (*ptype).contModel },
                        Some(xmlSchemaVContentModelCallback),
                        vctxt as *mut libc::c_void,
                    );
                    if regexCtxt.is_null() {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaValidateChildElem\0" as *const u8 as *const i8,
                            b"failed to create a regex context\0" as *const u8 as *const i8,
                        );
                        return -(1 as i32);
                    }
                    let fresh614 = unsafe { &mut ((*pielem).regexCtxt) };
                    *fresh614 = regexCtxt;
                }
                ret = xmlRegExecPushString2(
                    regexCtxt,
                    unsafe { (*(*vctxt).inode).localName },
                    unsafe { (*(*vctxt).inode).nsName },
                    (unsafe { (*vctxt).inode }) as *mut libc::c_void,
                );
                if (unsafe { (*vctxt).err }) == XML_SCHEMAV_INTERNAL as i32 {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaValidateChildElem\0" as *const u8 as *const i8,
                        b"calling xmlRegExecPushString2()\0" as *const u8 as *const i8,
                    );
                    return -(1 as i32);
                }
                if ret < 0 as i32 {
                    xmlRegExecErrInfo(
                        regexCtxt,
                        Option::<&'_ mut *const u8>::None,
                        Some(&mut nbval),
                        Some(&mut nbneg),
                        unsafe { &mut *values.as_mut_ptr().offset(0 as i32 as isize) },
                        Some(&mut terminal),
                    );
                    xmlSchemaComplexTypeErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        XML_SCHEMAV_ELEMENT_CONTENT,
                        0 as xmlNodePtr,
                        Option::<&'_ mut crate::src::xmlschemas::_xmlSchemaType<'_>>::None,
                        b"This element is not expected\0" as *const u8 as *const i8,
                        nbval,
                        nbneg,
                        values.as_mut_ptr(),
                    );
                    ret = unsafe { (*vctxt).err };
                    current_block = 16160522325362342750;
                } else {
                    ret = 0 as i32;
                    current_block = 3879520548144599102;
                }
            },
            4 | 6 => {
                let fresh615 = unsafe { &mut ((*vctxt).inode) };
                *fresh615 = unsafe { *((*vctxt).elemInfos).offset(((*vctxt).depth - 1 as i32) as isize) };
                if (unsafe { (*ptype).type_0 }) as u32 == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                    || (unsafe { (*ptype).builtInType }) == XML_SCHEMAS_ANYTYPE as i32
                {
                    ret = XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2 as i32;
                    xmlSchemaCustomErr (vctxt as xmlSchemaAbstractCtxtPtr , ret as xmlParserErrors , 0 as xmlNodePtr , 0 as xmlSchemaBasicItemPtr , b"Element content is not allowed, because the content type is a simple type definition\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
                } else {
                    ret = XML_SCHEMAV_CVC_TYPE_3_1_2 as i32;
                    xmlSchemaCustomErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        ret as xmlParserErrors,
                        0 as xmlNodePtr,
                        0 as xmlSchemaBasicItemPtr,
                        b"Element content is not allowed, because the type definition is simple\0"
                            as *const u8 as *const i8,
                        0 as *const xmlChar,
                        0 as *const xmlChar,
                    );
                }
                let fresh616 = unsafe { &mut ((*vctxt).inode) };
                *fresh616 = unsafe { *((*vctxt).elemInfos).offset((*vctxt).depth as isize) };
                ret = unsafe { (*vctxt).err };
                current_block = 16160522325362342750;
            },
            _ => {
                current_block = 3879520548144599102;
            },
        }
        match current_block {
            16160522325362342750 => {},
            _ => return ret,
        }
    }
    (unsafe { (*vctxt).skipDepth = (*vctxt).depth });
    (unsafe { (*(*vctxt).inode).flags |= (1 as i32) << 9 as i32 });
    (unsafe { (*pielem).flags |= (1 as i32) << 8 as i32 });
    return ret;
}
extern "C" fn xmlSchemaVPushText<'a1, 'a2>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut nodeType: i32,
    mut value: *const u8,
    mut len: i32,
    mut mode: i32,
    mut consumed: Option<&'a2 mut i32>,
) -> i32 {
    if !borrow(&consumed).is_none() {
        *(borrow_mut(&mut consumed)).unwrap() = 0 as i32;
    }
    if (unsafe { (*(*vctxt).inode).flags }) & (1 as i32) << 2 as i32 != 0 {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_ELT_3_2_1,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"Neither character nor element content is allowed because the element is 'nilled'\0"
                as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return unsafe { (*vctxt).err };
    }
    if (unsafe { (*(*(*vctxt).inode).typeDef).contentType }) as u32 == XML_SCHEMA_CONTENT_EMPTY as i32 as u32 {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"Character content is not allowed, because the content type is empty\0" as *const u8
                as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return unsafe { (*vctxt).err };
    }
    if (unsafe { (*(*(*vctxt).inode).typeDef).contentType }) as u32 == XML_SCHEMA_CONTENT_ELEMENTS as i32 as u32
    {
        if nodeType != XML_TEXT_NODE as i32 || xmlSchemaIsBlank(value as *mut xmlChar, len) == 0 {
            xmlSchemaCustomErr (vctxt as xmlSchemaAbstractCtxtPtr , XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3 , 0 as xmlNodePtr , 0 as xmlSchemaBasicItemPtr , b"Character content other than whitespace is not allowed because the content type is 'element-only'\0" as * const u8 as * const i8 , 0 as * const xmlChar , 0 as * const xmlChar ,) ;
            return unsafe { (*vctxt).err };
        }
        return 0 as i32;
    }
    if value.is_null() || (unsafe { *value.offset(0 as i32 as isize) }) as i32 == 0 as i32 {
        return 0 as i32;
    }
    if (unsafe { (*(*(*vctxt).inode).typeDef).contentType }) as u32 == XML_SCHEMA_CONTENT_MIXED as i32 as u32
        && ((unsafe { (*(*vctxt).inode).decl }).is_null() || (unsafe { (*(*(*vctxt).inode).decl).value }).is_null())
    {
        return 0 as i32;
    }
    if (unsafe { (*(*vctxt).inode).value }).is_null() {
        match mode {
            1 => {
                let fresh617 = unsafe { &mut ((*(*vctxt).inode).value) };
                *fresh617 = value;
            },
            2 => {
                let fresh618 = unsafe { &mut ((*(*vctxt).inode).value) };
                *fresh618 = value;
                if !borrow(&consumed).is_none() {
                    *(borrow_mut(&mut consumed)).unwrap() = 1 as i32;
                }
                (unsafe { (*(*vctxt).inode).flags |= (1 as i32) << 1 as i32 });
            },
            3 => {
                if len != -(1 as i32) {
                    let fresh619 = unsafe { &mut ((*(*vctxt).inode).value) };
                    *fresh619 = xmlStrndup(value, len);
                } else {
                    let fresh620 = unsafe { &mut ((*(*vctxt).inode).value) };
                    *fresh620 = xmlStrdup(value);
                }
                (unsafe { (*(*vctxt).inode).flags |= (1 as i32) << 1 as i32 });
            },
            _ => {},
        }
    } else {
        if len < 0 as i32 {
            len = xmlStrlen(value);
        }
        if (unsafe { (*(*vctxt).inode).flags }) & (1 as i32) << 1 as i32 != 0 {
            let fresh621 = unsafe { &mut ((*(*vctxt).inode).value) };
            *fresh621 = xmlStrncat((unsafe { (*(*vctxt).inode).value }) as *mut xmlChar, value, len);
        } else {
            let fresh622 = unsafe { &mut ((*(*vctxt).inode).value) };
            *fresh622 = xmlStrncatNew(unsafe { (*(*vctxt).inode).value }, value, len);
            (unsafe { (*(*vctxt).inode).flags |= (1 as i32) << 1 as i32 });
        }
    }
    return 0 as i32;
}
extern "C" fn xmlSchemaValidateElem<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> i32
where
    'a1: 'static,
{
    let mut current_block: u64;
    let mut ret: i32 = 0 as i32;
    if (unsafe { (*vctxt).skipDepth }) != -(1 as i32) && (unsafe { (*vctxt).depth }) >= (unsafe { (*vctxt).skipDepth }) {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaValidateElem\0" as *const u8 as *const i8,
            b"in skip-state\0" as *const u8 as *const i8,
        );
    } else {
        if (unsafe { (*vctxt).xsiAssemble }) != 0 {
            ret = xmlSchemaAssembleByXSI(vctxt);
            if ret != 0 as i32 {
                if ret == -(1 as i32) {
                    current_block = 17069188355963176026;
                } else {
                    (unsafe { (*vctxt).skipDepth = 0 as i32 });
                    return ret;
                }
            } else {
                (unsafe { xmlHashScan(
                    (*(*vctxt).schema).schemasImports,
                    Some(xmlSchemaAugmentImportedIDC),
                    vctxt as *mut libc::c_void,
                ) });
                current_block = 13536709405535804910;
            }
        } else {
            current_block = 13536709405535804910;
        }
        match current_block {
            17069188355963176026 => {},
            _ => {
                if (unsafe { (*vctxt).depth }) > 0 as i32 {
                    ret = xmlSchemaValidateChildElem(vctxt);
                    if ret != 0 as i32 {
                        if ret < 0 as i32 {
                            xmlSchemaInternalErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                b"xmlSchemaValidateElem\0" as *const u8 as *const i8,
                                b"calling xmlSchemaStreamValidateChildElement()\0" as *const u8
                                    as *const i8,
                            );
                            current_block = 17069188355963176026;
                        } else {
                            current_block = 6848767425915334727;
                        }
                    } else if (unsafe { (*vctxt).depth }) == (unsafe { (*vctxt).skipDepth }) {
                        current_block = 6848767425915334727;
                    } else if (unsafe { (*(*vctxt).inode).decl }).is_null()
                        && (unsafe { (*(*vctxt).inode).typeDef }).is_null()
                    {
                        xmlSchemaInternalErr (vctxt as xmlSchemaAbstractCtxtPtr , b"xmlSchemaValidateElem\0" as * const u8 as * const i8 , b"the child element was valid but neither the declaration nor the type was set\0" as * const u8 as * const i8 ,) ;
                        current_block = 17069188355963176026;
                    } else {
                        current_block = 16924917904204750491;
                    }
                } else {
                    let fresh623 = unsafe { &mut ((*(*vctxt).inode).decl) };
                    *fresh623 = xmlSchemaGetElem(
                        unsafe { (*vctxt).schema },
                        unsafe { (*(*vctxt).inode).localName },
                        unsafe { (*(*vctxt).inode).nsName },
                    );
                    if (unsafe { (*(*vctxt).inode).decl }).is_null() {
                        ret = XML_SCHEMAV_CVC_ELT_1 as i32;
                        xmlSchemaCustomErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            ret as xmlParserErrors,
                            0 as xmlNodePtr,
                            0 as xmlSchemaBasicItemPtr,
                            b"No matching global declaration available for the validation root\0"
                                as *const u8 as *const i8,
                            0 as *const xmlChar,
                            0 as *const xmlChar,
                        );
                        current_block = 6848767425915334727;
                    } else {
                        current_block = 16924917904204750491;
                    }
                }
                match current_block {
                    17069188355963176026 => {},
                    _ => {
                        match current_block {
                            16924917904204750491 => {
                                if (unsafe { (*(*vctxt).inode).decl }).is_null() {
                                    current_block = 10371967630163830273;
                                } else {
                                    if (unsafe { (*(*(*vctxt).inode).decl).type_0 }) as u32
                                        == XML_SCHEMA_TYPE_ANY as i32 as u32
                                    {
                                        let mut skip: i32 = 0;
                                        ret = xmlSchemaValidateElemWildcard(vctxt, Some(&mut skip));
                                        if ret != 0 as i32 {
                                            if ret < 0 as i32 {
                                                xmlSchemaInternalErr(
                                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                                    b"xmlSchemaValidateElem\0" as *const u8
                                                        as *const i8,
                                                    b"calling xmlSchemaValidateElemWildcard()\0"
                                                        as *const u8
                                                        as *const i8,
                                                );
                                                current_block = 17069188355963176026;
                                            } else {
                                                current_block = 6848767425915334727;
                                            }
                                        } else if skip != 0 {
                                            (unsafe { (*vctxt).skipDepth = (*vctxt).depth });
                                            current_block = 6848767425915334727;
                                        } else if (unsafe { (*(*(*vctxt).inode).decl).type_0 }) as u32
                                            != XML_SCHEMA_TYPE_ELEMENT as i32 as u32
                                        {
                                            let fresh624 = unsafe { &mut ((*(*vctxt).inode).decl) };
                                            *fresh624 = 0 as xmlSchemaElementPtr;
                                            current_block = 10371967630163830273;
                                        } else {
                                            current_block = 790185930182612747;
                                        }
                                    } else {
                                        current_block = 790185930182612747;
                                    }
                                    match current_block {
                                        6848767425915334727 => {},
                                        17069188355963176026 => {},
                                        10371967630163830273 => {},
                                        _ => {
                                            ret = xmlSchemaValidateElemDecl(vctxt);
                                            if ret != 0 as i32 {
                                                if ret < 0 as i32 {
                                                    xmlSchemaInternalErr(
                                                        vctxt as xmlSchemaAbstractCtxtPtr,
                                                        b"xmlSchemaValidateElem\0" as *const u8
                                                            as *const i8,
                                                        b"calling xmlSchemaValidateElemDecl()\0"
                                                            as *const u8
                                                            as *const i8,
                                                    );
                                                    current_block = 17069188355963176026;
                                                } else {
                                                    current_block = 6848767425915334727;
                                                }
                                            } else {
                                                current_block = 10371967630163830273;
                                            }
                                        },
                                    }
                                }
                                match current_block {
                                    6848767425915334727 => {},
                                    17069188355963176026 => {},
                                    _ => {
                                        if (unsafe { (*(*vctxt).inode).typeDef }).is_null() {
                                            (unsafe { (*(*vctxt).inode).flags |= (1 as i32) << 10 as i32 });
                                            ret = XML_SCHEMAV_CVC_TYPE_1 as i32;
                                            xmlSchemaCustomErr(
                                                vctxt as xmlSchemaAbstractCtxtPtr,
                                                ret as xmlParserErrors,
                                                0 as xmlNodePtr,
                                                0 as xmlSchemaBasicItemPtr,
                                                b"The type definition is absent\0" as *const u8
                                                    as *const i8,
                                                0 as *const xmlChar,
                                                0 as *const xmlChar,
                                            );
                                            current_block = 6848767425915334727;
                                        } else if (unsafe { (*(*(*vctxt).inode).typeDef).flags })
                                            & (1 as i32) << 20 as i32
                                            != 0
                                        {
                                            (unsafe { (*(*vctxt).inode).flags |= (1 as i32) << 10 as i32 });
                                            ret = XML_SCHEMAV_CVC_TYPE_2 as i32;
                                            xmlSchemaCustomErr(
                                                vctxt as xmlSchemaAbstractCtxtPtr,
                                                ret as xmlParserErrors,
                                                0 as xmlNodePtr,
                                                0 as xmlSchemaBasicItemPtr,
                                                b"The type definition is abstract\0" as *const u8
                                                    as *const i8,
                                                0 as *const xmlChar,
                                                0 as *const xmlChar,
                                            );
                                            current_block = 6848767425915334727;
                                        } else {
                                            if !(unsafe { (*vctxt).xpathStates }).is_null() {
                                                ret =
                                                    xmlSchemaXPathEvaluate(vctxt, XML_ELEMENT_NODE);
                                                (unsafe { (*(*vctxt).inode).appliedXPath = 1 as i32 });
                                                if ret == -(1 as i32) {
                                                    xmlSchemaInternalErr(
                                                        vctxt as xmlSchemaAbstractCtxtPtr,
                                                        b"xmlSchemaValidateElem\0" as *const u8
                                                            as *const i8,
                                                        b"calling xmlSchemaXPathEvaluate()\0"
                                                            as *const u8
                                                            as *const i8,
                                                    );
                                                    current_block = 17069188355963176026;
                                                } else {
                                                    current_block = 1874315696050160458;
                                                }
                                            } else {
                                                current_block = 1874315696050160458;
                                            }
                                            match current_block {
                                                17069188355963176026 => {},
                                                _ => {
                                                    if (unsafe { (*(*(*vctxt).inode).typeDef).type_0 }) as u32
                                                        == XML_SCHEMA_TYPE_COMPLEX as i32 as u32
                                                        || (unsafe { (*(*(*vctxt).inode).typeDef).builtInType })
                                                            == XML_SCHEMAS_ANYTYPE as i32
                                                    {
                                                        if (unsafe { (*vctxt).nbAttrInfos }) != 0 as i32
                                                            || !(unsafe { (*(*(*vctxt).inode).typeDef)
                                                                .attrUses })
                                                                .is_null()
                                                        {
                                                            ret =
                                                                xmlSchemaVAttributesComplex(vctxt);
                                                        }
                                                    } else if (unsafe { (*vctxt).nbAttrInfos }) != 0 as i32 {
                                                        ret = xmlSchemaVAttributesSimple(vctxt);
                                                    }
                                                    if (unsafe { (*vctxt).nbAttrInfos }) != 0 as i32 {
                                                        xmlSchemaClearAttrInfos(vctxt);
                                                    }
                                                    if ret == -(1 as i32) {
                                                        xmlSchemaInternalErr(
                                                            vctxt as xmlSchemaAbstractCtxtPtr,
                                                            b"xmlSchemaValidateElem\0" as *const u8
                                                                as *const i8,
                                                            b"calling attributes validation\0"
                                                                as *const u8
                                                                as *const i8,
                                                        );
                                                        current_block = 17069188355963176026;
                                                    } else {
                                                        ret = 0 as i32;
                                                        current_block = 6848767425915334727;
                                                    }
                                                },
                                            }
                                        }
                                    },
                                }
                            },
                            _ => {},
                        }
                        match current_block {
                            17069188355963176026 => {},
                            _ => {
                                if ret != 0 as i32 {
                                    (unsafe { (*vctxt).skipDepth = (*vctxt).depth });
                                }
                                return ret;
                            },
                        }
                    },
                }
            },
        }
    }
    return -(1 as i32);
}
extern "C" fn xmlSchemaSAXHandleText(
    mut ctx: *mut core::ffi::c_void,
    mut ch: *const u8,
    mut len: i32,
) {
    let mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'_> =
        ctx as xmlSchemaValidCtxtPtr;
    if (unsafe { (*vctxt).depth }) < 0 as i32 {
        return;
    }
    if (unsafe { (*vctxt).skipDepth }) != -(1 as i32) && (unsafe { (*vctxt).depth }) >= (unsafe { (*vctxt).skipDepth }) {
        return;
    }
    if (unsafe { (*(*vctxt).inode).flags }) & (1 as i32) << 5 as i32 != 0 {
        (unsafe { (*(*vctxt).inode).flags ^= (1 as i32) << 5 as i32 });
    }
    if xmlSchemaVPushText(
        vctxt,
        XML_TEXT_NODE as i32,
        ch,
        len,
        3 as i32,
        Option::<&'_ mut i32>::None,
    ) == -(1 as i32)
    {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaSAXHandleCDataSection\0" as *const u8 as *const i8,
            b"calling xmlSchemaVPushText()\0" as *const u8 as *const i8,
        );
        (unsafe { (*vctxt).err = -(1 as i32) });
        (unsafe { xmlStopParser((*vctxt).parserCtxt) });
    }
}
extern "C" fn xmlSchemaSAXHandleCDataSection(
    mut ctx: *mut core::ffi::c_void,
    mut ch: *const u8,
    mut len: i32,
) {
    let mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'_> =
        ctx as xmlSchemaValidCtxtPtr;
    if (unsafe { (*vctxt).depth }) < 0 as i32 {
        return;
    }
    if (unsafe { (*vctxt).skipDepth }) != -(1 as i32) && (unsafe { (*vctxt).depth }) >= (unsafe { (*vctxt).skipDepth }) {
        return;
    }
    if (unsafe { (*(*vctxt).inode).flags }) & (1 as i32) << 5 as i32 != 0 {
        (unsafe { (*(*vctxt).inode).flags ^= (1 as i32) << 5 as i32 });
    }
    if xmlSchemaVPushText(
        vctxt,
        XML_CDATA_SECTION_NODE as i32,
        ch,
        len,
        3 as i32,
        Option::<&'_ mut i32>::None,
    ) == -(1 as i32)
    {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaSAXHandleCDataSection\0" as *const u8 as *const i8,
            b"calling xmlSchemaVPushText()\0" as *const u8 as *const i8,
        );
        (unsafe { (*vctxt).err = -(1 as i32) });
        (unsafe { xmlStopParser((*vctxt).parserCtxt) });
    }
}
extern "C" fn xmlSchemaSAXHandleReference(mut ctx: *mut core::ffi::c_void, mut _name: *const u8) {
    let mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'_> =
        ctx as xmlSchemaValidCtxtPtr;
    if (unsafe { (*vctxt).depth }) < 0 as i32 {
        return;
    }
    if (unsafe { (*vctxt).skipDepth }) != -(1 as i32) && (unsafe { (*vctxt).depth }) >= (unsafe { (*vctxt).skipDepth }) {
        return;
    }
    (unsafe { (*__xmlGenericError()).expect("non-null function pointer")(
        *__xmlGenericErrorContext(),
        b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
        b"xmlschemas.c\0" as *const u8 as *const i8,
        27517 as i32,
    ) });
}
extern "C" fn xmlSchemaSAXHandleStartElementNs(
    mut ctx: *mut core::ffi::c_void,
    mut localname: *const u8,
    mut _prefix: *const u8,
    mut URI: *const u8,
    mut nb_namespaces: i32,
    mut namespaces: *mut *const u8,
    mut nb_attributes: i32,
    mut _nb_defaulted: i32,
    mut attributes: *mut *const u8,
) {
    let mut current_block: u64;
    let mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'_> =
        ctx as xmlSchemaValidCtxtPtr;
    let mut ret: i32 = 0;
    let mut ielem: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'_> =
        0 as *mut xmlSchemaNodeInfo;
    let mut i: i32 = 0;
    let mut j: i32 = 0;
    let fresh625 = unsafe { &mut ((*vctxt).depth) };
    *fresh625 += 1;
    if (unsafe { (*vctxt).skipDepth }) != -(1 as i32) && (unsafe { (*vctxt).depth }) >= (unsafe { (*vctxt).skipDepth }) {
        return;
    }
    if xmlSchemaValidatorPushElem(vctxt) == -(1 as i32) {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaSAXHandleStartElementNs\0" as *const u8 as *const i8,
            b"calling xmlSchemaValidatorPushElem()\0" as *const u8 as *const i8,
        );
    } else {
        ielem = unsafe { (*vctxt).inode };
        (unsafe { (*ielem).nodeLine = xmlSAX2GetLineNumber((*vctxt).parserCtxt as *mut libc::c_void) });
        let fresh626 = unsafe { &mut ((*ielem).localName) };
        *fresh626 = localname;
        let fresh627 = unsafe { &mut ((*ielem).nsName) };
        *fresh627 = URI;
        (unsafe { (*ielem).flags |= (1 as i32) << 5 as i32 });
        if nb_namespaces != 0 as i32 {
            i = 0 as i32;
            j = 0 as i32;
            loop {
                if !(i < nb_namespaces) {
                    current_block = 14434620278749266018;
                    break;
                }
                if (unsafe { (*ielem).nsBindings }).is_null() {
                    let fresh628 = unsafe { &mut ((*ielem).nsBindings) };
                    *fresh628 = (unsafe { xmlMalloc.expect("non-null function pointer")(
                        (10 as i32 as u64)
                            .wrapping_mul(::std::mem::size_of::<*const xmlChar>() as u64),
                    ) }) as *mut *const xmlChar;
                    if (unsafe { (*ielem).nsBindings }).is_null() {
                        xmlSchemaVErrMemory(
                            vctxt,
                            b"allocating namespace bindings for SAX validation\0" as *const u8
                                as *const i8,
                            0 as xmlNodePtr,
                        );
                        current_block = 757928548486660075;
                        break;
                    } else {
                        (unsafe { (*ielem).nbNsBindings = 0 as i32 });
                        (unsafe { (*ielem).sizeNsBindings = 5 as i32 });
                    }
                } else if (unsafe { (*ielem).sizeNsBindings }) <= (unsafe { (*ielem).nbNsBindings }) {
                    (unsafe { (*ielem).sizeNsBindings *= 2 as i32 });
                    let fresh629 = unsafe { &mut ((*ielem).nsBindings) };
                    *fresh629 = (unsafe { xmlRealloc.expect("non-null function pointer")(
                        (*ielem).nsBindings as *mut libc::c_void,
                        (((*ielem).sizeNsBindings * 2 as i32) as u64)
                            .wrapping_mul(::std::mem::size_of::<*const xmlChar>() as u64),
                    ) }) as *mut *const xmlChar;
                    if (unsafe { (*ielem).nsBindings }).is_null() {
                        xmlSchemaVErrMemory(
                            vctxt,
                            b"re-allocating namespace bindings for SAX validation\0" as *const u8
                                as *const i8,
                            0 as xmlNodePtr,
                        );
                        current_block = 757928548486660075;
                        break;
                    }
                }
                let fresh630 = unsafe { &mut (*((*ielem).nsBindings)
                    .offset(((*ielem).nbNsBindings * 2 as i32) as isize)) };
                *fresh630 = unsafe { *namespaces.offset(j as isize) };
                if (unsafe { *(*namespaces.offset((j + 1 as i32) as isize)).offset(0 as i32 as isize) }) as i32
                    == 0 as i32
                {
                    let fresh631 = unsafe { &mut (*((*ielem).nsBindings)
                        .offset(((*ielem).nbNsBindings * 2 as i32 + 1 as i32) as isize)) };
                    *fresh631 = 0 as *const xmlChar;
                } else {
                    let fresh632 = unsafe { &mut (*((*ielem).nsBindings)
                        .offset(((*ielem).nbNsBindings * 2 as i32 + 1 as i32) as isize)) };
                    *fresh632 = unsafe { *namespaces.offset((j + 1 as i32) as isize) };
                }
                let fresh633 = unsafe { &mut ((*ielem).nbNsBindings) };
                *fresh633 += 1;
                i += 1;
                j += 2 as i32;
            }
        } else {
            current_block = 14434620278749266018;
        }
        match current_block {
            757928548486660075 => {},
            _ => {
                if nb_attributes != 0 as i32 {
                    let mut valueLen: i32 = 0;
                    let mut k: i32 = 0;
                    let mut l: i32 = 0;
                    let mut value: *mut u8 = 0 as *mut xmlChar;
                    j = 0 as i32;
                    i = 0 as i32;
                    loop {
                        if !(i < nb_attributes) {
                            current_block = 9241535491006583629;
                            break;
                        }
                        valueLen = (unsafe { (*attributes.offset((j + 4 as i32) as isize))
                            .offset_from(*attributes.offset((j + 3 as i32) as isize)) })
                            as i64 as i32;
                        value = (unsafe { xmlMallocAtomic.expect("non-null function pointer")(
                            (valueLen + 1 as i32) as size_t,
                        ) }) as *mut xmlChar;
                        if value.is_null() {
                            xmlSchemaVErrMemory(
                                vctxt,
                                b"allocating string for decoded attribute\0" as *const u8
                                    as *const i8,
                                0 as xmlNodePtr,
                            );
                            current_block = 757928548486660075;
                            break;
                        } else {
                            k = 0 as i32;
                            l = 0 as i32;
                            while k < valueLen {
                                if k < valueLen - 4 as i32
                                    && (unsafe { *(*attributes.offset((j + 3 as i32) as isize))
                                        .offset((k + 0 as i32) as isize) })
                                        as i32
                                        == '&' as i32
                                    && (unsafe { *(*attributes.offset((j + 3 as i32) as isize))
                                        .offset((k + 1 as i32) as isize) })
                                        as i32
                                        == '#' as i32
                                    && (unsafe { *(*attributes.offset((j + 3 as i32) as isize))
                                        .offset((k + 2 as i32) as isize) })
                                        as i32
                                        == '3' as i32
                                    && (unsafe { *(*attributes.offset((j + 3 as i32) as isize))
                                        .offset((k + 3 as i32) as isize) })
                                        as i32
                                        == '8' as i32
                                    && (unsafe { *(*attributes.offset((j + 3 as i32) as isize))
                                        .offset((k + 4 as i32) as isize) })
                                        as i32
                                        == ';' as i32
                                {
                                    (unsafe { *value.offset(l as isize) = '&' as i32 as xmlChar });
                                    k += 5 as i32;
                                } else {
                                    (unsafe { *value.offset(l as isize) = *(*attributes
                                        .offset((j + 3 as i32) as isize))
                                    .offset(k as isize) });
                                    k += 1;
                                }
                                l += 1;
                            }
                            (unsafe { *value.offset(l as isize) = '\u{0}' as i32 as xmlChar });
                            ret = xmlSchemaValidatorPushAttribute(
                                vctxt,
                                0 as xmlNodePtr,
                                unsafe { (*ielem).nodeLine },
                                unsafe { *attributes.offset(j as isize) },
                                unsafe { *attributes.offset((j + 2 as i32) as isize) },
                                0 as i32,
                                value,
                                1 as i32,
                            );
                            if ret == -(1 as i32) {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaSAXHandleStartElementNs\0" as *const u8 as *const i8,
                                    b"calling xmlSchemaValidatorPushAttribute()\0" as *const u8
                                        as *const i8,
                                );
                                current_block = 757928548486660075;
                                break;
                            } else {
                                i += 1;
                                j += 5 as i32;
                            }
                        }
                    }
                } else {
                    current_block = 9241535491006583629;
                }
                match current_block {
                    757928548486660075 => {},
                    _ => {
                        ret = xmlSchemaValidateElem(vctxt);
                        if ret != 0 as i32 {
                            if ret == -(1 as i32) {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaSAXHandleStartElementNs\0" as *const u8 as *const i8,
                                    b"calling xmlSchemaValidateElem()\0" as *const u8 as *const i8,
                                );
                                current_block = 757928548486660075;
                            } else {
                                current_block = 2482997575520911882;
                            }
                        } else {
                            current_block = 2482997575520911882;
                        }
                        match current_block {
                            757928548486660075 => {},
                            _ => return,
                        }
                    },
                }
            },
        }
    }
    (unsafe { (*vctxt).err = -(1 as i32) });
    (unsafe { xmlStopParser((*vctxt).parserCtxt) });
}
extern "C" fn xmlSchemaSAXHandleEndElementNs(
    mut ctx: *mut core::ffi::c_void,
    mut localname: *const u8,
    mut _prefix: *const u8,
    mut URI: *const u8,
) {
    let mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'_> =
        ctx as xmlSchemaValidCtxtPtr;
    let mut res: i32 = 0;
    if (unsafe { (*vctxt).skipDepth }) != -(1 as i32) {
        if (unsafe { (*vctxt).depth }) > (unsafe { (*vctxt).skipDepth }) {
            let fresh634 = unsafe { &mut ((*vctxt).depth) };
            *fresh634 -= 1;
            return;
        } else {
            (unsafe { (*vctxt).skipDepth = -(1 as i32) });
        }
    }
    if xmlStrEqual(unsafe { (*(*vctxt).inode).localName }, localname) == 0
        || xmlStrEqual(unsafe { (*(*vctxt).inode).nsName }, URI) == 0
    {
        xmlSchemaInternalErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            b"xmlSchemaSAXHandleEndElementNs\0" as *const u8 as *const i8,
            b"elem pop mismatch\0" as *const u8 as *const i8,
        );
    }
    res = xmlSchemaValidatorPopElem(vctxt);
    if res != 0 as i32 {
        if res < 0 as i32 {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaSAXHandleEndElementNs\0" as *const u8 as *const i8,
                b"calling xmlSchemaValidatorPopElem()\0" as *const u8 as *const i8,
            );
            (unsafe { (*vctxt).err = -(1 as i32) });
            (unsafe { xmlStopParser((*vctxt).parserCtxt) });
            return;
        }
    }
}
#[no_mangle]
pub extern "C" fn xmlSchemaNewValidCtxt<'a1, 'a2>(
    mut schema: *mut crate::src::xmlschemas::_xmlSchema<'a1>,
) -> *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a2>
where
    'a2: 'a1,
    'a1: 'a2,
{
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'_> =
        0 as *mut xmlSchemaValidCtxt;
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaValidCtxt>() as u64
    ) }) as xmlSchemaValidCtxtPtr;
    if ret.is_null() {
        xmlSchemaVErrMemory(
            0 as xmlSchemaValidCtxtPtr,
            b"allocating validation context\0" as *const u8 as *const i8,
            0 as xmlNodePtr,
        );
        return 0 as xmlSchemaValidCtxtPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaValidCtxt>() as u64,
    ) });
    (unsafe { (*ret).type_0 = 2 as i32 });
    let fresh635 = unsafe { &mut ((*ret).dict) };
    *fresh635 = unsafe { xmlDictCreate() };
    let fresh636 = unsafe { &mut ((*ret).nodeQNames) };
    *fresh636 = xmlSchemaItemListCreate();
    let fresh637 = unsafe { &mut ((*ret).schema) };
    *fresh637 = schema;
    return ret;
}
#[no_mangle]
pub extern "C" fn xmlSchemaValidateSetFilename<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut filename: *const i8,
) {
    if vctxt.is_null() {
        return;
    }
    if !(unsafe { (*vctxt).filename }).is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")((*vctxt).filename as *mut libc::c_void) });
    }
    if !filename.is_null() {
        let fresh638 = unsafe { &mut ((*vctxt).filename) };
        *fresh638 = xmlStrdup(filename as *const xmlChar) as *mut i8;
    } else {
        let fresh639 = unsafe { &mut ((*vctxt).filename) };
        *fresh639 = 0 as *mut i8;
    };
}
extern "C" fn xmlSchemaClearValidCtxt<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) {
    if vctxt.is_null() {
        return;
    }
    (unsafe { (*vctxt).flags = 0 as i32 });
    let fresh640 = unsafe { &mut ((*vctxt).validationRoot) };
    *fresh640 = 0 as xmlNodePtr;
    let fresh641 = unsafe { &mut ((*vctxt).doc) };
    *fresh641 = 0 as xmlDocPtr;
    let fresh642 = &mut (borrow_mut(unsafe { &mut (*vctxt).reader }));
    *fresh642 = Option::<&'_ mut crate::src::xmlreader::_xmlTextReader<'_>>::None;
    (unsafe { (*vctxt).hasKeyrefs = 0 as i32 });
    if !(unsafe { (*vctxt).value }).is_null() {
        xmlSchemaFreeValue(unsafe { (*vctxt).value });
        let fresh643 = unsafe { &mut ((*vctxt).value) };
        *fresh643 = 0 as xmlSchemaValPtr;
    }
    if !(unsafe { (*vctxt).aidcs }).is_null() {
        let mut cur: *mut crate::src::xmlschemas::_xmlSchemaIDCAug<'_> = unsafe { (*vctxt).aidcs };
        let mut next: *mut crate::src::xmlschemas::_xmlSchemaIDCAug<'_> = 0 as *mut xmlSchemaIDCAug;
        loop {
            next = unsafe { (*cur).next };
            (unsafe { xmlFree.expect("non-null function pointer")(cur as *mut libc::c_void) });
            cur = next;
            if cur.is_null() {
                break;
            }
        }
        let fresh644 = unsafe { &mut ((*vctxt).aidcs) };
        *fresh644 = 0 as xmlSchemaIDCAugPtr;
    }
    if !(unsafe { (*vctxt).idcNodes }).is_null() {
        let mut i: i32 = 0;
        let mut item: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'_> =
            0 as *mut xmlSchemaPSVIIDCNode;
        i = 0 as i32;
        while i < (unsafe { (*vctxt).nbIdcNodes }) {
            item = unsafe { *((*vctxt).idcNodes).offset(i as isize) };
            (unsafe { xmlFree.expect("non-null function pointer")((*item).keys as *mut libc::c_void) });
            (unsafe { xmlFree.expect("non-null function pointer")(item as *mut libc::c_void) });
            i += 1;
        }
        (unsafe { xmlFree.expect("non-null function pointer")((*vctxt).idcNodes as *mut libc::c_void) });
        let fresh645 = unsafe { &mut ((*vctxt).idcNodes) };
        *fresh645 = 0 as *mut xmlSchemaPSVIIDCNodePtr;
        (unsafe { (*vctxt).nbIdcNodes = 0 as i32 });
        (unsafe { (*vctxt).sizeIdcNodes = 0 as i32 });
    }
    if !(unsafe { (*vctxt).idcKeys }).is_null() {
        let mut i_0: i32 = 0;
        i_0 = 0 as i32;
        while i_0 < (unsafe { (*vctxt).nbIdcKeys }) {
            xmlSchemaIDCFreeKey(unsafe { *((*vctxt).idcKeys).offset(i_0 as isize) });
            i_0 += 1;
        }
        (unsafe { xmlFree.expect("non-null function pointer")((*vctxt).idcKeys as *mut libc::c_void) });
        let fresh646 = unsafe { &mut ((*vctxt).idcKeys) };
        *fresh646 = 0 as *mut xmlSchemaPSVIIDCKeyPtr;
        (unsafe { (*vctxt).nbIdcKeys = 0 as i32 });
        (unsafe { (*vctxt).sizeIdcKeys = 0 as i32 });
    }
    if !(unsafe { (*vctxt).xpathStates }).is_null() {
        xmlSchemaFreeIDCStateObjList(unsafe { (*vctxt).xpathStates });
        let fresh647 = unsafe { &mut ((*vctxt).xpathStates) };
        *fresh647 = 0 as xmlSchemaIDCStateObjPtr;
    }
    if (unsafe { (*vctxt).nbAttrInfos }) != 0 as i32 {
        xmlSchemaClearAttrInfos(vctxt);
    }
    if !(unsafe { (*vctxt).elemInfos }).is_null() {
        let mut i_1: i32 = 0;
        let mut ei: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'_> =
            0 as *mut xmlSchemaNodeInfo;
        i_1 = 0 as i32;
        while i_1 < (unsafe { (*vctxt).sizeElemInfos }) {
            ei = unsafe { *((*vctxt).elemInfos).offset(i_1 as isize) };
            if ei.is_null() {
                break;
            }
            xmlSchemaClearElemInfo(vctxt, ei);
            i_1 += 1;
        }
    }
    xmlSchemaItemListClear(unsafe { (*vctxt).nodeQNames });
    (unsafe { xmlDictFree((*vctxt).dict) });
    let fresh648 = unsafe { &mut ((*vctxt).dict) };
    *fresh648 = unsafe { xmlDictCreate() };
    if !(unsafe { (*vctxt).filename }).is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")((*vctxt).filename as *mut libc::c_void) });
        let fresh649 = unsafe { &mut ((*vctxt).filename) };
        *fresh649 = 0 as *mut i8;
    }
    if !(unsafe { (*vctxt).idcMatcherCache }).is_null() {
        let mut matcher: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'_> =
            unsafe { (*vctxt).idcMatcherCache };
        let mut tmp: *mut crate::src::xmlschemas::_xmlSchemaIDCMatcher<'_> =
            0 as *mut xmlSchemaIDCMatcher;
        while !matcher.is_null() {
            tmp = matcher;
            matcher = unsafe { (*matcher).nextCached };
            xmlSchemaIDCFreeMatcherList(tmp);
        }
        let fresh650 = unsafe { &mut ((*vctxt).idcMatcherCache) };
        *fresh650 = 0 as xmlSchemaIDCMatcherPtr;
    }
}
#[no_mangle]
pub extern "C" fn xmlSchemaFreeValidCtxt<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) {
    if ctxt.is_null() {
        return;
    }
    if !(unsafe { (*ctxt).value }).is_null() {
        xmlSchemaFreeValue(unsafe { (*ctxt).value });
    }
    if !(unsafe { (*ctxt).pctxt }).is_null() {
        xmlSchemaFreeParserCtxt(unsafe { (*ctxt).pctxt });
    }
    if !(unsafe { (*ctxt).idcNodes }).is_null() {
        let mut i: i32 = 0;
        let mut item: *mut crate::src::xmlschemas::_xmlSchemaPSVIIDCNode<'_> =
            0 as *mut xmlSchemaPSVIIDCNode;
        i = 0 as i32;
        while i < (unsafe { (*ctxt).nbIdcNodes }) {
            item = unsafe { *((*ctxt).idcNodes).offset(i as isize) };
            (unsafe { xmlFree.expect("non-null function pointer")((*item).keys as *mut libc::c_void) });
            (unsafe { xmlFree.expect("non-null function pointer")(item as *mut libc::c_void) });
            i += 1;
        }
        (unsafe { xmlFree.expect("non-null function pointer")((*ctxt).idcNodes as *mut libc::c_void) });
    }
    if !(unsafe { (*ctxt).idcKeys }).is_null() {
        let mut i_0: i32 = 0;
        i_0 = 0 as i32;
        while i_0 < (unsafe { (*ctxt).nbIdcKeys }) {
            xmlSchemaIDCFreeKey(unsafe { *((*ctxt).idcKeys).offset(i_0 as isize) });
            i_0 += 1;
        }
        (unsafe { xmlFree.expect("non-null function pointer")((*ctxt).idcKeys as *mut libc::c_void) });
    }
    if !(unsafe { (*ctxt).xpathStates }).is_null() {
        xmlSchemaFreeIDCStateObjList(unsafe { (*ctxt).xpathStates });
        let fresh651 = unsafe { &mut ((*ctxt).xpathStates) };
        *fresh651 = 0 as xmlSchemaIDCStateObjPtr;
    }
    if !(unsafe { (*ctxt).xpathStatePool }).is_null() {
        xmlSchemaFreeIDCStateObjList(unsafe { (*ctxt).xpathStatePool });
        let fresh652 = unsafe { &mut ((*ctxt).xpathStatePool) };
        *fresh652 = 0 as xmlSchemaIDCStateObjPtr;
    }
    if !(unsafe { (*ctxt).aidcs }).is_null() {
        let mut cur: *mut crate::src::xmlschemas::_xmlSchemaIDCAug<'_> = unsafe { (*ctxt).aidcs };
        let mut next: *mut crate::src::xmlschemas::_xmlSchemaIDCAug<'_> = 0 as *mut xmlSchemaIDCAug;
        loop {
            next = unsafe { (*cur).next };
            (unsafe { xmlFree.expect("non-null function pointer")(cur as *mut libc::c_void) });
            cur = next;
            if cur.is_null() {
                break;
            }
        }
    }
    if !(unsafe { (*ctxt).attrInfos }).is_null() {
        let mut i_1: i32 = 0;
        let mut attr: *mut crate::src::xmlschemas::_xmlSchemaAttrInfo<'_> =
            0 as *mut xmlSchemaAttrInfo;
        if (unsafe { (*ctxt).nbAttrInfos }) != 0 as i32 {
            xmlSchemaClearAttrInfos(ctxt);
        }
        i_1 = 0 as i32;
        while i_1 < (unsafe { (*ctxt).sizeAttrInfos }) {
            attr = unsafe { *((*ctxt).attrInfos).offset(i_1 as isize) };
            (unsafe { xmlFree.expect("non-null function pointer")(attr as *mut libc::c_void) });
            i_1 += 1;
        }
        (unsafe { xmlFree.expect("non-null function pointer")((*ctxt).attrInfos as *mut libc::c_void) });
    }
    if !(unsafe { (*ctxt).elemInfos }).is_null() {
        let mut i_2: i32 = 0;
        let mut ei: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'_> =
            0 as *mut xmlSchemaNodeInfo;
        i_2 = 0 as i32;
        while i_2 < (unsafe { (*ctxt).sizeElemInfos }) {
            ei = unsafe { *((*ctxt).elemInfos).offset(i_2 as isize) };
            if ei.is_null() {
                break;
            }
            xmlSchemaClearElemInfo(ctxt, ei);
            (unsafe { xmlFree.expect("non-null function pointer")(ei as *mut libc::c_void) });
            i_2 += 1;
        }
        (unsafe { xmlFree.expect("non-null function pointer")((*ctxt).elemInfos as *mut libc::c_void) });
    }
    if !(unsafe { (*ctxt).nodeQNames }).is_null() {
        xmlSchemaItemListFree(unsafe { (*ctxt).nodeQNames });
    }
    if !(unsafe { (*ctxt).dict }).is_null() {
        (unsafe { xmlDictFree((*ctxt).dict) });
    }
    if !(unsafe { (*ctxt).filename }).is_null() {
        (unsafe { xmlFree.expect("non-null function pointer")((*ctxt).filename as *mut libc::c_void) });
    }
    (unsafe { xmlFree.expect("non-null function pointer")(ctxt as *mut libc::c_void) });
}
#[no_mangle]
pub extern "C" fn xmlSchemaIsValid<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> i32 {
    if ctxt.is_null() {
        return -(1 as i32);
    }
    return ((unsafe { (*ctxt).err }) == 0 as i32) as i32;
}
#[no_mangle]
pub extern "C" fn xmlSchemaSetValidErrors<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut err: Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>,
    mut warn: Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>,
    mut ctx: *mut core::ffi::c_void,
) {
    if ctxt.is_null() {
        return;
    }
    let fresh653 = unsafe { &mut ((*ctxt).error) };
    *fresh653 = err;
    let fresh654 = unsafe { &mut ((*ctxt).warning) };
    *fresh654 = warn;
    let fresh655 = unsafe { &mut ((*ctxt).errCtxt) };
    *fresh655 = ctx;
    if !(unsafe { (*ctxt).pctxt }).is_null() {
        xmlSchemaSetParserErrors(unsafe { (*ctxt).pctxt }, err, warn, ctx);
    }
}
#[no_mangle]
pub extern "C" fn xmlSchemaSetValidStructuredErrors<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut serror: Option<
        unsafe extern "C" fn(
            _: *mut core::ffi::c_void,
            _: *mut crate::src::threads::_xmlError,
        ) -> (),
    >,
    mut ctx: *mut core::ffi::c_void,
) {
    if ctxt.is_null() {
        return;
    }
    let fresh656 = unsafe { &mut ((*ctxt).serror) };
    *fresh656 = serror;
    let fresh657 = unsafe { &mut ((*ctxt).error) };
    *fresh657 = None;
    let fresh658 = unsafe { &mut ((*ctxt).warning) };
    *fresh658 = None;
    let fresh659 = unsafe { &mut ((*ctxt).errCtxt) };
    *fresh659 = ctx;
    if !(unsafe { (*ctxt).pctxt }).is_null() {
        xmlSchemaSetParserStructuredErrors(unsafe { (*ctxt).pctxt }, serror, ctx);
    }
}
#[no_mangle]
pub extern "C" fn xmlSchemaGetValidErrors<'a1, 'a2, 'a3, 'a4, 'a5>(
    mut ctxt: Option<&'a1 mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a2>>,
    mut err: Option<
        &'a3 mut Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>,
    >,
    mut warn: Option<
        &'a4 mut Option<unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *const i8, ...) -> ()>,
    >,
    mut ctx: Option<&'a5 mut *mut core::ffi::c_void>,
) -> i32 {
    if borrow(&ctxt).is_none() {
        return -(1 as i32);
    }
    if !borrow(&err).is_none() {
        *(borrow_mut(&mut err)).unwrap() = (*(borrow_mut(&mut ctxt)).unwrap()).error;
    }
    if !borrow(&warn).is_none() {
        *(borrow_mut(&mut warn)).unwrap() = (*(borrow_mut(&mut ctxt)).unwrap()).warning;
    }
    if !borrow(&ctx).is_none() {
        *(borrow_mut(&mut ctx)).unwrap() = (*(borrow_mut(&mut ctxt)).unwrap()).errCtxt;
    }
    return 0 as i32;
}
#[no_mangle]
pub extern "C" fn xmlSchemaSetValidOptions<'a1, 'a2>(
    mut ctxt: Option<&'a1 mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a2>>,
    mut options: i32,
) -> i32 {
    let mut i: i32 = 0;
    if borrow(&ctxt).is_none() {
        return -(1 as i32);
    }
    i = 1 as i32;
    while i < ::std::mem::size_of::<i32>() as u64 as i32 * 8 as i32 {
        if options & (1 as i32) << i != 0 {
            return -(1 as i32);
        }
        i += 1;
    }
    (*(borrow_mut(&mut ctxt)).unwrap()).options = options;
    return 0 as i32;
}
#[no_mangle]
pub extern "C" fn xmlSchemaValidCtxtGetOptions<'a1, 'a2>(
    mut ctxt: Option<&'a1 mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a2>>,
) -> i32 {
    if borrow(&ctxt).is_none() {
        return -(1 as i32);
    } else {
        return (*(borrow(&ctxt)).unwrap()).options;
    };
}
extern "C" fn xmlSchemaVDocWalk<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> i32
where
    'a1: 'static,
{
    let mut current_block: u64;
    let mut attr: *mut crate::src::threads::_xmlAttr = 0 as *mut xmlAttr;
    let mut ret: i32 = 0 as i32;
    let mut ielem: *mut crate::src::xmlschemas::_xmlSchemaNodeInfo<'_> = 0 as xmlSchemaNodeInfoPtr;
    let mut node: *mut crate::src::threads::_xmlNode = 0 as *mut xmlNode;
    let mut valRoot: *mut crate::src::threads::_xmlNode = 0 as *mut xmlNode;
    let mut nsName: *const u8 = 0 as *const xmlChar;
    if !(unsafe { (*vctxt).validationRoot }).is_null() {
        valRoot = unsafe { (*vctxt).validationRoot };
    } else {
        valRoot = xmlDocGetRootElement((unsafe { (*vctxt).doc }) as *const xmlDoc);
    }
    if valRoot.is_null() {
        xmlSchemaCustomErr(
            vctxt as xmlSchemaAbstractCtxtPtr,
            XML_ERR_INTERNAL_ERROR,
            0 as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"The document has no document element\0" as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return 1 as i32;
    }
    (unsafe { (*vctxt).depth = -(1 as i32) });
    let fresh660 = unsafe { &mut ((*vctxt).validationRoot) };
    *fresh660 = valRoot;
    node = valRoot;
    's_62: loop {
        if node.is_null() {
            current_block = 17798826982086638848;
            break;
        }
        if (unsafe { (*vctxt).skipDepth }) != -(1 as i32) && (unsafe { (*vctxt).depth }) >= (unsafe { (*vctxt).skipDepth }) {
            current_block = 14755719952959066985;
        } else {
            if (unsafe { (*node).type_0 }) as u32 == XML_ELEMENT_NODE as i32 as u32 {
                let fresh661 = unsafe { &mut ((*vctxt).depth) };
                *fresh661 += 1;
                if xmlSchemaValidatorPushElem(vctxt) == -(1 as i32) {
                    current_block = 1349865872602754158;
                    break;
                }
                ielem = unsafe { (*vctxt).inode };
                let fresh662 = unsafe { &mut ((*ielem).node) };
                *fresh662 = node;
                (unsafe { (*ielem).nodeLine = (*node).line as i32 });
                let fresh663 = unsafe { &mut ((*ielem).localName) };
                *fresh663 = unsafe { (*node).name };
                if !(unsafe { (*node).ns }).is_null() {
                    let fresh664 = unsafe { &mut ((*ielem).nsName) };
                    *fresh664 = unsafe { (*(*node).ns).href };
                }
                (unsafe { (*ielem).flags |= (1 as i32) << 5 as i32 });
                (unsafe { (*vctxt).nbAttrInfos = 0 as i32 });
                if !(unsafe { (*node).properties }).is_null() {
                    attr = unsafe { (*node).properties };
                    loop {
                        if !(unsafe { (*attr).ns }).is_null() {
                            nsName = unsafe { (*(*attr).ns).href };
                        } else {
                            nsName = 0 as *const xmlChar;
                        }
                        ret = xmlSchemaValidatorPushAttribute(
                            vctxt,
                            attr as xmlNodePtr,
                            unsafe { (*ielem).nodeLine },
                            unsafe { (*attr).name },
                            nsName,
                            0 as i32,
                            xmlNodeListGetString(unsafe { (*attr).doc }, unsafe { (*attr).children }, 1 as i32),
                            1 as i32,
                        );
                        if ret == -(1 as i32) {
                            xmlSchemaInternalErr(
                                vctxt as xmlSchemaAbstractCtxtPtr,
                                b"xmlSchemaDocWalk\0" as *const u8 as *const i8,
                                b"calling xmlSchemaValidatorPushAttribute()\0" as *const u8
                                    as *const i8,
                            );
                            current_block = 1349865872602754158;
                            break 's_62;
                        } else {
                            attr = unsafe { (*attr).next };
                            if attr.is_null() {
                                break;
                            }
                        }
                    }
                }
                ret = xmlSchemaValidateElem(vctxt);
                if ret != 0 as i32 {
                    if ret == -(1 as i32) {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaDocWalk\0" as *const u8 as *const i8,
                            b"calling xmlSchemaValidateElem()\0" as *const u8 as *const i8,
                        );
                        current_block = 1349865872602754158;
                        break;
                    }
                    current_block = 15505510009722066756;
                } else if (unsafe { (*vctxt).skipDepth }) != -(1 as i32) && (unsafe { (*vctxt).depth }) >= (unsafe { (*vctxt).skipDepth })
                {
                    current_block = 15505510009722066756;
                } else {
                    current_block = 17233182392562552756;
                }
            } else if (unsafe { (*node).type_0 }) as u32 == XML_TEXT_NODE as i32 as u32
                || (unsafe { (*node).type_0 }) as u32 == XML_CDATA_SECTION_NODE as i32 as u32
            {
                if !ielem.is_null() && (unsafe { (*ielem).flags }) & (1 as i32) << 5 as i32 != 0 {
                    (unsafe { (*ielem).flags ^= (1 as i32) << 5 as i32 });
                }
                ret = xmlSchemaVPushText(
                    vctxt,
                    (unsafe { (*node).type_0 }) as i32,
                    unsafe { (*node).content },
                    -(1 as i32),
                    1 as i32,
                    Option::<&'_ mut i32>::None,
                );
                if ret < 0 as i32 {
                    xmlSchemaInternalErr(
                        vctxt as xmlSchemaAbstractCtxtPtr,
                        b"xmlSchemaVDocWalk\0" as *const u8 as *const i8,
                        b"calling xmlSchemaVPushText()\0" as *const u8 as *const i8,
                    );
                    current_block = 1349865872602754158;
                    break;
                } else {
                    current_block = 17233182392562552756;
                }
            } else if (unsafe { (*node).type_0 }) as u32 == XML_ENTITY_NODE as i32 as u32
                || (unsafe { (*node).type_0 }) as u32 == XML_ENTITY_REF_NODE as i32 as u32
            {
                xmlSchemaInternalErr (vctxt as xmlSchemaAbstractCtxtPtr , b"xmlSchemaVDocWalk\0" as * const u8 as * const i8 , b"there is at least one entity reference in the node-tree currently being validated. Processing of entities with this XML Schema processor is not supported (yet). Please substitute entities before validation.\0" as * const u8 as * const i8 ,) ;
                current_block = 1349865872602754158;
                break;
            } else {
                current_block = 15505510009722066756;
            }
            match current_block {
                15505510009722066756 => {},
                _ => {
                    if !(unsafe { (*node).children }).is_null() {
                        node = unsafe { (*node).children };
                        continue;
                    } else {
                        current_block = 15505510009722066756;
                    }
                },
            }
        }
        loop {
            match current_block {
                14755719952959066985 => {
                    if !(unsafe { (*node).next }).is_null() {
                        node = unsafe { (*node).next };
                        break;
                    } else {
                        node = unsafe { (*node).parent };
                        current_block = 15505510009722066756;
                    }
                },
                _ => {
                    if !((unsafe { (*node).type_0 }) as u32 == XML_ELEMENT_NODE as i32 as u32) {
                        current_block = 14755719952959066985;
                        continue;
                    }
                    if node != (unsafe { (*(*vctxt).inode).node }) {
                        xmlSchemaInternalErr(
                            vctxt as xmlSchemaAbstractCtxtPtr,
                            b"xmlSchemaVDocWalk\0" as *const u8 as *const i8,
                            b"element position mismatch\0" as *const u8 as *const i8,
                        );
                        current_block = 1349865872602754158;
                        break 's_62;
                    } else {
                        ret = xmlSchemaValidatorPopElem(vctxt);
                        if ret != 0 as i32 {
                            if ret < 0 as i32 {
                                xmlSchemaInternalErr(
                                    vctxt as xmlSchemaAbstractCtxtPtr,
                                    b"xmlSchemaVDocWalk\0" as *const u8 as *const i8,
                                    b"calling xmlSchemaValidatorPopElem()\0" as *const u8
                                        as *const i8,
                                );
                                current_block = 1349865872602754158;
                                break 's_62;
                            }
                        }
                        if node == valRoot {
                            current_block = 17798826982086638848;
                            break 's_62;
                        } else {
                            current_block = 14755719952959066985;
                        }
                    }
                },
            }
        }
    }
    match current_block {
        1349865872602754158 => return -(1 as i32),
        _ => return ret,
    };
}
extern "C" fn xmlSchemaPreRun<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> i32 {
    (unsafe { (*vctxt).err = 0 as i32 });
    (unsafe { (*vctxt).nberrors = 0 as i32 });
    (unsafe { (*vctxt).depth = -(1 as i32) });
    (unsafe { (*vctxt).skipDepth = -(1 as i32) });
    (unsafe { (*vctxt).hasKeyrefs = 0 as i32 });
    (unsafe { (*vctxt).createIDCNodeTables = 0 as i32 });
    if (unsafe { (*vctxt).schema }).is_null() {
        let mut pctxt: *mut crate::src::xmlschemas::_xmlSchemaParserCtxt<'_> =
            0 as *mut xmlSchemaParserCtxt;
        (unsafe { (*vctxt).xsiAssemble = 1 as i32 });
        if (unsafe { (*vctxt).pctxt }).is_null() && xmlSchemaCreatePCtxtOnVCtxt(vctxt) == -(1 as i32) {
            return -(1 as i32);
        }
        pctxt = unsafe { (*vctxt).pctxt };
        (unsafe { (*pctxt).xsiAssemble = 1 as i32 });
        let fresh665 = unsafe { &mut ((*vctxt).schema) };
        *fresh665 = xmlSchemaNewSchema(pctxt);
        if (unsafe { (*vctxt).schema }).is_null() {
            return -(1 as i32);
        }
        let fresh666 = unsafe { &mut ((*pctxt).constructor) };
        *fresh666 = xmlSchemaConstructionCtxtCreate(unsafe { (*pctxt).dict });
        if (unsafe { (*pctxt).constructor }).is_null() {
            return -(1 as i32);
        }
        let fresh667 = unsafe { &mut ((*(*pctxt).constructor).mainSchema) };
        *fresh667 = unsafe { (*vctxt).schema };
        (unsafe { (*pctxt).ownsConstructor = 1 as i32 });
    }
    (unsafe { xmlHashScan(
        (*(*vctxt).schema).schemasImports,
        Some(xmlSchemaAugmentImportedIDC),
        vctxt as *mut libc::c_void,
    ) });
    return 0 as i32;
}
extern "C" fn xmlSchemaPostRun<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) {
    if (unsafe { (*vctxt).xsiAssemble }) != 0 {
        if !(unsafe { (*vctxt).schema }).is_null() {
            xmlSchemaFree(unsafe { (*vctxt).schema });
            let fresh668 = unsafe { &mut ((*vctxt).schema) };
            *fresh668 = 0 as xmlSchemaPtr;
        }
    }
    xmlSchemaClearValidCtxt(vctxt);
}
extern "C" fn xmlSchemaVStart<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
) -> i32
where
    'a1: 'static,
{
    let mut ret: i32 = 0 as i32;
    if xmlSchemaPreRun(vctxt) < 0 as i32 {
        return -(1 as i32);
    }
    if !(unsafe { (*vctxt).doc }).is_null() {
        ret = xmlSchemaVDocWalk(vctxt);
    } else if borrow(unsafe { &((*vctxt).reader) }).is_none() {
        if !(unsafe { (*vctxt).sax }).is_null() && !(unsafe { (*vctxt).parserCtxt }).is_null() {
            ret = unsafe { xmlParseDocument((*vctxt).parserCtxt) };
        } else {
            xmlSchemaInternalErr(
                vctxt as xmlSchemaAbstractCtxtPtr,
                b"xmlSchemaVStart\0" as *const u8 as *const i8,
                b"no instance to validate\0" as *const u8 as *const i8,
            );
            ret = -(1 as i32);
        }
    }
    xmlSchemaPostRun(vctxt);
    if ret == 0 as i32 {
        ret = unsafe { (*vctxt).err };
    }
    return ret;
}
#[no_mangle]
pub extern "C" fn xmlSchemaValidateOneElement<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut elem: *mut crate::src::threads::_xmlNode,
) -> i32
where
    'a1: 'static,
{
    if ctxt.is_null() || elem.is_null() || (unsafe { (*elem).type_0 }) as u32 != XML_ELEMENT_NODE as i32 as u32 {
        return -(1 as i32);
    }
    if (unsafe { (*ctxt).schema }).is_null() {
        return -(1 as i32);
    }
    let fresh669 = unsafe { &mut ((*ctxt).doc) };
    *fresh669 = unsafe { (*elem).doc };
    let fresh670 = unsafe { &mut ((*ctxt).node) };
    *fresh670 = elem;
    let fresh671 = unsafe { &mut ((*ctxt).validationRoot) };
    *fresh671 = elem;
    return xmlSchemaVStart(ctxt);
}
#[no_mangle]
pub extern "C" fn xmlSchemaValidateDoc<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut doc: *mut crate::src::threads::_xmlDoc,
) -> i32
where
    'a1: 'static,
{
    if ctxt.is_null() || doc.is_null() {
        return -(1 as i32);
    }
    let fresh672 = unsafe { &mut ((*ctxt).doc) };
    *fresh672 = doc;
    let fresh673 = unsafe { &mut ((*ctxt).node) };
    *fresh673 = xmlDocGetRootElement(doc as *const xmlDoc);
    if (unsafe { (*ctxt).node }).is_null() {
        xmlSchemaCustomErr(
            ctxt as xmlSchemaAbstractCtxtPtr,
            XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING,
            doc as xmlNodePtr,
            0 as xmlSchemaBasicItemPtr,
            b"The document has no document element\0" as *const u8 as *const i8,
            0 as *const xmlChar,
            0 as *const xmlChar,
        );
        return unsafe { (*ctxt).err };
    }
    let fresh674 = unsafe { &mut ((*ctxt).validationRoot) };
    *fresh674 = unsafe { (*ctxt).node };
    return xmlSchemaVStart(ctxt);
}
extern "C" fn internalSubsetSplit(
    mut ctx: *mut core::ffi::c_void,
    mut name: *const u8,
    mut ExternalID: *const u8,
    mut SystemID: *const u8,
) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null()
        && !(unsafe { (*ctxt).user_sax }).is_null()
        && (unsafe { ((*(*ctxt).user_sax).internalSubset).is_some() })
    {
        (unsafe { ((*(*ctxt).user_sax).internalSubset).expect("non-null function pointer")(
            (*ctxt).user_data,
            name,
            ExternalID,
            SystemID,
        ) });
    }
}
extern "C" fn isStandaloneSplit(mut ctx: *mut core::ffi::c_void) -> i32 {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null()
        && !(unsafe { (*ctxt).user_sax }).is_null()
        && (unsafe { ((*(*ctxt).user_sax).isStandalone).is_some() })
    {
        return unsafe { ((*(*ctxt).user_sax).isStandalone).expect("non-null function pointer")(
            (*ctxt).user_data,
        ) };
    }
    return 0 as i32;
}
extern "C" fn hasInternalSubsetSplit(mut ctx: *mut core::ffi::c_void) -> i32 {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null()
        && !(unsafe { (*ctxt).user_sax }).is_null()
        && (unsafe { ((*(*ctxt).user_sax).hasInternalSubset).is_some() })
    {
        return unsafe { ((*(*ctxt).user_sax).hasInternalSubset).expect("non-null function pointer")(
            (*ctxt).user_data,
        ) };
    }
    return 0 as i32;
}
extern "C" fn hasExternalSubsetSplit(mut ctx: *mut core::ffi::c_void) -> i32 {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null()
        && !(unsafe { (*ctxt).user_sax }).is_null()
        && (unsafe { ((*(*ctxt).user_sax).hasExternalSubset).is_some() })
    {
        return unsafe { ((*(*ctxt).user_sax).hasExternalSubset).expect("non-null function pointer")(
            (*ctxt).user_data,
        ) };
    }
    return 0 as i32;
}
extern "C" fn externalSubsetSplit(
    mut ctx: *mut core::ffi::c_void,
    mut name: *const u8,
    mut ExternalID: *const u8,
    mut SystemID: *const u8,
) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null()
        && !(unsafe { (*ctxt).user_sax }).is_null()
        && (unsafe { ((*(*ctxt).user_sax).externalSubset).is_some() })
    {
        (unsafe { ((*(*ctxt).user_sax).externalSubset).expect("non-null function pointer")(
            (*ctxt).user_data,
            name,
            ExternalID,
            SystemID,
        ) });
    }
}
extern "C" fn resolveEntitySplit(
    mut ctx: *mut core::ffi::c_void,
    mut publicId: *const u8,
    mut systemId: *const u8,
) -> *mut crate::src::threads::_xmlParserInput {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null()
        && !(unsafe { (*ctxt).user_sax }).is_null()
        && (unsafe { ((*(*ctxt).user_sax).resolveEntity).is_some() })
    {
        return unsafe { ((*(*ctxt).user_sax).resolveEntity).expect("non-null function pointer")(
            (*ctxt).user_data,
            publicId,
            systemId,
        ) };
    }
    return 0 as xmlParserInputPtr;
}
extern "C" fn getEntitySplit(
    mut ctx: *mut core::ffi::c_void,
    mut name: *const u8,
) -> *mut crate::src::threads::_xmlEntity {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(unsafe { (*ctxt).user_sax }).is_null() && (unsafe { ((*(*ctxt).user_sax).getEntity).is_some() })
    {
        return unsafe { ((*(*ctxt).user_sax).getEntity).expect("non-null function pointer")(
            (*ctxt).user_data,
            name,
        ) };
    }
    return 0 as xmlEntityPtr;
}
extern "C" fn getParameterEntitySplit(
    mut ctx: *mut core::ffi::c_void,
    mut name: *const u8,
) -> *mut crate::src::threads::_xmlEntity {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null()
        && !(unsafe { (*ctxt).user_sax }).is_null()
        && (unsafe { ((*(*ctxt).user_sax).getParameterEntity).is_some() })
    {
        return unsafe { ((*(*ctxt).user_sax).getParameterEntity).expect("non-null function pointer")(
            (*ctxt).user_data,
            name,
        ) };
    }
    return 0 as xmlEntityPtr;
}
extern "C" fn entityDeclSplit(
    mut ctx: *mut core::ffi::c_void,
    mut name: *const u8,
    mut type_0: i32,
    mut publicId: *const u8,
    mut systemId: *const u8,
    mut content: *mut u8,
) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null()
        && !(unsafe { (*ctxt).user_sax }).is_null()
        && (unsafe { ((*(*ctxt).user_sax).entityDecl).is_some() })
    {
        (unsafe { ((*(*ctxt).user_sax).entityDecl).expect("non-null function pointer")(
            (*ctxt).user_data,
            name,
            type_0,
            publicId,
            systemId,
            content,
        ) });
    }
}
extern "C" fn attributeDeclSplit(
    mut ctx: *mut core::ffi::c_void,
    mut elem: *const u8,
    mut name: *const u8,
    mut type_0: i32,
    mut def: i32,
    mut defaultValue: *const u8,
    mut tree: *mut crate::src::threads::_xmlEnumeration,
) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null()
        && !(unsafe { (*ctxt).user_sax }).is_null()
        && (unsafe { ((*(*ctxt).user_sax).attributeDecl).is_some() })
    {
        (unsafe { ((*(*ctxt).user_sax).attributeDecl).expect("non-null function pointer")(
            (*ctxt).user_data,
            elem,
            name,
            type_0,
            def,
            defaultValue,
            tree,
        ) });
    } else {
        xmlFreeEnumeration(tree);
    };
}
extern "C" fn elementDeclSplit(
    mut ctx: *mut core::ffi::c_void,
    mut name: *const u8,
    mut type_0: i32,
    mut content: *mut crate::src::threads::_xmlElementContent,
) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null()
        && !(unsafe { (*ctxt).user_sax }).is_null()
        && (unsafe { ((*(*ctxt).user_sax).elementDecl).is_some() })
    {
        (unsafe { ((*(*ctxt).user_sax).elementDecl).expect("non-null function pointer")(
            (*ctxt).user_data,
            name,
            type_0,
            content,
        ) });
    }
}
extern "C" fn notationDeclSplit(
    mut ctx: *mut core::ffi::c_void,
    mut name: *const u8,
    mut publicId: *const u8,
    mut systemId: *const u8,
) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null()
        && !(unsafe { (*ctxt).user_sax }).is_null()
        && (unsafe { ((*(*ctxt).user_sax).notationDecl).is_some() })
    {
        (unsafe { ((*(*ctxt).user_sax).notationDecl).expect("non-null function pointer")(
            (*ctxt).user_data,
            name,
            publicId,
            systemId,
        ) });
    }
}
extern "C" fn unparsedEntityDeclSplit(
    mut ctx: *mut core::ffi::c_void,
    mut name: *const u8,
    mut publicId: *const u8,
    mut systemId: *const u8,
    mut notationName: *const u8,
) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null()
        && !(unsafe { (*ctxt).user_sax }).is_null()
        && (unsafe { ((*(*ctxt).user_sax).unparsedEntityDecl).is_some() })
    {
        (unsafe { ((*(*ctxt).user_sax).unparsedEntityDecl).expect("non-null function pointer")(
            (*ctxt).user_data,
            name,
            publicId,
            systemId,
            notationName,
        ) });
    }
}
extern "C" fn setDocumentLocatorSplit(
    mut ctx: *mut core::ffi::c_void,
    mut loc: *mut crate::src::threads::_xmlSAXLocator,
) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null()
        && !(unsafe { (*ctxt).user_sax }).is_null()
        && (unsafe { ((*(*ctxt).user_sax).setDocumentLocator).is_some() })
    {
        (unsafe { ((*(*ctxt).user_sax).setDocumentLocator).expect("non-null function pointer")(
            (*ctxt).user_data,
            loc,
        ) });
    }
}
extern "C" fn startDocumentSplit(mut ctx: *mut core::ffi::c_void) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null()
        && !(unsafe { (*ctxt).user_sax }).is_null()
        && (unsafe { ((*(*ctxt).user_sax).startDocument).is_some() })
    {
        (unsafe { ((*(*ctxt).user_sax).startDocument).expect("non-null function pointer")((*ctxt).user_data) });
    }
}
extern "C" fn endDocumentSplit(mut ctx: *mut core::ffi::c_void) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null()
        && !(unsafe { (*ctxt).user_sax }).is_null()
        && (unsafe { ((*(*ctxt).user_sax).endDocument).is_some() })
    {
        (unsafe { ((*(*ctxt).user_sax).endDocument).expect("non-null function pointer")((*ctxt).user_data) });
    }
}
extern "C" fn processingInstructionSplit(
    mut ctx: *mut core::ffi::c_void,
    mut target: *const u8,
    mut data: *const u8,
) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null()
        && !(unsafe { (*ctxt).user_sax }).is_null()
        && (unsafe { ((*(*ctxt).user_sax).processingInstruction).is_some() })
    {
        (unsafe { ((*(*ctxt).user_sax).processingInstruction).expect("non-null function pointer")(
            (*ctxt).user_data,
            target,
            data,
        ) });
    }
}
extern "C" fn commentSplit(mut ctx: *mut core::ffi::c_void, mut value: *const u8) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !(unsafe { (*ctxt).user_sax }).is_null() && (unsafe { ((*(*ctxt).user_sax).comment).is_some() }) {
        (unsafe { ((*(*ctxt).user_sax).comment).expect("non-null function pointer")((*ctxt).user_data, value) });
    }
}
unsafe extern "C" fn warningSplit(
    mut ctx: *mut core::ffi::c_void,
    mut _msg: *const i8,
    mut _args: ...
) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null() && ((*(*ctxt).user_sax).warning).is_some() {
        (*__xmlGenericError()).expect("non-null function pointer")(
            *__xmlGenericErrorContext(),
            b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
            b"xmlschemas.c\0" as *const u8 as *const i8,
            28699 as i32,
        );
    }
}
unsafe extern "C" fn errorSplit(
    mut ctx: *mut core::ffi::c_void,
    mut _msg: *const i8,
    mut _args: ...
) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null() && !((*ctxt).user_sax).is_null() && ((*(*ctxt).user_sax).error).is_some() {
        (*__xmlGenericError()).expect("non-null function pointer")(
            *__xmlGenericErrorContext(),
            b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
            b"xmlschemas.c\0" as *const u8 as *const i8,
            28707 as i32,
        );
    }
}
unsafe extern "C" fn fatalErrorSplit(
    mut ctx: *mut core::ffi::c_void,
    mut _msg: *const i8,
    mut _args: ...
) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if !ctxt.is_null()
        && !((*ctxt).user_sax).is_null()
        && ((*(*ctxt).user_sax).fatalError).is_some()
    {
        (*__xmlGenericError()).expect("non-null function pointer")(
            *__xmlGenericErrorContext(),
            b"Unimplemented block at %s:%d\n\0" as *const u8 as *const i8,
            b"xmlschemas.c\0" as *const u8 as *const i8,
            28715 as i32,
        );
    }
}
extern "C" fn charactersSplit(mut ctx: *mut core::ffi::c_void, mut ch: *const u8, mut len: i32) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !(unsafe { (*ctxt).user_sax }).is_null() && (unsafe { ((*(*ctxt).user_sax).characters).is_some() }) {
        (unsafe { ((*(*ctxt).user_sax).characters).expect("non-null function pointer")(
            (*ctxt).user_data,
            ch,
            len,
        ) });
    }
    if !(unsafe { (*ctxt).ctxt }).is_null() {
        xmlSchemaSAXHandleText((unsafe { (*ctxt).ctxt }) as *mut libc::c_void, ch, len);
    }
}
extern "C" fn ignorableWhitespaceSplit(
    mut ctx: *mut core::ffi::c_void,
    mut ch: *const u8,
    mut len: i32,
) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !(unsafe { (*ctxt).user_sax }).is_null() && (unsafe { ((*(*ctxt).user_sax).ignorableWhitespace).is_some() }) {
        (unsafe { ((*(*ctxt).user_sax).ignorableWhitespace).expect("non-null function pointer")(
            (*ctxt).user_data,
            ch,
            len,
        ) });
    }
    if !(unsafe { (*ctxt).ctxt }).is_null() {
        xmlSchemaSAXHandleText((unsafe { (*ctxt).ctxt }) as *mut libc::c_void, ch, len);
    }
}
extern "C" fn cdataBlockSplit(mut ctx: *mut core::ffi::c_void, mut value: *const u8, mut len: i32) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !(unsafe { (*ctxt).user_sax }).is_null() && (unsafe { ((*(*ctxt).user_sax).cdataBlock).is_some() }) {
        (unsafe { ((*(*ctxt).user_sax).cdataBlock).expect("non-null function pointer")(
            (*ctxt).user_data,
            value,
            len,
        ) });
    }
    if !(unsafe { (*ctxt).ctxt }).is_null() {
        xmlSchemaSAXHandleCDataSection((unsafe { (*ctxt).ctxt }) as *mut libc::c_void, value, len);
    }
}
extern "C" fn referenceSplit(mut ctx: *mut core::ffi::c_void, mut name: *const u8) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !ctxt.is_null() && !(unsafe { (*ctxt).user_sax }).is_null() && (unsafe { ((*(*ctxt).user_sax).reference).is_some() })
    {
        (unsafe { ((*(*ctxt).user_sax).reference).expect("non-null function pointer")(
            (*ctxt).user_data,
            name,
        ) });
    }
    if !(unsafe { (*ctxt).ctxt }).is_null() {
        xmlSchemaSAXHandleReference(unsafe { (*ctxt).user_data }, name);
    }
}
extern "C" fn startElementNsSplit(
    mut ctx: *mut core::ffi::c_void,
    mut localname: *const u8,
    mut prefix: *const u8,
    mut URI: *const u8,
    mut nb_namespaces: i32,
    mut namespaces: *mut *const u8,
    mut nb_attributes: i32,
    mut nb_defaulted: i32,
    mut attributes: *mut *const u8,
) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !(unsafe { (*ctxt).user_sax }).is_null() && (unsafe { ((*(*ctxt).user_sax).startElementNs).is_some() }) {
        (unsafe { ((*(*ctxt).user_sax).startElementNs).expect("non-null function pointer")(
            (*ctxt).user_data,
            localname,
            prefix,
            URI,
            nb_namespaces,
            namespaces,
            nb_attributes,
            nb_defaulted,
            attributes,
        ) });
    }
    if !(unsafe { (*ctxt).ctxt }).is_null() {
        xmlSchemaSAXHandleStartElementNs(
            (unsafe { (*ctxt).ctxt }) as *mut libc::c_void,
            localname,
            prefix,
            URI,
            nb_namespaces,
            namespaces,
            nb_attributes,
            nb_defaulted,
            attributes,
        );
    }
}
extern "C" fn endElementNsSplit(
    mut ctx: *mut core::ffi::c_void,
    mut localname: *const u8,
    mut prefix: *const u8,
    mut URI: *const u8,
) {
    let mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = ctx as xmlSchemaSAXPlugPtr;
    if ctxt.is_null() {
        return;
    }
    if !(unsafe { (*ctxt).user_sax }).is_null() && (unsafe { ((*(*ctxt).user_sax).endElementNs).is_some() }) {
        (unsafe { ((*(*ctxt).user_sax).endElementNs).expect("non-null function pointer")(
            (*ctxt).user_data,
            localname,
            prefix,
            URI,
        ) });
    }
    if !(unsafe { (*ctxt).ctxt }).is_null() {
        xmlSchemaSAXHandleEndElementNs((unsafe { (*ctxt).ctxt }) as *mut libc::c_void, localname, prefix, URI);
    }
}
#[no_mangle]
pub extern "C" fn xmlSchemaSAXPlug<'a1, 'a2, 'a3, 'a4>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut sax: Option<&'a2 mut *mut crate::src::tree::_xmlSAXHandler>,
    mut user_data: Option<&'a3 mut *mut core::ffi::c_void>,
) -> *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'a4>
where
    'a4: 'a1,
    'a1: 'a4,
{
    let mut ret: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> =
        0 as *mut xmlSchemaSAXPlugStruct;
    let mut old_sax: *mut crate::src::tree::_xmlSAXHandler = 0 as *mut xmlSAXHandler;
    if ctxt.is_null() || borrow(&sax).is_none() || borrow(&user_data).is_none() {
        return 0 as xmlSchemaSAXPlugPtr;
    }
    old_sax = *(borrow_mut(&mut sax)).unwrap();
    if !old_sax.is_null() && (unsafe { (*old_sax).initialized }) != 0xdeedbeaf as u32 {
        return 0 as xmlSchemaSAXPlugPtr;
    }
    if !old_sax.is_null()
        && (unsafe { ((*old_sax).startElementNs).is_none() })
        && (unsafe { ((*old_sax).endElementNs).is_none() })
        && ((unsafe { ((*old_sax).startElement).is_some() }) || (unsafe { ((*old_sax).endElement).is_some() }))
    {
        return 0 as xmlSchemaSAXPlugPtr;
    }
    ret = (unsafe { xmlMalloc.expect("non-null function pointer")(
        ::std::mem::size_of::<xmlSchemaSAXPlugStruct>() as u64,
    ) }) as xmlSchemaSAXPlugPtr;
    if ret.is_null() {
        return 0 as xmlSchemaSAXPlugPtr;
    }
    (unsafe { memset(
        ret as *mut libc::c_void,
        0 as i32,
        ::std::mem::size_of::<xmlSchemaSAXPlugStruct>() as u64,
    ) });
    (unsafe { (*ret).magic = 0xdc43ba21 as u32 });
    (unsafe { (*ret).schemas_sax.initialized = 0xdeedbeaf as u32 });
    let fresh675 = unsafe { &mut ((*ret).ctxt) };
    *fresh675 = ctxt;
    let fresh676 = &mut (borrow_mut(unsafe { &mut (*ret).user_sax_ptr }));
    *fresh676 = borrow_mut(&mut sax);
    let fresh677 = unsafe { &mut ((*ret).user_sax) };
    *fresh677 = old_sax;
    if old_sax.is_null() {
        let fresh678 = unsafe { &mut ((*ret).schemas_sax.startElementNs) };
        *fresh678 = Some(xmlSchemaSAXHandleStartElementNs);
        let fresh679 = unsafe { &mut ((*ret).schemas_sax.endElementNs) };
        *fresh679 = Some(xmlSchemaSAXHandleEndElementNs);
        let fresh680 = unsafe { &mut ((*ret).schemas_sax.ignorableWhitespace) };
        *fresh680 = Some(xmlSchemaSAXHandleText);
        let fresh681 = unsafe { &mut ((*ret).schemas_sax.characters) };
        *fresh681 = Some(xmlSchemaSAXHandleText);
        let fresh682 = unsafe { &mut ((*ret).schemas_sax.cdataBlock) };
        *fresh682 = Some(xmlSchemaSAXHandleCDataSection);
        let fresh683 = unsafe { &mut ((*ret).schemas_sax.reference) };
        *fresh683 = Some(xmlSchemaSAXHandleReference);
        let fresh684 = unsafe { &mut ((*ret).user_data) };
        *fresh684 = ctxt as *mut libc::c_void;
        *(borrow_mut(&mut user_data)).unwrap() = ctxt as *mut libc::c_void;
    } else {
        if unsafe { ((*old_sax).internalSubset).is_some() } {
            let fresh685 = unsafe { &mut ((*ret).schemas_sax.internalSubset) };
            *fresh685 = Some(internalSubsetSplit);
        }
        if unsafe { ((*old_sax).isStandalone).is_some() } {
            let fresh686 = unsafe { &mut ((*ret).schemas_sax.isStandalone) };
            *fresh686 = Some(isStandaloneSplit);
        }
        if unsafe { ((*old_sax).hasInternalSubset).is_some() } {
            let fresh687 = unsafe { &mut ((*ret).schemas_sax.hasInternalSubset) };
            *fresh687 = Some(hasInternalSubsetSplit);
        }
        if unsafe { ((*old_sax).hasExternalSubset).is_some() } {
            let fresh688 = unsafe { &mut ((*ret).schemas_sax.hasExternalSubset) };
            *fresh688 = Some(hasExternalSubsetSplit);
        }
        if unsafe { ((*old_sax).resolveEntity).is_some() } {
            let fresh689 = unsafe { &mut ((*ret).schemas_sax.resolveEntity) };
            *fresh689 = Some(resolveEntitySplit);
        }
        if unsafe { ((*old_sax).getEntity).is_some() } {
            let fresh690 = unsafe { &mut ((*ret).schemas_sax.getEntity) };
            *fresh690 = Some(getEntitySplit);
        }
        if unsafe { ((*old_sax).entityDecl).is_some() } {
            let fresh691 = unsafe { &mut ((*ret).schemas_sax.entityDecl) };
            *fresh691 = Some(entityDeclSplit);
        }
        if unsafe { ((*old_sax).notationDecl).is_some() } {
            let fresh692 = unsafe { &mut ((*ret).schemas_sax.notationDecl) };
            *fresh692 = Some(notationDeclSplit);
        }
        if unsafe { ((*old_sax).attributeDecl).is_some() } {
            let fresh693 = unsafe { &mut ((*ret).schemas_sax.attributeDecl) };
            *fresh693 = Some(attributeDeclSplit);
        }
        if unsafe { ((*old_sax).elementDecl).is_some() } {
            let fresh694 = unsafe { &mut ((*ret).schemas_sax.elementDecl) };
            *fresh694 = Some(elementDeclSplit);
        }
        if unsafe { ((*old_sax).unparsedEntityDecl).is_some() } {
            let fresh695 = unsafe { &mut ((*ret).schemas_sax.unparsedEntityDecl) };
            *fresh695 = Some(unparsedEntityDeclSplit);
        }
        if unsafe { ((*old_sax).setDocumentLocator).is_some() } {
            let fresh696 = unsafe { &mut ((*ret).schemas_sax.setDocumentLocator) };
            *fresh696 = Some(setDocumentLocatorSplit);
        }
        if unsafe { ((*old_sax).startDocument).is_some() } {
            let fresh697 = unsafe { &mut ((*ret).schemas_sax.startDocument) };
            *fresh697 = Some(startDocumentSplit);
        }
        if unsafe { ((*old_sax).endDocument).is_some() } {
            let fresh698 = unsafe { &mut ((*ret).schemas_sax.endDocument) };
            *fresh698 = Some(endDocumentSplit);
        }
        if unsafe { ((*old_sax).processingInstruction).is_some() } {
            let fresh699 = unsafe { &mut ((*ret).schemas_sax.processingInstruction) };
            *fresh699 = Some(processingInstructionSplit);
        }
        if unsafe { ((*old_sax).comment).is_some() } {
            let fresh700 = unsafe { &mut ((*ret).schemas_sax.comment) };
            *fresh700 = Some(commentSplit);
        }
        if unsafe { ((*old_sax).warning).is_some() } {
            let fresh701 = unsafe { &mut ((*ret).schemas_sax.warning) };
            *fresh701 = Some(warningSplit);
        }
        if unsafe { ((*old_sax).error).is_some() } {
            let fresh702 = unsafe { &mut ((*ret).schemas_sax.error) };
            *fresh702 = Some(errorSplit);
        }
        if unsafe { ((*old_sax).fatalError).is_some() } {
            let fresh703 = unsafe { &mut ((*ret).schemas_sax.fatalError) };
            *fresh703 = Some(fatalErrorSplit);
        }
        if unsafe { ((*old_sax).getParameterEntity).is_some() } {
            let fresh704 = unsafe { &mut ((*ret).schemas_sax.getParameterEntity) };
            *fresh704 = Some(getParameterEntitySplit);
        }
        if unsafe { ((*old_sax).externalSubset).is_some() } {
            let fresh705 = unsafe { &mut ((*ret).schemas_sax.externalSubset) };
            *fresh705 = Some(externalSubsetSplit);
        }
        let fresh706 = unsafe { &mut ((*ret).schemas_sax.characters) };
        *fresh706 = Some(charactersSplit);
        if (unsafe { ((*old_sax).ignorableWhitespace).is_some() })
            && (unsafe { (*old_sax).ignorableWhitespace }).map(|f| f as usize)
                == (unsafe { (*old_sax).characters }).map(|f| f as usize)
        {
            let fresh707 = unsafe { &mut ((*ret).schemas_sax.ignorableWhitespace) };
            *fresh707 = Some(ignorableWhitespaceSplit);
        } else {
            let fresh708 = unsafe { &mut ((*ret).schemas_sax.ignorableWhitespace) };
            *fresh708 = Some(charactersSplit);
        }
        let fresh709 = unsafe { &mut ((*ret).schemas_sax.cdataBlock) };
        *fresh709 = Some(cdataBlockSplit);
        let fresh710 = unsafe { &mut ((*ret).schemas_sax.reference) };
        *fresh710 = Some(referenceSplit);
        let fresh711 = unsafe { &mut ((*ret).schemas_sax.startElementNs) };
        *fresh711 = Some(startElementNsSplit);
        let fresh712 = unsafe { &mut ((*ret).schemas_sax.endElementNs) };
        *fresh712 = Some(endElementNsSplit);
        let fresh713 = &mut (borrow_mut(unsafe { &mut (*ret).user_data_ptr }));
        *fresh713 = borrow_mut(&mut user_data);
        let fresh714 = unsafe { &mut ((*ret).user_data) };
        *fresh714 = *(borrow_mut(&mut user_data)).unwrap();
        *(borrow_mut(&mut user_data)).unwrap() = ret as *mut libc::c_void;
    }
    *(borrow_mut(&mut sax)).unwrap() = unsafe { &mut (*ret).schemas_sax };
    let fresh715 = unsafe { &mut ((*ctxt).sax) };
    *fresh715 = *(borrow_mut(&mut sax)).unwrap();
    (unsafe { (*ctxt).flags |= 1 as i32 });
    xmlSchemaPreRun(ctxt);
    return ret;
}
#[no_mangle]
pub extern "C" fn xmlSchemaSAXUnplug<'a1>(
    mut plug: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'a1>,
) -> i32 {
    let mut sax: Option<&'_ mut *mut crate::src::tree::_xmlSAXHandler> =
        Option::<&'_ mut *mut crate::src::tree::_xmlSAXHandler>::None;
    let mut user_data: Option<&'_ mut *mut core::ffi::c_void> =
        Option::<&'_ mut *mut core::ffi::c_void>::None;
    if plug.is_null() || (unsafe { (*plug).magic }) != 0xdc43ba21 as u32 {
        return -(1 as i32);
    }
    (unsafe { (*plug).magic = 0 as i32 as u32 });
    xmlSchemaPostRun(unsafe { (*plug).ctxt });
    sax = borrow_mut(unsafe { &mut (*plug).user_sax_ptr });
    *(borrow_mut(&mut sax)).unwrap() = unsafe { (*plug).user_sax };
    if !(unsafe { (*plug).user_sax }).is_null() {
        user_data = borrow_mut(unsafe { &mut (*plug).user_data_ptr });
        *(borrow_mut(&mut user_data)).unwrap() = unsafe { (*plug).user_data };
    }
    (unsafe { xmlFree.expect("non-null function pointer")(plug as *mut libc::c_void) });
    return 0 as i32;
}
#[no_mangle]
pub extern "C" fn xmlSchemaValidateSetLocator<'a1>(
    mut vctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut f: Option<
        unsafe extern "C" fn(_: *mut core::ffi::c_void, _: *mut *const i8, _: *mut u64) -> i32,
    >,
    mut ctxt: *mut core::ffi::c_void,
) {
    if vctxt.is_null() {
        return;
    }
    let fresh716 = unsafe { &mut ((*vctxt).locFunc) };
    *fresh716 = f;
    let fresh717 = unsafe { &mut ((*vctxt).locCtxt) };
    *fresh717 = ctxt;
}
extern "C" fn xmlSchemaValidateStreamLocator(
    mut ctx: *mut core::ffi::c_void,
    mut file: *mut *const i8,
    mut line: *mut u64,
) -> i32 {
    let mut ctxt: *mut crate::src::tree::_xmlParserCtxt =
        0 as *mut crate::src::tree::_xmlParserCtxt;
    if ctx.is_null() || file.is_null() && line.is_null() {
        return -(1 as i32);
    }
    if !file.is_null() {
        (unsafe { *file = 0 as *const i8 });
    }
    if !line.is_null() {
        (unsafe { *line = 0 as i32 as u64 });
    }
    ctxt = ctx as xmlParserCtxtPtr;
    if !(unsafe { (*ctxt).input }).is_null() {
        if !file.is_null() {
            (unsafe { *file = (*(*ctxt).input).filename });
        }
        if !line.is_null() {
            (unsafe { *line = (*(*ctxt).input).line as u64 });
        }
        return 0 as i32;
    }
    return -(1 as i32);
}
#[no_mangle]
pub extern "C" fn xmlSchemaValidateStream<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut input: *mut crate::src::threads::_xmlParserInputBuffer,
    mut enc: i32,
    mut sax: *mut crate::src::tree::_xmlSAXHandler,
    mut user_data: *mut core::ffi::c_void,
) -> i32
where
    'a1: 'static,
{
    let mut plug: *mut crate::src::xmlschemas::_xmlSchemaSAXPlug<'_> = 0 as xmlSchemaSAXPlugPtr;
    let mut old_sax: *mut crate::src::tree::_xmlSAXHandler = 0 as xmlSAXHandlerPtr;
    let mut pctxt: *mut crate::src::tree::_xmlParserCtxt = 0 as xmlParserCtxtPtr;
    let mut inputStream: *mut crate::src::threads::_xmlParserInput = 0 as xmlParserInputPtr;
    let mut ret: i32 = 0;
    if ctxt.is_null() || input.is_null() {
        return -(1 as i32);
    }
    pctxt = unsafe { xmlNewParserCtxt() };
    if pctxt.is_null() {
        return -(1 as i32);
    }
    old_sax = unsafe { (*pctxt).sax };
    let fresh718 = unsafe { &mut ((*pctxt).sax) };
    *fresh718 = sax;
    let fresh719 = unsafe { &mut ((*pctxt).userData) };
    *fresh719 = user_data;
    (unsafe { (*pctxt).linenumbers = 1 as i32 });
    xmlSchemaValidateSetLocator(
        ctxt,
        Some(xmlSchemaValidateStreamLocator),
        pctxt as *mut libc::c_void,
    );
    inputStream = unsafe { xmlNewIOInputStream(pctxt, input, enc) };
    if inputStream.is_null() {
        ret = -(1 as i32);
    } else {
        (unsafe { inputPush(pctxt, inputStream) });
        let fresh720 = unsafe { &mut ((*ctxt).parserCtxt) };
        *fresh720 = pctxt;
        let fresh721 = unsafe { &mut ((*ctxt).input) };
        *fresh721 = input;
        plug = xmlSchemaSAXPlug(ctxt, Some(unsafe { &mut (*pctxt).sax }), Some(unsafe { &mut (*pctxt).userData }));
        if plug.is_null() {
            ret = -(1 as i32);
        } else {
            let fresh722 = unsafe { &mut ((*ctxt).input) };
            *fresh722 = input;
            (unsafe { (*ctxt).enc = enc });
            let fresh723 = unsafe { &mut ((*ctxt).sax) };
            *fresh723 = unsafe { (*pctxt).sax };
            (unsafe { (*ctxt).flags |= 1 as i32 });
            ret = xmlSchemaVStart(ctxt);
            if ret == 0 as i32 && (unsafe { (*(*ctxt).parserCtxt).wellFormed }) == 0 {
                ret = unsafe { (*(*ctxt).parserCtxt).errNo };
                if ret == 0 as i32 {
                    ret = 1 as i32;
                }
            }
        }
    }
    let fresh724 = unsafe { &mut ((*ctxt).parserCtxt) };
    *fresh724 = 0 as xmlParserCtxtPtr;
    let fresh725 = unsafe { &mut ((*ctxt).sax) };
    *fresh725 = 0 as xmlSAXHandlerPtr;
    let fresh726 = unsafe { &mut ((*ctxt).input) };
    *fresh726 = 0 as xmlParserInputBufferPtr;
    if !plug.is_null() {
        xmlSchemaSAXUnplug(plug);
    }
    if !pctxt.is_null() {
        let fresh727 = unsafe { &mut ((*pctxt).sax) };
        *fresh727 = old_sax;
        (unsafe { xmlFreeParserCtxt(pctxt) });
    }
    return ret;
}
#[no_mangle]
pub extern "C" fn xmlSchemaValidateFile<'a1>(
    mut ctxt: *mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a1>,
    mut filename: *const i8,
    mut _options: i32,
) -> i32
where
    'a1: 'static,
{
    let mut ret: i32 = 0;
    let mut input: *mut crate::src::threads::_xmlParserInputBuffer = 0 as *mut xmlParserInputBuffer;
    if ctxt.is_null() || filename.is_null() {
        return -(1 as i32);
    }
    input = xmlParserInputBufferCreateFilename(filename, XML_CHAR_ENCODING_NONE);
    if input.is_null() {
        return -(1 as i32);
    }
    ret = xmlSchemaValidateStream(
        ctxt,
        input,
        XML_CHAR_ENCODING_NONE,
        0 as xmlSAXHandlerPtr,
        0 as *mut libc::c_void,
    );
    return ret;
}
#[no_mangle]
pub extern "C" fn xmlSchemaValidCtxtGetParserCtxt<'a1, 'a2>(
    mut ctxt: Option<&'a1 mut crate::src::xmlschemas::_xmlSchemaValidCtxt<'a2>>,
) -> *mut crate::src::tree::_xmlParserCtxt {
    if borrow(&ctxt).is_none() {
        return 0 as xmlParserCtxtPtr;
    }
    return (*(borrow_mut(&mut ctxt)).unwrap()).parserCtxt;
}
use crate::laertes_rt::*;
